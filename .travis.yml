sudo: required

language: php

notifications:
  email: false

php:
  - 7.0

services:
  # Require docker and docker-compose as we'll need them to manage the containers.
  - docker

addons:
  apt:
    packages:
      - libjpeg-dev
      - libpng12-dev

# Disable the default submodule logic.
git:
  submodules: false

## Cache composer and node bits
cache:
  apt: true
  directories:
    - vendor
    - node_modules
    # The composer user-level cache.
    - $HOME/.composer/cache

env:
  global:
    - WP_VERSION="latest"
    - NODE_RELEASE="skip"

matrix:
  allow_failures:
    - env: NODE_RELEASE="skip"
      php: 7.3

  include:
    - env: NODE_RELEASE="stable"
      php: 7.0
    - env: NODE_RELEASE="skip"
      php: 7.3

before_install:
  # Sourcing the .env file will make sure we use, in the environment configuration, the same variables the tests are using.
  - set -o allexport; source .env; set +o allexport;

  # Spin up the `db` container from the test stack.
  # Between initialization and creation of the test database it might take
  # some time (seconds); if we spin it up now it should be ready to run by
  # the time we need it.
  - docker-compose -f ${TRAVIS_BUILD_DIR}/dev/docker/ci-compose.yml up -d db

  # Tweak git to correctly work with submodules.
  #- sed -i 's/git@github.com:/git:\/\/github.com\//' .gitmodules
  #- git submodule update --init
  #- git submodule foreach --recursive "[ -f .gitmodules ] && sed -i 's/git@github.com:/git:\/\/github.com\//' .gitmodules; git submodule update --init;"

  # Only do npm install if we're running the latest stable node (Pipe preserves subsequent whitespace)
  - |
    if [ $NODE_RELEASE == "stable" ]; then
        . $HOME/.nvm/nvm.sh;
        nvm install ${NODE_RELEASE};
        npm install;
    fi
install:
  # Disable XDebug to speed up the tests.
  - phpenv config-rm xdebug.ini

  # The installation will include wp-cli as well as it's a requirement of wp-browser.
  - composer update --prefer-dist

  # Install composer on common if it exists; use --no-dev to avoid Common dev dependencies being used in ET tests.
  #- if [[ -d "common" ]]; then cd common; composer update --prefer-dist --no-dev; cd ../; fi;

  # Install wp-cli phar.
  # While wp-cli is one of wp-browser dependencies the binary that lives in the `vendor/bin` folder will load the
  # Composer autoload file when used and that will conflict with the one loaded by the plugin.
  - curl -O https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
  - chmod +x wp-cli.phar
  - mkdir -p ${HOME}/.local/bin && mv wp-cli.phar ${HOME}/.local/bin/wp

  # Tweak the path to look for binaries in `vendor/bin` first.
  # Binaries installed in the `vendor/bin` folder, like `codecept`, will be available system-wide.
  - export PATH=${PATH}:${TRAVIS_BUILD_DIR}/vendor/bin

  # Create the WordPress root folder.
  - mkdir -p ${WP_ROOT_FOLDER}

  # Download, configure and install WordPress in the `wordpress` folder.
  # To configure WordPress we use the configuration parameters that will be used by the Docker container.
  # See `dev/docker/ci-compose.yml` for more information.
  - cd ${WP_ROOT_FOLDER}
  - wp core download --version=${WP_VERSION}
  # Let's generate the wp-config.php file for the WordPress installation from a template.
  - echo "WP_DB_NAME=${WP_DB_NAME} WP_DB_PORT=${WP_DB_PORT} WP_TABLE_PREFIX=${WP_TABLE_PREFIX}"
  - envsubst '${WP_DB_NAME},${WP_DB_PORT},${WP_TABLE_PREFIX}' < ${TRAVIS_BUILD_DIR}/dev/docker/wp-config.template > ./wp-config.php
  # Reset the WordPress installation database if set and then  re-install it.
  - wp db reset --yes
  - wp core install --url="${WP_URL}" --title="Tribe Tests" --admin_user="${WP_ADMIN_USERNAME}" --admin_password="${WP_ADMIN_PASSWORD}" --admin_email="admin@tribe.localhost" --skip-email
  # Create a wp-cli configuration file to allow it to write an .htaccess file.
  - echo -e "apache_modules:\n\t- mod_rewrite" > wp-cli.yml

  # Now that it is we've got a wp-config.php in place start the WordPress Docker container to have WordPress.
  - docker-compose -f ${TRAVIS_BUILD_DIR}/dev/docker/ci-compose.yml up -d wordpress
  # Since we've bound the WordPress folder from the local filesystem let's clear any possible r/w access issue.
  - docker-compose -f ${TRAVIS_BUILD_DIR}/dev/docker/ci-compose.yml exec wordpress bash -c "chmod -R 0777 /var/www/html/wp-content/uploads"
  # Copy over a mu-plugin that will make it so that WordPress will be able to resolve `http://localhost:port`.
  - mkdir -p ${WP_ROOT_FOLDER}/wp-content/mu-plugins && cp ${TRAVIS_BUILD_DIR}/dev/docker/redirect-localhost-requests.php ${WP_ROOT_FOLDER}/wp-content/mu-plugins

  # Create the database we'll use in integration tests accessing the database container.
  - mysql --user=root --host=127.0.0.1 --port=${WP_DB_PORT} -e "create database ${WP_TEST_DB_NAME}";
  - mysql --user=root --host=127.0.0.1 --port=${WP_DB_PORT} -e "show databases";

  # If there are required plugins, clone them.
  - source ${TRAVIS_BUILD_DIR}/dev/functions.sh; git_clone_required_plugins

  # Get back to the build folder, the one where the plugin has been cloned by the CI.
  - cd ${TRAVIS_BUILD_DIR}

  # Copy the plugin into the WordPress plugin folder.
  # We also set two variables:
  # `PLUGIN_BASENAME` is the name of the plugin folder, e.g. `the-events-calendar` or `events-pro`.
  # `PLUGIN_DIR` is the absolute path to the plugin folder in the WordPress installation, e.g. `/tmp/wordpress/wp-content/plugins/the-events-calendar`.
  - export PLUGIN_BASENAME=$(basename "$(pwd)") && echo "PLUGIN_BASENAME=${PLUGIN_BASENAME}"
  - cp -r ${TRAVIS_BUILD_DIR} ${WP_ROOT_FOLDER}/wp-content/plugins/${PLUGIN_BASENAME}
  - export PLUGIN_DIR="${WP_ROOT_FOLDER}/wp-content/plugins/${PLUGIN_BASENAME}" && echo "PLUGIN_DIR=${PLUGIN_DIR}"

  # Get back to the WordPress installation root folder.
  - cd ${WP_ROOT_FOLDER}; echo "pwd=$(pwd)"

  # Obtain the IP address of the `wordpress` container we started before from the stack.
  - export WP_CONTAINER_IP=`docker inspect -f '{{ .NetworkSettings.Networks.docker_default.IPAddress }}' ci_wordpress`

  # Finally start the Selenium and Chromedriver container.
  # - docker-compose -f ${TRAVIS_BUILD_DIR}/dev/docker/ci-compose.yml up -d chromedriver

before_script:
  # Activate the plugin in WordPress.
  - wp plugin activate ${PLUGIN_BASENAME}

  # Flush rewrite rules to make sure we're using permalinks.
  - wp rewrite structure '/%postname%/' --hard

  # Export a dump of the just installed database to the _data folder.
  - wp db export ${PLUGIN_DIR}/tests/codeception/_data/dump.sql

  # Get back to the plugin dir.
  - cd ${PLUGIN_DIR}

script:

  # Only run non-traversal tests
  - codecept run integration
  - codecept run wpunit

  # Only run traversal tests
  - codecept run wpunit-traversal --skip-group='pods-traversal-deep'

  # Only run js tests if we're running the latest stable node (Pipe preserves subsequent whitespace)
  - |
    if [ $NODE_RELEASE == "stable" ]; then
        npm run test-dfv;
        npm run jest-tests;
    fi

after_failure:
  # if the build failed let's see why
  - sudo cat $(php -i | grep ^error_log | cut -d' ' -f 3)
  - sudo cat /var/log/nginx/error.log
