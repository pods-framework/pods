/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./ui/js/blocks/src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/inheritsLoose.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inheritsLoose.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

module.exports = _inheritsLoose;

/***/ }),

/***/ "./node_modules/@emotion/cache/dist/cache.browser.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@emotion/cache/dist/cache.browser.esm.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _emotion_sheet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/sheet */ "./node_modules/@emotion/sheet/dist/sheet.browser.esm.js");
/* harmony import */ var _emotion_stylis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/stylis */ "./node_modules/@emotion/stylis/dist/stylis.browser.esm.js");
/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/weak-memoize */ "./node_modules/@emotion/weak-memoize/dist/weak-memoize.browser.esm.js");




// https://github.com/thysultan/stylis.js/tree/master/plugins/rule-sheet
// inlined to avoid umd wrapper and peerDep warnings/installing stylis
// since we use stylis after closure compiler
var delimiter = '/*|*/';
var needle = delimiter + '}';

function toSheet(block) {
  if (block) {
    Sheet.current.insert(block + '}');
  }
}

var Sheet = {
  current: null
};
var ruleSheet = function ruleSheet(context, content, selectors, parents, line, column, length, ns, depth, at) {
  switch (context) {
    // property
    case 1:
      {
        switch (content.charCodeAt(0)) {
          case 64:
            {
              // @import
              Sheet.current.insert(content + ';');
              return '';
            }
          // charcode for l

          case 108:
            {
              // charcode for b
              // this ignores label
              if (content.charCodeAt(2) === 98) {
                return '';
              }
            }
        }

        break;
      }
    // selector

    case 2:
      {
        if (ns === 0) return content + delimiter;
        break;
      }
    // at-rule

    case 3:
      {
        switch (ns) {
          // @font-face, @page
          case 102:
          case 112:
            {
              Sheet.current.insert(selectors[0] + content);
              return '';
            }

          default:
            {
              return content + (at === 0 ? delimiter : '');
            }
        }
      }

    case -2:
      {
        content.split(needle).forEach(toSheet);
      }
  }
};

var createCache = function createCache(options) {
  if (options === undefined) options = {};
  var key = options.key || 'css';
  var stylisOptions;

  if (options.prefix !== undefined) {
    stylisOptions = {
      prefix: options.prefix
    };
  }

  var stylis = new _emotion_stylis__WEBPACK_IMPORTED_MODULE_1__["default"](stylisOptions);

  if (true) {
    // $FlowFixMe
    if (/[^a-z-]/.test(key)) {
      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
    }
  }

  var inserted = {}; // $FlowFixMe

  var container;

  {
    container = options.container || document.head;
    var nodes = document.querySelectorAll("style[data-emotion-" + key + "]");
    Array.prototype.forEach.call(nodes, function (node) {
      var attrib = node.getAttribute("data-emotion-" + key); // $FlowFixMe

      attrib.split(' ').forEach(function (id) {
        inserted[id] = true;
      });

      if (node.parentNode !== container) {
        container.appendChild(node);
      }
    });
  }

  var _insert;

  {
    stylis.use(options.stylisPlugins)(ruleSheet);

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      var name = serialized.name;
      Sheet.current = sheet;

      if ( true && serialized.map !== undefined) {
        var map = serialized.map;
        Sheet.current = {
          insert: function insert(rule) {
            sheet.insert(rule + map);
          }
        };
      }

      stylis(selector, serialized.styles);

      if (shouldCache) {
        cache.inserted[name] = true;
      }
    };
  }

  if (true) {
    // https://esbench.com/bench/5bf7371a4cd7e6009ef61d0a
    var commentStart = /\/\*/g;
    var commentEnd = /\*\//g;
    stylis.use(function (context, content) {
      switch (context) {
        case -1:
          {
            while (commentStart.test(content)) {
              commentEnd.lastIndex = commentStart.lastIndex;

              if (commentEnd.test(content)) {
                commentStart.lastIndex = commentEnd.lastIndex;
                continue;
              }

              throw new Error('Your styles have an unterminated comment ("/*" without corresponding "*/").');
            }

            commentStart.lastIndex = 0;
            break;
          }
      }
    });
    stylis.use(function (context, content, selectors) {
      switch (context) {
        case -1:
          {
            var flag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';
            var unsafePseudoClasses = content.match(/(:first|:nth|:nth-last)-child/g);

            if (unsafePseudoClasses && cache.compat !== true) {
              unsafePseudoClasses.forEach(function (unsafePseudoClass) {
                var ignoreRegExp = new RegExp(unsafePseudoClass + ".*\\/\\* " + flag + " \\*\\/");
                var ignore = ignoreRegExp.test(content);

                if (unsafePseudoClass && !ignore) {
                  console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
                }
              });
            }

            break;
          }
      }
    });
  }

  var cache = {
    key: key,
    sheet: new _emotion_sheet__WEBPACK_IMPORTED_MODULE_0__["StyleSheet"]({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  return cache;
};

/* harmony default export */ __webpack_exports__["default"] = (createCache);


/***/ }),

/***/ "./node_modules/@emotion/core/dist/core.browser.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@emotion/core/dist/core.browser.esm.js ***!
  \*************************************************************/
/*! exports provided: css, CacheProvider, ClassNames, Global, ThemeContext, jsx, keyframes, withEmotionCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CacheProvider", function() { return CacheProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClassNames", function() { return ClassNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Global", function() { return Global; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemeContext", function() { return ThemeContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jsx", function() { return jsx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyframes", function() { return keyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withEmotionCache", function() { return withEmotionCache; });
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/inheritsLoose.js");
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _emotion_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/cache */ "./node_modules/@emotion/cache/dist/cache.browser.esm.js");
/* harmony import */ var _emotion_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/utils */ "./node_modules/@emotion/utils/dist/utils.browser.esm.js");
/* harmony import */ var _emotion_serialize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/serialize */ "./node_modules/@emotion/serialize/dist/serialize.browser.esm.js");
/* harmony import */ var _emotion_sheet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/sheet */ "./node_modules/@emotion/sheet/dist/sheet.browser.esm.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @emotion/css */ "./node_modules/@emotion/css/dist/css.browser.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "css", function() { return _emotion_css__WEBPACK_IMPORTED_MODULE_6__["default"]; });










var EmotionCacheContext = Object(react__WEBPACK_IMPORTED_MODULE_1__["createContext"])( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? Object(_emotion_cache__WEBPACK_IMPORTED_MODULE_2__["default"])() : null);
var ThemeContext = Object(react__WEBPACK_IMPORTED_MODULE_1__["createContext"])({});
var CacheProvider = EmotionCacheContext.Provider;

var withEmotionCache = function withEmotionCache(func) {
  var render = function render(props, ref) {
    return Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(EmotionCacheContext.Consumer, null, function (cache) {
      return func(props, cache, ref);
    });
  }; // $FlowFixMe


  return Object(react__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(render);
};

// thus we only need to replace what is a valid character for JS, but not for CSS

var sanitizeIdentifier = function sanitizeIdentifier(identifier) {
  return identifier.replace(/\$/g, '-');
};

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';
var hasOwnProperty = Object.prototype.hasOwnProperty;

var render = function render(cache, props, theme, ref) {
  var cssProp = theme === null ? props.css : props.css(theme); // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var type = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = Object(_emotion_utils__WEBPACK_IMPORTED_MODULE_3__["getRegisteredStyles"])(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = Object(_emotion_serialize__WEBPACK_IMPORTED_MODULE_4__["serializeStyles"])(registeredStyles);

  if ( true && serialized.name.indexOf('-') === -1) {
    var labelFromStack = props[labelPropName];

    if (labelFromStack) {
      serialized = Object(_emotion_serialize__WEBPACK_IMPORTED_MODULE_4__["serializeStyles"])([serialized, 'label:' + labelFromStack + ';']);
    }
  }

  var rules = Object(_emotion_utils__WEBPACK_IMPORTED_MODULE_3__["insertStyles"])(cache, serialized, typeof type === 'string');
  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ( false || key !== labelPropName)) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  var ele = Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(type, newProps);

  return ele;
};

var Emotion =
/* #__PURE__ */
withEmotionCache(function (props, cache, ref) {
  // use Context.read for the theme when it's stable
  if (typeof props.css === 'function') {
    return Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(ThemeContext.Consumer, null, function (theme) {
      return render(cache, props, theme, ref);
    });
  }

  return render(cache, props, null, ref);
});

if (true) {
  Emotion.displayName = 'EmotionCssPropInternal';
} // $FlowFixMe


var jsx = function jsx(type, props) {
  var args = arguments;

  if (props == null || !hasOwnProperty.call(props, 'css')) {
    // $FlowFixMe
    return react__WEBPACK_IMPORTED_MODULE_1__["createElement"].apply(undefined, args);
  }

  if ( true && typeof props.css === 'string' && // check if there is a css declaration
  props.css.indexOf(':') !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/css' like this: css`" + props.css + "`");
  }

  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion;
  var newProps = {};

  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }

  newProps[typePropName] = type;

  if (true) {
    var error = new Error();

    if (error.stack) {
      // chrome
      var match = error.stack.match(/at (?:Object\.|)jsx.*\n\s+at ([A-Z][A-Za-z$]+) /);

      if (!match) {
        // safari and firefox
        match = error.stack.match(/.*\n([A-Z][A-Za-z$]+)@/);
      }

      if (match) {
        newProps[labelPropName] = sanitizeIdentifier(match[1]);
      }
    }
  }

  createElementArgArray[1] = newProps;

  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  } // $FlowFixMe


  return react__WEBPACK_IMPORTED_MODULE_1__["createElement"].apply(null, createElementArgArray);
};

var warnedAboutCssPropForGlobal = false;
var Global =
/* #__PURE__ */
withEmotionCache(function (props, cache) {
  if ( true && !warnedAboutCssPropForGlobal && ( // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }

  var styles = props.styles;

  if (typeof styles === 'function') {
    return Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(ThemeContext.Consumer, null, function (theme) {
      var serialized = Object(_emotion_serialize__WEBPACK_IMPORTED_MODULE_4__["serializeStyles"])([styles(theme)]);
      return Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(InnerGlobal, {
        serialized: serialized,
        cache: cache
      });
    });
  }

  var serialized = Object(_emotion_serialize__WEBPACK_IMPORTED_MODULE_4__["serializeStyles"])([styles]);
  return Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(InnerGlobal, {
    serialized: serialized,
    cache: cache
  });
});

// maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag
var InnerGlobal =
/*#__PURE__*/
function (_React$Component) {
  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0___default()(InnerGlobal, _React$Component);

  function InnerGlobal(props, context, updater) {
    return _React$Component.call(this, props, context, updater) || this;
  }

  var _proto = InnerGlobal.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.sheet = new _emotion_sheet__WEBPACK_IMPORTED_MODULE_5__["StyleSheet"]({
      key: this.props.cache.key + "-global",
      nonce: this.props.cache.sheet.nonce,
      container: this.props.cache.sheet.container
    }); // $FlowFixMe

    var node = document.querySelector("style[data-emotion-" + this.props.cache.key + "=\"" + this.props.serialized.name + "\"]");

    if (node !== null) {
      this.sheet.tags.push(node);
    }

    if (this.props.cache.sheet.tags.length) {
      this.sheet.before = this.props.cache.sheet.tags[0];
    }

    this.insertStyles();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.serialized.name !== this.props.serialized.name) {
      this.insertStyles();
    }
  };

  _proto.insertStyles = function insertStyles$1() {
    if (this.props.serialized.next !== undefined) {
      // insert keyframes
      Object(_emotion_utils__WEBPACK_IMPORTED_MODULE_3__["insertStyles"])(this.props.cache, this.props.serialized.next, true);
    }

    if (this.sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      var element = this.sheet.tags[this.sheet.tags.length - 1].nextElementSibling;
      this.sheet.before = element;
      this.sheet.flush();
    }

    this.props.cache.insert("", this.props.serialized, this.sheet, false);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.sheet.flush();
  };

  _proto.render = function render() {

    return null;
  };

  return InnerGlobal;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]);

var keyframes = function keyframes() {
  var insertable = _emotion_css__WEBPACK_IMPORTED_MODULE_6__["default"].apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};

var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';

  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;

    switch (typeof arg) {
      case 'boolean':
        break;

      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            toAdd = '';

            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }

          break;
        }

      default:
        {
          toAdd = arg;
        }
    }

    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }

  return cls;
};

function merge(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = Object(_emotion_utils__WEBPACK_IMPORTED_MODULE_3__["getRegisteredStyles"])(registered, registeredStyles, className);

  if (registeredStyles.length < 2) {
    return className;
  }

  return rawClassName + css(registeredStyles);
}

var ClassNames = withEmotionCache(function (props, context) {
  return Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(ThemeContext.Consumer, null, function (theme) {
    var hasRendered = false;

    var css = function css() {
      if (hasRendered && "development" !== 'production') {
        throw new Error('css can only be used during render');
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var serialized = Object(_emotion_serialize__WEBPACK_IMPORTED_MODULE_4__["serializeStyles"])(args, context.registered);

      {
        Object(_emotion_utils__WEBPACK_IMPORTED_MODULE_3__["insertStyles"])(context, serialized, false);
      }

      return context.key + "-" + serialized.name;
    };

    var cx = function cx() {
      if (hasRendered && "development" !== 'production') {
        throw new Error('cx can only be used during render');
      }

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return merge(context.registered, css, classnames(args));
    };

    var content = {
      css: css,
      cx: cx,
      theme: theme
    };
    var ele = props.children(content);
    hasRendered = true;

    return ele;
  });
});




/***/ }),

/***/ "./node_modules/@emotion/css/dist/css.browser.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/@emotion/css/dist/css.browser.esm.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _emotion_serialize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/serialize */ "./node_modules/@emotion/serialize/dist/serialize.browser.esm.js");


function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return Object(_emotion_serialize__WEBPACK_IMPORTED_MODULE_0__["serializeStyles"])(args);
}

/* harmony default export */ __webpack_exports__["default"] = (css);


/***/ }),

/***/ "./node_modules/@emotion/hash/dist/hash.browser.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@emotion/hash/dist/hash.browser.esm.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

/* harmony default export */ __webpack_exports__["default"] = (murmur2);


/***/ }),

/***/ "./node_modules/@emotion/memoize/dist/memoize.browser.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@emotion/memoize/dist/memoize.browser.esm.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (memoize);


/***/ }),

/***/ "./node_modules/@emotion/serialize/dist/serialize.browser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@emotion/serialize/dist/serialize.browser.esm.js ***!
  \***********************************************************************/
/*! exports provided: serializeStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serializeStyles", function() { return serializeStyles; });
/* harmony import */ var _emotion_hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/hash */ "./node_modules/@emotion/hash/dist/hash.browser.esm.js");
/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/unitless */ "./node_modules/@emotion/unitless/dist/unitless.browser.esm.js");
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/memoize */ "./node_modules/@emotion/memoize/dist/memoize.browser.esm.js");




var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = Object(_emotion_memoize__WEBPACK_IMPORTED_MODULE_2__["default"])(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (_emotion_unitless__WEBPACK_IMPORTED_MODULE_1__["default"][key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (true) {
  var contentValuePattern = /(attr|calc|counters?|url)\(/;
  var contentValues = ['normal', 'none', 'counter', 'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote', 'initial', 'inherit', 'unset'];
  var oldProcessStyleValue = processStyleValue;
  var msPattern = /^-ms-/;
  var hyphenPattern = /-(.)/g;
  var hyphenatedCache = {};

  processStyleValue = function processStyleValue(key, value) {
    if (key === 'content') {
      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        console.error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }

    var processed = oldProcessStyleValue(key, value);

    if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }

    return processed;
  };
}

var shouldWarnAboutInterpolatingClassNameFromCss = true;

function handleInterpolation(mergedProps, registered, interpolation, couldBeSelectorInterpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if ( true && interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
      throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
    }

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          if ( true && interpolation.map !== undefined) {
            styles += interpolation.map;
          }

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result, couldBeSelectorInterpolation);
        } else if (true) {
          console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
        }

        break;
      }

    case 'string':
      if (true) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
          return "${" + fakeVarName + "}";
        });

        if (matched.length) {
          console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
        }
      }

      break;
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];

  if ( true && couldBeSelectorInterpolation && shouldWarnAboutInterpolatingClassNameFromCss && cached !== undefined) {
    console.error('Interpolating a className from css`` is not recommended and will cause problems with composition.\n' + 'Interpolating a className from css`` will be completely unsupported in a future major version of Emotion');
    shouldWarnAboutInterpolatingClassNameFromCss = false;
  }

  return cached !== undefined && !couldBeSelectorInterpolation ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i], false);
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "development" !== 'production') {
          throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value, false);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {
                if ( true && _key === 'undefined') {
                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                }

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;
var sourceMapPattern;

if (true) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//;
} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings, false);
  } else {
    if ( true && strings[0] === undefined) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i], styles.charCodeAt(styles.length - 1) === 46);

    if (stringMode) {
      if ( true && strings[i] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }

      styles += strings[i];
    }
  }

  var sourceMap;

  if (true) {
    styles = styles.replace(sourceMapPattern, function (match) {
      sourceMap = match;
      return '';
    });
  } // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = Object(_emotion_hash__WEBPACK_IMPORTED_MODULE_0__["default"])(styles) + identifierName;

  if (true) {
    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
    return {
      name: name,
      styles: styles,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};




/***/ }),

/***/ "./node_modules/@emotion/sheet/dist/sheet.browser.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@emotion/sheet/dist/sheet.browser.esm.js ***!
  \***************************************************************/
/*! exports provided: StyleSheet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleSheet", function() { return StyleSheet; });
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  return tag;
}

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(options) {
    this.isSpeedy = options.speedy === undefined ? "development" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      var _tag = createStyleElement(this);

      var before;

      if (this.tags.length === 0) {
        before = this.before;
      } else {
        before = this.tags[this.tags.length - 1].nextSibling;
      }

      this.container.insertBefore(_tag, before);
      this.tags.push(_tag);
    }

    var tag = this.tags[this.tags.length - 1];

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is a really hot path
        // we check the second character first because having "i"
        // as the second character will happen less often than
        // having "@" as the first character
        var isImportRule = rule.charCodeAt(1) === 105 && rule.charCodeAt(0) === 64; // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools

        sheet.insertRule(rule, // we need to insert @import rules before anything else
        // otherwise there will be an error
        // technically this means that the @import rules will
        // _usually_(not always since there could be multiple style tags)
        // be the first ones in prod and generally later in dev
        // this shouldn't really matter in the real world though
        // @import is generally only used for font faces from google fonts and etc.
        // so while this could be technically correct then it would be slower and larger
        // for a tiny bit of correctness that won't matter in the real world
        isImportRule ? 0 : sheet.cssRules.length);
      } catch (e) {
        if (true) {
          console.warn("There was a problem inserting the following rule: \"" + rule + "\"", e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };

  return StyleSheet;
}();




/***/ }),

/***/ "./node_modules/@emotion/stylis/dist/stylis.browser.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@emotion/stylis/dist/stylis.browser.esm.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function stylis_min (W) {
  function M(d, c, e, h, a) {
    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
      g = e.charCodeAt(l);
      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

      if (0 === b + n + v + m) {
        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
          switch (g) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;

            default:
              f += e.charAt(l);
          }

          g = 59;
        }

        switch (g) {
          case 123:
            f = f.trim();
            q = f.charCodeAt(0);
            k = 1;

            for (t = ++l; l < B;) {
              switch (g = e.charCodeAt(l)) {
                case 123:
                  k++;
                  break;

                case 125:
                  k--;
                  break;

                case 47:
                  switch (g = e.charCodeAt(l + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u = l + 1; u < J; ++u) {
                          switch (e.charCodeAt(u)) {
                            case 47:
                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                l = u + 1;
                                break a;
                              }

                              break;

                            case 10:
                              if (47 === g) {
                                l = u + 1;
                                break a;
                              }

                          }
                        }

                        l = u;
                      }

                  }

                  break;

                case 91:
                  g++;

                case 40:
                  g++;

                case 34:
                case 39:
                  for (; l++ < J && e.charCodeAt(l) !== g;) {
                  }

              }

              if (0 === k) break;
              l++;
            }

            k = e.substring(t, l);
            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

            switch (q) {
              case 64:
                0 < r && (f = f.replace(N, ''));
                g = f.charCodeAt(1);

                switch (g) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r = c;
                    break;

                  default:
                    r = O;
                }

                k = M(c, r, k, g, a + 1);
                t = k.length;
                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                if (0 < t) switch (g) {
                  case 115:
                    f = f.replace(da, ea);

                  case 100:
                  case 109:
                  case 45:
                    k = f + '{' + k + '}';
                    break;

                  case 107:
                    f = f.replace(fa, '$1 $2');
                    k = f + '{' + k + '}';
                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                    break;

                  default:
                    k = f + k, 112 === h && (k = (p += k, ''));
                } else k = '';
                break;

              default:
                k = M(c, X(c, f, I), k, h, a + 1);
            }

            F += k;
            k = I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
            break;

          case 125:
          case 59:
            f = (0 < r ? f.replace(N, '') : f).trim();
            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
              case 0:
                break;

              case 64:
                if (105 === g || 99 === g) {
                  G += f + e.charAt(l);
                  break;
                }

              default:
                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
            }
            I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
        }
      }

      switch (g) {
        case 13:
        case 10:
          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
          z = 1;
          D++;
          break;

        case 59:
        case 125:
          if (0 === b + n + v + m) {
            z++;
            break;
          }

        default:
          z++;
          y = e.charAt(l);

          switch (g) {
            case 9:
            case 32:
              if (0 === n + m + b) switch (x) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y = '';
                  break;

                default:
                  32 !== g && (y = ' ');
              }
              break;

            case 0:
              y = '\\0';
              break;

            case 12:
              y = '\\f';
              break;

            case 11:
              y = '\\v';
              break;

            case 38:
              0 === n + b + m && (r = I = 1, y = '\f' + y);
              break;

            case 108:
              if (0 === n + b + m + E && 0 < u) switch (l - u) {
                case 2:
                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                case 8:
                  111 === K && (E = K);
              }
              break;

            case 58:
              0 === n + b + m && (u = l);
              break;

            case 44:
              0 === b + v + n + m && (r = 1, y += '\r');
              break;

            case 34:
            case 39:
              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
              break;

            case 91:
              0 === n + b + v && m++;
              break;

            case 93:
              0 === n + b + v && m--;
              break;

            case 41:
              0 === n + b + m && v--;
              break;

            case 40:
              if (0 === n + b + m) {
                if (0 === q) switch (2 * x + 3 * K) {
                  case 533:
                    break;

                  default:
                    q = 1;
                }
                v++;
              }

              break;

            case 64:
              0 === b + v + n + m + u + k && (k = 1);
              break;

            case 42:
            case 47:
              if (!(0 < n + m + v)) switch (b) {
                case 0:
                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                    case 235:
                      b = 47;
                      break;

                    case 220:
                      t = l, b = 42;
                  }

                  break;

                case 42:
                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
              }
          }

          0 === b && (f += y);
      }

      K = x;
      x = g;
      l++;
    }

    t = p.length;

    if (0 < t) {
      r = c;
      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
      p = r.join(',') + '{' + p + '}';

      if (0 !== w * E) {
        2 !== w || L(p, 2) || (E = 0);

        switch (E) {
          case 111:
            p = p.replace(ha, ':-moz-$1') + p;
            break;

          case 112:
            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
        }

        E = 0;
      }
    }

    return G + p + F;
  }

  function X(d, c, e) {
    var h = c.trim().split(ia);
    c = h;
    var a = h.length,
        m = d.length;

    switch (m) {
      case 0:
      case 1:
        var b = 0;

        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
          c[b] = Z(d, c[b], e).trim();
        }

        break;

      default:
        var v = b = 0;

        for (c = []; b < a; ++b) {
          for (var n = 0; n < m; ++n) {
            c[v++] = Z(d[n] + ' ', h[b], e).trim();
          }
        }

    }

    return c;
  }

  function Z(d, c, e) {
    var h = c.charCodeAt(0);
    33 > h && (h = (c = c.trim()).charCodeAt(0));

    switch (h) {
      case 38:
        return c.replace(F, '$1' + d.trim());

      case 58:
        return d.trim() + c.replace(F, '$1' + d.trim());

      default:
        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
    }

    return d + c;
  }

  function P(d, c, e, h) {
    var a = d + ';',
        m = 2 * c + 3 * e + 4 * h;

    if (944 === m) {
      d = a.indexOf(':', 9) + 1;
      var b = a.substring(d, a.length - 1).trim();
      b = a.substring(0, d).trim() + b + ';';
      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
    }

    if (0 === w || 2 === w && !L(a, 1)) return a;

    switch (m) {
      case 1015:
        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

      case 951:
        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

      case 963:
        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

      case 1009:
        if (100 !== a.charCodeAt(4)) break;

      case 969:
      case 942:
        return '-webkit-' + a + a;

      case 978:
        return '-webkit-' + a + '-moz-' + a + a;

      case 1019:
      case 983:
        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

      case 883:
        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
        break;

      case 932:
        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
          case 103:
            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

          case 115:
            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

          case 98:
            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
        }
        return '-webkit-' + a + '-ms-' + a + a;

      case 964:
        return '-webkit-' + a + '-ms-flex-' + a + a;

      case 1023:
        if (99 !== a.charCodeAt(8)) break;
        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

      case 1005:
        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

      case 1e3:
        b = a.substring(13).trim();
        c = b.indexOf('-') + 1;

        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
          case 226:
            b = a.replace(G, 'tb');
            break;

          case 232:
            b = a.replace(G, 'tb-rl');
            break;

          case 220:
            b = a.replace(G, 'lr');
            break;

          default:
            return a;
        }

        return '-webkit-' + a + '-ms-' + b + a;

      case 1017:
        if (-1 === a.indexOf('sticky', 9)) break;

      case 975:
        c = (a = d).length - 10;
        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b.charCodeAt(8)) break;

          case 115:
            a = a.replace(b, '-webkit-' + b) + ';' + a;
            break;

          case 207:
          case 102:
            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
        }

        return a + ';';

      case 938:
        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
          case 105:
            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

          case 115:
            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

          default:
            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
        }
        break;

      case 973:
      case 989:
        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

      case 931:
      case 953:
        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
        break;

      case 962:
        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
    }

    return a;
  }

  function L(d, c) {
    var e = d.indexOf(1 === c ? ':' : '{'),
        h = d.substring(0, 3 !== c ? e : 10);
    e = d.substring(e + 1, d.length - 1);
    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
  }

  function ea(d, c) {
    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
  }

  function H(d, c, e, h, a, m, b, v, n, q) {
    for (var g = 0, x = c, w; g < A; ++g) {
      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;

        default:
          x = w;
      }
    }

    if (x !== c) return x;
  }

  function T(d) {
    switch (d) {
      case void 0:
      case null:
        A = S.length = 0;
        break;

      default:
        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
          T(d[c]);
        } else Y = !!d | 0;
    }

    return T;
  }

  function U(d) {
    d = d.prefix;
    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
    return U;
  }

  function B(d, c) {
    var e = d;
    33 > e.charCodeAt(0) && (e = e.trim());
    V = e;
    e = [V];

    if (0 < A) {
      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
      void 0 !== h && 'string' === typeof h && (c = h);
    }

    var a = M(O, e, c, 0, 0);
    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
    V = '';
    E = 0;
    z = D = 1;
    return a;
  }

  var ca = /^\0+/g,
      N = /[\0\r\f]/g,
      aa = /: */g,
      ka = /zoo|gra/,
      ma = /([,: ])(transform)/g,
      ia = /,\r+?/g,
      F = /([\t\r\n ])*\f?&/g,
      fa = /@(k\w+)\s*(\S*)\s*/,
      Q = /::(place)/g,
      ha = /:(read-only)/g,
      G = /[svh]\w+-[tblr]{2}/,
      da = /\(\s*(.*)\s*\)/g,
      oa = /([\s\S]*?);/g,
      ba = /-self|flex-/g,
      na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
      la = /stretch|:\s*\w+\-(?:conte|avail)/,
      ja = /([^-])(image-set\()/,
      z = 1,
      D = 1,
      E = 0,
      w = 1,
      O = [],
      S = [],
      A = 0,
      R = null,
      Y = 0,
      V = '';
  B.use = T;
  B.set = U;
  void 0 !== W && U(W);
  return B;
}

/* harmony default export */ __webpack_exports__["default"] = (stylis_min);


/***/ }),

/***/ "./node_modules/@emotion/unitless/dist/unitless.browser.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@emotion/unitless/dist/unitless.browser.esm.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ __webpack_exports__["default"] = (unitlessKeys);


/***/ }),

/***/ "./node_modules/@emotion/utils/dist/utils.browser.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@emotion/utils/dist/utils.browser.esm.js ***!
  \***************************************************************/
/*! exports provided: getRegisteredStyles, insertStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRegisteredStyles", function() { return getRegisteredStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertStyles", function() { return insertStyles; });
var isBrowser = "object" !== 'undefined';
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className]);
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false && cache.compat !== undefined) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      var maybeStyles = cache.insert("." + className, current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};




/***/ }),

/***/ "./node_modules/@emotion/weak-memoize/dist/weak-memoize.browser.esm.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@emotion/weak-memoize/dist/weak-memoize.browser.esm.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var weakMemoize = function weakMemoize(func) {
  // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
  var cache = new WeakMap();
  return function (arg) {
    if (cache.has(arg)) {
      // $FlowFixMe
      return cache.get(arg);
    }

    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};

/* harmony default export */ __webpack_exports__["default"] = (weakMemoize);


/***/ }),

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/dom-serializer/foreignNames.json":
/*!*******************************************************!*\
  !*** ./node_modules/dom-serializer/foreignNames.json ***!
  \*******************************************************/
/*! exports provided: elementNames, attributeNames, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"elementNames\":{\"altglyph\":\"altGlyph\",\"altglyphdef\":\"altGlyphDef\",\"altglyphitem\":\"altGlyphItem\",\"animatecolor\":\"animateColor\",\"animatemotion\":\"animateMotion\",\"animatetransform\":\"animateTransform\",\"clippath\":\"clipPath\",\"feblend\":\"feBlend\",\"fecolormatrix\":\"feColorMatrix\",\"fecomponenttransfer\":\"feComponentTransfer\",\"fecomposite\":\"feComposite\",\"feconvolvematrix\":\"feConvolveMatrix\",\"fediffuselighting\":\"feDiffuseLighting\",\"fedisplacementmap\":\"feDisplacementMap\",\"fedistantlight\":\"feDistantLight\",\"fedropshadow\":\"feDropShadow\",\"feflood\":\"feFlood\",\"fefunca\":\"feFuncA\",\"fefuncb\":\"feFuncB\",\"fefuncg\":\"feFuncG\",\"fefuncr\":\"feFuncR\",\"fegaussianblur\":\"feGaussianBlur\",\"feimage\":\"feImage\",\"femerge\":\"feMerge\",\"femergenode\":\"feMergeNode\",\"femorphology\":\"feMorphology\",\"feoffset\":\"feOffset\",\"fepointlight\":\"fePointLight\",\"fespecularlighting\":\"feSpecularLighting\",\"fespotlight\":\"feSpotLight\",\"fetile\":\"feTile\",\"feturbulence\":\"feTurbulence\",\"foreignobject\":\"foreignObject\",\"glyphref\":\"glyphRef\",\"lineargradient\":\"linearGradient\",\"radialgradient\":\"radialGradient\",\"textpath\":\"textPath\"},\"attributeNames\":{\"definitionurl\":\"definitionURL\",\"attributename\":\"attributeName\",\"attributetype\":\"attributeType\",\"basefrequency\":\"baseFrequency\",\"baseprofile\":\"baseProfile\",\"calcmode\":\"calcMode\",\"clippathunits\":\"clipPathUnits\",\"diffuseconstant\":\"diffuseConstant\",\"edgemode\":\"edgeMode\",\"filterunits\":\"filterUnits\",\"glyphref\":\"glyphRef\",\"gradienttransform\":\"gradientTransform\",\"gradientunits\":\"gradientUnits\",\"kernelmatrix\":\"kernelMatrix\",\"kernelunitlength\":\"kernelUnitLength\",\"keypoints\":\"keyPoints\",\"keysplines\":\"keySplines\",\"keytimes\":\"keyTimes\",\"lengthadjust\":\"lengthAdjust\",\"limitingconeangle\":\"limitingConeAngle\",\"markerheight\":\"markerHeight\",\"markerunits\":\"markerUnits\",\"markerwidth\":\"markerWidth\",\"maskcontentunits\":\"maskContentUnits\",\"maskunits\":\"maskUnits\",\"numoctaves\":\"numOctaves\",\"pathlength\":\"pathLength\",\"patterncontentunits\":\"patternContentUnits\",\"patterntransform\":\"patternTransform\",\"patternunits\":\"patternUnits\",\"pointsatx\":\"pointsAtX\",\"pointsaty\":\"pointsAtY\",\"pointsatz\":\"pointsAtZ\",\"preservealpha\":\"preserveAlpha\",\"preserveaspectratio\":\"preserveAspectRatio\",\"primitiveunits\":\"primitiveUnits\",\"refx\":\"refX\",\"refy\":\"refY\",\"repeatcount\":\"repeatCount\",\"repeatdur\":\"repeatDur\",\"requiredextensions\":\"requiredExtensions\",\"requiredfeatures\":\"requiredFeatures\",\"specularconstant\":\"specularConstant\",\"specularexponent\":\"specularExponent\",\"spreadmethod\":\"spreadMethod\",\"startoffset\":\"startOffset\",\"stddeviation\":\"stdDeviation\",\"stitchtiles\":\"stitchTiles\",\"surfacescale\":\"surfaceScale\",\"systemlanguage\":\"systemLanguage\",\"tablevalues\":\"tableValues\",\"targetx\":\"targetX\",\"targety\":\"targetY\",\"textlength\":\"textLength\",\"viewbox\":\"viewBox\",\"viewtarget\":\"viewTarget\",\"xchannelselector\":\"xChannelSelector\",\"ychannelselector\":\"yChannelSelector\",\"zoomandpan\":\"zoomAndPan\"}}");

/***/ }),

/***/ "./node_modules/dom-serializer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dom-serializer/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
  Module dependencies
*/
var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js");
var entities = __webpack_require__(/*! entities */ "./node_modules/entities/lib/index.js");

/* mixed-case SVG and MathML tags & attributes
   recognized by the HTML parser, see
   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
*/
var foreignNames = __webpack_require__(/*! ./foreignNames.json */ "./node_modules/dom-serializer/foreignNames.json");
foreignNames.elementNames.__proto__ = null; /* use as a simple dictionary */
foreignNames.attributeNames.__proto__ = null;

var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;

  var output = '';
  var value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }

    if (opts.xmlMode === 'foreign') {
      /* fix up mixed-case attribute names */
      key = foreignNames.attributeNames[key] || key;
    }
    output += key;
    if ((value !== null && value !== '') || opts.xmlMode) {
      output +=
        '="' +
        (opts.decodeEntities
          ? entities.encodeXML(value)
          : value.replace(/\"/g, '&quot;')) +
        '"';
    }
  }

  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

var render = (module.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};

  var output = '';

  for (var i = 0; i < dom.length; i++) {
    var elem = dom[i];

    if (elem.type === 'root') output += render(elem.children, opts);
    else if (ElementType.isTag(elem)) output += renderTag(elem, opts);
    else if (elem.type === ElementType.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType.Comment) output += renderComment(elem);
    else if (elem.type === ElementType.CDATA) output += renderCdata(elem);
    else output += renderText(elem, opts);
  }

  return output;
});

var foreignModeIntegrationPoints = [
  'mi',
  'mo',
  'mn',
  'ms',
  'mtext',
  'annotation-xml',
  'foreignObject',
  'desc',
  'title'
];

function renderTag(elem, opts) {
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === 'foreign') {
    /* fix up mixed-case element names */
    elem.name = foreignNames.elementNames[elem.name] || elem.name;
    /* exit foreign mode at integration points */
    if (
      elem.parent &&
      foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0
    )
      opts = Object.assign({}, opts, { xmlMode: false });
  }
  if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {
    opts = Object.assign({}, opts, { xmlMode: 'foreign' });
  }

  var tag = '<' + elem.name;
  var attribs = formatAttrs(elem.attribs, opts);

  if (attribs) {
    tag += ' ' + attribs;
  }

  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }

    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }

  return tag;
}

function renderDirective(elem) {
  return '<' + elem.data + '>';
}

function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (
    opts.decodeEntities &&
    !(elem.parent && elem.parent.name in unencodedElements)
  ) {
    data = entities.encodeXML(data);
  }

  return data;
}

function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}

function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}


/***/ }),

/***/ "./node_modules/domelementtype/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/domelementtype/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === "tag" /* Tag */ ||
        elem.type === "script" /* Script */ ||
        elem.type === "style" /* Style */);
}
exports.isTag = isTag;
// Exports for backwards compatibility
exports.Text = "text" /* Text */; //Text
exports.Directive = "directive" /* Directive */; //<? ... ?>
exports.Comment = "comment" /* Comment */; //<!-- ... -->
exports.Script = "script" /* Script */; //<script> tags
exports.Style = "style" /* Style */; //<style> tags
exports.Tag = "tag" /* Tag */; //Any tag
exports.CDATA = "cdata" /* CDATA */; //<![CDATA[ ... ]]>
exports.Doctype = "doctype" /* Doctype */;


/***/ }),

/***/ "./node_modules/domhandler/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/domhandler/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var node_1 = __webpack_require__(/*! ./node */ "./node_modules/domhandler/lib/node.js");
exports.Node = node_1.Node;
exports.Element = node_1.Element;
exports.DataNode = node_1.DataNode;
exports.NodeWithChildren = node_1.NodeWithChildren;
var reWhitespace = /\s+/g;
// Default options
var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false
};
var DomHandler = /** @class */ (function () {
    /**
     * Initiate a new DomHandler.
     *
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The constructed DOM */
        this.dom = [];
        /** Indicated whether parsing has been completed. */
        this._done = false;
        /** Stack of open tags. */
        this._tagStack = [];
        /** A data node that is still being written to. */
        this._lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this._parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this._callback = callback || null;
        this._options = options || defaultOpts;
        this._elementCB = elementCB || null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this._parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        this.dom = [];
        this._done = false;
        this._tagStack = [];
        this._lastNode = null;
        this._parser = this._parser || null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this._done)
            return;
        this._done = true;
        this._parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this._lastNode = null;
        // If(this._tagStack.pop().name !== name) this.handleCallback(Error("Tagname didn't match!"));
        var elem = this._tagStack.pop();
        if (!elem || !this._parser) {
            return;
        }
        if (this._options.withEndIndices) {
            elem.endIndex = this._parser.endIndex;
        }
        if (this._elementCB)
            this._elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var element = new node_1.Element(name, attribs);
        this.addNode(element);
        this._tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var normalize = this._options.normalizeWhitespace;
        var _lastNode = this._lastNode;
        if (_lastNode && _lastNode.type === "text" /* Text */) {
            if (normalize) {
                _lastNode.data = (_lastNode.data + data).replace(reWhitespace, " ");
            }
            else {
                _lastNode.data += data;
            }
        }
        else {
            if (normalize) {
                data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.DataNode("text" /* Text */, data);
            this.addNode(node);
            this._lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this._lastNode && this._lastNode.type === "comment" /* Comment */) {
            this._lastNode.data += data;
            return;
        }
        var node = new node_1.DataNode("comment" /* Comment */, data);
        this.addNode(node);
        this._lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this._lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_1.DataNode("text" /* Text */, "");
        var node = new node_1.NodeWithChildren("cdata" /* CDATA */, [text]);
        this.addNode(node);
        text.parent = node;
        this._lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this._lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this._callback === "function") {
            this._callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this._tagStack[this._tagStack.length - 1];
        var siblings = parent ? parent.children : this.dom;
        var previousSibling = siblings[siblings.length - 1];
        if (this._parser) {
            if (this._options.withStartIndices) {
                node.startIndex = this._parser.startIndex;
            }
            if (this._options.withEndIndices) {
                node.endIndex = this._parser.endIndex;
            }
        }
        siblings.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        if (parent) {
            node.parent = parent;
        }
        this._lastNode = null;
    };
    DomHandler.prototype.addDataNode = function (node) {
        this.addNode(node);
        this._lastNode = node;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports.default = DomHandler;


/***/ }),

/***/ "./node_modules/domhandler/lib/node.js":
/*!*********************************************!*\
  !*** ./node_modules/domhandler/lib/node.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var nodeTypes = new Map([
    ["tag" /* Tag */, 1],
    ["script" /* Script */, 1],
    ["style" /* Style */, 1],
    ["directive" /* Directive */, 1],
    ["text" /* Text */, 3],
    ["cdata" /* CDATA */, 4],
    ["comment" /* Comment */, 8]
]);
// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var Node = /** @class */ (function () {
    /**
     *
     * @param type The type of the node.
     */
    function Node(type) {
        this.type = type;
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "nodeType", {
        // Read-only aliases
        get: function () {
            return nodeTypes.get(this.type) || 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        get: function () {
            return this.parent || null;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        get: function () {
            return this.prev || null;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        get: function () {
            return this.next || null;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: true,
        configurable: true
    });
    return Node;
}());
exports.Node = Node;
var DataNode = /** @class */ (function (_super) {
    __extends(DataNode, _super);
    /**
     *
     * @param type The type of the node
     * @param data The content of the data node
     */
    function DataNode(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: true,
        configurable: true
    });
    return DataNode;
}(Node));
exports.DataNode = DataNode;
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, "directive" /* Directive */, data) || this;
        _this.name = name;
        return _this;
    }
    return ProcessingInstruction;
}(DataNode));
exports.ProcessingInstruction = ProcessingInstruction;
var NodeWithChildren = /** @class */ (function (_super) {
    __extends(NodeWithChildren, _super);
    /**
     *
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        get: function () {
            return this.children[0] || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        get: function () {
            return this.children[this.children.length - 1] || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: true,
        configurable: true
    });
    return NodeWithChildren;
}(Node));
exports.NodeWithChildren = NodeWithChildren;
var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    /**
     *
     * @param name Name of the tag, eg. `div`, `span`
     * @param attribs Object mapping attribute names to attribute values
     */
    function Element(name, attribs) {
        var _this = _super.call(this, name === "script"
            ? "script" /* Script */
            : name === "style"
                ? "style" /* Style */
                : "tag" /* Tag */, []) || this;
        _this.name = name;
        _this.attribs = attribs;
        _this.attribs = attribs;
        return _this;
    }
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: true,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
exports.Element = Element;


/***/ }),

/***/ "./node_modules/domutils/lib/helpers.js":
/*!**********************************************!*\
  !*** ./node_modules/domutils/lib/helpers.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tagtypes_1 = __webpack_require__(/*! ./tagtypes */ "./node_modules/domutils/lib/tagtypes.js");
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes — Nodes to filter.
 */
function removeSubsets(nodes) {
    var idx = nodes.length;
    // Check if each node (or one of its ancestors) is already contained in the
    // array.
    while (--idx >= 0) {
        var node = nodes[idx];
        // Remove the node if it is not unique.
        // We are going through the array from the end, so we only
        // have to check nodes that preceed the node under consideration in the array.
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.indexOf(ancestor) > -1) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
exports.removeSubsets = removeSubsets;
/***
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 * @argument nodaA The first node to use in the comparison
 * @argument nodeB The second node to use in the comparison
 *
 * @return A bitmask describing the input nodes' relative position.
 *
 *        See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 *        a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = tagtypes_1.hasChildren(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = tagtypes_1.hasChildren(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var idx = 0;
    while (aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return 1 /* DISCONNECTED */;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
        }
        return 4 /* FOLLOWING */;
    }
    else {
        if (sharedParent === nodeA) {
            return 2 /* PRECEDING */ | 8 /* CONTAINS */;
        }
        return 2 /* PRECEDING */;
    }
}
exports.compareDocumentPosition = compareDocumentPosition;
/***
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @argument nodes Array of DOM nodes
 * @returns collection of unique nodes, sorted in document order
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2 /* PRECEDING */) {
            return -1;
        }
        else if (relative & 4 /* FOLLOWING */) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
exports.uniqueSort = uniqueSort;


/***/ }),

/***/ "./node_modules/domutils/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/domutils/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./stringify */ "./node_modules/domutils/lib/stringify.js"));
__export(__webpack_require__(/*! ./traversal */ "./node_modules/domutils/lib/traversal.js"));
__export(__webpack_require__(/*! ./manipulation */ "./node_modules/domutils/lib/manipulation.js"));
__export(__webpack_require__(/*! ./querying */ "./node_modules/domutils/lib/querying.js"));
__export(__webpack_require__(/*! ./legacy */ "./node_modules/domutils/lib/legacy.js"));
__export(__webpack_require__(/*! ./helpers */ "./node_modules/domutils/lib/helpers.js"));
__export(__webpack_require__(/*! ./tagtypes */ "./node_modules/domutils/lib/tagtypes.js"));


/***/ }),

/***/ "./node_modules/domutils/lib/legacy.js":
/*!*********************************************!*\
  !*** ./node_modules/domutils/lib/legacy.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var querying_1 = __webpack_require__(/*! ./querying */ "./node_modules/domutils/lib/querying.js");
var tagtypes_1 = __webpack_require__(/*! ./tagtypes */ "./node_modules/domutils/lib/tagtypes.js");
function isTextNode(node) {
    return node.type === "text" /* Text */;
}
/* eslint-disable @typescript-eslint/camelcase */
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return tagtypes_1.isTag(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return tagtypes_1.isTag;
        }
        else {
            return function (elem) { return tagtypes_1.isTag(elem) && elem.name === name; };
        }
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        else {
            return function (elem) { return elem.type === type; };
        }
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return isTextNode(elem) && data(elem.data); };
        }
        else {
            return function (elem) { return isTextNode(elem) && elem.data === data; };
        }
    }
};
/* eslint-enable @typescript-eslint/camelcase */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return tagtypes_1.isTag(elem) && value(elem.attribs[attrib]); };
    }
    else {
        return function (elem) { return tagtypes_1.isTag(elem) && elem.attribs[attrib] === value; };
    }
}
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        // @ts-ignore
        return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, element) {
    var test = compileTest(options);
    return test ? test(element) : true;
}
exports.testElement = testElement;
function getElements(options, element, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? querying_1.filter(test, element, recurse, limit) : [];
}
exports.getElements = getElements;
function getElementById(id, element, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(element))
        element = [element];
    return querying_1.findOne(getAttribCheck("id", id), element, recurse);
}
exports.getElementById = getElementById;
function getElementsByTagName(name, element, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    return querying_1.filter(Checks.tag_name(name), element, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
function getElementsByTagType(type, element, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return querying_1.filter(Checks.tag_type(type), element, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType;


/***/ }),

/***/ "./node_modules/domutils/lib/manipulation.js":
/*!***************************************************!*\
  !*** ./node_modules/domutils/lib/manipulation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/***
 * Remove an element from the dom
 *
 * @argument elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
exports.removeElement = removeElement;
/***
 * Replace an element in the dom
 *
 * @argument elem The element to be replaced
 * @argument replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
}
exports.replaceElement = replaceElement;
/***
 * Append a child to an element
 *
 * @argument elem The element to append to
 * @argument child The element to be added as a child
 */
function appendChild(elem, child) {
    child.parent = elem;
    if (elem.children.push(child) !== 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
        child.next = null;
    }
}
exports.appendChild = appendChild;
/***
 * Append an element after another
 *
 * @argument elem The element to append to
 * @argument next The element be added
 */
function append(elem, next) {
    var parent = elem.parent, currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
exports.append = append;
/***
 * Prepend an element before another
 *
 * @argument elem The element to append to
 * @argument prev The element be added
 */
function prepend(elem, prev) {
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
exports.prepend = prepend;


/***/ }),

/***/ "./node_modules/domutils/lib/querying.js":
/*!***********************************************!*\
  !*** ./node_modules/domutils/lib/querying.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tagtypes_1 = __webpack_require__(/*! ./tagtypes */ "./node_modules/domutils/lib/tagtypes.js");
function filter(test, element, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(element))
        element = [element];
    return find(test, element, recurse, limit);
}
exports.filter = filter;
function find(test, elems, recurse, limit) {
    var result = [];
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && tagtypes_1.hasChildren(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result = result.concat(children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
exports.find = find;
function findOneChild(test, elems) {
    for (var i = 0; i < elems.length; i++) {
        if (test(elems[i]))
            return elems[i];
    }
    return null;
}
exports.findOneChild = findOneChild;
function findOne(test, elems, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < elems.length && !elem; i++) {
        var checked = elems[i];
        if (!tagtypes_1.isTag(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children);
        }
    }
    return elem;
}
exports.findOne = findOne;
function existsOne(test, elems) {
    for (var i = 0; i < elems.length; i++) {
        var checked = elems[i];
        if (tagtypes_1.isTag(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne(test, checked.children)))) {
            return true;
        }
    }
    return false;
}
exports.existsOne = existsOne;
function findAll(test, rootElems) {
    var result = [];
    var stack = rootElems.slice();
    while (stack.length) {
        var elem = stack.shift();
        if (!elem || !tagtypes_1.isTag(elem))
            continue;
        if (elem.children && elem.children.length > 0) {
            stack.unshift.apply(stack, elem.children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
exports.findAll = findAll;


/***/ }),

/***/ "./node_modules/domutils/lib/stringify.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/stringify.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tagtypes_1 = __webpack_require__(/*! ./tagtypes */ "./node_modules/domutils/lib/tagtypes.js");
var dom_serializer_1 = __importDefault(__webpack_require__(/*! dom-serializer */ "./node_modules/dom-serializer/index.js"));
exports.getOuterHTML = dom_serializer_1.default;
function getInnerHTML(node, options) {
    return tagtypes_1.hasChildren(node)
        ? node.children.map(function (node) { return exports.getOuterHTML(node, options); }).join("")
        : "";
}
exports.getInnerHTML = getInnerHTML;
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if (tagtypes_1.isTag(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if (tagtypes_1.isCDATA(node))
        return getText(node.children);
    if (tagtypes_1.isText(node))
        return node.data;
    return "";
}
exports.getText = getText;


/***/ }),

/***/ "./node_modules/domutils/lib/tagtypes.js":
/*!***********************************************!*\
  !*** ./node_modules/domutils/lib/tagtypes.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var domelementtype_1 = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js");
function isTag(node) {
    return domelementtype_1.isTag(node);
}
exports.isTag = isTag;
function isCDATA(node) {
    return "cdata" /* CDATA */ === node.type;
}
exports.isCDATA = isCDATA;
function isText(node) {
    return node.type === "text" /* Text */;
}
exports.isText = isText;
function isComment(node) {
    return node.type === "comment" /* Comment */;
}
exports.isComment = isComment;
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;


/***/ }),

/***/ "./node_modules/domutils/lib/traversal.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/traversal.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getChildren(elem) {
    // @ts-ignore
    return elem.children || null;
}
exports.getChildren = getChildren;
function getParent(elem) {
    return elem.parent || null;
}
exports.getParent = getParent;
function getSiblings(elem) {
    var parent = getParent(elem);
    return parent ? getChildren(parent) : [elem];
}
exports.getSiblings = getSiblings;
function getAttributeValue(elem, name) {
    return elem.attribs && elem.attribs[name];
}
exports.getAttributeValue = getAttributeValue;
function hasAttrib(elem, name) {
    return !!getAttributeValue(elem, name);
}
exports.hasAttrib = hasAttrib;
/***
 * Returns the name property of an element
 *
 * @argument elem The element to get the name for
 */
function getName(elem) {
    return elem.name;
}
exports.getName = getName;


/***/ }),

/***/ "./node_modules/entities/lib/decode.js":
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/decode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ "./node_modules/entities/lib/maps/entities.json"));
var legacy_json_1 = __importDefault(__webpack_require__(/*! ./maps/legacy.json */ "./node_modules/entities/lib/maps/legacy.json"));
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ "./node_modules/entities/lib/maps/xml.json"));
var decode_codepoint_1 = __importDefault(__webpack_require__(/*! ./decode_codepoint */ "./node_modules/entities/lib/decode_codepoint.js"));
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
    var keys = Object.keys(map).join("|");
    var replace = getReplacer(map);
    keys += "|#[xX][\\da-fA-F]+|#\\d+";
    var re = new RegExp("&(?:" + keys + ");", "g");
    return function (str) { return String(str).replace(re, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
exports.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    //TODO consider creating a merged map
    return function (str) {
        return String(str).replace(re, replacer);
    };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            if (str.charAt(2) === "X" || str.charAt(2) === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)];
    };
}


/***/ }),

/***/ "./node_modules/entities/lib/decode_codepoint.js":
/*!*******************************************************!*\
  !*** ./node_modules/entities/lib/decode_codepoint.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var decode_json_1 = __importDefault(__webpack_require__(/*! ./maps/decode.json */ "./node_modules/entities/lib/maps/decode.json"));
// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        // @ts-ignore
        codePoint = decode_json_1.default[codePoint];
    }
    var output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
}
exports.default = decodeCodePoint;


/***/ }),

/***/ "./node_modules/entities/lib/encode.js":
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/encode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ "./node_modules/entities/lib/maps/xml.json"));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
exports.encodeXML = getInverse(inverseXML, xmlReplacer);
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ "./node_modules/entities/lib/maps/entities.json"));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    Object.keys(inverse).forEach(function (k) {
        return k.length === 1
            ? // Add value to single array
                single.push("\\" + k)
            : // Add value to multiple array
                multiple.push(k);
    });
    //TODO add ranges
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
var reNonASCII = /[^\0-\x7F]/g;
var reAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
function singleCharReplacer(c) {
    return "&#x" + c
        .charCodeAt(0)
        .toString(16)
        .toUpperCase() + ";";
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
function astralReplacer(c, _) {
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    var high = c.charCodeAt(0);
    var low = c.charCodeAt(1);
    var codePoint = (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;
    return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reAstralSymbols, astralReplacer)
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reXmlChars = getInverseReplacer(inverseXML);
function escape(data) {
    return data
        .replace(reXmlChars, singleCharReplacer)
        .replace(reAstralSymbols, astralReplacer)
        .replace(reNonASCII, singleCharReplacer);
}
exports.escape = escape;


/***/ }),

/***/ "./node_modules/entities/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/entities/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var decode_1 = __webpack_require__(/*! ./decode */ "./node_modules/entities/lib/decode.js");
var encode_1 = __webpack_require__(/*! ./encode */ "./node_modules/entities/lib/encode.js");
function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __webpack_require__(/*! ./encode */ "./node_modules/entities/lib/encode.js");
exports.encodeXML = encode_2.encodeXML;
exports.encodeHTML = encode_2.encodeHTML;
exports.escape = encode_2.escape;
// Legacy aliases
exports.encodeHTML4 = encode_2.encodeHTML;
exports.encodeHTML5 = encode_2.encodeHTML;
var decode_2 = __webpack_require__(/*! ./decode */ "./node_modules/entities/lib/decode.js");
exports.decodeXML = decode_2.decodeXML;
exports.decodeHTML = decode_2.decodeHTML;
exports.decodeHTMLStrict = decode_2.decodeHTMLStrict;
// Legacy aliases
exports.decodeHTML4 = decode_2.decodeHTML;
exports.decodeHTML5 = decode_2.decodeHTML;
exports.decodeHTML4Strict = decode_2.decodeHTMLStrict;
exports.decodeHTML5Strict = decode_2.decodeHTMLStrict;
exports.decodeXMLStrict = decode_2.decodeXML;


/***/ }),

/***/ "./node_modules/entities/lib/maps/decode.json":
/*!****************************************************!*\
  !*** ./node_modules/entities/lib/maps/decode.json ***!
  \****************************************************/
/*! exports provided: 0, 128, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 142, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}");

/***/ }),

/***/ "./node_modules/entities/lib/maps/entities.json":
/*!******************************************************!*\
  !*** ./node_modules/entities/lib/maps/entities.json ***!
  \******************************************************/
/*! exports provided: Aacute, aacute, Abreve, abreve, ac, acd, acE, Acirc, acirc, acute, Acy, acy, AElig, aelig, af, Afr, afr, Agrave, agrave, alefsym, aleph, Alpha, alpha, Amacr, amacr, amalg, amp, AMP, andand, And, and, andd, andslope, andv, ang, ange, angle, angmsdaa, angmsdab, angmsdac, angmsdad, angmsdae, angmsdaf, angmsdag, angmsdah, angmsd, angrt, angrtvb, angrtvbd, angsph, angst, angzarr, Aogon, aogon, Aopf, aopf, apacir, ap, apE, ape, apid, apos, ApplyFunction, approx, approxeq, Aring, aring, Ascr, ascr, Assign, ast, asymp, asympeq, Atilde, atilde, Auml, auml, awconint, awint, backcong, backepsilon, backprime, backsim, backsimeq, Backslash, Barv, barvee, barwed, Barwed, barwedge, bbrk, bbrktbrk, bcong, Bcy, bcy, bdquo, becaus, because, Because, bemptyv, bepsi, bernou, Bernoullis, Beta, beta, beth, between, Bfr, bfr, bigcap, bigcirc, bigcup, bigodot, bigoplus, bigotimes, bigsqcup, bigstar, bigtriangledown, bigtriangleup, biguplus, bigvee, bigwedge, bkarow, blacklozenge, blacksquare, blacktriangle, blacktriangledown, blacktriangleleft, blacktriangleright, blank, blk12, blk14, blk34, block, bne, bnequiv, bNot, bnot, Bopf, bopf, bot, bottom, bowtie, boxbox, boxdl, boxdL, boxDl, boxDL, boxdr, boxdR, boxDr, boxDR, boxh, boxH, boxhd, boxHd, boxhD, boxHD, boxhu, boxHu, boxhU, boxHU, boxminus, boxplus, boxtimes, boxul, boxuL, boxUl, boxUL, boxur, boxuR, boxUr, boxUR, boxv, boxV, boxvh, boxvH, boxVh, boxVH, boxvl, boxvL, boxVl, boxVL, boxvr, boxvR, boxVr, boxVR, bprime, breve, Breve, brvbar, bscr, Bscr, bsemi, bsim, bsime, bsolb, bsol, bsolhsub, bull, bullet, bump, bumpE, bumpe, Bumpeq, bumpeq, Cacute, cacute, capand, capbrcup, capcap, cap, Cap, capcup, capdot, CapitalDifferentialD, caps, caret, caron, Cayleys, ccaps, Ccaron, ccaron, Ccedil, ccedil, Ccirc, ccirc, Cconint, ccups, ccupssm, Cdot, cdot, cedil, Cedilla, cemptyv, cent, centerdot, CenterDot, cfr, Cfr, CHcy, chcy, check, checkmark, Chi, chi, circ, circeq, circlearrowleft, circlearrowright, circledast, circledcirc, circleddash, CircleDot, circledR, circledS, CircleMinus, CirclePlus, CircleTimes, cir, cirE, cire, cirfnint, cirmid, cirscir, ClockwiseContourIntegral, CloseCurlyDoubleQuote, CloseCurlyQuote, clubs, clubsuit, colon, Colon, Colone, colone, coloneq, comma, commat, comp, compfn, complement, complexes, cong, congdot, Congruent, conint, Conint, ContourIntegral, copf, Copf, coprod, Coproduct, copy, COPY, copysr, CounterClockwiseContourIntegral, crarr, cross, Cross, Cscr, cscr, csub, csube, csup, csupe, ctdot, cudarrl, cudarrr, cuepr, cuesc, cularr, cularrp, cupbrcap, cupcap, CupCap, cup, Cup, cupcup, cupdot, cupor, cups, curarr, curarrm, curlyeqprec, curlyeqsucc, curlyvee, curlywedge, curren, curvearrowleft, curvearrowright, cuvee, cuwed, cwconint, cwint, cylcty, dagger, Dagger, daleth, darr, Darr, dArr, dash, Dashv, dashv, dbkarow, dblac, Dcaron, dcaron, Dcy, dcy, ddagger, ddarr, DD, dd, DDotrahd, ddotseq, deg, Del, Delta, delta, demptyv, dfisht, Dfr, dfr, dHar, dharl, dharr, DiacriticalAcute, DiacriticalDot, DiacriticalDoubleAcute, DiacriticalGrave, DiacriticalTilde, diam, diamond, Diamond, diamondsuit, diams, die, DifferentialD, digamma, disin, div, divide, divideontimes, divonx, DJcy, djcy, dlcorn, dlcrop, dollar, Dopf, dopf, Dot, dot, DotDot, doteq, doteqdot, DotEqual, dotminus, dotplus, dotsquare, doublebarwedge, DoubleContourIntegral, DoubleDot, DoubleDownArrow, DoubleLeftArrow, DoubleLeftRightArrow, DoubleLeftTee, DoubleLongLeftArrow, DoubleLongLeftRightArrow, DoubleLongRightArrow, DoubleRightArrow, DoubleRightTee, DoubleUpArrow, DoubleUpDownArrow, DoubleVerticalBar, DownArrowBar, downarrow, DownArrow, Downarrow, DownArrowUpArrow, DownBreve, downdownarrows, downharpoonleft, downharpoonright, DownLeftRightVector, DownLeftTeeVector, DownLeftVectorBar, DownLeftVector, DownRightTeeVector, DownRightVectorBar, DownRightVector, DownTeeArrow, DownTee, drbkarow, drcorn, drcrop, Dscr, dscr, DScy, dscy, dsol, Dstrok, dstrok, dtdot, dtri, dtrif, duarr, duhar, dwangle, DZcy, dzcy, dzigrarr, Eacute, eacute, easter, Ecaron, ecaron, Ecirc, ecirc, ecir, ecolon, Ecy, ecy, eDDot, Edot, edot, eDot, ee, efDot, Efr, efr, eg, Egrave, egrave, egs, egsdot, el, Element, elinters, ell, els, elsdot, Emacr, emacr, empty, emptyset, EmptySmallSquare, emptyv, EmptyVerySmallSquare, emsp13, emsp14, emsp, ENG, eng, ensp, Eogon, eogon, Eopf, eopf, epar, eparsl, eplus, epsi, Epsilon, epsilon, epsiv, eqcirc, eqcolon, eqsim, eqslantgtr, eqslantless, Equal, equals, EqualTilde, equest, Equilibrium, equiv, equivDD, eqvparsl, erarr, erDot, escr, Escr, esdot, Esim, esim, Eta, eta, ETH, eth, Euml, euml, euro, excl, exist, Exists, expectation, exponentiale, ExponentialE, fallingdotseq, Fcy, fcy, female, ffilig, fflig, ffllig, Ffr, ffr, filig, FilledSmallSquare, FilledVerySmallSquare, fjlig, flat, fllig, fltns, fnof, Fopf, fopf, forall, ForAll, fork, forkv, Fouriertrf, fpartint, frac12, frac13, frac14, frac15, frac16, frac18, frac23, frac25, frac34, frac35, frac38, frac45, frac56, frac58, frac78, frasl, frown, fscr, Fscr, gacute, Gamma, gamma, Gammad, gammad, gap, Gbreve, gbreve, Gcedil, Gcirc, gcirc, Gcy, gcy, Gdot, gdot, ge, gE, gEl, gel, geq, geqq, geqslant, gescc, ges, gesdot, gesdoto, gesdotol, gesl, gesles, Gfr, gfr, gg, Gg, ggg, gimel, GJcy, gjcy, gla, gl, glE, glj, gnap, gnapprox, gne, gnE, gneq, gneqq, gnsim, Gopf, gopf, grave, GreaterEqual, GreaterEqualLess, GreaterFullEqual, GreaterGreater, GreaterLess, GreaterSlantEqual, GreaterTilde, Gscr, gscr, gsim, gsime, gsiml, gtcc, gtcir, gt, GT, Gt, gtdot, gtlPar, gtquest, gtrapprox, gtrarr, gtrdot, gtreqless, gtreqqless, gtrless, gtrsim, gvertneqq, gvnE, Hacek, hairsp, half, hamilt, HARDcy, hardcy, harrcir, harr, hArr, harrw, Hat, hbar, Hcirc, hcirc, hearts, heartsuit, hellip, hercon, hfr, Hfr, HilbertSpace, hksearow, hkswarow, hoarr, homtht, hookleftarrow, hookrightarrow, hopf, Hopf, horbar, HorizontalLine, hscr, Hscr, hslash, Hstrok, hstrok, HumpDownHump, HumpEqual, hybull, hyphen, Iacute, iacute, ic, Icirc, icirc, Icy, icy, Idot, IEcy, iecy, iexcl, iff, ifr, Ifr, Igrave, igrave, ii, iiiint, iiint, iinfin, iiota, IJlig, ijlig, Imacr, imacr, image, ImaginaryI, imagline, imagpart, imath, Im, imof, imped, Implies, incare, in, infin, infintie, inodot, intcal, int, Int, integers, Integral, intercal, Intersection, intlarhk, intprod, InvisibleComma, InvisibleTimes, IOcy, iocy, Iogon, iogon, Iopf, iopf, Iota, iota, iprod, iquest, iscr, Iscr, isin, isindot, isinE, isins, isinsv, isinv, it, Itilde, itilde, Iukcy, iukcy, Iuml, iuml, Jcirc, jcirc, Jcy, jcy, Jfr, jfr, jmath, Jopf, jopf, Jscr, jscr, Jsercy, jsercy, Jukcy, jukcy, Kappa, kappa, kappav, Kcedil, kcedil, Kcy, kcy, Kfr, kfr, kgreen, KHcy, khcy, KJcy, kjcy, Kopf, kopf, Kscr, kscr, lAarr, Lacute, lacute, laemptyv, lagran, Lambda, lambda, lang, Lang, langd, langle, lap, Laplacetrf, laquo, larrb, larrbfs, larr, Larr, lArr, larrfs, larrhk, larrlp, larrpl, larrsim, larrtl, latail, lAtail, lat, late, lates, lbarr, lBarr, lbbrk, lbrace, lbrack, lbrke, lbrksld, lbrkslu, Lcaron, lcaron, Lcedil, lcedil, lceil, lcub, Lcy, lcy, ldca, ldquo, ldquor, ldrdhar, ldrushar, ldsh, le, lE, LeftAngleBracket, LeftArrowBar, leftarrow, LeftArrow, Leftarrow, LeftArrowRightArrow, leftarrowtail, LeftCeiling, LeftDoubleBracket, LeftDownTeeVector, LeftDownVectorBar, LeftDownVector, LeftFloor, leftharpoondown, leftharpoonup, leftleftarrows, leftrightarrow, LeftRightArrow, Leftrightarrow, leftrightarrows, leftrightharpoons, leftrightsquigarrow, LeftRightVector, LeftTeeArrow, LeftTee, LeftTeeVector, leftthreetimes, LeftTriangleBar, LeftTriangle, LeftTriangleEqual, LeftUpDownVector, LeftUpTeeVector, LeftUpVectorBar, LeftUpVector, LeftVectorBar, LeftVector, lEg, leg, leq, leqq, leqslant, lescc, les, lesdot, lesdoto, lesdotor, lesg, lesges, lessapprox, lessdot, lesseqgtr, lesseqqgtr, LessEqualGreater, LessFullEqual, LessGreater, lessgtr, LessLess, lesssim, LessSlantEqual, LessTilde, lfisht, lfloor, Lfr, lfr, lg, lgE, lHar, lhard, lharu, lharul, lhblk, LJcy, ljcy, llarr, ll, Ll, llcorner, Lleftarrow, llhard, lltri, Lmidot, lmidot, lmoustache, lmoust, lnap, lnapprox, lne, lnE, lneq, lneqq, lnsim, loang, loarr, lobrk, longleftarrow, LongLeftArrow, Longleftarrow, longleftrightarrow, LongLeftRightArrow, Longleftrightarrow, longmapsto, longrightarrow, LongRightArrow, Longrightarrow, looparrowleft, looparrowright, lopar, Lopf, lopf, loplus, lotimes, lowast, lowbar, LowerLeftArrow, LowerRightArrow, loz, lozenge, lozf, lpar, lparlt, lrarr, lrcorner, lrhar, lrhard, lrm, lrtri, lsaquo, lscr, Lscr, lsh, Lsh, lsim, lsime, lsimg, lsqb, lsquo, lsquor, Lstrok, lstrok, ltcc, ltcir, lt, LT, Lt, ltdot, lthree, ltimes, ltlarr, ltquest, ltri, ltrie, ltrif, ltrPar, lurdshar, luruhar, lvertneqq, lvnE, macr, male, malt, maltese, Map, map, mapsto, mapstodown, mapstoleft, mapstoup, marker, mcomma, Mcy, mcy, mdash, mDDot, measuredangle, MediumSpace, Mellintrf, Mfr, mfr, mho, micro, midast, midcir, mid, middot, minusb, minus, minusd, minusdu, MinusPlus, mlcp, mldr, mnplus, models, Mopf, mopf, mp, mscr, Mscr, mstpos, Mu, mu, multimap, mumap, nabla, Nacute, nacute, nang, nap, napE, napid, napos, napprox, natural, naturals, natur, nbsp, nbump, nbumpe, ncap, Ncaron, ncaron, Ncedil, ncedil, ncong, ncongdot, ncup, Ncy, ncy, ndash, nearhk, nearr, neArr, nearrow, ne, nedot, NegativeMediumSpace, NegativeThickSpace, NegativeThinSpace, NegativeVeryThinSpace, nequiv, nesear, nesim, NestedGreaterGreater, NestedLessLess, NewLine, nexist, nexists, Nfr, nfr, ngE, nge, ngeq, ngeqq, ngeqslant, nges, nGg, ngsim, nGt, ngt, ngtr, nGtv, nharr, nhArr, nhpar, ni, nis, nisd, niv, NJcy, njcy, nlarr, nlArr, nldr, nlE, nle, nleftarrow, nLeftarrow, nleftrightarrow, nLeftrightarrow, nleq, nleqq, nleqslant, nles, nless, nLl, nlsim, nLt, nlt, nltri, nltrie, nLtv, nmid, NoBreak, NonBreakingSpace, nopf, Nopf, Not, not, NotCongruent, NotCupCap, NotDoubleVerticalBar, NotElement, NotEqual, NotEqualTilde, NotExists, NotGreater, NotGreaterEqual, NotGreaterFullEqual, NotGreaterGreater, NotGreaterLess, NotGreaterSlantEqual, NotGreaterTilde, NotHumpDownHump, NotHumpEqual, notin, notindot, notinE, notinva, notinvb, notinvc, NotLeftTriangleBar, NotLeftTriangle, NotLeftTriangleEqual, NotLess, NotLessEqual, NotLessGreater, NotLessLess, NotLessSlantEqual, NotLessTilde, NotNestedGreaterGreater, NotNestedLessLess, notni, notniva, notnivb, notnivc, NotPrecedes, NotPrecedesEqual, NotPrecedesSlantEqual, NotReverseElement, NotRightTriangleBar, NotRightTriangle, NotRightTriangleEqual, NotSquareSubset, NotSquareSubsetEqual, NotSquareSuperset, NotSquareSupersetEqual, NotSubset, NotSubsetEqual, NotSucceeds, NotSucceedsEqual, NotSucceedsSlantEqual, NotSucceedsTilde, NotSuperset, NotSupersetEqual, NotTilde, NotTildeEqual, NotTildeFullEqual, NotTildeTilde, NotVerticalBar, nparallel, npar, nparsl, npart, npolint, npr, nprcue, nprec, npreceq, npre, nrarrc, nrarr, nrArr, nrarrw, nrightarrow, nRightarrow, nrtri, nrtrie, nsc, nsccue, nsce, Nscr, nscr, nshortmid, nshortparallel, nsim, nsime, nsimeq, nsmid, nspar, nsqsube, nsqsupe, nsub, nsubE, nsube, nsubset, nsubseteq, nsubseteqq, nsucc, nsucceq, nsup, nsupE, nsupe, nsupset, nsupseteq, nsupseteqq, ntgl, Ntilde, ntilde, ntlg, ntriangleleft, ntrianglelefteq, ntriangleright, ntrianglerighteq, Nu, nu, num, numero, numsp, nvap, nvdash, nvDash, nVdash, nVDash, nvge, nvgt, nvHarr, nvinfin, nvlArr, nvle, nvlt, nvltrie, nvrArr, nvrtrie, nvsim, nwarhk, nwarr, nwArr, nwarrow, nwnear, Oacute, oacute, oast, Ocirc, ocirc, ocir, Ocy, ocy, odash, Odblac, odblac, odiv, odot, odsold, OElig, oelig, ofcir, Ofr, ofr, ogon, Ograve, ograve, ogt, ohbar, ohm, oint, olarr, olcir, olcross, oline, olt, Omacr, omacr, Omega, omega, Omicron, omicron, omid, ominus, Oopf, oopf, opar, OpenCurlyDoubleQuote, OpenCurlyQuote, operp, oplus, orarr, Or, or, ord, order, orderof, ordf, ordm, origof, oror, orslope, orv, oS, Oscr, oscr, Oslash, oslash, osol, Otilde, otilde, otimesas, Otimes, otimes, Ouml, ouml, ovbar, OverBar, OverBrace, OverBracket, OverParenthesis, para, parallel, par, parsim, parsl, part, PartialD, Pcy, pcy, percnt, period, permil, perp, pertenk, Pfr, pfr, Phi, phi, phiv, phmmat, phone, Pi, pi, pitchfork, piv, planck, planckh, plankv, plusacir, plusb, pluscir, plus, plusdo, plusdu, pluse, PlusMinus, plusmn, plussim, plustwo, pm, Poincareplane, pointint, popf, Popf, pound, prap, Pr, pr, prcue, precapprox, prec, preccurlyeq, Precedes, PrecedesEqual, PrecedesSlantEqual, PrecedesTilde, preceq, precnapprox, precneqq, precnsim, pre, prE, precsim, prime, Prime, primes, prnap, prnE, prnsim, prod, Product, profalar, profline, profsurf, prop, Proportional, Proportion, propto, prsim, prurel, Pscr, pscr, Psi, psi, puncsp, Qfr, qfr, qint, qopf, Qopf, qprime, Qscr, qscr, quaternions, quatint, quest, questeq, quot, QUOT, rAarr, race, Racute, racute, radic, raemptyv, rang, Rang, rangd, range, rangle, raquo, rarrap, rarrb, rarrbfs, rarrc, rarr, Rarr, rArr, rarrfs, rarrhk, rarrlp, rarrpl, rarrsim, Rarrtl, rarrtl, rarrw, ratail, rAtail, ratio, rationals, rbarr, rBarr, RBarr, rbbrk, rbrace, rbrack, rbrke, rbrksld, rbrkslu, Rcaron, rcaron, Rcedil, rcedil, rceil, rcub, Rcy, rcy, rdca, rdldhar, rdquo, rdquor, rdsh, real, realine, realpart, reals, Re, rect, reg, REG, ReverseElement, ReverseEquilibrium, ReverseUpEquilibrium, rfisht, rfloor, rfr, Rfr, rHar, rhard, rharu, rharul, Rho, rho, rhov, RightAngleBracket, RightArrowBar, rightarrow, RightArrow, Rightarrow, RightArrowLeftArrow, rightarrowtail, RightCeiling, RightDoubleBracket, RightDownTeeVector, RightDownVectorBar, RightDownVector, RightFloor, rightharpoondown, rightharpoonup, rightleftarrows, rightleftharpoons, rightrightarrows, rightsquigarrow, RightTeeArrow, RightTee, RightTeeVector, rightthreetimes, RightTriangleBar, RightTriangle, RightTriangleEqual, RightUpDownVector, RightUpTeeVector, RightUpVectorBar, RightUpVector, RightVectorBar, RightVector, ring, risingdotseq, rlarr, rlhar, rlm, rmoustache, rmoust, rnmid, roang, roarr, robrk, ropar, ropf, Ropf, roplus, rotimes, RoundImplies, rpar, rpargt, rppolint, rrarr, Rrightarrow, rsaquo, rscr, Rscr, rsh, Rsh, rsqb, rsquo, rsquor, rthree, rtimes, rtri, rtrie, rtrif, rtriltri, RuleDelayed, ruluhar, rx, Sacute, sacute, sbquo, scap, Scaron, scaron, Sc, sc, sccue, sce, scE, Scedil, scedil, Scirc, scirc, scnap, scnE, scnsim, scpolint, scsim, Scy, scy, sdotb, sdot, sdote, searhk, searr, seArr, searrow, sect, semi, seswar, setminus, setmn, sext, Sfr, sfr, sfrown, sharp, SHCHcy, shchcy, SHcy, shcy, ShortDownArrow, ShortLeftArrow, shortmid, shortparallel, ShortRightArrow, ShortUpArrow, shy, Sigma, sigma, sigmaf, sigmav, sim, simdot, sime, simeq, simg, simgE, siml, simlE, simne, simplus, simrarr, slarr, SmallCircle, smallsetminus, smashp, smeparsl, smid, smile, smt, smte, smtes, SOFTcy, softcy, solbar, solb, sol, Sopf, sopf, spades, spadesuit, spar, sqcap, sqcaps, sqcup, sqcups, Sqrt, sqsub, sqsube, sqsubset, sqsubseteq, sqsup, sqsupe, sqsupset, sqsupseteq, square, Square, SquareIntersection, SquareSubset, SquareSubsetEqual, SquareSuperset, SquareSupersetEqual, SquareUnion, squarf, squ, squf, srarr, Sscr, sscr, ssetmn, ssmile, sstarf, Star, star, starf, straightepsilon, straightphi, strns, sub, Sub, subdot, subE, sube, subedot, submult, subnE, subne, subplus, subrarr, subset, Subset, subseteq, subseteqq, SubsetEqual, subsetneq, subsetneqq, subsim, subsub, subsup, succapprox, succ, succcurlyeq, Succeeds, SucceedsEqual, SucceedsSlantEqual, SucceedsTilde, succeq, succnapprox, succneqq, succnsim, succsim, SuchThat, sum, Sum, sung, sup1, sup2, sup3, sup, Sup, supdot, supdsub, supE, supe, supedot, Superset, SupersetEqual, suphsol, suphsub, suplarr, supmult, supnE, supne, supplus, supset, Supset, supseteq, supseteqq, supsetneq, supsetneqq, supsim, supsub, supsup, swarhk, swarr, swArr, swarrow, swnwar, szlig, Tab, target, Tau, tau, tbrk, Tcaron, tcaron, Tcedil, tcedil, Tcy, tcy, tdot, telrec, Tfr, tfr, there4, therefore, Therefore, Theta, theta, thetasym, thetav, thickapprox, thicksim, ThickSpace, ThinSpace, thinsp, thkap, thksim, THORN, thorn, tilde, Tilde, TildeEqual, TildeFullEqual, TildeTilde, timesbar, timesb, times, timesd, tint, toea, topbot, topcir, top, Topf, topf, topfork, tosa, tprime, trade, TRADE, triangle, triangledown, triangleleft, trianglelefteq, triangleq, triangleright, trianglerighteq, tridot, trie, triminus, TripleDot, triplus, trisb, tritime, trpezium, Tscr, tscr, TScy, tscy, TSHcy, tshcy, Tstrok, tstrok, twixt, twoheadleftarrow, twoheadrightarrow, Uacute, uacute, uarr, Uarr, uArr, Uarrocir, Ubrcy, ubrcy, Ubreve, ubreve, Ucirc, ucirc, Ucy, ucy, udarr, Udblac, udblac, udhar, ufisht, Ufr, ufr, Ugrave, ugrave, uHar, uharl, uharr, uhblk, ulcorn, ulcorner, ulcrop, ultri, Umacr, umacr, uml, UnderBar, UnderBrace, UnderBracket, UnderParenthesis, Union, UnionPlus, Uogon, uogon, Uopf, uopf, UpArrowBar, uparrow, UpArrow, Uparrow, UpArrowDownArrow, updownarrow, UpDownArrow, Updownarrow, UpEquilibrium, upharpoonleft, upharpoonright, uplus, UpperLeftArrow, UpperRightArrow, upsi, Upsi, upsih, Upsilon, upsilon, UpTeeArrow, UpTee, upuparrows, urcorn, urcorner, urcrop, Uring, uring, urtri, Uscr, uscr, utdot, Utilde, utilde, utri, utrif, uuarr, Uuml, uuml, uwangle, vangrt, varepsilon, varkappa, varnothing, varphi, varpi, varpropto, varr, vArr, varrho, varsigma, varsubsetneq, varsubsetneqq, varsupsetneq, varsupsetneqq, vartheta, vartriangleleft, vartriangleright, vBar, Vbar, vBarv, Vcy, vcy, vdash, vDash, Vdash, VDash, Vdashl, veebar, vee, Vee, veeeq, vellip, verbar, Verbar, vert, Vert, VerticalBar, VerticalLine, VerticalSeparator, VerticalTilde, VeryThinSpace, Vfr, vfr, vltri, vnsub, vnsup, Vopf, vopf, vprop, vrtri, Vscr, vscr, vsubnE, vsubne, vsupnE, vsupne, Vvdash, vzigzag, Wcirc, wcirc, wedbar, wedge, Wedge, wedgeq, weierp, Wfr, wfr, Wopf, wopf, wp, wr, wreath, Wscr, wscr, xcap, xcirc, xcup, xdtri, Xfr, xfr, xharr, xhArr, Xi, xi, xlarr, xlArr, xmap, xnis, xodot, Xopf, xopf, xoplus, xotime, xrarr, xrArr, Xscr, xscr, xsqcup, xuplus, xutri, xvee, xwedge, Yacute, yacute, YAcy, yacy, Ycirc, ycirc, Ycy, ycy, yen, Yfr, yfr, YIcy, yicy, Yopf, yopf, Yscr, yscr, YUcy, yucy, yuml, Yuml, Zacute, zacute, Zcaron, zcaron, Zcy, zcy, Zdot, zdot, zeetrf, ZeroWidthSpace, Zeta, zeta, zfr, Zfr, ZHcy, zhcy, zigrarr, zopf, Zopf, Zscr, zscr, zwj, zwnj, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}");

/***/ }),

/***/ "./node_modules/entities/lib/maps/legacy.json":
/*!****************************************************!*\
  !*** ./node_modules/entities/lib/maps/legacy.json ***!
  \****************************************************/
/*! exports provided: Aacute, aacute, Acirc, acirc, acute, AElig, aelig, Agrave, agrave, amp, AMP, Aring, aring, Atilde, atilde, Auml, auml, brvbar, Ccedil, ccedil, cedil, cent, copy, COPY, curren, deg, divide, Eacute, eacute, Ecirc, ecirc, Egrave, egrave, ETH, eth, Euml, euml, frac12, frac14, frac34, gt, GT, Iacute, iacute, Icirc, icirc, iexcl, Igrave, igrave, iquest, Iuml, iuml, laquo, lt, LT, macr, micro, middot, nbsp, not, Ntilde, ntilde, Oacute, oacute, Ocirc, ocirc, Ograve, ograve, ordf, ordm, Oslash, oslash, Otilde, otilde, Ouml, ouml, para, plusmn, pound, quot, QUOT, raquo, reg, REG, sect, shy, sup1, sup2, sup3, szlig, THORN, thorn, times, Uacute, uacute, Ucirc, ucirc, Ugrave, ugrave, uml, Uuml, uuml, Yacute, yacute, yen, yuml, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"Agrave\":\"À\",\"agrave\":\"à\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"Å\",\"aring\":\"å\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"brvbar\":\"¦\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"cedil\":\"¸\",\"cent\":\"¢\",\"copy\":\"©\",\"COPY\":\"©\",\"curren\":\"¤\",\"deg\":\"°\",\"divide\":\"÷\",\"Eacute\":\"É\",\"eacute\":\"é\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"Egrave\":\"È\",\"egrave\":\"è\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"frac12\":\"½\",\"frac14\":\"¼\",\"frac34\":\"¾\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"iexcl\":\"¡\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"iquest\":\"¿\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"laquo\":\"«\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"¯\",\"micro\":\"µ\",\"middot\":\"·\",\"nbsp\":\" \",\"not\":\"¬\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ordf\":\"ª\",\"ordm\":\"º\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"para\":\"¶\",\"plusmn\":\"±\",\"pound\":\"£\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"raquo\":\"»\",\"reg\":\"®\",\"REG\":\"®\",\"sect\":\"§\",\"shy\":\"­\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"szlig\":\"ß\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"times\":\"×\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uml\":\"¨\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"yen\":\"¥\",\"yuml\":\"ÿ\"}");

/***/ }),

/***/ "./node_modules/entities/lib/maps/xml.json":
/*!*************************************************!*\
  !*** ./node_modules/entities/lib/maps/xml.json ***!
  \*************************************************/
/*! exports provided: amp, apos, gt, lt, quot, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"amp\":\"&\",\"apos\":\"'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\"\"}");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/html-to-react/index.js":
/*!*********************************************!*\
  !*** ./node_modules/html-to-react/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var parser = __webpack_require__(/*! ./lib/parser */ "./node_modules/html-to-react/lib/parser.js");
var processingInstructions = __webpack_require__(/*! ./lib/processing-instructions */ "./node_modules/html-to-react/lib/processing-instructions.js");
var isValidNodeDefinitions = __webpack_require__(/*! ./lib/is-valid-node-definitions */ "./node_modules/html-to-react/lib/is-valid-node-definitions.js");
var processNodeDefinitions = __webpack_require__(/*! ./lib/process-node-definitions */ "./node_modules/html-to-react/lib/process-node-definitions.js");

module.exports = {
  Parser: parser,
  ProcessingInstructions: processingInstructions,
  IsValidNodeDefinitions: isValidNodeDefinitions,
  ProcessNodeDefinitions: processNodeDefinitions,
};


/***/ }),

/***/ "./node_modules/html-to-react/lib/camel-case-attribute-names.js":
/*!**********************************************************************!*\
  !*** ./node_modules/html-to-react/lib/camel-case-attribute-names.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// These are all sourced from https://facebook.github.io/react/docs/tags-and-attributes.html -
// all attributes regardless of whether they have a different case to their HTML equivalents are
// listed to reduce the chance of human error and make it easier to just copy-paste the new list if
// it changes.

var HTML_ATTRIBUTES = [
  'accept', 'acceptCharset', 'accessKey', 'action', 'allowFullScreen', 'allowTransparency',
  'alt', 'async', 'autoComplete', 'autoFocus', 'autoPlay', 'capture', 'cellPadding',
  'cellSpacing', 'challenge', 'charSet', 'checked', 'cite', 'classID', 'className',
  'colSpan', 'cols', 'content', 'contentEditable', 'contextMenu', 'controls', 'coords',
  'crossOrigin', 'data', 'dateTime', 'default', 'defer', 'dir', 'disabled', 'download',
  'draggable', 'encType', 'form', 'formAction', 'formEncType', 'formMethod', 'formNoValidate',
  'formTarget', 'frameBorder', 'headers', 'height', 'hidden', 'high', 'href', 'hrefLang',
  'htmlFor', 'httpEquiv', 'icon', 'id', 'inputMode', 'integrity', 'is', 'keyParams', 'keyType',
  'kind', 'label', 'lang', 'list', 'loop', 'low', 'manifest', 'marginHeight', 'marginWidth',
  'max', 'maxLength', 'media', 'mediaGroup', 'method', 'min', 'minLength', 'multiple', 'muted',
  'name', 'noValidate', 'nonce', 'open', 'optimum', 'pattern', 'placeholder', 'poster',
  'preload', 'profile', 'radioGroup', 'readOnly', 'rel', 'required', 'reversed', 'role',
  'rowSpan', 'rows', 'sandbox', 'scope', 'scoped', 'scrolling', 'seamless', 'selected',
  'shape', 'size', 'sizes', 'span', 'spellCheck', 'src', 'srcDoc', 'srcLang', 'srcSet', 'start',
  'step', 'style', 'summary', 'tabIndex', 'target', 'title', 'type', 'useMap', 'value', 'width',
  'wmode', 'wrap', 'onClick',
];

var NON_STANDARD_ATTRIBUTES = [
  'autoCapitalize', 'autoCorrect', 'color', 'itemProp', 'itemScope', 'itemType', 'itemRef',
  'itemID', 'security', 'unselectable', 'results', 'autoSave',
];

var SVG_ATTRIBUTES = [
  'accentHeight', 'accumulate', 'additive', 'alignmentBaseline', 'allowReorder', 'alphabetic',
  'amplitude', 'arabicForm', 'ascent', 'attributeName', 'attributeType', 'autoReverse', 'azimuth',
  'baseFrequency', 'baseProfile', 'baselineShift', 'bbox', 'begin', 'bias', 'by', 'calcMode',
  'capHeight', 'clip', 'clipPath', 'clipPathUnits', 'clipRule', 'colorInterpolation',
  'colorInterpolationFilters', 'colorProfile', 'colorRendering', 'contentScriptType',
  'contentStyleType', 'cursor', 'cx', 'cy', 'd', 'decelerate', 'descent', 'diffuseConstant',
  'direction', 'display', 'divisor', 'dominantBaseline', 'dur', 'dx', 'dy', 'edgeMode',
  'elevation', 'enableBackground', 'end', 'exponent', 'externalResourcesRequired', 'fill',
  'fillOpacity', 'fillRule', 'filter', 'filterRes', 'filterUnits', 'floodColor', 'floodOpacity',
  'focusable', 'fontFamily', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle',
  'fontVariant', 'fontWeight', 'format', 'from', 'fx', 'fy', 'g1', 'g2', 'glyphName',
  'glyphOrientationHorizontal', 'glyphOrientationVertical', 'glyphRef',
  'gradientTransform', 'gradientUnits', 'hanging', 'horizAdvX', 'horizOriginX', 'ideographic',
  'imageRendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kernelMatrix',
  'kernelUnitLength', 'kerning', 'keyPoints', 'keySplines', 'keyTimes', 'lengthAdjust',
  'letterSpacing', 'lightingColor', 'limitingConeAngle', 'local', 'markerEnd', 'markerHeight',
  'markerMid', 'markerStart', 'markerUnits', 'markerWidth', 'mask', 'maskContentUnits',
  'maskUnits', 'mathematical', 'mode', 'numOctaves', 'offset', 'opacity', 'operator', 'order',
  'orient', 'orientation', 'origin', 'overflow', 'overlinePosition', 'overlineThickness',
  'paintOrder', 'panose1', 'pathLength', 'patternContentUnits', 'patternTransform',
  'patternUnits', 'pointerEvents', 'points', 'pointsAtX', 'pointsAtY', 'pointsAtZ',
  'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'r', 'radius', 'refX', 'refY',
  'renderingIntent', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures',
  'restart', 'result', 'rotate', 'rx', 'ry', 'scale', 'seed', 'shapeRendering', 'slope',
  'spacing', 'specularConstant', 'specularExponent', 'speed', 'spreadMethod', 'startOffset',
  'stdDeviation', 'stemh', 'stemv', 'stitchTiles', 'stopColor', 'stopOpacity',
  'strikethroughPosition', 'strikethroughThickness', 'string', 'stroke', 'strokeDasharray',
  'strokeDashoffset', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity',
  'strokeWidth', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY',
  'textAnchor', 'textDecoration', 'textLength', 'textRendering', 'to', 'transform', 'u1',
  'u2', 'underlinePosition', 'underlineThickness', 'unicode', 'unicodeBidi', 'unicodeRange',
  'unitsPerEm', 'vAlphabetic', 'vHanging', 'vIdeographic', 'vMathematical', 'values',
  'vectorEffect', 'version', 'vertAdvY', 'vertOriginX', 'vertOriginY', 'viewBox',
  'viewTarget', 'visibility', 'widths', 'wordSpacing', 'writingMode', 'x', 'x1', 'x2',
  'xChannelSelector', 'xHeight', 'xlinkActuate', 'xlinkArcrole', 'xlinkHref', 'xlinkRole',
  'xlinkShow', 'xlinkTitle', 'xlinkType', 'xmlns', 'xmlnsXlink', 'xmlBase', 'xmlLang',
  'xmlSpace', 'y', 'y1', 'y2', 'yChannelSelector', 'z', 'zoomAndPan',
];

var camelCaseMap = HTML_ATTRIBUTES
  .concat(NON_STANDARD_ATTRIBUTES)
  .concat(SVG_ATTRIBUTES)
  .reduce(function (soFar, attr) {
    var lower = attr.toLowerCase();
    if (lower !== attr) {
      soFar[lower] = attr;
    }
    return soFar;
  }, {});

module.exports = camelCaseMap;


/***/ }),

/***/ "./node_modules/html-to-react/lib/is-valid-node-definitions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/html-to-react/lib/is-valid-node-definitions.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function alwaysValid() {
  return true;
}

module.exports = {
  alwaysValid: alwaysValid,
};


/***/ }),

/***/ "./node_modules/html-to-react/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/html-to-react/lib/parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var forEach = __webpack_require__(/*! ramda/src/forEach */ "./node_modules/ramda/src/forEach.js");
var find = __webpack_require__(/*! ramda/src/find */ "./node_modules/ramda/src/find.js");
var reject = __webpack_require__(/*! ramda/src/reject */ "./node_modules/ramda/src/reject.js");
var addIndex = __webpack_require__(/*! ramda/src/addIndex */ "./node_modules/ramda/src/addIndex.js");
var map = __webpack_require__(/*! ramda/src/map */ "./node_modules/ramda/src/map.js");
var HtmlParser = __webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js").Parser;
var DomHandler = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js").DomHandler;
var ProcessingInstructions = __webpack_require__(/*! ./processing-instructions */ "./node_modules/html-to-react/lib/processing-instructions.js");
var IsValidNodeDefinitions = __webpack_require__(/*! ./is-valid-node-definitions */ "./node_modules/html-to-react/lib/is-valid-node-definitions.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/html-to-react/lib/utils.js");

function Html2ReactParser(options) {
  function parseHtmlToTree(html) {
    options = options || {};
    options.decodeEntities = true;
    var handler = new DomHandler();
    var parser = new HtmlParser(handler, options);
    parser.parseComplete(html);
    return handler.dom.filter(function (element) {
      return element.type !== 'directive';
    });
  };

  function traverseDom(node, isValidNode, processingInstructions, preprocessingInstructions,
    index) {
    if (isValidNode(node)) {
      forEach(function (preprocessingInstruction) {
        if (preprocessingInstruction.shouldPreprocessNode(node)) {
          preprocessingInstruction.preprocessNode(node, index);
        }
      }, preprocessingInstructions || []);

      var processingInstruction = find(function (processingInstruction) {
        return processingInstruction.shouldProcessNode(node);
      }, processingInstructions || []);
      if (processingInstruction != null) {
        var children = reject(function (x) {return x == null || x === false;},
          addIndex(map)(function (child, i) {
            return traverseDom(child, isValidNode, processingInstructions,
              preprocessingInstructions, i);
          }, node.children || []));

        if (processingInstruction.replaceChildren) {
          return utils.createElement(node, index, node.data, [
            processingInstruction.processNode(node, children, index),
          ]);
        } else {
          return processingInstruction.processNode(node, children, index);
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
  };

  function parseWithInstructions(html, isValidNode, processingInstructions,
      preprocessingInstructions) {
    var domTree = parseHtmlToTree(html);
    var list = domTree.map(function (domTreeItem, index) {
      return traverseDom(domTreeItem, isValidNode, processingInstructions,
        preprocessingInstructions, index);
    });
    return list.length <= 1 ? list[0] : list;
  };

  function parse(html) {
    var processingInstructions = new ProcessingInstructions();
    return parseWithInstructions(html,
      IsValidNodeDefinitions.alwaysValid,
      processingInstructions.defaultProcessingInstructions);
  };

  return {
    parse: parse,
    parseWithInstructions: parseWithInstructions,
  };
};

module.exports = Html2ReactParser;


/***/ }),

/***/ "./node_modules/html-to-react/lib/process-node-definitions.js":
/*!********************************************************************!*\
  !*** ./node_modules/html-to-react/lib/process-node-definitions.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var utils = __webpack_require__(/*! ./utils */ "./node_modules/html-to-react/lib/utils.js");

// eslint-disable-next-line max-len
// https://github.com/facebook/react/blob/15.0-stable/src/renderers/dom/shared/ReactDOMComponent.js#L457
var voidElementTags = [
  'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param',
  'source', 'track', 'wbr', 'menuitem', 'textarea',
];

function ProcessNodeDefinitions() {
  function processDefaultNode(node, children, index) {
    if (node.type === 'text') {
      return node.data;
    } else if (node.type === 'comment') {
      // FIXME: The following doesn't work as the generated HTML results in
      // "&lt;!--  This is a comment  --&gt;"
      // return '<!-- ' + node.data + ' -->';
      return false;
    }

    if (voidElementTags.indexOf(node.name) > -1) {
      return utils.createElement(node, index);
    } else {
      return utils.createElement(node, index, node.data, children);
    }
  }

  return {
    processDefaultNode: processDefaultNode,
  };
}

module.exports = ProcessNodeDefinitions;


/***/ }),

/***/ "./node_modules/html-to-react/lib/processing-instructions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/html-to-react/lib/processing-instructions.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ShouldProcessNodeDefinitions = __webpack_require__(/*! ./should-process-node-definitions */ "./node_modules/html-to-react/lib/should-process-node-definitions.js");
var ProcessNodeDefinitions = __webpack_require__(/*! ./process-node-definitions */ "./node_modules/html-to-react/lib/process-node-definitions.js");

function ProcessingInstructions() {
  var processNodeDefinitions = new ProcessNodeDefinitions();

  return {
    defaultProcessingInstructions: [{
      shouldProcessNode: ShouldProcessNodeDefinitions.shouldProcessEveryNode,
      processNode: processNodeDefinitions.processDefaultNode,
    },],
  };
};

module.exports = ProcessingInstructions;


/***/ }),

/***/ "./node_modules/html-to-react/lib/should-process-node-definitions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/html-to-react/lib/should-process-node-definitions.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function shouldProcessEveryNode(node) {
  return true;
}

module.exports = {
  shouldProcessEveryNode: shouldProcessEveryNode,
};


/***/ }),

/***/ "./node_modules/html-to-react/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/html-to-react/lib/utils.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var camelCase = __webpack_require__(/*! lodash.camelcase */ "./node_modules/lodash.camelcase/index.js");
var toPairs = __webpack_require__(/*! ramda/src/toPairs */ "./node_modules/ramda/src/toPairs.js");
var reduce = __webpack_require__(/*! ramda/src/reduce */ "./node_modules/ramda/src/reduce.js");
var React = __webpack_require__(/*! react */ "react");
var camelCaseAttrMap = __webpack_require__(/*! ./camel-case-attribute-names */ "./node_modules/html-to-react/lib/camel-case-attribute-names.js");

function createStyleJsonFromString(styleString) {
  styleString = styleString || '';
  var styles = styleString.split(/;(?!base64)/);
  var singleStyle, key, value, jsonStyles = {};
  for (var i = 0; i < styles.length; ++i) {
    singleStyle = styles[i].split(':');
    if (singleStyle.length > 2) {
      singleStyle[1] = singleStyle.slice(1).join(':');
    }

    key = singleStyle[0];
    value = singleStyle[1];
    if (typeof value === 'string'){
      value = value.trim();
    }

    if (key != null && value != null && key.length > 0 && value.length > 0) {
      jsonStyles[camelCase(key)] = value;
    }
  }
  return jsonStyles;
}

function createElement(node, index, data, children) {
  var elementProps = {
    key: index,
  };
  if (node.attribs) {
    elementProps = reduce(function(result, keyAndValue) {
      var key = keyAndValue[0];
      var value = keyAndValue[1];
      key = camelCaseAttrMap[key.replace(/[-:]/, '')] || key;
      if (key === 'style') {
        value = createStyleJsonFromString(value);
      } else if (key === 'class') {
        key = 'className';
      } else if (key === 'for') {
        key = 'htmlFor';
      }
      result[key] = value || key;
      return result;
    }, elementProps, toPairs(node.attribs));
  }

  children = children || [];
  var allChildren = data != null ? [data,].concat(children) : children;
  return React.createElement.apply(
    null, [node.name, elementProps,].concat(allChildren)
  );
}

module.exports = {
  createElement: createElement,
};


/***/ }),

/***/ "./node_modules/htmlparser2/lib/CollectingHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/htmlparser2/lib/CollectingHandler.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var MultiplexHandler_1 = __importDefault(__webpack_require__(/*! ./MultiplexHandler */ "./node_modules/htmlparser2/lib/MultiplexHandler.js"));
var CollectingHandler = /** @class */ (function (_super) {
    __extends(CollectingHandler, _super);
    function CollectingHandler(cbs) {
        if (cbs === void 0) { cbs = {}; }
        var _this = _super.call(this, function (name) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            _this.events.push([name].concat(args));
            // @ts-ignore
            if (_this._cbs[name])
                (_a = _this._cbs)[name].apply(_a, args);
        }) || this;
        _this._cbs = cbs;
        _this.events = [];
        return _this;
    }
    CollectingHandler.prototype.onreset = function () {
        this.events = [];
        if (this._cbs.onreset)
            this._cbs.onreset();
    };
    CollectingHandler.prototype.restart = function () {
        var _a;
        if (this._cbs.onreset)
            this._cbs.onreset();
        for (var i = 0; i < this.events.length; i++) {
            var _b = this.events[i], name_1 = _b[0], args = _b.slice(1);
            if (!this._cbs[name_1]) {
                continue;
            }
            // @ts-ignore
            (_a = this._cbs)[name_1].apply(_a, args);
        }
    };
    return CollectingHandler;
}(MultiplexHandler_1.default));
exports.CollectingHandler = CollectingHandler;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/FeedHandler.js":
/*!*****************************************************!*\
  !*** ./node_modules/htmlparser2/lib/FeedHandler.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var domhandler_1 = __importDefault(__webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js"));
var DomUtils = __importStar(__webpack_require__(/*! domutils */ "./node_modules/domutils/lib/index.js"));
var Parser_1 = __webpack_require__(/*! ./Parser */ "./node_modules/htmlparser2/lib/Parser.js");
//TODO: Consume data as it is coming in
var FeedHandler = /** @class */ (function (_super) {
    __extends(FeedHandler, _super);
    /**
     *
     * @param callback
     * @param options
     */
    function FeedHandler(callback, options) {
        var _this = this;
        if (typeof callback === "object" && callback !== null) {
            callback = undefined;
            options = callback;
        }
        _this = _super.call(this, callback, options) || this;
        return _this;
    }
    FeedHandler.prototype.onend = function () {
        var feed = {};
        var feedRoot = getOneElement(isValidFeed, this.dom);
        if (feedRoot) {
            if (feedRoot.name === "feed") {
                var childs = feedRoot.children;
                feed.type = "atom";
                addConditionally(feed, "id", "id", childs);
                addConditionally(feed, "title", "title", childs);
                var href = getAttribute("href", getOneElement("link", childs));
                if (href) {
                    feed.link = href;
                }
                addConditionally(feed, "description", "subtitle", childs);
                var updated = fetch("updated", childs);
                if (updated) {
                    feed.updated = new Date(updated);
                }
                addConditionally(feed, "author", "email", childs, true);
                feed.items = getElements("entry", childs).map(function (item) {
                    var entry = {};
                    var children = item.children;
                    addConditionally(entry, "id", "id", children);
                    addConditionally(entry, "title", "title", children);
                    var href = getAttribute("href", getOneElement("link", children));
                    if (href) {
                        entry.link = href;
                    }
                    var description = fetch("summary", children) ||
                        fetch("content", children);
                    if (description) {
                        entry.description = description;
                    }
                    var pubDate = fetch("updated", children);
                    if (pubDate) {
                        entry.pubDate = new Date(pubDate);
                    }
                    return entry;
                });
            }
            else {
                var childs = getOneElement("channel", feedRoot.children)
                    .children;
                feed.type = feedRoot.name.substr(0, 3);
                feed.id = "";
                addConditionally(feed, "title", "title", childs);
                addConditionally(feed, "link", "link", childs);
                addConditionally(feed, "description", "description", childs);
                var updated = fetch("lastBuildDate", childs);
                if (updated) {
                    feed.updated = new Date(updated);
                }
                addConditionally(feed, "author", "managingEditor", childs, true);
                feed.items = getElements("item", feedRoot.children).map(function (item) {
                    var entry = {};
                    var children = item.children;
                    addConditionally(entry, "id", "guid", children);
                    addConditionally(entry, "title", "title", children);
                    addConditionally(entry, "link", "link", children);
                    addConditionally(entry, "description", "description", children);
                    var pubDate = fetch("pubDate", children);
                    if (pubDate)
                        entry.pubDate = new Date(pubDate);
                    return entry;
                });
            }
        }
        this.feed = feed;
        this.handleCallback(feedRoot ? null : Error("couldn't find root of feed"));
    };
    return FeedHandler;
}(domhandler_1.default));
exports.FeedHandler = FeedHandler;
function getElements(what, where) {
    return DomUtils.getElementsByTagName(what, where, true);
}
function getOneElement(what, where) {
    return DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function fetch(what, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
}
function getAttribute(name, elem) {
    if (!elem) {
        return null;
    }
    var attribs = elem.attribs;
    return attribs[name];
}
function addConditionally(obj, prop, what, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var tmp = fetch(what, where, recurse);
    // @ts-ignore
    if (tmp)
        obj[prop] = tmp;
}
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}
var defaultOptions = { xmlMode: true };
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this option, you probably want to set `xmlMode` to `true`.
 */
function parseFeed(feed, options) {
    if (options === void 0) { options = defaultOptions; }
    var handler = new FeedHandler(options);
    new Parser_1.Parser(handler, options).end(feed);
    return handler.feed;
}
exports.parseFeed = parseFeed;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/MultiplexHandler.js":
/*!**********************************************************!*\
  !*** ./node_modules/htmlparser2/lib/MultiplexHandler.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Calls a specific handler function for all events that are encountered.
 *
 * @param func — The function to multiplex all events to.
 */
var MultiplexHandler = /** @class */ (function () {
    function MultiplexHandler(func) {
        this._func = func;
    }
    /* Format: eventname: number of arguments */
    MultiplexHandler.prototype.onattribute = function (name, value) {
        this._func("onattribute", name, value);
    };
    MultiplexHandler.prototype.oncdatastart = function () {
        this._func("oncdatastart");
    };
    MultiplexHandler.prototype.oncdataend = function () {
        this._func("oncdataend");
    };
    MultiplexHandler.prototype.ontext = function (text) {
        this._func("ontext", text);
    };
    MultiplexHandler.prototype.onprocessinginstruction = function (name, value) {
        this._func("onprocessinginstruction", name, value);
    };
    MultiplexHandler.prototype.oncomment = function (comment) {
        this._func("oncomment", comment);
    };
    MultiplexHandler.prototype.oncommentend = function () {
        this._func("oncommentend");
    };
    MultiplexHandler.prototype.onclosetag = function (name) {
        this._func("onclosetag", name);
    };
    MultiplexHandler.prototype.onopentag = function (name, attribs) {
        this._func("onopentag", name, attribs);
    };
    MultiplexHandler.prototype.onopentagname = function (name) {
        this._func("onopentagname", name);
    };
    MultiplexHandler.prototype.onerror = function (error) {
        this._func("onerror", error);
    };
    MultiplexHandler.prototype.onend = function () {
        this._func("onend");
    };
    MultiplexHandler.prototype.onparserinit = function (parser) {
        this._func("onparserinit", parser);
    };
    MultiplexHandler.prototype.onreset = function () {
        this._func("onreset");
    };
    return MultiplexHandler;
}());
exports.default = MultiplexHandler;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/Parser.js":
/*!************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Parser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Tokenizer_1 = __importDefault(__webpack_require__(/*! ./Tokenizer */ "./node_modules/htmlparser2/lib/Tokenizer.js"));
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
]);
var pTag = new Set(["p"]);
var openImpliesClose = {
    tr: new Set(["tr", "th", "td"]),
    th: new Set(["th"]),
    td: new Set(["thead", "th", "td"]),
    body: new Set(["head", "link", "script"]),
    li: new Set(["li"]),
    p: pTag,
    h1: pTag,
    h2: pTag,
    h3: pTag,
    h4: pTag,
    h5: pTag,
    h6: pTag,
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: new Set(["option"]),
    optgroup: new Set(["optgroup", "option"]),
    dd: new Set(["dt", "dd"]),
    dt: new Set(["dt", "dd"]),
    address: pTag,
    article: pTag,
    aside: pTag,
    blockquote: pTag,
    details: pTag,
    div: pTag,
    dl: pTag,
    fieldset: pTag,
    figcaption: pTag,
    figure: pTag,
    footer: pTag,
    form: pTag,
    header: pTag,
    hr: pTag,
    main: pTag,
    nav: pTag,
    ol: pTag,
    pre: pTag,
    section: pTag,
    table: pTag,
    ul: pTag,
    rt: new Set(["rt", "rp"]),
    rp: new Set(["rt", "rp"]),
    tbody: new Set(["thead", "tbody"]),
    tfoot: new Set(["thead", "tbody"])
};
var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
]);
var reNameEnd = /\s|\//;
var Parser = /** @class */ (function (_super) {
    __extends(Parser, _super);
    function Parser(cbs, options) {
        var _this = _super.call(this) || this;
        _this._tagname = "";
        _this._attribname = "";
        _this._attribvalue = "";
        _this._attribs = null;
        _this._stack = [];
        _this._foreignContext = [];
        _this.startIndex = 0;
        _this.endIndex = null;
        // Aliases for backwards compatibility
        _this.parseChunk = Parser.prototype.write;
        _this.done = Parser.prototype.end;
        _this._options = options || {};
        _this._cbs = cbs || {};
        _this._tagname = "";
        _this._attribname = "";
        _this._attribvalue = "";
        _this._attribs = null;
        _this._stack = [];
        _this._foreignContext = [];
        _this.startIndex = 0;
        _this.endIndex = null;
        _this._lowerCaseTagNames =
            "lowerCaseTags" in _this._options
                ? !!_this._options.lowerCaseTags
                : !_this._options.xmlMode;
        _this._lowerCaseAttributeNames =
            "lowerCaseAttributeNames" in _this._options
                ? !!_this._options.lowerCaseAttributeNames
                : !_this._options.xmlMode;
        _this._tokenizer = new (_this._options.Tokenizer || Tokenizer_1.default)(_this._options, _this);
        if (_this._cbs.onparserinit)
            _this._cbs.onparserinit(_this);
        return _this;
    }
    Parser.prototype._updatePosition = function (initialOffset) {
        if (this.endIndex === null) {
            if (this._tokenizer._sectionStart <= initialOffset) {
                this.startIndex = 0;
            }
            else {
                this.startIndex = this._tokenizer._sectionStart - initialOffset;
            }
        }
        else
            this.startIndex = this.endIndex + 1;
        this.endIndex = this._tokenizer.getAbsoluteIndex();
    };
    //Tokenizer event handlers
    Parser.prototype.ontext = function (data) {
        this._updatePosition(1);
        // @ts-ignore
        this.endIndex--;
        if (this._cbs.ontext)
            this._cbs.ontext(data);
    };
    Parser.prototype.onopentagname = function (name) {
        if (this._lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this._tagname = name;
        if (!this._options.xmlMode &&
            Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
            for (var el = void 0; 
            // @ts-ignore
            openImpliesClose[name].has((el = this._stack[this._stack.length - 1])); this.onclosetag(el))
                ;
        }
        if (this._options.xmlMode || !voidElements.has(name)) {
            this._stack.push(name);
            if (foreignContextElements.has(name)) {
                this._foreignContext.push(true);
            }
            else if (htmlIntegrationElements.has(name)) {
                this._foreignContext.push(false);
            }
        }
        if (this._cbs.onopentagname)
            this._cbs.onopentagname(name);
        if (this._cbs.onopentag)
            this._attribs = {};
    };
    Parser.prototype.onopentagend = function () {
        this._updatePosition(1);
        if (this._attribs) {
            if (this._cbs.onopentag) {
                this._cbs.onopentag(this._tagname, this._attribs);
            }
            this._attribs = null;
        }
        if (!this._options.xmlMode &&
            this._cbs.onclosetag &&
            voidElements.has(this._tagname)) {
            this._cbs.onclosetag(this._tagname);
        }
        this._tagname = "";
    };
    Parser.prototype.onclosetag = function (name) {
        this._updatePosition(1);
        if (this._lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) ||
            htmlIntegrationElements.has(name)) {
            this._foreignContext.pop();
        }
        if (this._stack.length &&
            (this._options.xmlMode || !voidElements.has(name))) {
            var pos = this._stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this._cbs.onclosetag) {
                    pos = this._stack.length - pos;
                    // @ts-ignore
                    while (pos--)
                        this._cbs.onclosetag(this._stack.pop());
                }
                else
                    this._stack.length = pos;
            }
            else if (name === "p" && !this._options.xmlMode) {
                this.onopentagname(name);
                this._closeCurrentTag();
            }
        }
        else if (!this._options.xmlMode && (name === "br" || name === "p")) {
            this.onopentagname(name);
            this._closeCurrentTag();
        }
    };
    Parser.prototype.onselfclosingtag = function () {
        if (this._options.xmlMode ||
            this._options.recognizeSelfClosing ||
            this._foreignContext[this._foreignContext.length - 1]) {
            this._closeCurrentTag();
        }
        else {
            this.onopentagend();
        }
    };
    Parser.prototype._closeCurrentTag = function () {
        var name = this._tagname;
        this.onopentagend();
        //self-closing tags will be on the top of the stack
        //(cheaper check than in onclosetag)
        if (this._stack[this._stack.length - 1] === name) {
            if (this._cbs.onclosetag) {
                this._cbs.onclosetag(name);
            }
            this._stack.pop();
        }
    };
    Parser.prototype.onattribname = function (name) {
        if (this._lowerCaseAttributeNames) {
            name = name.toLowerCase();
        }
        this._attribname = name;
    };
    Parser.prototype.onattribdata = function (value) {
        this._attribvalue += value;
    };
    Parser.prototype.onattribend = function () {
        if (this._cbs.onattribute)
            this._cbs.onattribute(this._attribname, this._attribvalue);
        if (this._attribs &&
            !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
            this._attribs[this._attribname] = this._attribvalue;
        }
        this._attribname = "";
        this._attribvalue = "";
    };
    Parser.prototype._getInstructionName = function (value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this._lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    };
    Parser.prototype.ondeclaration = function (value) {
        if (this._cbs.onprocessinginstruction) {
            var name_1 = this._getInstructionName(value);
            this._cbs.onprocessinginstruction("!" + name_1, "!" + value);
        }
    };
    Parser.prototype.onprocessinginstruction = function (value) {
        if (this._cbs.onprocessinginstruction) {
            var name_2 = this._getInstructionName(value);
            this._cbs.onprocessinginstruction("?" + name_2, "?" + value);
        }
    };
    Parser.prototype.oncomment = function (value) {
        this._updatePosition(4);
        if (this._cbs.oncomment)
            this._cbs.oncomment(value);
        if (this._cbs.oncommentend)
            this._cbs.oncommentend();
    };
    Parser.prototype.oncdata = function (value) {
        this._updatePosition(1);
        if (this._options.xmlMode || this._options.recognizeCDATA) {
            if (this._cbs.oncdatastart)
                this._cbs.oncdatastart();
            if (this._cbs.ontext)
                this._cbs.ontext(value);
            if (this._cbs.oncdataend)
                this._cbs.oncdataend();
        }
        else {
            this.oncomment("[CDATA[" + value + "]]");
        }
    };
    Parser.prototype.onerror = function (err) {
        if (this._cbs.onerror)
            this._cbs.onerror(err);
    };
    Parser.prototype.onend = function () {
        if (this._cbs.onclosetag) {
            for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i]))
                ;
        }
        if (this._cbs.onend)
            this._cbs.onend();
    };
    //Resets the parser to a blank state, ready to parse a new HTML document
    Parser.prototype.reset = function () {
        if (this._cbs.onreset)
            this._cbs.onreset();
        this._tokenizer.reset();
        this._tagname = "";
        this._attribname = "";
        this._attribs = null;
        this._stack = [];
        if (this._cbs.onparserinit)
            this._cbs.onparserinit(this);
    };
    //Parses a complete HTML document and pushes it to the handler
    Parser.prototype.parseComplete = function (data) {
        this.reset();
        this.end(data);
    };
    Parser.prototype.write = function (chunk) {
        this._tokenizer.write(chunk);
    };
    Parser.prototype.end = function (chunk) {
        this._tokenizer.end(chunk);
    };
    Parser.prototype.pause = function () {
        this._tokenizer.pause();
    };
    Parser.prototype.resume = function () {
        this._tokenizer.resume();
    };
    return Parser;
}(events_1.EventEmitter));
exports.Parser = Parser;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/Tokenizer.js":
/*!***************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Tokenizer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var decode_codepoint_1 = __importDefault(__webpack_require__(/*! entities/lib/decode_codepoint */ "./node_modules/entities/lib/decode_codepoint.js"));
var entities_json_1 = __importDefault(__webpack_require__(/*! entities/lib/maps/entities.json */ "./node_modules/entities/lib/maps/entities.json"));
var legacy_json_1 = __importDefault(__webpack_require__(/*! entities/lib/maps/legacy.json */ "./node_modules/entities/lib/maps/legacy.json"));
var xml_json_1 = __importDefault(__webpack_require__(/*! entities/lib/maps/xml.json */ "./node_modules/entities/lib/maps/xml.json"));
function whitespace(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
        return function (t, c) {
            if (c === lower) {
                t._state = SUCCESS;
            }
            else {
                t._state = FAILURE;
                t._index--;
            }
        };
    }
    else {
        return function (t, c) {
            if (c === lower || c === upper) {
                t._state = SUCCESS;
            }
            else {
                t._state = FAILURE;
                t._index--;
            }
        };
    }
}
function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function (t, c) {
        if (c === lower || c === upper) {
            t._state = NEXT_STATE;
        }
        else {
            t._state = 3 /* InTagName */;
            t._index--; //consume the token again
        }
    };
}
var stateBeforeCdata1 = ifElseState("C", 23 /* BeforeCdata2 */, 16 /* InDeclaration */);
var stateBeforeCdata2 = ifElseState("D", 24 /* BeforeCdata3 */, 16 /* InDeclaration */);
var stateBeforeCdata3 = ifElseState("A", 25 /* BeforeCdata4 */, 16 /* InDeclaration */);
var stateBeforeCdata4 = ifElseState("T", 26 /* BeforeCdata5 */, 16 /* InDeclaration */);
var stateBeforeCdata5 = ifElseState("A", 27 /* BeforeCdata6 */, 16 /* InDeclaration */);
var stateBeforeScript1 = consumeSpecialNameChar("R", 34 /* BeforeScript2 */);
var stateBeforeScript2 = consumeSpecialNameChar("I", 35 /* BeforeScript3 */);
var stateBeforeScript3 = consumeSpecialNameChar("P", 36 /* BeforeScript4 */);
var stateBeforeScript4 = consumeSpecialNameChar("T", 37 /* BeforeScript5 */);
var stateAfterScript1 = ifElseState("R", 39 /* AfterScript2 */, 1 /* Text */);
var stateAfterScript2 = ifElseState("I", 40 /* AfterScript3 */, 1 /* Text */);
var stateAfterScript3 = ifElseState("P", 41 /* AfterScript4 */, 1 /* Text */);
var stateAfterScript4 = ifElseState("T", 42 /* AfterScript5 */, 1 /* Text */);
var stateBeforeStyle1 = consumeSpecialNameChar("Y", 44 /* BeforeStyle2 */);
var stateBeforeStyle2 = consumeSpecialNameChar("L", 45 /* BeforeStyle3 */);
var stateBeforeStyle3 = consumeSpecialNameChar("E", 46 /* BeforeStyle4 */);
var stateAfterStyle1 = ifElseState("Y", 48 /* AfterStyle2 */, 1 /* Text */);
var stateAfterStyle2 = ifElseState("L", 49 /* AfterStyle3 */, 1 /* Text */);
var stateAfterStyle3 = ifElseState("E", 50 /* AfterStyle4 */, 1 /* Text */);
var stateBeforeEntity = ifElseState("#", 52 /* BeforeNumericEntity */, 53 /* InNamedEntity */);
var stateBeforeNumericEntity = ifElseState("X", 55 /* InHexEntity */, 54 /* InNumericEntity */);
var Tokenizer = /** @class */ (function () {
    function Tokenizer(options, cbs) {
        /** The current state the tokenizer is in. */
        this._state = 1 /* Text */;
        /** The read buffer. */
        this._buffer = "";
        /** The beginning of the section that is currently being read. */
        this._sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */
        this._index = 0;
        /**
         * Data that has already been processed will be removed from the buffer occasionally.
         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
         */
        this._bufferOffset = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
        this._baseState = 1 /* Text */;
        /** For special parsing behavior inside of script and style tags. */
        this._special = 1 /* None */;
        /** Indicates whether the tokenizer has been paused. */
        this._running = true;
        /** Indicates whether the tokenizer has finished running / `.end` has been called. */
        this._ended = false;
        this._cbs = cbs;
        this._xmlMode = !!(options && options.xmlMode);
        this._decodeEntities = !!(options && options.decodeEntities);
    }
    Tokenizer.prototype.reset = function () {
        this._state = 1 /* Text */;
        this._buffer = "";
        this._sectionStart = 0;
        this._index = 0;
        this._bufferOffset = 0;
        this._baseState = 1 /* Text */;
        this._special = 1 /* None */;
        this._running = true;
        this._ended = false;
    };
    Tokenizer.prototype._stateText = function (c) {
        if (c === "<") {
            if (this._index > this._sectionStart) {
                this._cbs.ontext(this._getSection());
            }
            this._state = 2 /* BeforeTagName */;
            this._sectionStart = this._index;
        }
        else if (this._decodeEntities &&
            this._special === 1 /* None */ &&
            c === "&") {
            if (this._index > this._sectionStart) {
                this._cbs.ontext(this._getSection());
            }
            this._baseState = 1 /* Text */;
            this._state = 51 /* BeforeEntity */;
            this._sectionStart = this._index;
        }
    };
    Tokenizer.prototype._stateBeforeTagName = function (c) {
        if (c === "/") {
            this._state = 5 /* BeforeClosingTagName */;
        }
        else if (c === "<") {
            this._cbs.ontext(this._getSection());
            this._sectionStart = this._index;
        }
        else if (c === ">" ||
            this._special !== 1 /* None */ ||
            whitespace(c)) {
            this._state = 1 /* Text */;
        }
        else if (c === "!") {
            this._state = 15 /* BeforeDeclaration */;
            this._sectionStart = this._index + 1;
        }
        else if (c === "?") {
            this._state = 17 /* InProcessingInstruction */;
            this._sectionStart = this._index + 1;
        }
        else {
            this._state =
                !this._xmlMode && (c === "s" || c === "S")
                    ? 31 /* BeforeSpecial */
                    : 3 /* InTagName */;
            this._sectionStart = this._index;
        }
    };
    Tokenizer.prototype._stateInTagName = function (c) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this._emitToken("onopentagname");
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype._stateBeforeClosingTagName = function (c) {
        if (whitespace(c)) {
            // ignore
        }
        else if (c === ">") {
            this._state = 1 /* Text */;
        }
        else if (this._special !== 1 /* None */) {
            if (c === "s" || c === "S") {
                this._state = 32 /* BeforeSpecialEnd */;
            }
            else {
                this._state = 1 /* Text */;
                this._index--;
            }
        }
        else {
            this._state = 6 /* InClosingTagName */;
            this._sectionStart = this._index;
        }
    };
    Tokenizer.prototype._stateInClosingTagName = function (c) {
        if (c === ">" || whitespace(c)) {
            this._emitToken("onclosetag");
            this._state = 7 /* AfterClosingTagName */;
            this._index--;
        }
    };
    Tokenizer.prototype._stateAfterClosingTagName = function (c) {
        //skip everything until ">"
        if (c === ">") {
            this._state = 1 /* Text */;
            this._sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype._stateBeforeAttributeName = function (c) {
        if (c === ">") {
            this._cbs.onopentagend();
            this._state = 1 /* Text */;
            this._sectionStart = this._index + 1;
        }
        else if (c === "/") {
            this._state = 4 /* InSelfClosingTag */;
        }
        else if (!whitespace(c)) {
            this._state = 9 /* InAttributeName */;
            this._sectionStart = this._index;
        }
    };
    Tokenizer.prototype._stateInSelfClosingTag = function (c) {
        if (c === ">") {
            this._cbs.onselfclosingtag();
            this._state = 1 /* Text */;
            this._sectionStart = this._index + 1;
        }
        else if (!whitespace(c)) {
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype._stateInAttributeName = function (c) {
        if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
            this._cbs.onattribname(this._getSection());
            this._sectionStart = -1;
            this._state = 10 /* AfterAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype._stateAfterAttributeName = function (c) {
        if (c === "=") {
            this._state = 11 /* BeforeAttributeValue */;
        }
        else if (c === "/" || c === ">") {
            this._cbs.onattribend();
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
        else if (!whitespace(c)) {
            this._cbs.onattribend();
            this._state = 9 /* InAttributeName */;
            this._sectionStart = this._index;
        }
    };
    Tokenizer.prototype._stateBeforeAttributeValue = function (c) {
        if (c === '"') {
            this._state = 12 /* InAttributeValueDq */;
            this._sectionStart = this._index + 1;
        }
        else if (c === "'") {
            this._state = 13 /* InAttributeValueSq */;
            this._sectionStart = this._index + 1;
        }
        else if (!whitespace(c)) {
            this._state = 14 /* InAttributeValueNq */;
            this._sectionStart = this._index;
            this._index--; //reconsume token
        }
    };
    Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function (c) {
        if (c === '"') {
            this._emitToken("onattribdata");
            this._cbs.onattribend();
            this._state = 8 /* BeforeAttributeName */;
        }
        else if (this._decodeEntities && c === "&") {
            this._emitToken("onattribdata");
            this._baseState = this._state;
            this._state = 51 /* BeforeEntity */;
            this._sectionStart = this._index;
        }
    };
    Tokenizer.prototype._stateInAttributeValueSingleQuotes = function (c) {
        if (c === "'") {
            this._emitToken("onattribdata");
            this._cbs.onattribend();
            this._state = 8 /* BeforeAttributeName */;
        }
        else if (this._decodeEntities && c === "&") {
            this._emitToken("onattribdata");
            this._baseState = this._state;
            this._state = 51 /* BeforeEntity */;
            this._sectionStart = this._index;
        }
    };
    Tokenizer.prototype._stateInAttributeValueNoQuotes = function (c) {
        if (whitespace(c) || c === ">") {
            this._emitToken("onattribdata");
            this._cbs.onattribend();
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
        else if (this._decodeEntities && c === "&") {
            this._emitToken("onattribdata");
            this._baseState = this._state;
            this._state = 51 /* BeforeEntity */;
            this._sectionStart = this._index;
        }
    };
    Tokenizer.prototype._stateBeforeDeclaration = function (c) {
        this._state =
            c === "["
                ? 22 /* BeforeCdata1 */
                : c === "-"
                    ? 18 /* BeforeComment */
                    : 16 /* InDeclaration */;
    };
    Tokenizer.prototype._stateInDeclaration = function (c) {
        if (c === ">") {
            this._cbs.ondeclaration(this._getSection());
            this._state = 1 /* Text */;
            this._sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype._stateInProcessingInstruction = function (c) {
        if (c === ">") {
            this._cbs.onprocessinginstruction(this._getSection());
            this._state = 1 /* Text */;
            this._sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype._stateBeforeComment = function (c) {
        if (c === "-") {
            this._state = 19 /* InComment */;
            this._sectionStart = this._index + 1;
        }
        else {
            this._state = 16 /* InDeclaration */;
        }
    };
    Tokenizer.prototype._stateInComment = function (c) {
        if (c === "-")
            this._state = 20 /* AfterComment1 */;
    };
    Tokenizer.prototype._stateAfterComment1 = function (c) {
        if (c === "-") {
            this._state = 21 /* AfterComment2 */;
        }
        else {
            this._state = 19 /* InComment */;
        }
    };
    Tokenizer.prototype._stateAfterComment2 = function (c) {
        if (c === ">") {
            //remove 2 trailing chars
            this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
            this._state = 1 /* Text */;
            this._sectionStart = this._index + 1;
        }
        else if (c !== "-") {
            this._state = 19 /* InComment */;
        }
        // else: stay in AFTER_COMMENT_2 (`--->`)
    };
    Tokenizer.prototype._stateBeforeCdata6 = function (c) {
        if (c === "[") {
            this._state = 28 /* InCdata */;
            this._sectionStart = this._index + 1;
        }
        else {
            this._state = 16 /* InDeclaration */;
            this._index--;
        }
    };
    Tokenizer.prototype._stateInCdata = function (c) {
        if (c === "]")
            this._state = 29 /* AfterCdata1 */;
    };
    Tokenizer.prototype._stateAfterCdata1 = function (c) {
        if (c === "]")
            this._state = 30 /* AfterCdata2 */;
        else
            this._state = 28 /* InCdata */;
    };
    Tokenizer.prototype._stateAfterCdata2 = function (c) {
        if (c === ">") {
            //remove 2 trailing chars
            this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
            this._state = 1 /* Text */;
            this._sectionStart = this._index + 1;
        }
        else if (c !== "]") {
            this._state = 28 /* InCdata */;
        }
        //else: stay in AFTER_CDATA_2 (`]]]>`)
    };
    Tokenizer.prototype._stateBeforeSpecial = function (c) {
        if (c === "c" || c === "C") {
            this._state = 33 /* BeforeScript1 */;
        }
        else if (c === "t" || c === "T") {
            this._state = 43 /* BeforeStyle1 */;
        }
        else {
            this._state = 3 /* InTagName */;
            this._index--; //consume the token again
        }
    };
    Tokenizer.prototype._stateBeforeSpecialEnd = function (c) {
        if (this._special === 2 /* Script */ && (c === "c" || c === "C")) {
            this._state = 38 /* AfterScript1 */;
        }
        else if (this._special === 3 /* Style */ &&
            (c === "t" || c === "T")) {
            this._state = 47 /* AfterStyle1 */;
        }
        else
            this._state = 1 /* Text */;
    };
    Tokenizer.prototype._stateBeforeScript5 = function (c) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this._special = 2 /* Script */;
        }
        this._state = 3 /* InTagName */;
        this._index--; //consume the token again
    };
    Tokenizer.prototype._stateAfterScript5 = function (c) {
        if (c === ">" || whitespace(c)) {
            this._special = 1 /* None */;
            this._state = 6 /* InClosingTagName */;
            this._sectionStart = this._index - 6;
            this._index--; //reconsume the token
        }
        else
            this._state = 1 /* Text */;
    };
    Tokenizer.prototype._stateBeforeStyle4 = function (c) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this._special = 3 /* Style */;
        }
        this._state = 3 /* InTagName */;
        this._index--; //consume the token again
    };
    Tokenizer.prototype._stateAfterStyle4 = function (c) {
        if (c === ">" || whitespace(c)) {
            this._special = 1 /* None */;
            this._state = 6 /* InClosingTagName */;
            this._sectionStart = this._index - 5;
            this._index--; //reconsume the token
        }
        else
            this._state = 1 /* Text */;
    };
    //for entities terminated with a semicolon
    Tokenizer.prototype._parseNamedEntityStrict = function () {
        //offset = 1
        if (this._sectionStart + 1 < this._index) {
            var entity = this._buffer.substring(this._sectionStart + 1, this._index), map = this._xmlMode ? xml_json_1.default : entities_json_1.default;
            if (Object.prototype.hasOwnProperty.call(map, entity)) {
                // @ts-ignore
                this._emitPartial(map[entity]);
                this._sectionStart = this._index + 1;
            }
        }
    };
    //parses legacy entities (without trailing semicolon)
    Tokenizer.prototype._parseLegacyEntity = function () {
        var start = this._sectionStart + 1;
        var limit = this._index - start;
        if (limit > 6)
            limit = 6; // The max length of legacy entities is 6
        while (limit >= 2) {
            // The min length of legacy entities is 2
            var entity = this._buffer.substr(start, limit);
            if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
                // @ts-ignore
                this._emitPartial(legacy_json_1.default[entity]);
                this._sectionStart += limit + 1;
                return;
            }
            else {
                limit--;
            }
        }
    };
    Tokenizer.prototype._stateInNamedEntity = function (c) {
        if (c === ";") {
            this._parseNamedEntityStrict();
            if (this._sectionStart + 1 < this._index && !this._xmlMode) {
                this._parseLegacyEntity();
            }
            this._state = this._baseState;
        }
        else if ((c < "a" || c > "z") &&
            (c < "A" || c > "Z") &&
            (c < "0" || c > "9")) {
            if (this._xmlMode || this._sectionStart + 1 === this._index) {
                // ignore
            }
            else if (this._baseState !== 1 /* Text */) {
                if (c !== "=") {
                    this._parseNamedEntityStrict();
                }
            }
            else {
                this._parseLegacyEntity();
            }
            this._state = this._baseState;
            this._index--;
        }
    };
    Tokenizer.prototype._decodeNumericEntity = function (offset, base) {
        var sectionStart = this._sectionStart + offset;
        if (sectionStart !== this._index) {
            //parse entity
            var entity = this._buffer.substring(sectionStart, this._index);
            var parsed = parseInt(entity, base);
            this._emitPartial(decode_codepoint_1.default(parsed));
            this._sectionStart = this._index;
        }
        else {
            this._sectionStart--;
        }
        this._state = this._baseState;
    };
    Tokenizer.prototype._stateInNumericEntity = function (c) {
        if (c === ";") {
            this._decodeNumericEntity(2, 10);
            this._sectionStart++;
        }
        else if (c < "0" || c > "9") {
            if (!this._xmlMode) {
                this._decodeNumericEntity(2, 10);
            }
            else {
                this._state = this._baseState;
            }
            this._index--;
        }
    };
    Tokenizer.prototype._stateInHexEntity = function (c) {
        if (c === ";") {
            this._decodeNumericEntity(3, 16);
            this._sectionStart++;
        }
        else if ((c < "a" || c > "f") &&
            (c < "A" || c > "F") &&
            (c < "0" || c > "9")) {
            if (!this._xmlMode) {
                this._decodeNumericEntity(3, 16);
            }
            else {
                this._state = this._baseState;
            }
            this._index--;
        }
    };
    Tokenizer.prototype._cleanup = function () {
        if (this._sectionStart < 0) {
            this._buffer = "";
            this._bufferOffset += this._index;
            this._index = 0;
        }
        else if (this._running) {
            if (this._state === 1 /* Text */) {
                if (this._sectionStart !== this._index) {
                    this._cbs.ontext(this._buffer.substr(this._sectionStart));
                }
                this._buffer = "";
                this._bufferOffset += this._index;
                this._index = 0;
            }
            else if (this._sectionStart === this._index) {
                //the section just started
                this._buffer = "";
                this._bufferOffset += this._index;
                this._index = 0;
            }
            else {
                //remove everything unnecessary
                this._buffer = this._buffer.substr(this._sectionStart);
                this._index -= this._sectionStart;
                this._bufferOffset += this._sectionStart;
            }
            this._sectionStart = 0;
        }
    };
    //TODO make events conditional
    Tokenizer.prototype.write = function (chunk) {
        if (this._ended)
            this._cbs.onerror(Error(".write() after done!"));
        this._buffer += chunk;
        this._parse();
    };
    // Iterates through the buffer, calling the function corresponding to the current state.
    // States that are more likely to be hit are higher up, as a performance improvement.
    Tokenizer.prototype._parse = function () {
        while (this._index < this._buffer.length && this._running) {
            var c = this._buffer.charAt(this._index);
            if (this._state === 1 /* Text */) {
                this._stateText(c);
            }
            else if (this._state === 12 /* InAttributeValueDq */) {
                this._stateInAttributeValueDoubleQuotes(c);
            }
            else if (this._state === 9 /* InAttributeName */) {
                this._stateInAttributeName(c);
            }
            else if (this._state === 19 /* InComment */) {
                this._stateInComment(c);
            }
            else if (this._state === 8 /* BeforeAttributeName */) {
                this._stateBeforeAttributeName(c);
            }
            else if (this._state === 3 /* InTagName */) {
                this._stateInTagName(c);
            }
            else if (this._state === 6 /* InClosingTagName */) {
                this._stateInClosingTagName(c);
            }
            else if (this._state === 2 /* BeforeTagName */) {
                this._stateBeforeTagName(c);
            }
            else if (this._state === 10 /* AfterAttributeName */) {
                this._stateAfterAttributeName(c);
            }
            else if (this._state === 13 /* InAttributeValueSq */) {
                this._stateInAttributeValueSingleQuotes(c);
            }
            else if (this._state === 11 /* BeforeAttributeValue */) {
                this._stateBeforeAttributeValue(c);
            }
            else if (this._state === 5 /* BeforeClosingTagName */) {
                this._stateBeforeClosingTagName(c);
            }
            else if (this._state === 7 /* AfterClosingTagName */) {
                this._stateAfterClosingTagName(c);
            }
            else if (this._state === 31 /* BeforeSpecial */) {
                this._stateBeforeSpecial(c);
            }
            else if (this._state === 20 /* AfterComment1 */) {
                this._stateAfterComment1(c);
            }
            else if (this._state === 14 /* InAttributeValueNq */) {
                this._stateInAttributeValueNoQuotes(c);
            }
            else if (this._state === 4 /* InSelfClosingTag */) {
                this._stateInSelfClosingTag(c);
            }
            else if (this._state === 16 /* InDeclaration */) {
                this._stateInDeclaration(c);
            }
            else if (this._state === 15 /* BeforeDeclaration */) {
                this._stateBeforeDeclaration(c);
            }
            else if (this._state === 21 /* AfterComment2 */) {
                this._stateAfterComment2(c);
            }
            else if (this._state === 18 /* BeforeComment */) {
                this._stateBeforeComment(c);
            }
            else if (this._state === 32 /* BeforeSpecialEnd */) {
                this._stateBeforeSpecialEnd(c);
            }
            else if (this._state === 38 /* AfterScript1 */) {
                stateAfterScript1(this, c);
            }
            else if (this._state === 39 /* AfterScript2 */) {
                stateAfterScript2(this, c);
            }
            else if (this._state === 40 /* AfterScript3 */) {
                stateAfterScript3(this, c);
            }
            else if (this._state === 33 /* BeforeScript1 */) {
                stateBeforeScript1(this, c);
            }
            else if (this._state === 34 /* BeforeScript2 */) {
                stateBeforeScript2(this, c);
            }
            else if (this._state === 35 /* BeforeScript3 */) {
                stateBeforeScript3(this, c);
            }
            else if (this._state === 36 /* BeforeScript4 */) {
                stateBeforeScript4(this, c);
            }
            else if (this._state === 37 /* BeforeScript5 */) {
                this._stateBeforeScript5(c);
            }
            else if (this._state === 41 /* AfterScript4 */) {
                stateAfterScript4(this, c);
            }
            else if (this._state === 42 /* AfterScript5 */) {
                this._stateAfterScript5(c);
            }
            else if (this._state === 43 /* BeforeStyle1 */) {
                stateBeforeStyle1(this, c);
            }
            else if (this._state === 28 /* InCdata */) {
                this._stateInCdata(c);
            }
            else if (this._state === 44 /* BeforeStyle2 */) {
                stateBeforeStyle2(this, c);
            }
            else if (this._state === 45 /* BeforeStyle3 */) {
                stateBeforeStyle3(this, c);
            }
            else if (this._state === 46 /* BeforeStyle4 */) {
                this._stateBeforeStyle4(c);
            }
            else if (this._state === 47 /* AfterStyle1 */) {
                stateAfterStyle1(this, c);
            }
            else if (this._state === 48 /* AfterStyle2 */) {
                stateAfterStyle2(this, c);
            }
            else if (this._state === 49 /* AfterStyle3 */) {
                stateAfterStyle3(this, c);
            }
            else if (this._state === 50 /* AfterStyle4 */) {
                this._stateAfterStyle4(c);
            }
            else if (this._state === 17 /* InProcessingInstruction */) {
                this._stateInProcessingInstruction(c);
            }
            else if (this._state === 53 /* InNamedEntity */) {
                this._stateInNamedEntity(c);
            }
            else if (this._state === 22 /* BeforeCdata1 */) {
                stateBeforeCdata1(this, c);
            }
            else if (this._state === 51 /* BeforeEntity */) {
                stateBeforeEntity(this, c);
            }
            else if (this._state === 23 /* BeforeCdata2 */) {
                stateBeforeCdata2(this, c);
            }
            else if (this._state === 24 /* BeforeCdata3 */) {
                stateBeforeCdata3(this, c);
            }
            else if (this._state === 29 /* AfterCdata1 */) {
                this._stateAfterCdata1(c);
            }
            else if (this._state === 30 /* AfterCdata2 */) {
                this._stateAfterCdata2(c);
            }
            else if (this._state === 25 /* BeforeCdata4 */) {
                stateBeforeCdata4(this, c);
            }
            else if (this._state === 26 /* BeforeCdata5 */) {
                stateBeforeCdata5(this, c);
            }
            else if (this._state === 27 /* BeforeCdata6 */) {
                this._stateBeforeCdata6(c);
            }
            else if (this._state === 55 /* InHexEntity */) {
                this._stateInHexEntity(c);
            }
            else if (this._state === 54 /* InNumericEntity */) {
                this._stateInNumericEntity(c);
            }
            else if (this._state === 52 /* BeforeNumericEntity */) {
                stateBeforeNumericEntity(this, c);
            }
            else {
                this._cbs.onerror(Error("unknown _state"), this._state);
            }
            this._index++;
        }
        this._cleanup();
    };
    Tokenizer.prototype.pause = function () {
        this._running = false;
    };
    Tokenizer.prototype.resume = function () {
        this._running = true;
        if (this._index < this._buffer.length) {
            this._parse();
        }
        if (this._ended) {
            this._finish();
        }
    };
    Tokenizer.prototype.end = function (chunk) {
        if (this._ended)
            this._cbs.onerror(Error(".end() after done!"));
        if (chunk)
            this.write(chunk);
        this._ended = true;
        if (this._running)
            this._finish();
    };
    Tokenizer.prototype._finish = function () {
        //if there is remaining data, emit it in a reasonable way
        if (this._sectionStart < this._index) {
            this._handleTrailingData();
        }
        this._cbs.onend();
    };
    Tokenizer.prototype._handleTrailingData = function () {
        var data = this._buffer.substr(this._sectionStart);
        if (this._state === 28 /* InCdata */ ||
            this._state === 29 /* AfterCdata1 */ ||
            this._state === 30 /* AfterCdata2 */) {
            this._cbs.oncdata(data);
        }
        else if (this._state === 19 /* InComment */ ||
            this._state === 20 /* AfterComment1 */ ||
            this._state === 21 /* AfterComment2 */) {
            this._cbs.oncomment(data);
        }
        else if (this._state === 53 /* InNamedEntity */ && !this._xmlMode) {
            this._parseLegacyEntity();
            if (this._sectionStart < this._index) {
                this._state = this._baseState;
                this._handleTrailingData();
            }
        }
        else if (this._state === 54 /* InNumericEntity */ && !this._xmlMode) {
            this._decodeNumericEntity(2, 10);
            if (this._sectionStart < this._index) {
                this._state = this._baseState;
                this._handleTrailingData();
            }
        }
        else if (this._state === 55 /* InHexEntity */ && !this._xmlMode) {
            this._decodeNumericEntity(3, 16);
            if (this._sectionStart < this._index) {
                this._state = this._baseState;
                this._handleTrailingData();
            }
        }
        else if (this._state !== 3 /* InTagName */ &&
            this._state !== 8 /* BeforeAttributeName */ &&
            this._state !== 11 /* BeforeAttributeValue */ &&
            this._state !== 10 /* AfterAttributeName */ &&
            this._state !== 9 /* InAttributeName */ &&
            this._state !== 13 /* InAttributeValueSq */ &&
            this._state !== 12 /* InAttributeValueDq */ &&
            this._state !== 14 /* InAttributeValueNq */ &&
            this._state !== 6 /* InClosingTagName */) {
            this._cbs.ontext(data);
        }
        //else, ignore remaining data
        //TODO add a way to remove current tag
    };
    Tokenizer.prototype.getAbsoluteIndex = function () {
        return this._bufferOffset + this._index;
    };
    Tokenizer.prototype._getSection = function () {
        return this._buffer.substring(this._sectionStart, this._index);
    };
    Tokenizer.prototype._emitToken = function (name) {
        this._cbs[name](this._getSection());
        this._sectionStart = -1;
    };
    Tokenizer.prototype._emitPartial = function (value) {
        if (this._baseState !== 1 /* Text */) {
            this._cbs.onattribdata(value); //TODO implement the new event
        }
        else {
            this._cbs.ontext(value);
        }
    };
    return Tokenizer;
}());
exports.default = Tokenizer;


/***/ }),

/***/ "./node_modules/htmlparser2/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/htmlparser2/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Parser_1 = __webpack_require__(/*! ./Parser */ "./node_modules/htmlparser2/lib/Parser.js");
exports.Parser = Parser_1.Parser;
var domhandler_1 = __webpack_require__(/*! domhandler */ "./node_modules/domhandler/lib/index.js");
exports.DomHandler = domhandler_1.DomHandler;
exports.DefaultHandler = domhandler_1.DomHandler;
// Helper methods
/**
 * Parses data, returns the resulting DOM.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */
function parseDOM(data, options) {
    var handler = new domhandler_1.DomHandler(void 0, options);
    new Parser_1.Parser(handler, options).end(data);
    return handler.dom;
}
exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */
function createDomStream(cb, options, elementCb) {
    var handler = new domhandler_1.DomHandler(cb, options, elementCb);
    return new Parser_1.Parser(handler, options);
}
exports.createDomStream = createDomStream;
var Tokenizer_1 = __webpack_require__(/*! ./Tokenizer */ "./node_modules/htmlparser2/lib/Tokenizer.js");
exports.Tokenizer = Tokenizer_1.default;
var ElementType = __importStar(__webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js"));
exports.ElementType = ElementType;
/**
 * List of all events that the parser emits.
 *
 * Format: eventname: number of arguments.
 */
exports.EVENTS = {
    attribute: 2,
    cdatastart: 0,
    cdataend: 0,
    text: 1,
    processinginstruction: 2,
    comment: 1,
    commentend: 0,
    closetag: 1,
    opentag: 2,
    opentagname: 1,
    error: 1,
    end: 0
};
/*
    All of the following exports exist for backwards-compatibility.
    They should probably be removed eventually.
*/
__export(__webpack_require__(/*! ./FeedHandler */ "./node_modules/htmlparser2/lib/FeedHandler.js"));
__export(__webpack_require__(/*! ./WritableStream */ 0));
__export(__webpack_require__(/*! ./CollectingHandler */ "./node_modules/htmlparser2/lib/CollectingHandler.js"));
var DomUtils = __importStar(__webpack_require__(/*! domutils */ "./node_modules/domutils/lib/index.js"));
exports.DomUtils = DomUtils;
var FeedHandler_1 = __webpack_require__(/*! ./FeedHandler */ "./node_modules/htmlparser2/lib/FeedHandler.js");
exports.RssHandler = FeedHandler_1.FeedHandler;


/***/ }),

/***/ "./node_modules/lodash.camelcase/index.js":
/*!************************************************!*\
  !*** ./node_modules/lodash.camelcase/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsAstral = '[' + rsAstralRange + ']',
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 'ss'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = camelCase;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/memoize-one/dist/memoize-one.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (newInputs[i] !== lastInputs[i]) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

/* harmony default export */ __webpack_exports__["default"] = (memoizeOne);


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/ramda/src/addIndex.js":
/*!********************************************!*\
  !*** ./node_modules/ramda/src/addIndex.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _concat = /*#__PURE__*/__webpack_require__(/*! ./internal/_concat */ "./node_modules/ramda/src/internal/_concat.js");

var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ "./node_modules/ramda/src/curryN.js");

/**
 * Creates a new list iteration function from an existing one by adding two new
 * parameters to its callback function: the current index, and the entire list.
 *
 * This would turn, for instance, [`R.map`](#map) function into one that
 * more closely resembles `Array.prototype.map`. Note that this will only work
 * for functions in which the iteration callback function is the first
 * parameter, and where the list is the last parameter. (This latter might be
 * unimportant if the list parameter is not used.)
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Function
 * @category List
 * @sig ((a ... -> b) ... -> [a] -> *) -> ((a ..., Int, [a] -> b) ... -> [a] -> *)
 * @param {Function} fn A list iteration function that does not pass index or list to its callback
 * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
 * @example
 *
 *      const mapIndexed = R.addIndex(R.map);
 *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
 *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
 */


var addIndex = /*#__PURE__*/_curry1(function addIndex(fn) {
  return curryN(fn.length, function () {
    var idx = 0;
    var origFn = arguments[0];
    var list = arguments[arguments.length - 1];
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function () {
      var result = origFn.apply(this, _concat(arguments, [idx, list]));
      idx += 1;
      return result;
    };
    return fn.apply(this, args);
  });
});
module.exports = addIndex;

/***/ }),

/***/ "./node_modules/ramda/src/bind.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/bind.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ "./node_modules/ramda/src/internal/_arity.js");

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      const log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */


var bind = /*#__PURE__*/_curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});
module.exports = bind;

/***/ }),

/***/ "./node_modules/ramda/src/curryN.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/curryN.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _arity = /*#__PURE__*/__webpack_require__(/*! ./internal/_arity */ "./node_modules/ramda/src/internal/_arity.js");

var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _curryN = /*#__PURE__*/__webpack_require__(/*! ./internal/_curryN */ "./node_modules/ramda/src/internal/_curryN.js");

/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      const sumArgs = (...args) => R.sum(args);
 *
 *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      const f = curriedAddFourNumbers(1, 2);
 *      const g = f(3);
 *      g(4); //=> 10
 */


var curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }
  return _arity(length, _curryN(length, [], fn));
});
module.exports = curryN;

/***/ }),

/***/ "./node_modules/ramda/src/filter.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/filter.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/ramda/src/internal/_dispatchable.js");

var _filter = /*#__PURE__*/__webpack_require__(/*! ./internal/_filter */ "./node_modules/ramda/src/internal/_filter.js");

var _isObject = /*#__PURE__*/__webpack_require__(/*! ./internal/_isObject */ "./node_modules/ramda/src/internal/_isObject.js");

var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ "./node_modules/ramda/src/internal/_reduce.js");

var _xfilter = /*#__PURE__*/__webpack_require__(/*! ./internal/_xfilter */ "./node_modules/ramda/src/internal/_xfilter.js");

var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ "./node_modules/ramda/src/keys.js");

/**
 * Takes a predicate and a `Filterable`, and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array} Filterable
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      const isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */


var filter = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['filter'], _xfilter, function (pred, filterable) {
  return _isObject(filterable) ? _reduce(function (acc, key) {
    if (pred(filterable[key])) {
      acc[key] = filterable[key];
    }
    return acc;
  }, {}, keys(filterable)) :
  // else
  _filter(pred, filterable);
}));
module.exports = filter;

/***/ }),

/***/ "./node_modules/ramda/src/find.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/find.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/ramda/src/internal/_dispatchable.js");

var _xfind = /*#__PURE__*/__webpack_require__(/*! ./internal/_xfind */ "./node_modules/ramda/src/internal/_xfind.js");

/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */


var find = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['find'], _xfind, function find(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx += 1;
  }
}));
module.exports = find;

/***/ }),

/***/ "./node_modules/ramda/src/forEach.js":
/*!*******************************************!*\
  !*** ./node_modules/ramda/src/forEach.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod = /*#__PURE__*/__webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/ramda/src/internal/_checkForMethod.js");

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

/**
 * Iterate over an input `list`, calling a provided function `fn` for each
 * element in the list.
 *
 * `fn` receives one argument: *(value)*.
 *
 * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.forEach` method. For more
 * details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
 *
 * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
 * the original array. In some libraries this function is named `each`.
 *
 * Dispatches to the `forEach` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> *) -> [a] -> [a]
 * @param {Function} fn The function to invoke. Receives one argument, `value`.
 * @param {Array} list The list to iterate over.
 * @return {Array} The original list.
 * @see R.addIndex
 * @example
 *
 *      const printXPlusFive = x => console.log(x + 5);
 *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
 *      // logs 6
 *      // logs 7
 *      // logs 8
 * @symb R.forEach(f, [a, b, c]) = [a, b, c]
 */


var forEach = /*#__PURE__*/_curry2( /*#__PURE__*/_checkForMethod('forEach', function forEach(fn, list) {
  var len = list.length;
  var idx = 0;
  while (idx < len) {
    fn(list[idx]);
    idx += 1;
  }
  return list;
}));
module.exports = forEach;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_arity.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_arity.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };
    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}
module.exports = _arity;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_checkForMethod.js":
/*!************************************************************!*\
  !*** ./node_modules/ramda/src/internal/_checkForMethod.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _isArray = /*#__PURE__*/__webpack_require__(/*! ./_isArray */ "./node_modules/ramda/src/internal/_isArray.js");

/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */


function _checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}
module.exports = _checkForMethod;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_complement.js":
/*!********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_complement.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _complement(f) {
  return function () {
    return !f.apply(this, arguments);
  };
}
module.exports = _complement;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_concat.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_concat.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];

  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }
  return result;
}
module.exports = _concat;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry1.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry1.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ "./node_modules/ramda/src/internal/_isPlaceholder.js");

/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}
module.exports = _curry1;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry2.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry2.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ "./node_modules/ramda/src/internal/_isPlaceholder.js");

/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}
module.exports = _curry2;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry3.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry3.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ "./node_modules/ramda/src/internal/_isPlaceholder.js");

/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function (_c) {
          return fn(a, b, _c);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}
module.exports = _curry3;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curryN.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curryN.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _arity = /*#__PURE__*/__webpack_require__(/*! ./_arity */ "./node_modules/ramda/src/internal/_arity.js");

var _isPlaceholder = /*#__PURE__*/__webpack_require__(/*! ./_isPlaceholder */ "./node_modules/ramda/src/internal/_isPlaceholder.js");

/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
}
module.exports = _curryN;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_dispatchable.js":
/*!**********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_dispatchable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _isArray = /*#__PURE__*/__webpack_require__(/*! ./_isArray */ "./node_modules/ramda/src/internal/_isArray.js");

var _isTransformer = /*#__PURE__*/__webpack_require__(/*! ./_isTransformer */ "./node_modules/ramda/src/internal/_isTransformer.js");

/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */


function _dispatchable(methodNames, xf, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }
    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();
    if (!_isArray(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
}
module.exports = _dispatchable;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_filter.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_filter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
}
module.exports = _filter;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_has.js":
/*!*************************************************!*\
  !*** ./node_modules/ramda/src/internal/_has.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
module.exports = _has;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isArguments.js":
/*!*********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isArguments.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _has = /*#__PURE__*/__webpack_require__(/*! ./_has */ "./node_modules/ramda/src/internal/_has.js");

var toString = Object.prototype.toString;
var _isArguments = /*#__PURE__*/function () {
  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return _has('callee', x);
  };
}();

module.exports = _isArguments;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isArray.js":
/*!*****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isArray.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
};

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isArrayLike.js":
/*!*********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isArrayLike.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _isArray = /*#__PURE__*/__webpack_require__(/*! ./_isArray */ "./node_modules/ramda/src/internal/_isArray.js");

var _isString = /*#__PURE__*/__webpack_require__(/*! ./_isString */ "./node_modules/ramda/src/internal/_isString.js");

/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */


var _isArrayLike = /*#__PURE__*/_curry1(function isArrayLike(x) {
  if (_isArray(x)) {
    return true;
  }
  if (!x) {
    return false;
  }
  if (typeof x !== 'object') {
    return false;
  }
  if (_isString(x)) {
    return false;
  }
  if (x.nodeType === 1) {
    return !!x.length;
  }
  if (x.length === 0) {
    return true;
  }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});
module.exports = _isArrayLike;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isObject.js":
/*!******************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isObject.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
}
module.exports = _isObject;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isPlaceholder.js":
/*!***********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isPlaceholder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isPlaceholder(a) {
       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}
module.exports = _isPlaceholder;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isString.js":
/*!******************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isString.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}
module.exports = _isString;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isTransformer.js":
/*!***********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isTransformer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isTransformer(obj) {
  return obj != null && typeof obj['@@transducer/step'] === 'function';
}
module.exports = _isTransformer;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_map.js":
/*!*************************************************!*\
  !*** ./node_modules/ramda/src/internal/_map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
}
module.exports = _map;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_reduce.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_reduce.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _isArrayLike = /*#__PURE__*/__webpack_require__(/*! ./_isArrayLike */ "./node_modules/ramda/src/internal/_isArrayLike.js");

var _xwrap = /*#__PURE__*/__webpack_require__(/*! ./_xwrap */ "./node_modules/ramda/src/internal/_xwrap.js");

var bind = /*#__PURE__*/__webpack_require__(/*! ../bind */ "./node_modules/ramda/src/bind.js");

function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf['@@transducer/step'](acc, list[idx]);
    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }
    idx += 1;
  }
  return xf['@@transducer/result'](acc);
}

function _iterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf['@@transducer/step'](acc, step.value);
    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }
    step = iter.next();
  }
  return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
}

var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';

function _reduce(fn, acc, list) {
  if (typeof fn === 'function') {
    fn = _xwrap(fn);
  }
  if (_isArrayLike(list)) {
    return _arrayReduce(fn, acc, list);
  }
  if (typeof list['fantasy-land/reduce'] === 'function') {
    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
  }
  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }
  if (typeof list.next === 'function') {
    return _iterableReduce(fn, acc, list);
  }
  if (typeof list.reduce === 'function') {
    return _methodReduce(fn, acc, list, 'reduce');
  }

  throw new TypeError('reduce: list must be array or iterable');
}
module.exports = _reduce;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_reduced.js":
/*!*****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_reduced.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}
module.exports = _reduced;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_xfBase.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_xfBase.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  init: function () {
    return this.xf['@@transducer/init']();
  },
  result: function (result) {
    return this.xf['@@transducer/result'](result);
  }
};

/***/ }),

/***/ "./node_modules/ramda/src/internal/_xfilter.js":
/*!*****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_xfilter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ "./node_modules/ramda/src/internal/_xfBase.js");

var XFilter = /*#__PURE__*/function () {

  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFilter.prototype['@@transducer/init'] = _xfBase.init;
  XFilter.prototype['@@transducer/result'] = _xfBase.result;
  XFilter.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return XFilter;
}();

var _xfilter = /*#__PURE__*/_curry2(function _xfilter(f, xf) {
  return new XFilter(f, xf);
});
module.exports = _xfilter;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_xfind.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_xfind.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _reduced = /*#__PURE__*/__webpack_require__(/*! ./_reduced */ "./node_modules/ramda/src/internal/_reduced.js");

var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ "./node_modules/ramda/src/internal/_xfBase.js");

var XFind = /*#__PURE__*/function () {

  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }
  XFind.prototype['@@transducer/init'] = _xfBase.init;
  XFind.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFind.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, input));
    }
    return result;
  };

  return XFind;
}();

var _xfind = /*#__PURE__*/_curry2(function _xfind(f, xf) {
  return new XFind(f, xf);
});
module.exports = _xfind;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_xmap.js":
/*!**************************************************!*\
  !*** ./node_modules/ramda/src/internal/_xmap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _xfBase = /*#__PURE__*/__webpack_require__(/*! ./_xfBase */ "./node_modules/ramda/src/internal/_xfBase.js");

var XMap = /*#__PURE__*/function () {

  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase.init;
  XMap.prototype['@@transducer/result'] = _xfBase.result;
  XMap.prototype['@@transducer/step'] = function (result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return XMap;
}();

var _xmap = /*#__PURE__*/_curry2(function _xmap(f, xf) {
  return new XMap(f, xf);
});
module.exports = _xmap;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_xwrap.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_xwrap.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var XWrap = /*#__PURE__*/function () {
  function XWrap(fn) {
    this.f = fn;
  }
  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };
  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };
  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return XWrap;
}();

function _xwrap(fn) {
  return new XWrap(fn);
}
module.exports = _xwrap;

/***/ }),

/***/ "./node_modules/ramda/src/keys.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/keys.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ "./node_modules/ramda/src/internal/_has.js");

var _isArguments = /*#__PURE__*/__webpack_require__(/*! ./internal/_isArguments */ "./node_modules/ramda/src/internal/_isArguments.js");

// cover IE < 9 keys issues


var hasEnumBug = ! /*#__PURE__*/{ toString: null }.propertyIsEnumerable('toString');
var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
// Safari bug
var hasArgsEnumBug = /*#__PURE__*/function () {
  'use strict';

  return arguments.propertyIsEnumerable('length');
}();

var contains = function contains(list, item) {
  var idx = 0;
  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};

/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @see R.keysIn, R.values
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? /*#__PURE__*/_curry1(function keys(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) : /*#__PURE__*/_curry1(function keys(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop, nIdx;
  var ks = [];
  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
  for (prop in obj) {
    if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
      ks[ks.length] = prop;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];
      if (_has(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }
      nIdx -= 1;
    }
  }
  return ks;
});
module.exports = keys;

/***/ }),

/***/ "./node_modules/ramda/src/map.js":
/*!***************************************!*\
  !*** ./node_modules/ramda/src/map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _dispatchable = /*#__PURE__*/__webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/ramda/src/internal/_dispatchable.js");

var _map = /*#__PURE__*/__webpack_require__(/*! ./internal/_map */ "./node_modules/ramda/src/internal/_map.js");

var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ "./node_modules/ramda/src/internal/_reduce.js");

var _xmap = /*#__PURE__*/__webpack_require__(/*! ./internal/_xmap */ "./node_modules/ramda/src/internal/_xmap.js");

var curryN = /*#__PURE__*/__webpack_require__(/*! ./curryN */ "./node_modules/ramda/src/curryN.js");

var keys = /*#__PURE__*/__webpack_require__(/*! ./keys */ "./node_modules/ramda/src/keys.js");

/**
 * Takes a function and
 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
 * applies the function to each of the functor's values, and returns
 * a functor of the same shape.
 *
 * Ramda provides suitable `map` implementations for `Array` and `Object`,
 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
 *
 * Dispatches to the `map` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * Also treats functions as functors and will compose them together.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => (a -> b) -> f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @see R.transduce, R.addIndex
 * @example
 *
 *      const double = x => x * 2;
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 *
 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
 * @symb R.map(f, [a, b]) = [f(a), f(b)]
 * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
 * @symb R.map(f, functor_o) = functor_o.map(f)
 */


var map = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case '[object Function]':
      return curryN(functor.length, function () {
        return fn.call(this, functor.apply(this, arguments));
      });
    case '[object Object]':
      return _reduce(function (acc, key) {
        acc[key] = fn(functor[key]);
        return acc;
      }, {}, keys(functor));
    default:
      return _map(fn, functor);
  }
}));
module.exports = map;

/***/ }),

/***/ "./node_modules/ramda/src/reduce.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/reduce.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry3 */ "./node_modules/ramda/src/internal/_curry3.js");

var _reduce = /*#__PURE__*/__webpack_require__(/*! ./internal/_reduce */ "./node_modules/ramda/src/internal/_reduce.js");

/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to shortcut the iteration.
 *
 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
 * is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present. When
 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
 * shortcuting, as this is not implemented by `reduce`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *      //          -               -10
 *      //         / \              / \
 *      //        -   4           -6   4
 *      //       / \              / \
 *      //      -   3   ==>     -3   3
 *      //     / \              / \
 *      //    -   2           -1   2
 *      //   / \              / \
 *      //  0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */


var reduce = /*#__PURE__*/_curry3(_reduce);
module.exports = reduce;

/***/ }),

/***/ "./node_modules/ramda/src/reject.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/reject.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _complement = /*#__PURE__*/__webpack_require__(/*! ./internal/_complement */ "./node_modules/ramda/src/internal/_complement.js");

var _curry2 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var filter = /*#__PURE__*/__webpack_require__(/*! ./filter */ "./node_modules/ramda/src/filter.js");

/**
 * The complement of [`filter`](#filter).
 *
 * Acts as a transducer if a transformer is given in list position. Filterable
 * objects include plain objects or any object that has a filter method such
 * as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      const isOdd = (n) => n % 2 === 1;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */


var reject = /*#__PURE__*/_curry2(function reject(pred, filterable) {
  return filter(_complement(pred), filterable);
});
module.exports = reject;

/***/ }),

/***/ "./node_modules/ramda/src/toPairs.js":
/*!*******************************************!*\
  !*** ./node_modules/ramda/src/toPairs.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 = /*#__PURE__*/__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _has = /*#__PURE__*/__webpack_require__(/*! ./internal/_has */ "./node_modules/ramda/src/internal/_has.js");

/**
 * Converts an object into an array of key, value arrays. Only the object's
 * own properties are used.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.4.0
 * @category Object
 * @sig {String: *} -> [[String,*]]
 * @param {Object} obj The object to extract from
 * @return {Array} An array of key, value arrays from the object's own properties.
 * @see R.fromPairs
 * @example
 *
 *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
 */


var toPairs = /*#__PURE__*/_curry1(function toPairs(obj) {
  var pairs = [];
  for (var prop in obj) {
    if (_has(prop, obj)) {
      pairs[pairs.length] = [prop, obj[prop]];
    }
  }
  return pairs;
});
module.exports = toPairs;

/***/ }),

/***/ "./node_modules/react-input-autosize/lib/AutosizeInput.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-input-autosize/lib/AutosizeInput.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var sizerStyle = {
	position: 'absolute',
	top: 0,
	left: 0,
	visibility: 'hidden',
	height: 0,
	overflow: 'scroll',
	whiteSpace: 'pre'
};

var INPUT_PROPS_BLACKLIST = ['extraWidth', 'injectStyles', 'inputClassName', 'inputRef', 'inputStyle', 'minWidth', 'onAutosize', 'placeholderIsMinWidth'];

var cleanInputProps = function cleanInputProps(inputProps) {
	INPUT_PROPS_BLACKLIST.forEach(function (field) {
		return delete inputProps[field];
	});
	return inputProps;
};

var copyStyles = function copyStyles(styles, node) {
	node.style.fontSize = styles.fontSize;
	node.style.fontFamily = styles.fontFamily;
	node.style.fontWeight = styles.fontWeight;
	node.style.fontStyle = styles.fontStyle;
	node.style.letterSpacing = styles.letterSpacing;
	node.style.textTransform = styles.textTransform;
};

var isIE = typeof window !== 'undefined' && window.navigator ? /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent) : false;

var generateId = function generateId() {
	// we only need an auto-generated ID for stylesheet injection, which is only
	// used for IE. so if the browser is not IE, this should return undefined.
	return isIE ? '_' + Math.random().toString(36).substr(2, 12) : undefined;
};

var AutosizeInput = function (_Component) {
	_inherits(AutosizeInput, _Component);

	function AutosizeInput(props) {
		_classCallCheck(this, AutosizeInput);

		var _this = _possibleConstructorReturn(this, (AutosizeInput.__proto__ || Object.getPrototypeOf(AutosizeInput)).call(this, props));

		_this.inputRef = function (el) {
			_this.input = el;
			if (typeof _this.props.inputRef === 'function') {
				_this.props.inputRef(el);
			}
		};

		_this.placeHolderSizerRef = function (el) {
			_this.placeHolderSizer = el;
		};

		_this.sizerRef = function (el) {
			_this.sizer = el;
		};

		_this.state = {
			inputWidth: props.minWidth,
			inputId: props.id || generateId()
		};
		return _this;
	}

	_createClass(AutosizeInput, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.mounted = true;
			this.copyInputStyles();
			this.updateInputWidth();
		}
	}, {
		key: 'UNSAFE_componentWillReceiveProps',
		value: function UNSAFE_componentWillReceiveProps(nextProps) {
			var id = nextProps.id;

			if (id !== this.props.id) {
				this.setState({ inputId: id || generateId() });
			}
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			if (prevState.inputWidth !== this.state.inputWidth) {
				if (typeof this.props.onAutosize === 'function') {
					this.props.onAutosize(this.state.inputWidth);
				}
			}
			this.updateInputWidth();
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.mounted = false;
		}
	}, {
		key: 'copyInputStyles',
		value: function copyInputStyles() {
			if (!this.mounted || !window.getComputedStyle) {
				return;
			}
			var inputStyles = this.input && window.getComputedStyle(this.input);
			if (!inputStyles) {
				return;
			}
			copyStyles(inputStyles, this.sizer);
			if (this.placeHolderSizer) {
				copyStyles(inputStyles, this.placeHolderSizer);
			}
		}
	}, {
		key: 'updateInputWidth',
		value: function updateInputWidth() {
			if (!this.mounted || !this.sizer || typeof this.sizer.scrollWidth === 'undefined') {
				return;
			}
			var newInputWidth = void 0;
			if (this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth)) {
				newInputWidth = Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2;
			} else {
				newInputWidth = this.sizer.scrollWidth + 2;
			}
			// add extraWidth to the detected width. for number types, this defaults to 16 to allow for the stepper UI
			var extraWidth = this.props.type === 'number' && this.props.extraWidth === undefined ? 16 : parseInt(this.props.extraWidth) || 0;
			newInputWidth += extraWidth;
			if (newInputWidth < this.props.minWidth) {
				newInputWidth = this.props.minWidth;
			}
			if (newInputWidth !== this.state.inputWidth) {
				this.setState({
					inputWidth: newInputWidth
				});
			}
		}
	}, {
		key: 'getInput',
		value: function getInput() {
			return this.input;
		}
	}, {
		key: 'focus',
		value: function focus() {
			this.input.focus();
		}
	}, {
		key: 'blur',
		value: function blur() {
			this.input.blur();
		}
	}, {
		key: 'select',
		value: function select() {
			this.input.select();
		}
	}, {
		key: 'renderStyles',
		value: function renderStyles() {
			// this method injects styles to hide IE's clear indicator, which messes
			// with input size detection. the stylesheet is only injected when the
			// browser is IE, and can also be disabled by the `injectStyles` prop.
			var injectStyles = this.props.injectStyles;

			return isIE && injectStyles ? _react2.default.createElement('style', { dangerouslySetInnerHTML: {
					__html: 'input#' + this.state.inputId + '::-ms-clear {display: none;}'
				} }) : null;
		}
	}, {
		key: 'render',
		value: function render() {
			var sizerValue = [this.props.defaultValue, this.props.value, ''].reduce(function (previousValue, currentValue) {
				if (previousValue !== null && previousValue !== undefined) {
					return previousValue;
				}
				return currentValue;
			});

			var wrapperStyle = _extends({}, this.props.style);
			if (!wrapperStyle.display) wrapperStyle.display = 'inline-block';

			var inputStyle = _extends({
				boxSizing: 'content-box',
				width: this.state.inputWidth + 'px'
			}, this.props.inputStyle);

			var inputProps = _objectWithoutProperties(this.props, []);

			cleanInputProps(inputProps);
			inputProps.className = this.props.inputClassName;
			inputProps.id = this.state.inputId;
			inputProps.style = inputStyle;

			return _react2.default.createElement(
				'div',
				{ className: this.props.className, style: wrapperStyle },
				this.renderStyles(),
				_react2.default.createElement('input', _extends({}, inputProps, { ref: this.inputRef })),
				_react2.default.createElement(
					'div',
					{ ref: this.sizerRef, style: sizerStyle },
					sizerValue
				),
				this.props.placeholder ? _react2.default.createElement(
					'div',
					{ ref: this.placeHolderSizerRef, style: sizerStyle },
					this.props.placeholder
				) : null
			);
		}
	}]);

	return AutosizeInput;
}(_react.Component);

AutosizeInput.propTypes = {
	className: _propTypes2.default.string, // className for the outer element
	defaultValue: _propTypes2.default.any, // default field value
	extraWidth: _propTypes2.default.oneOfType([// additional width for input element
	_propTypes2.default.number, _propTypes2.default.string]),
	id: _propTypes2.default.string, // id to use for the input, can be set for consistent snapshots
	injectStyles: _propTypes2.default.bool, // inject the custom stylesheet to hide clear UI, defaults to true
	inputClassName: _propTypes2.default.string, // className for the input element
	inputRef: _propTypes2.default.func, // ref callback for the input element
	inputStyle: _propTypes2.default.object, // css styles for the input element
	minWidth: _propTypes2.default.oneOfType([// minimum width for input element
	_propTypes2.default.number, _propTypes2.default.string]),
	onAutosize: _propTypes2.default.func, // onAutosize handler: function(newWidth) {}
	onChange: _propTypes2.default.func, // onChange handler: function(event) {}
	placeholder: _propTypes2.default.string, // placeholder text
	placeholderIsMinWidth: _propTypes2.default.bool, // don't collapse size to less than the placeholder
	style: _propTypes2.default.object, // css styles for the outer element
	value: _propTypes2.default.any // field value
};
AutosizeInput.defaultProps = {
	minWidth: 1,
	injectStyles: true
};

exports.default = AutosizeInput;

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-select/dist/Select-9fdb8cd0.browser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-select/dist/Select-9fdb8cd0.browser.esm.js ***!
  \***********************************************************************/
/*! exports provided: S, a, c, d, m */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return Select; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defaultTheme; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return createFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return defaultProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return mergeStyles; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
/* harmony import */ var _emotion_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/core */ "./node_modules/@emotion/core/dist/core.browser.esm.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils-06b0d5a4.browser.esm.js */ "./node_modules/react-select/dist/utils-06b0d5a4.browser.esm.js");
/* harmony import */ var _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-4322c0ed.browser.esm.js */ "./node_modules/react-select/dist/index-4322c0ed.browser.esm.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @emotion/css */ "./node_modules/@emotion/css/dist/css.browser.esm.js");








var diacritics = [{
  base: 'A',
  letters: /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
}, {
  base: 'AA',
  letters: /[\uA732]/g
}, {
  base: 'AE',
  letters: /[\u00C6\u01FC\u01E2]/g
}, {
  base: 'AO',
  letters: /[\uA734]/g
}, {
  base: 'AU',
  letters: /[\uA736]/g
}, {
  base: 'AV',
  letters: /[\uA738\uA73A]/g
}, {
  base: 'AY',
  letters: /[\uA73C]/g
}, {
  base: 'B',
  letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
}, {
  base: 'C',
  letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
}, {
  base: 'D',
  letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
}, {
  base: 'DZ',
  letters: /[\u01F1\u01C4]/g
}, {
  base: 'Dz',
  letters: /[\u01F2\u01C5]/g
}, {
  base: 'E',
  letters: /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
}, {
  base: 'F',
  letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g
}, {
  base: 'G',
  letters: /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
}, {
  base: 'H',
  letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
}, {
  base: 'I',
  letters: /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
}, {
  base: 'J',
  letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g
}, {
  base: 'K',
  letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
}, {
  base: 'L',
  letters: /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
}, {
  base: 'LJ',
  letters: /[\u01C7]/g
}, {
  base: 'Lj',
  letters: /[\u01C8]/g
}, {
  base: 'M',
  letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
}, {
  base: 'N',
  letters: /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
}, {
  base: 'NJ',
  letters: /[\u01CA]/g
}, {
  base: 'Nj',
  letters: /[\u01CB]/g
}, {
  base: 'O',
  letters: /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
}, {
  base: 'OI',
  letters: /[\u01A2]/g
}, {
  base: 'OO',
  letters: /[\uA74E]/g
}, {
  base: 'OU',
  letters: /[\u0222]/g
}, {
  base: 'P',
  letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
}, {
  base: 'Q',
  letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g
}, {
  base: 'R',
  letters: /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
}, {
  base: 'S',
  letters: /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
}, {
  base: 'T',
  letters: /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
}, {
  base: 'TZ',
  letters: /[\uA728]/g
}, {
  base: 'U',
  letters: /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
}, {
  base: 'V',
  letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
}, {
  base: 'VY',
  letters: /[\uA760]/g
}, {
  base: 'W',
  letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
}, {
  base: 'X',
  letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g
}, {
  base: 'Y',
  letters: /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
}, {
  base: 'Z',
  letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
}, {
  base: 'a',
  letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
}, {
  base: 'aa',
  letters: /[\uA733]/g
}, {
  base: 'ae',
  letters: /[\u00E6\u01FD\u01E3]/g
}, {
  base: 'ao',
  letters: /[\uA735]/g
}, {
  base: 'au',
  letters: /[\uA737]/g
}, {
  base: 'av',
  letters: /[\uA739\uA73B]/g
}, {
  base: 'ay',
  letters: /[\uA73D]/g
}, {
  base: 'b',
  letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
}, {
  base: 'c',
  letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
}, {
  base: 'd',
  letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
}, {
  base: 'dz',
  letters: /[\u01F3\u01C6]/g
}, {
  base: 'e',
  letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
}, {
  base: 'f',
  letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
}, {
  base: 'g',
  letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
}, {
  base: 'h',
  letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
}, {
  base: 'hv',
  letters: /[\u0195]/g
}, {
  base: 'i',
  letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
}, {
  base: 'j',
  letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
}, {
  base: 'k',
  letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
}, {
  base: 'l',
  letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
}, {
  base: 'lj',
  letters: /[\u01C9]/g
}, {
  base: 'm',
  letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
}, {
  base: 'n',
  letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
}, {
  base: 'nj',
  letters: /[\u01CC]/g
}, {
  base: 'o',
  letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
}, {
  base: 'oi',
  letters: /[\u01A3]/g
}, {
  base: 'ou',
  letters: /[\u0223]/g
}, {
  base: 'oo',
  letters: /[\uA74F]/g
}, {
  base: 'p',
  letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
}, {
  base: 'q',
  letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
}, {
  base: 'r',
  letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
}, {
  base: 's',
  letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
}, {
  base: 't',
  letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
}, {
  base: 'tz',
  letters: /[\uA729]/g
}, {
  base: 'u',
  letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
}, {
  base: 'v',
  letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
}, {
  base: 'vy',
  letters: /[\uA761]/g
}, {
  base: 'w',
  letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
}, {
  base: 'x',
  letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
}, {
  base: 'y',
  letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
}, {
  base: 'z',
  letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
}];
var stripDiacritics = function stripDiacritics(str) {
  for (var i = 0; i < diacritics.length; i++) {
    str = str.replace(diacritics[i].letters, diacritics[i].base);
  }

  return str;
};

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var trimString = function trimString(str) {
  return str.replace(/^\s+|\s+$/g, '');
};

var defaultStringify = function defaultStringify(option) {
  return option.label + " " + option.value;
};

var createFilter = function createFilter(config) {
  return function (option, rawInput) {
    var _ignoreCase$ignoreAcc = _extends({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: 'any'
    }, config),
        ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
        ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
        stringify = _ignoreCase$ignoreAcc.stringify,
        trim = _ignoreCase$ignoreAcc.trim,
        matchFrom = _ignoreCase$ignoreAcc.matchFrom;

    var input = trim ? trimString(rawInput) : rawInput;
    var candidate = trim ? trimString(stringify(option)) : stringify(option);

    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }

    if (ignoreAccents) {
      input = stripDiacritics(input);
      candidate = stripDiacritics(candidate);
    }

    return matchFrom === 'start' ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

var _ref =  false ? undefined : {
  name: "1laao21-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVFNIiwiZmlsZSI6IkExMXlUZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgdHlwZSBFbGVtZW50Q29uZmlnIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vY29yZSc7XG5cbi8vIEFzc2lzdGl2ZSB0ZXh0IHRvIGRlc2NyaWJlIHZpc3VhbCBlbGVtZW50cy4gSGlkZGVuIGZvciBzaWdodGVkIHVzZXJzLlxuY29uc3QgQTExeVRleHQgPSAocHJvcHM6IEVsZW1lbnRDb25maWc8J3NwYW4nPikgPT4gKFxuICAgIDxzcGFuXG4gICAgICBjc3M9e3tcbiAgICAgICAgbGFiZWw6ICdhMTF5VGV4dCcsXG4gICAgICAgIHpJbmRleDogOTk5OSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBjbGlwOiAncmVjdCgxcHgsIDFweCwgMXB4LCAxcHgpJyxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICB9fVxuICAgICAgey4uLnByb3BzfVxuICAgIC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBBMTF5VGV4dDtcbiJdfQ== */"
};

var A11yText = function A11yText(props) {
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_2__["jsx"])("span", _extends$1({
    css: _ref
  }, props));
};

function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function DummyInput(_ref) {
  var inProp = _ref.in,
      out = _ref.out,
      onExited = _ref.onExited,
      appear = _ref.appear,
      enter = _ref.enter,
      exit = _ref.exit,
      innerRef = _ref.innerRef,
      emotion = _ref.emotion,
      props = _objectWithoutPropertiesLoose(_ref, ["in", "out", "onExited", "appear", "enter", "exit", "innerRef", "emotion"]);

  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_2__["jsx"])("input", _extends$2({
    ref: innerRef
  }, props, {
    css:
    /*#__PURE__*/
    Object(_emotion_css__WEBPACK_IMPORTED_MODULE_6__["default"])({
      label: 'dummyInput',
      // get rid of any default styles
      background: 0,
      border: 0,
      fontSize: 'inherit',
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: 'transparent',
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: 'relative',
      transform: 'scale(0)'
    },  false ? undefined : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbUJNIiwiZmlsZSI6IkR1bW15SW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9jb3JlJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHVtbXlJbnB1dCh7XG4gIGluOiBpblByb3AsXG4gIG91dCxcbiAgb25FeGl0ZWQsXG4gIGFwcGVhcixcbiAgZW50ZXIsXG4gIGV4aXQsXG4gIGlubmVyUmVmLFxuICBlbW90aW9uLFxuICAuLi5wcm9wc1xufTogYW55KSB7XG4gIHJldHVybiAoXG4gICAgPGlucHV0XG4gICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgey4uLnByb3BzfVxuICAgICAgY3NzPXt7XG4gICAgICAgIGxhYmVsOiAnZHVtbXlJbnB1dCcsXG4gICAgICAgIC8vIGdldCByaWQgb2YgYW55IGRlZmF1bHQgc3R5bGVzXG4gICAgICAgIGJhY2tncm91bmQ6IDAsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgZm9udFNpemU6ICdpbmhlcml0JyxcbiAgICAgICAgb3V0bGluZTogMCxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgLy8gaW1wb3J0YW50ISB3aXRob3V0IGB3aWR0aGAgYnJvd3NlcnMgd29uJ3QgYWxsb3cgZm9jdXNcbiAgICAgICAgd2lkdGg6IDEsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBkZXNrdG9wXG4gICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gICAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gbW9iaWxlIHdoaWxzdCBtYWludGFpbmluZyBcInNjcm9sbCBpbnRvIHZpZXdcIiBiZWhhdmlvdXJcbiAgICAgICAgbGVmdDogLTEwMCxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDApJyxcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn1cbiJdfQ== */")
  }));
}

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var NodeResolver =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(NodeResolver, _Component);

  function NodeResolver() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = NodeResolver.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.innerRef(Object(react_dom__WEBPACK_IMPORTED_MODULE_3__["findDOMNode"])(this));
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.innerRef(null);
  };

  _proto.render = function render() {
    return this.props.children;
  };

  return NodeResolver;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

var STYLE_KEYS = ['boxSizing', 'height', 'overflow', 'paddingRight', 'position'];
var LOCK_STYLES = {
  boxSizing: 'border-box',
  // account for possible declaration `width: 100%;` on body
  overflow: 'hidden',
  position: 'relative',
  height: '100%'
};

function preventTouchMove(e) {
  e.preventDefault();
}
function allowTouchMove(e) {
  e.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;

  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
} // `ontouchstart` check works on most browsers
// `maxTouchPoints` works on IE10/11 and Surface

function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints;
}

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
var canUseDOM = !!( window.document && window.document.createElement);
var activeScrollLocks = 0;

var ScrollLock =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose$1(ScrollLock, _Component);

  function ScrollLock() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.originalStyles = {};
    _this.listenerOptions = {
      capture: false,
      passive: false
    };
    return _this;
  }

  var _proto = ScrollLock.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    if (!canUseDOM) return;
    var _this$props = this.props,
        accountForScrollbars = _this$props.accountForScrollbars,
        touchScrollTarget = _this$props.touchScrollTarget;
    var target = document.body;
    var targetStyle = target && target.style;

    if (accountForScrollbars) {
      // store any styles already applied to the body
      STYLE_KEYS.forEach(function (key) {
        var val = targetStyle && targetStyle[key];
        _this2.originalStyles[key] = val;
      });
    } // apply the lock styles and padding if this is the first scroll lock


    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(this.originalStyles.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function (key) {
        var val = LOCK_STYLES[key];

        if (targetStyle) {
          targetStyle[key] = val;
        }
      });

      if (targetStyle) {
        targetStyle.paddingRight = adjustedPadding + "px";
      }
    } // account for touch devices


    if (target && isTouchDevice()) {
      // Mobile Safari ignores { overflow: hidden } declaration on the body.
      target.addEventListener('touchmove', preventTouchMove, this.listenerOptions); // Allow scroll on provided target

      if (touchScrollTarget) {
        touchScrollTarget.addEventListener('touchstart', preventInertiaScroll, this.listenerOptions);
        touchScrollTarget.addEventListener('touchmove', allowTouchMove, this.listenerOptions);
      }
    } // increment active scroll locks


    activeScrollLocks += 1;
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this3 = this;

    if (!canUseDOM) return;
    var _this$props2 = this.props,
        accountForScrollbars = _this$props2.accountForScrollbars,
        touchScrollTarget = _this$props2.touchScrollTarget;
    var target = document.body;
    var targetStyle = target && target.style; // safely decrement active scroll locks

    activeScrollLocks = Math.max(activeScrollLocks - 1, 0); // reapply original body styles, if any

    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function (key) {
        var val = _this3.originalStyles[key];

        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    } // remove touch listeners


    if (target && isTouchDevice()) {
      target.removeEventListener('touchmove', preventTouchMove, this.listenerOptions);

      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener('touchstart', preventInertiaScroll, this.listenerOptions);
        touchScrollTarget.removeEventListener('touchmove', allowTouchMove, this.listenerOptions);
      }
    }
  };

  _proto.render = function render() {
    return null;
  };

  return ScrollLock;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

ScrollLock.defaultProps = {
  accountForScrollbars: true
};

function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _ref$1 =  false ? undefined : {
  name: "1dsbpcp",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbEJsb2NrLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZEVSIsImZpbGUiOiJTY3JvbGxCbG9jay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG4vKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IFB1cmVDb21wb25lbnQsIHR5cGUgRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL2NvcmUnO1xuaW1wb3J0IE5vZGVSZXNvbHZlciBmcm9tICcuL05vZGVSZXNvbHZlcic7XG5pbXBvcnQgU2Nyb2xsTG9jayBmcm9tICcuL1Njcm9sbExvY2svaW5kZXgnO1xuXG50eXBlIFByb3BzID0ge1xuICBjaGlsZHJlbjogRWxlbWVudDwqPixcbiAgaXNFbmFibGVkOiBib29sZWFuLFxufTtcbnR5cGUgU3RhdGUgPSB7XG4gIHRvdWNoU2Nyb2xsVGFyZ2V0OiBIVE1MRWxlbWVudCB8IG51bGwsXG59O1xuXG4vLyBOT1RFOlxuLy8gV2Ugc2hvdWxkbid0IG5lZWQgdGhpcyBhZnRlciB1cGRhdGluZyB0byBSZWFjdCB2MTYuMy4wLCB3aGljaCBpbnRyb2R1Y2VzOlxuLy8gLSBjcmVhdGVSZWYoKSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjcmVhdGVyZWZcbi8vIC0gZm9yd2FyZFJlZigpIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGZvcndhcmRyZWZcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsQmxvY2sgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0ZSA9IHsgdG91Y2hTY3JvbGxUYXJnZXQ6IG51bGwgfTtcblxuICAvLyBtdXN0IGJlIGluIHN0YXRlIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIsIG9ubHkgcnVucyBvbmNlIHBlciBpbnN0YW5jZVxuICBnZXRTY3JvbGxUYXJnZXQgPSAocmVmOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGlmIChyZWYgPT09IHRoaXMuc3RhdGUudG91Y2hTY3JvbGxUYXJnZXQpIHJldHVybjtcbiAgICB0aGlzLnNldFN0YXRlKHsgdG91Y2hTY3JvbGxUYXJnZXQ6IHJlZiB9KTtcbiAgfTtcblxuICAvLyB0aGlzIHdpbGwgY2xvc2UgdGhlIG1lbnUgd2hlbiBhIHVzZXIgY2xpY2tzIG91dHNpZGVcbiAgYmx1clNlbGVjdElucHV0ID0gKCkgPT4ge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGlzRW5hYmxlZCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHRvdWNoU2Nyb2xsVGFyZ2V0IH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gYmFpbCBlYXJseSBpZiBub3QgZW5hYmxlZFxuICAgIGlmICghaXNFbmFibGVkKSByZXR1cm4gY2hpbGRyZW47XG5cbiAgICAvKlxuICAgICAqIERpdlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIGJsb2NrcyBzY3JvbGxpbmcgb24gbm9uLWJvZHkgZWxlbWVudHMgYmVoaW5kIHRoZSBtZW51XG5cbiAgICAgKiBOb2RlUmVzb2x2ZXJcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiB3ZSBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgdG8gXCJ1bmxvY2tcIiBzY3JvbGwgb25cbiAgICAgKiBtb2JpbGUgZGV2aWNlc1xuXG4gICAgICogU2Nyb2xsTG9ja1xuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIGFjdHVhbGx5IGRvZXMgdGhlIHNjcm9sbCBsb2NraW5nXG4gICAgICovXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLmJsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgICA8Tm9kZVJlc29sdmVyIGlubmVyUmVmPXt0aGlzLmdldFNjcm9sbFRhcmdldH0+e2NoaWxkcmVufTwvTm9kZVJlc29sdmVyPlxuICAgICAgICB7dG91Y2hTY3JvbGxUYXJnZXQgPyAoXG4gICAgICAgICAgPFNjcm9sbExvY2sgdG91Y2hTY3JvbGxUYXJnZXQ9e3RvdWNoU2Nyb2xsVGFyZ2V0fSAvPlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiJdfQ== */"
};

// NOTE:
// We shouldn't need this after updating to React v16.3.0, which introduces:
// - createRef() https://reactjs.org/docs/react-api.html#reactcreateref
// - forwardRef() https://reactjs.org/docs/react-api.html#reactforwardref
var ScrollBlock =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose$2(ScrollBlock, _PureComponent);

  function ScrollBlock() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _PureComponent.call.apply(_PureComponent, [this].concat(args)) || this;
    _this.state = {
      touchScrollTarget: null
    };

    _this.getScrollTarget = function (ref) {
      if (ref === _this.state.touchScrollTarget) return;

      _this.setState({
        touchScrollTarget: ref
      });
    };

    _this.blurSelectInput = function () {
      if (document.activeElement) {
        document.activeElement.blur();
      }
    };

    return _this;
  }

  var _proto = ScrollBlock.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        isEnabled = _this$props.isEnabled;
    var touchScrollTarget = this.state.touchScrollTarget; // bail early if not enabled

    if (!isEnabled) return children;
    /*
     * Div
     * ------------------------------
     * blocks scrolling on non-body elements behind the menu
      * NodeResolver
     * ------------------------------
     * we need a reference to the scrollable element to "unlock" scroll on
     * mobile devices
      * ScrollLock
     * ------------------------------
     * actually does the scroll locking
     */

    return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_2__["jsx"])("div", null, Object(_emotion_core__WEBPACK_IMPORTED_MODULE_2__["jsx"])("div", {
      onClick: this.blurSelectInput,
      css: _ref$1
    }), Object(_emotion_core__WEBPACK_IMPORTED_MODULE_2__["jsx"])(NodeResolver, {
      innerRef: this.getScrollTarget
    }, children), touchScrollTarget ? Object(_emotion_core__WEBPACK_IMPORTED_MODULE_2__["jsx"])(ScrollLock, {
      touchScrollTarget: touchScrollTarget
    }) : null);
  };

  return ScrollBlock;
}(react__WEBPACK_IMPORTED_MODULE_0__["PureComponent"]);

function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var ScrollCaptor =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose$3(ScrollCaptor, _Component);

  function ScrollCaptor() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.isBottom = false;
    _this.isTop = false;
    _this.scrollTarget = void 0;
    _this.touchStart = void 0;

    _this.cancelScroll = function (event) {
      event.preventDefault();
      event.stopPropagation();
    };

    _this.handleEventDelta = function (event, delta) {
      var _this$props = _this.props,
          onBottomArrive = _this$props.onBottomArrive,
          onBottomLeave = _this$props.onBottomLeave,
          onTopArrive = _this$props.onTopArrive,
          onTopLeave = _this$props.onTopLeave;
      var _this$scrollTarget = _this.scrollTarget,
          scrollTop = _this$scrollTarget.scrollTop,
          scrollHeight = _this$scrollTarget.scrollHeight,
          clientHeight = _this$scrollTarget.clientHeight;
      var target = _this.scrollTarget;
      var isDeltaPositive = delta > 0;
      var availableScroll = scrollHeight - clientHeight - scrollTop;
      var shouldCancelScroll = false; // reset bottom/top flags

      if (availableScroll > delta && _this.isBottom) {
        if (onBottomLeave) onBottomLeave(event);
        _this.isBottom = false;
      }

      if (isDeltaPositive && _this.isTop) {
        if (onTopLeave) onTopLeave(event);
        _this.isTop = false;
      } // bottom limit


      if (isDeltaPositive && delta > availableScroll) {
        if (onBottomArrive && !_this.isBottom) {
          onBottomArrive(event);
        }

        target.scrollTop = scrollHeight;
        shouldCancelScroll = true;
        _this.isBottom = true; // top limit
      } else if (!isDeltaPositive && -delta > scrollTop) {
        if (onTopArrive && !_this.isTop) {
          onTopArrive(event);
        }

        target.scrollTop = 0;
        shouldCancelScroll = true;
        _this.isTop = true;
      } // cancel scroll


      if (shouldCancelScroll) {
        _this.cancelScroll(event);
      }
    };

    _this.onWheel = function (event) {
      _this.handleEventDelta(event, event.deltaY);
    };

    _this.onTouchStart = function (event) {
      // set touch start so we can calculate touchmove delta
      _this.touchStart = event.changedTouches[0].clientY;
    };

    _this.onTouchMove = function (event) {
      var deltaY = _this.touchStart - event.changedTouches[0].clientY;

      _this.handleEventDelta(event, deltaY);
    };

    _this.getScrollTarget = function (ref) {
      _this.scrollTarget = ref;
    };

    return _this;
  }

  var _proto = ScrollCaptor.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.startListening(this.scrollTarget);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.stopListening(this.scrollTarget);
  };

  _proto.startListening = function startListening(el) {
    // bail early if no element is available to attach to
    if (!el) return; // all the if statements are to appease Flow 😢

    if (typeof el.addEventListener === 'function') {
      el.addEventListener('wheel', this.onWheel, false);
    }

    if (typeof el.addEventListener === 'function') {
      el.addEventListener('touchstart', this.onTouchStart, false);
    }

    if (typeof el.addEventListener === 'function') {
      el.addEventListener('touchmove', this.onTouchMove, false);
    }
  };

  _proto.stopListening = function stopListening(el) {
    // all the if statements are to appease Flow 😢
    if (typeof el.removeEventListener === 'function') {
      el.removeEventListener('wheel', this.onWheel, false);
    }

    if (typeof el.removeEventListener === 'function') {
      el.removeEventListener('touchstart', this.onTouchStart, false);
    }

    if (typeof el.removeEventListener === 'function') {
      el.removeEventListener('touchmove', this.onTouchMove, false);
    }
  };

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(NodeResolver, {
      innerRef: this.getScrollTarget
    }, this.props.children);
  };

  return ScrollCaptor;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

function ScrollCaptorSwitch(_ref) {
  var _ref$isEnabled = _ref.isEnabled,
      isEnabled = _ref$isEnabled === void 0 ? true : _ref$isEnabled,
      props = _objectWithoutPropertiesLoose$1(_ref, ["isEnabled"]);

  return isEnabled ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ScrollCaptor, props) : props.children;
}

var instructionsAriaMessage = function instructionsAriaMessage(event, context) {
  if (context === void 0) {
    context = {};
  }

  var _context = context,
      isSearchable = _context.isSearchable,
      isMulti = _context.isMulti,
      label = _context.label,
      isDisabled = _context.isDisabled;

  switch (event) {
    case 'menu':
      return "Use Up and Down to choose options" + (isDisabled ? '' : ', press Enter to select the currently focused option') + ", press Escape to exit the menu, press Tab to select the option and exit the menu.";

    case 'input':
      return (label ? label : 'Select') + " is focused " + (isSearchable ? ',type to refine list' : '') + ", press Down to open the menu, " + (isMulti ? ' press left to focus selected values' : '');

    case 'value':
      return 'Use left and right to toggle between focused values, press Backspace to remove the currently focused value';
  }
};
var valueEventAriaMessage = function valueEventAriaMessage(event, context) {
  var value = context.value,
      isDisabled = context.isDisabled;
  if (!value) return;

  switch (event) {
    case 'deselect-option':
    case 'pop-value':
    case 'remove-value':
      return "option " + value + ", deselected.";

    case 'select-option':
      return isDisabled ? "option " + value + " is disabled. Select another option." : "option " + value + ", selected.";
  }
};
var valueFocusAriaMessage = function valueFocusAriaMessage(_ref) {
  var focusedValue = _ref.focusedValue,
      getOptionLabel = _ref.getOptionLabel,
      selectValue = _ref.selectValue;
  return "value " + getOptionLabel(focusedValue) + " focused, " + (selectValue.indexOf(focusedValue) + 1) + " of " + selectValue.length + ".";
};
var optionFocusAriaMessage = function optionFocusAriaMessage(_ref2) {
  var focusedOption = _ref2.focusedOption,
      getOptionLabel = _ref2.getOptionLabel,
      options = _ref2.options;
  return "option " + getOptionLabel(focusedOption) + " focused" + (focusedOption.isDisabled ? ' disabled' : '') + ", " + (options.indexOf(focusedOption) + 1) + " of " + options.length + ".";
};
var resultsAriaMessage = function resultsAriaMessage(_ref3) {
  var inputValue = _ref3.inputValue,
      screenReaderMessage = _ref3.screenReaderMessage;
  return "" + screenReaderMessage + (inputValue ? ' for search term ' + inputValue : '') + ".";
};

var formatGroupLabel = function formatGroupLabel(group) {
  return group.label;
};
var getOptionLabel = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled(option) {
  return !!option.isDisabled;
};

function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
var defaultStyles = {
  clearIndicator: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["c"],
  container: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["a"],
  control: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["b"],
  dropdownIndicator: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["d"],
  group: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["g"],
  groupHeading: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["e"],
  indicatorsContainer: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["i"],
  indicatorSeparator: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["f"],
  input: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["h"],
  loadingIndicator: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["l"],
  loadingMessage: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["j"],
  menu: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["m"],
  menuList: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["k"],
  menuPortal: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["n"],
  multiValue: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["o"],
  multiValueLabel: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["p"],
  multiValueRemove: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["q"],
  noOptionsMessage: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["r"],
  option: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["s"],
  placeholder: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["t"],
  singleValue: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["u"],
  valueContainer: _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["v"]
}; // Merge Utility
// Allows consumers to extend a base Select with additional styles

function mergeStyles(source, target) {
  if (target === void 0) {
    target = {};
  }

  // initialize with source styles
  var styles = _extends$3({}, source); // massage in target styles


  Object.keys(target).forEach(function (key) {
    if (source[key]) {
      styles[key] = function (rsCss, props) {
        return target[key](source[key](rsCss, props), props);
      };
    } else {
      styles[key] = target[key];
    }
  });
  return styles;
}

var colors = {
  primary: '#2684FF',
  primary75: '#4C9AFF',
  primary50: '#B2D4FF',
  primary25: '#DEEBFF',
  danger: '#DE350B',
  dangerLight: '#FFBDAD',
  neutral0: 'hsl(0, 0%, 100%)',
  neutral5: 'hsl(0, 0%, 95%)',
  neutral10: 'hsl(0, 0%, 90%)',
  neutral20: 'hsl(0, 0%, 80%)',
  neutral30: 'hsl(0, 0%, 70%)',
  neutral40: 'hsl(0, 0%, 60%)',
  neutral50: 'hsl(0, 0%, 50%)',
  neutral60: 'hsl(0, 0%, 40%)',
  neutral70: 'hsl(0, 0%, 30%)',
  neutral80: 'hsl(0, 0%, 20%)',
  neutral90: 'hsl(0, 0%, 10%)'
};
var borderRadius = 4; // Used to calculate consistent margin/padding on elements

var baseUnit = 4; // The minimum height of the control

var controlHeight = 38; // The amount of space between the control and menu */

var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit: baseUnit,
  controlHeight: controlHeight,
  menuGutter: menuGutter
};
var defaultTheme = {
  borderRadius: borderRadius,
  colors: colors,
  spacing: spacing
};

function _objectWithoutPropertiesLoose$2(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }

function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
var defaultProps = {
  backspaceRemovesValue: true,
  blurInputOnSelect: Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["i"])(),
  captureMenuScroll: !Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["i"])(),
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel: formatGroupLabel,
  getOptionLabel: getOptionLabel,
  getOptionValue: getOptionValue,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled: isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return 'Loading...';
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: 'bottom',
  menuPosition: 'absolute',
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["d"])(),
  noOptionsMessage: function noOptionsMessage() {
    return 'No options';
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: 'Select...',
  screenReaderStatus: function screenReaderStatus(_ref) {
    var count = _ref.count;
    return count + " result" + (count !== 1 ? 's' : '') + " available";
  },
  styles: {},
  tabIndex: '0',
  tabSelectsValue: true
};
var instanceId = 1;

var Select =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose$4(Select, _Component);

  // Misc. Instance Properties
  // ------------------------------
  // TODO
  // Refs
  // ------------------------------
  // Lifecycle
  // ------------------------------
  function Select(_props) {
    var _this;

    _this = _Component.call(this, _props) || this;
    _this.state = {
      ariaLiveSelection: '',
      ariaLiveContext: '',
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      menuOptions: {
        render: [],
        focusable: []
      },
      selectValue: []
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.clearFocusValueOnUpdate = false;
    _this.commonProps = void 0;
    _this.components = void 0;
    _this.hasGroups = false;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.inputIsHiddenAfterUpdate = void 0;
    _this.instancePrefix = '';
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;

    _this.getControlRef = function (ref) {
      _this.controlRef = ref;
    };

    _this.focusedOptionRef = null;

    _this.getFocusedOptionRef = function (ref) {
      _this.focusedOptionRef = ref;
    };

    _this.menuListRef = null;

    _this.getMenuListRef = function (ref) {
      _this.menuListRef = ref;
    };

    _this.inputRef = null;

    _this.getInputRef = function (ref) {
      _this.inputRef = ref;
    };

    _this.cacheComponents = function (components) {
      _this.components = Object(_index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["w"])({
        components: components
      });
    };

    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;

    _this.onChange = function (newValue, actionMeta) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          name = _this$props.name;
      onChange(newValue, _extends$4({}, actionMeta, {
        name: name
      }));
    };

    _this.setValue = function (newValue, action, option) {
      if (action === void 0) {
        action = 'set-value';
      }

      var _this$props2 = _this.props,
          closeMenuOnSelect = _this$props2.closeMenuOnSelect,
          isMulti = _this$props2.isMulti;

      _this.onInputChange('', {
        action: 'set-value'
      });

      if (closeMenuOnSelect) {
        _this.inputIsHiddenAfterUpdate = !isMulti;

        _this.onMenuClose();
      } // when the select value should change, we should reset focusedValue


      _this.clearFocusValueOnUpdate = true;

      _this.onChange(newValue, {
        action: action,
        option: option
      });
    };

    _this.selectOption = function (newValue) {
      var _this$props3 = _this.props,
          blurInputOnSelect = _this$props3.blurInputOnSelect,
          isMulti = _this$props3.isMulti;
      var selectValue = _this.state.selectValue;

      if (isMulti) {
        if (_this.isOptionSelected(newValue, selectValue)) {
          var candidate = _this.getOptionValue(newValue);

          _this.setValue(selectValue.filter(function (i) {
            return _this.getOptionValue(i) !== candidate;
          }), 'deselect-option', newValue);

          _this.announceAriaLiveSelection({
            event: 'deselect-option',
            context: {
              value: _this.getOptionLabel(newValue)
            }
          });
        } else {
          if (!_this.isOptionDisabled(newValue, selectValue)) {
            _this.setValue([].concat(selectValue, [newValue]), 'select-option', newValue);

            _this.announceAriaLiveSelection({
              event: 'select-option',
              context: {
                value: _this.getOptionLabel(newValue)
              }
            });
          } else {
            // announce that option is disabled
            _this.announceAriaLiveSelection({
              event: 'select-option',
              context: {
                value: _this.getOptionLabel(newValue),
                isDisabled: true
              }
            });
          }
        }
      } else {
        if (!_this.isOptionDisabled(newValue, selectValue)) {
          _this.setValue(newValue, 'select-option');

          _this.announceAriaLiveSelection({
            event: 'select-option',
            context: {
              value: _this.getOptionLabel(newValue)
            }
          });
        } else {
          // announce that option is disabled
          _this.announceAriaLiveSelection({
            event: 'select-option',
            context: {
              value: _this.getOptionLabel(newValue),
              isDisabled: true
            }
          });
        }
      }

      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };

    _this.removeValue = function (removedValue) {
      var selectValue = _this.state.selectValue;

      var candidate = _this.getOptionValue(removedValue);

      var newValue = selectValue.filter(function (i) {
        return _this.getOptionValue(i) !== candidate;
      });

      _this.onChange(newValue.length ? newValue : null, {
        action: 'remove-value',
        removedValue: removedValue
      });

      _this.announceAriaLiveSelection({
        event: 'remove-value',
        context: {
          value: removedValue ? _this.getOptionLabel(removedValue) : ''
        }
      });

      _this.focusInput();
    };

    _this.clearValue = function () {
      var isMulti = _this.props.isMulti;

      _this.onChange(isMulti ? [] : null, {
        action: 'clear'
      });
    };

    _this.popValue = function () {
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValue = selectValue.slice(0, selectValue.length - 1);

      _this.announceAriaLiveSelection({
        event: 'pop-value',
        context: {
          value: lastSelectedValue ? _this.getOptionLabel(lastSelectedValue) : ''
        }
      });

      _this.onChange(newValue.length ? newValue : null, {
        action: 'pop-value',
        removedValue: lastSelectedValue
      });
    };

    _this.getOptionLabel = function (data) {
      return _this.props.getOptionLabel(data);
    };

    _this.getOptionValue = function (data) {
      return _this.props.getOptionValue(data);
    };

    _this.getStyles = function (key, props) {
      var base = defaultStyles[key](props);
      base.boxSizing = 'border-box';
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };

    _this.getElementId = function (element) {
      return _this.instancePrefix + "-" + element;
    };

    _this.getActiveDescendentId = function () {
      var menuIsOpen = _this.props.menuIsOpen;
      var _this$state = _this.state,
          menuOptions = _this$state.menuOptions,
          focusedOption = _this$state.focusedOption;
      if (!focusedOption || !menuIsOpen) return undefined;
      var index = menuOptions.focusable.indexOf(focusedOption);
      var option = menuOptions.render[index];
      return option && option.key;
    };

    _this.announceAriaLiveSelection = function (_ref2) {
      var event = _ref2.event,
          context = _ref2.context;

      _this.setState({
        ariaLiveSelection: valueEventAriaMessage(event, context)
      });
    };

    _this.announceAriaLiveContext = function (_ref3) {
      var event = _ref3.event,
          context = _ref3.context;

      _this.setState({
        ariaLiveContext: instructionsAriaMessage(event, _extends$4({}, context, {
          label: _this.props['aria-label']
        }))
      });
    };

    _this.onMenuMouseDown = function (event) {
      if (event.button !== 0) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      _this.focusInput();
    };

    _this.onMenuMouseMove = function (event) {
      _this.blockOptionHover = false;
    };

    _this.onControlMouseDown = function (event) {
      var openMenuOnClick = _this.props.openMenuOnClick;

      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }

        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu('first');
        }
      } else {
        if ( // $FlowFixMe
        event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
          _this.onMenuClose();
        }
      }

      if ( // $FlowFixMe
      event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
        event.preventDefault();
      }
    };

    _this.onDropdownIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      if (_this.props.isDisabled) return;
      var _this$props4 = _this.props,
          isMulti = _this$props4.isMulti,
          menuIsOpen = _this$props4.menuIsOpen;

      _this.focusInput();

      if (menuIsOpen) {
        _this.inputIsHiddenAfterUpdate = !isMulti;

        _this.onMenuClose();
      } else {
        _this.openMenu('first');
      }

      event.preventDefault();
      event.stopPropagation();
    };

    _this.onClearIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      _this.clearValue();

      event.stopPropagation();
      _this.openAfterFocus = false;

      if (event.type === 'touchend') {
        _this.focusInput();
      } else {
        setTimeout(function () {
          return _this.focusInput();
        });
      }
    };

    _this.onScroll = function (event) {
      if (typeof _this.props.closeMenuOnScroll === 'boolean') {
        if (event.target instanceof HTMLElement && Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["j"])(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === 'function') {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };

    _this.onCompositionStart = function () {
      _this.isComposing = true;
    };

    _this.onCompositionEnd = function () {
      _this.isComposing = false;
    };

    _this.onTouchStart = function (_ref4) {
      var touches = _ref4.touches;
      var touch = touches.item(0);

      if (!touch) {
        return;
      }

      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };

    _this.onTouchMove = function (_ref5) {
      var touches = _ref5.touches;
      var touch = touches.item(0);

      if (!touch) {
        return;
      }

      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };

    _this.onTouchEnd = function (event) {
      if (_this.userIsDragging) return; // close the menu if the user taps outside
      // we're checking on event.target here instead of event.currentTarget, because we want to assert information
      // on events on child elements, not the document (which we've attached this handler to).

      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      } // reset move vars


      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };

    _this.onControlTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onControlMouseDown(event);
    };

    _this.onClearIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onClearIndicatorMouseDown(event);
    };

    _this.onDropdownIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      _this.onDropdownIndicatorMouseDown(event);
    };

    _this.handleInputChange = function (event) {
      var inputValue = event.currentTarget.value;
      _this.inputIsHiddenAfterUpdate = false;

      _this.onInputChange(inputValue, {
        action: 'input-change'
      });

      _this.onMenuOpen();
    };

    _this.onInputFocus = function (event) {
      var _this$props5 = _this.props,
          isSearchable = _this$props5.isSearchable,
          isMulti = _this$props5.isMulti;

      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }

      _this.inputIsHiddenAfterUpdate = false;

      _this.announceAriaLiveContext({
        event: 'input',
        context: {
          isSearchable: isSearchable,
          isMulti: isMulti
        }
      });

      _this.setState({
        isFocused: true
      });

      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu('first');
      }

      _this.openAfterFocus = false;
    };

    _this.onInputBlur = function (event) {
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();

        return;
      }

      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }

      _this.onInputChange('', {
        action: 'input-blur'
      });

      _this.onMenuClose();

      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };

    _this.onOptionHover = function (focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }

      _this.setState({
        focusedOption: focusedOption
      });
    };

    _this.shouldHideSelectedOptions = function () {
      var _this$props6 = _this.props,
          hideSelectedOptions = _this$props6.hideSelectedOptions,
          isMulti = _this$props6.isMulti;
      if (hideSelectedOptions === undefined) return isMulti;
      return hideSelectedOptions;
    };

    _this.onKeyDown = function (event) {
      var _this$props7 = _this.props,
          isMulti = _this$props7.isMulti,
          backspaceRemovesValue = _this$props7.backspaceRemovesValue,
          escapeClearsValue = _this$props7.escapeClearsValue,
          inputValue = _this$props7.inputValue,
          isClearable = _this$props7.isClearable,
          isDisabled = _this$props7.isDisabled,
          menuIsOpen = _this$props7.menuIsOpen,
          onKeyDown = _this$props7.onKeyDown,
          tabSelectsValue = _this$props7.tabSelectsValue,
          openMenuOnFocus = _this$props7.openMenuOnFocus;
      var _this$state2 = _this.state,
          focusedOption = _this$state2.focusedOption,
          focusedValue = _this$state2.focusedValue,
          selectValue = _this$state2.selectValue;
      if (isDisabled) return;

      if (typeof onKeyDown === 'function') {
        onKeyDown(event);

        if (event.defaultPrevented) {
          return;
        }
      } // Block option hover events when the user has just pressed a key


      _this.blockOptionHover = true;

      switch (event.key) {
        case 'ArrowLeft':
          if (!isMulti || inputValue) return;

          _this.focusValue('previous');

          break;

        case 'ArrowRight':
          if (!isMulti || inputValue) return;

          _this.focusValue('next');

          break;

        case 'Delete':
        case 'Backspace':
          if (inputValue) return;

          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) return;

            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }

          break;

        case 'Tab':
          if (_this.isComposing) return;

          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }

          _this.selectOption(focusedOption);

          break;

        case 'Enter':
          if (event.keyCode === 229) {
            // ignore the keydown event from an Input Method Editor(IME)
            // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
            break;
          }

          if (menuIsOpen) {
            if (!focusedOption) return;
            if (_this.isComposing) return;

            _this.selectOption(focusedOption);

            break;
          }

          return;

        case 'Escape':
          if (menuIsOpen) {
            _this.inputIsHiddenAfterUpdate = false;

            _this.onInputChange('', {
              action: 'menu-close'
            });

            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }

          break;

        case ' ':
          // space
          if (inputValue) {
            return;
          }

          if (!menuIsOpen) {
            _this.openMenu('first');

            break;
          }

          if (!focusedOption) return;

          _this.selectOption(focusedOption);

          break;

        case 'ArrowUp':
          if (menuIsOpen) {
            _this.focusOption('up');
          } else {
            _this.openMenu('last');
          }

          break;

        case 'ArrowDown':
          if (menuIsOpen) {
            _this.focusOption('down');
          } else {
            _this.openMenu('first');
          }

          break;

        case 'PageUp':
          if (!menuIsOpen) return;

          _this.focusOption('pageup');

          break;

        case 'PageDown':
          if (!menuIsOpen) return;

          _this.focusOption('pagedown');

          break;

        case 'Home':
          if (!menuIsOpen) return;

          _this.focusOption('first');

          break;

        case 'End':
          if (!menuIsOpen) return;

          _this.focusOption('last');

          break;

        default:
          return;
      }

      event.preventDefault();
    };

    _this.buildMenuOptions = function (props, selectValue) {
      var _props$inputValue = props.inputValue,
          inputValue = _props$inputValue === void 0 ? '' : _props$inputValue,
          options = props.options;

      var toOption = function toOption(option, id) {
        var isDisabled = _this.isOptionDisabled(option, selectValue);

        var isSelected = _this.isOptionSelected(option, selectValue);

        var label = _this.getOptionLabel(option);

        var value = _this.getOptionValue(option);

        if (_this.shouldHideSelectedOptions() && isSelected || !_this.filterOption({
          label: label,
          value: value,
          data: option
        }, inputValue)) {
          return;
        }

        var onHover = isDisabled ? undefined : function () {
          return _this.onOptionHover(option);
        };
        var onSelect = isDisabled ? undefined : function () {
          return _this.selectOption(option);
        };
        var optionId = _this.getElementId('option') + "-" + id;
        return {
          innerProps: {
            id: optionId,
            onClick: onSelect,
            onMouseMove: onHover,
            onMouseOver: onHover,
            tabIndex: -1
          },
          data: option,
          isDisabled: isDisabled,
          isSelected: isSelected,
          key: optionId,
          label: label,
          type: 'option',
          value: value
        };
      };

      return options.reduce(function (acc, item, itemIndex) {
        if (item.options) {
          // TODO needs a tidier implementation
          if (!_this.hasGroups) _this.hasGroups = true;
          var items = item.options;
          var children = items.map(function (child, i) {
            var option = toOption(child, itemIndex + "-" + i);
            if (option) acc.focusable.push(child);
            return option;
          }).filter(Boolean);

          if (children.length) {
            var groupId = _this.getElementId('group') + "-" + itemIndex;
            acc.render.push({
              type: 'group',
              key: groupId,
              data: item,
              options: children
            });
          }
        } else {
          var option = toOption(item, "" + itemIndex);

          if (option) {
            acc.render.push(option);
            acc.focusable.push(item);
          }
        }

        return acc;
      }, {
        render: [],
        focusable: []
      });
    };

    var _value = _props.value;
    _this.cacheComponents = Object(memoize_one__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.cacheComponents, _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["x"]).bind(_assertThisInitialized(_assertThisInitialized(_this)));

    _this.cacheComponents(_props.components);

    _this.instancePrefix = 'react-select-' + (_this.props.instanceId || ++instanceId);

    var _selectValue = Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["e"])(_value);

    _this.buildMenuOptions = Object(memoize_one__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.buildMenuOptions, function (newArgs, lastArgs) {
      var _ref6 = newArgs,
          newProps = _ref6[0],
          newSelectValue = _ref6[1];
      var _ref7 = lastArgs,
          lastProps = _ref7[0],
          lastSelectValue = _ref7[1];
      return Object(_index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["x"])(newSelectValue, lastSelectValue) && Object(_index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["x"])(newProps.inputValue, lastProps.inputValue) && Object(_index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["x"])(newProps.options, lastProps.options);
    }).bind(_assertThisInitialized(_assertThisInitialized(_this)));

    var _menuOptions = _props.menuIsOpen ? _this.buildMenuOptions(_props, _selectValue) : {
      render: [],
      focusable: []
    };

    _this.state.menuOptions = _menuOptions;
    _this.state.selectValue = _selectValue;
    return _this;
  }

  var _proto = Select.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.startListeningComposition();
    this.startListeningToTouch();

    if (this.props.closeMenuOnScroll && document && document.addEventListener) {
      // Listen to all scroll events, and filter them out inside of 'onScroll'
      document.addEventListener('scroll', this.onScroll, true);
    }

    if (this.props.autoFocus) {
      this.focusInput();
    }
  };

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    var _this$props8 = this.props,
        options = _this$props8.options,
        value = _this$props8.value,
        menuIsOpen = _this$props8.menuIsOpen,
        inputValue = _this$props8.inputValue; // re-cache custom components

    this.cacheComponents(nextProps.components); // rebuild the menu options

    if (nextProps.value !== value || nextProps.options !== options || nextProps.menuIsOpen !== menuIsOpen || nextProps.inputValue !== inputValue) {
      var selectValue = Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["e"])(nextProps.value);
      var menuOptions = nextProps.menuIsOpen ? this.buildMenuOptions(nextProps, selectValue) : {
        render: [],
        focusable: []
      };
      var focusedValue = this.getNextFocusedValue(selectValue);
      var focusedOption = this.getNextFocusedOption(menuOptions.focusable);
      this.setState({
        menuOptions: menuOptions,
        selectValue: selectValue,
        focusedOption: focusedOption,
        focusedValue: focusedValue
      });
    } // some updates should toggle the state of the input visibility


    if (this.inputIsHiddenAfterUpdate != null) {
      this.setState({
        inputIsHidden: this.inputIsHiddenAfterUpdate
      });
      delete this.inputIsHiddenAfterUpdate;
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props9 = this.props,
        isDisabled = _this$props9.isDisabled,
        menuIsOpen = _this$props9.menuIsOpen;
    var isFocused = this.state.isFocused;

    if ( // ensure focus is restored correctly when the control becomes enabled
    isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
    isFocused && menuIsOpen && !prevProps.menuIsOpen) {
      this.focusInput();
    } // scroll the focused option into view if necessary


    if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
      Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["f"])(this.menuListRef, this.focusedOptionRef);
      this.scrollToFocusedOptionOnUpdate = false;
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.stopListeningComposition();
    this.stopListeningToTouch();
    document.removeEventListener('scroll', this.onScroll, true);
  };

  // ==============================
  // Consumer Handlers
  // ==============================
  _proto.onMenuOpen = function onMenuOpen() {
    this.props.onMenuOpen();
  };

  _proto.onMenuClose = function onMenuClose() {
    var _this$props10 = this.props,
        isSearchable = _this$props10.isSearchable,
        isMulti = _this$props10.isMulti;
    this.announceAriaLiveContext({
      event: 'input',
      context: {
        isSearchable: isSearchable,
        isMulti: isMulti
      }
    });
    this.onInputChange('', {
      action: 'menu-close'
    });
    this.props.onMenuClose();
  };

  _proto.onInputChange = function onInputChange(newValue, actionMeta) {
    this.props.onInputChange(newValue, actionMeta);
  } // ==============================
  // Methods
  // ==============================
  ;

  _proto.focusInput = function focusInput() {
    if (!this.inputRef) return;
    this.inputRef.focus();
  };

  _proto.blurInput = function blurInput() {
    if (!this.inputRef) return;
    this.inputRef.blur();
  } // aliased for consumers
  ;

  _proto.openMenu = function openMenu(focusOption) {
    var _this2 = this;

    var _this$state3 = this.state,
        selectValue = _this$state3.selectValue,
        isFocused = _this$state3.isFocused;
    var menuOptions = this.buildMenuOptions(this.props, selectValue);
    var isMulti = this.props.isMulti;
    var openAtIndex = focusOption === 'first' ? 0 : menuOptions.focusable.length - 1;

    if (!isMulti) {
      var selectedIndex = menuOptions.focusable.indexOf(selectValue[0]);

      if (selectedIndex > -1) {
        openAtIndex = selectedIndex;
      }
    } // only scroll if the menu isn't already open


    this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
    this.inputIsHiddenAfterUpdate = false;
    this.setState({
      menuOptions: menuOptions,
      focusedValue: null,
      focusedOption: menuOptions.focusable[openAtIndex]
    }, function () {
      _this2.onMenuOpen();

      _this2.announceAriaLiveContext({
        event: 'menu'
      });
    });
  };

  _proto.focusValue = function focusValue(direction) {
    var _this$props11 = this.props,
        isMulti = _this$props11.isMulti,
        isSearchable = _this$props11.isSearchable;
    var _this$state4 = this.state,
        selectValue = _this$state4.selectValue,
        focusedValue = _this$state4.focusedValue; // Only multiselects support value focusing

    if (!isMulti) return;
    this.setState({
      focusedOption: null
    });
    var focusedIndex = selectValue.indexOf(focusedValue);

    if (!focusedValue) {
      focusedIndex = -1;
      this.announceAriaLiveContext({
        event: 'value'
      });
    }

    var lastIndex = selectValue.length - 1;
    var nextFocus = -1;
    if (!selectValue.length) return;

    switch (direction) {
      case 'previous':
        if (focusedIndex === 0) {
          // don't cycle from the start to the end
          nextFocus = 0;
        } else if (focusedIndex === -1) {
          // if nothing is focused, focus the last value first
          nextFocus = lastIndex;
        } else {
          nextFocus = focusedIndex - 1;
        }

        break;

      case 'next':
        if (focusedIndex > -1 && focusedIndex < lastIndex) {
          nextFocus = focusedIndex + 1;
        }

        break;
    }

    if (nextFocus === -1) {
      this.announceAriaLiveContext({
        event: 'input',
        context: {
          isSearchable: isSearchable,
          isMulti: isMulti
        }
      });
    }

    this.setState({
      inputIsHidden: nextFocus !== -1,
      focusedValue: selectValue[nextFocus]
    });
  };

  _proto.focusOption = function focusOption(direction) {
    if (direction === void 0) {
      direction = 'first';
    }

    var pageSize = this.props.pageSize;
    var _this$state5 = this.state,
        focusedOption = _this$state5.focusedOption,
        menuOptions = _this$state5.menuOptions;
    var options = menuOptions.focusable;
    if (!options.length) return;
    var nextFocus = 0; // handles 'first'

    var focusedIndex = options.indexOf(focusedOption);

    if (!focusedOption) {
      focusedIndex = -1;
      this.announceAriaLiveContext({
        event: 'menu'
      });
    }

    if (direction === 'up') {
      nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
    } else if (direction === 'down') {
      nextFocus = (focusedIndex + 1) % options.length;
    } else if (direction === 'pageup') {
      nextFocus = focusedIndex - pageSize;
      if (nextFocus < 0) nextFocus = 0;
    } else if (direction === 'pagedown') {
      nextFocus = focusedIndex + pageSize;
      if (nextFocus > options.length - 1) nextFocus = options.length - 1;
    } else if (direction === 'last') {
      nextFocus = options.length - 1;
    }

    this.scrollToFocusedOptionOnUpdate = true;
    this.setState({
      focusedOption: options[nextFocus],
      focusedValue: null
    });
    this.announceAriaLiveContext({
      event: 'menu',
      context: {
        isDisabled: isOptionDisabled(options[nextFocus])
      }
    });
  };

  // ==============================
  // Getters
  // ==============================
  _proto.getTheme = function getTheme() {
    // Use the default theme if there are no customizations.
    if (!this.props.theme) {
      return defaultTheme;
    } // If the theme prop is a function, assume the function
    // knows how to merge the passed-in default theme with
    // its own modifications.


    if (typeof this.props.theme === 'function') {
      return this.props.theme(defaultTheme);
    } // Otherwise, if a plain theme object was passed in,
    // overlay it with the default theme.


    return _extends$4({}, defaultTheme, this.props.theme);
  };

  _proto.getCommonProps = function getCommonProps() {
    var clearValue = this.clearValue,
        getStyles = this.getStyles,
        setValue = this.setValue,
        selectOption = this.selectOption,
        props = this.props;
    var classNamePrefix = props.classNamePrefix,
        isMulti = props.isMulti,
        isRtl = props.isRtl,
        options = props.options;
    var selectValue = this.state.selectValue;
    var hasValue = this.hasValue();

    var getValue = function getValue() {
      return selectValue;
    };

    var cx = _utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["h"].bind(null, classNamePrefix);
    return {
      cx: cx,
      clearValue: clearValue,
      getStyles: getStyles,
      getValue: getValue,
      hasValue: hasValue,
      isMulti: isMulti,
      isRtl: isRtl,
      options: options,
      selectOption: selectOption,
      setValue: setValue,
      selectProps: props,
      theme: this.getTheme()
    };
  };

  _proto.getNextFocusedValue = function getNextFocusedValue(nextSelectValue) {
    if (this.clearFocusValueOnUpdate) {
      this.clearFocusValueOnUpdate = false;
      return null;
    }

    var _this$state6 = this.state,
        focusedValue = _this$state6.focusedValue,
        lastSelectValue = _this$state6.selectValue;
    var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);

    if (lastFocusedIndex > -1) {
      var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);

      if (nextFocusedIndex > -1) {
        // the focused value is still in the selectValue, return it
        return focusedValue;
      } else if (lastFocusedIndex < nextSelectValue.length) {
        // the focusedValue is not present in the next selectValue array by
        // reference, so return the new value at the same index
        return nextSelectValue[lastFocusedIndex];
      }
    }

    return null;
  };

  _proto.getNextFocusedOption = function getNextFocusedOption(options) {
    var lastFocusedOption = this.state.focusedOption;
    return lastFocusedOption && options.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options[0];
  };

  _proto.hasValue = function hasValue() {
    var selectValue = this.state.selectValue;
    return selectValue.length > 0;
  };

  _proto.hasOptions = function hasOptions() {
    return !!this.state.menuOptions.render.length;
  };

  _proto.countOptions = function countOptions() {
    return this.state.menuOptions.focusable.length;
  };

  _proto.isClearable = function isClearable() {
    var _this$props12 = this.props,
        isClearable = _this$props12.isClearable,
        isMulti = _this$props12.isMulti; // single select, by default, IS NOT clearable
    // multi select, by default, IS clearable

    if (isClearable === undefined) return isMulti;
    return isClearable;
  };

  _proto.isOptionDisabled = function isOptionDisabled(option, selectValue) {
    return typeof this.props.isOptionDisabled === 'function' ? this.props.isOptionDisabled(option, selectValue) : false;
  };

  _proto.isOptionSelected = function isOptionSelected(option, selectValue) {
    var _this3 = this;

    if (selectValue.indexOf(option) > -1) return true;

    if (typeof this.props.isOptionSelected === 'function') {
      return this.props.isOptionSelected(option, selectValue);
    }

    var candidate = this.getOptionValue(option);
    return selectValue.some(function (i) {
      return _this3.getOptionValue(i) === candidate;
    });
  };

  _proto.filterOption = function filterOption(option, inputValue) {
    return this.props.filterOption ? this.props.filterOption(option, inputValue) : true;
  };

  _proto.formatOptionLabel = function formatOptionLabel(data, context) {
    if (typeof this.props.formatOptionLabel === 'function') {
      var inputValue = this.props.inputValue;
      var selectValue = this.state.selectValue;
      return this.props.formatOptionLabel(data, {
        context: context,
        inputValue: inputValue,
        selectValue: selectValue
      });
    } else {
      return this.getOptionLabel(data);
    }
  };

  _proto.formatGroupLabel = function formatGroupLabel(data) {
    return this.props.formatGroupLabel(data);
  } // ==============================
  // Mouse Handlers
  // ==============================
  ;

  // ==============================
  // Composition Handlers
  // ==============================
  _proto.startListeningComposition = function startListeningComposition() {
    if (document && document.addEventListener) {
      document.addEventListener('compositionstart', this.onCompositionStart, false);
      document.addEventListener('compositionend', this.onCompositionEnd, false);
    }
  };

  _proto.stopListeningComposition = function stopListeningComposition() {
    if (document && document.removeEventListener) {
      document.removeEventListener('compositionstart', this.onCompositionStart);
      document.removeEventListener('compositionend', this.onCompositionEnd);
    }
  };

  // ==============================
  // Touch Handlers
  // ==============================
  _proto.startListeningToTouch = function startListeningToTouch() {
    if (document && document.addEventListener) {
      document.addEventListener('touchstart', this.onTouchStart, false);
      document.addEventListener('touchmove', this.onTouchMove, false);
      document.addEventListener('touchend', this.onTouchEnd, false);
    }
  };

  _proto.stopListeningToTouch = function stopListeningToTouch() {
    if (document && document.removeEventListener) {
      document.removeEventListener('touchstart', this.onTouchStart);
      document.removeEventListener('touchmove', this.onTouchMove);
      document.removeEventListener('touchend', this.onTouchEnd);
    }
  };

  // ==============================
  // Renderers
  // ==============================
  _proto.constructAriaLiveMessage = function constructAriaLiveMessage() {
    var _this$state7 = this.state,
        ariaLiveContext = _this$state7.ariaLiveContext,
        selectValue = _this$state7.selectValue,
        focusedValue = _this$state7.focusedValue,
        focusedOption = _this$state7.focusedOption;
    var _this$props13 = this.props,
        options = _this$props13.options,
        menuIsOpen = _this$props13.menuIsOpen,
        inputValue = _this$props13.inputValue,
        screenReaderStatus = _this$props13.screenReaderStatus; // An aria live message representing the currently focused value in the select.

    var focusedValueMsg = focusedValue ? valueFocusAriaMessage({
      focusedValue: focusedValue,
      getOptionLabel: this.getOptionLabel,
      selectValue: selectValue
    }) : ''; // An aria live message representing the currently focused option in the select.

    var focusedOptionMsg = focusedOption && menuIsOpen ? optionFocusAriaMessage({
      focusedOption: focusedOption,
      getOptionLabel: this.getOptionLabel,
      options: options
    }) : ''; // An aria live message representing the set of focusable results and current searchterm/inputvalue.

    var resultsMsg = resultsAriaMessage({
      inputValue: inputValue,
      screenReaderMessage: screenReaderStatus({
        count: this.countOptions()
      })
    });
    return focusedValueMsg + " " + focusedOptionMsg + " " + resultsMsg + " " + ariaLiveContext;
  };

  _proto.renderInput = function renderInput() {
    var _this$props14 = this.props,
        isDisabled = _this$props14.isDisabled,
        isSearchable = _this$props14.isSearchable,
        inputId = _this$props14.inputId,
        inputValue = _this$props14.inputValue,
        tabIndex = _this$props14.tabIndex;
    var Input = this.components.Input;
    var inputIsHidden = this.state.inputIsHidden;
    var id = inputId || this.getElementId('input'); // aria attributes makes the JSX "noisy", separated for clarity

    var ariaAttributes = {
      'aria-autocomplete': 'list',
      'aria-label': this.props['aria-label'],
      'aria-labelledby': this.props['aria-labelledby']
    };

    if (!isSearchable) {
      // use a dummy input to maintain focus/blur functionality
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DummyInput, _extends$4({
        id: id,
        innerRef: this.getInputRef,
        onBlur: this.onInputBlur,
        onChange: _utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["n"],
        onFocus: this.onInputFocus,
        readOnly: true,
        disabled: isDisabled,
        tabIndex: tabIndex,
        value: ""
      }, ariaAttributes));
    }

    var _this$commonProps = this.commonProps,
        cx = _this$commonProps.cx,
        theme = _this$commonProps.theme,
        selectProps = _this$commonProps.selectProps;
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Input, _extends$4({
      autoCapitalize: "none",
      autoComplete: "off",
      autoCorrect: "off",
      cx: cx,
      getStyles: this.getStyles,
      id: id,
      innerRef: this.getInputRef,
      isDisabled: isDisabled,
      isHidden: inputIsHidden,
      onBlur: this.onInputBlur,
      onChange: this.handleInputChange,
      onFocus: this.onInputFocus,
      selectProps: selectProps,
      spellCheck: "false",
      tabIndex: tabIndex,
      theme: theme,
      type: "text",
      value: inputValue
    }, ariaAttributes));
  };

  _proto.renderPlaceholderOrValue = function renderPlaceholderOrValue() {
    var _this4 = this;

    var _this$components = this.components,
        MultiValue = _this$components.MultiValue,
        MultiValueContainer = _this$components.MultiValueContainer,
        MultiValueLabel = _this$components.MultiValueLabel,
        MultiValueRemove = _this$components.MultiValueRemove,
        SingleValue = _this$components.SingleValue,
        Placeholder = _this$components.Placeholder;
    var commonProps = this.commonProps;
    var _this$props15 = this.props,
        controlShouldRenderValue = _this$props15.controlShouldRenderValue,
        isDisabled = _this$props15.isDisabled,
        isMulti = _this$props15.isMulti,
        inputValue = _this$props15.inputValue,
        placeholder = _this$props15.placeholder;
    var _this$state8 = this.state,
        selectValue = _this$state8.selectValue,
        focusedValue = _this$state8.focusedValue,
        isFocused = _this$state8.isFocused;

    if (!this.hasValue() || !controlShouldRenderValue) {
      return inputValue ? null : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Placeholder, _extends$4({}, commonProps, {
        key: "placeholder",
        isDisabled: isDisabled,
        isFocused: isFocused
      }), placeholder);
    }

    if (isMulti) {
      var selectValues = selectValue.map(function (opt, index) {
        var isOptionFocused = opt === focusedValue;
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MultiValue, _extends$4({}, commonProps, {
          components: {
            Container: MultiValueContainer,
            Label: MultiValueLabel,
            Remove: MultiValueRemove
          },
          isFocused: isOptionFocused,
          isDisabled: isDisabled,
          key: _this4.getOptionValue(opt),
          index: index,
          removeProps: {
            onClick: function onClick() {
              return _this4.removeValue(opt);
            },
            onTouchEnd: function onTouchEnd() {
              return _this4.removeValue(opt);
            },
            onMouseDown: function onMouseDown(e) {
              e.preventDefault();
              e.stopPropagation();
            }
          },
          data: opt
        }), _this4.formatOptionLabel(opt, 'value'));
      });
      return selectValues;
    }

    if (inputValue) {
      return null;
    }

    var singleValue = selectValue[0];
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(SingleValue, _extends$4({}, commonProps, {
      data: singleValue,
      isDisabled: isDisabled
    }), this.formatOptionLabel(singleValue, 'value'));
  };

  _proto.renderClearIndicator = function renderClearIndicator() {
    var ClearIndicator = this.components.ClearIndicator;
    var commonProps = this.commonProps;
    var _this$props16 = this.props,
        isDisabled = _this$props16.isDisabled,
        isLoading = _this$props16.isLoading;
    var isFocused = this.state.isFocused;

    if (!this.isClearable() || !ClearIndicator || isDisabled || !this.hasValue() || isLoading) {
      return null;
    }

    var innerProps = {
      onMouseDown: this.onClearIndicatorMouseDown,
      onTouchEnd: this.onClearIndicatorTouchEnd,
      'aria-hidden': 'true'
    };
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ClearIndicator, _extends$4({}, commonProps, {
      innerProps: innerProps,
      isFocused: isFocused
    }));
  };

  _proto.renderLoadingIndicator = function renderLoadingIndicator() {
    var LoadingIndicator = this.components.LoadingIndicator;
    var commonProps = this.commonProps;
    var _this$props17 = this.props,
        isDisabled = _this$props17.isDisabled,
        isLoading = _this$props17.isLoading;
    var isFocused = this.state.isFocused;
    if (!LoadingIndicator || !isLoading) return null;
    var innerProps = {
      'aria-hidden': 'true'
    };
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LoadingIndicator, _extends$4({}, commonProps, {
      innerProps: innerProps,
      isDisabled: isDisabled,
      isFocused: isFocused
    }));
  };

  _proto.renderIndicatorSeparator = function renderIndicatorSeparator() {
    var _this$components2 = this.components,
        DropdownIndicator = _this$components2.DropdownIndicator,
        IndicatorSeparator = _this$components2.IndicatorSeparator; // separator doesn't make sense without the dropdown indicator

    if (!DropdownIndicator || !IndicatorSeparator) return null;
    var commonProps = this.commonProps;
    var isDisabled = this.props.isDisabled;
    var isFocused = this.state.isFocused;
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(IndicatorSeparator, _extends$4({}, commonProps, {
      isDisabled: isDisabled,
      isFocused: isFocused
    }));
  };

  _proto.renderDropdownIndicator = function renderDropdownIndicator() {
    var DropdownIndicator = this.components.DropdownIndicator;
    if (!DropdownIndicator) return null;
    var commonProps = this.commonProps;
    var isDisabled = this.props.isDisabled;
    var isFocused = this.state.isFocused;
    var innerProps = {
      onMouseDown: this.onDropdownIndicatorMouseDown,
      onTouchEnd: this.onDropdownIndicatorTouchEnd,
      'aria-hidden': 'true'
    };
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(DropdownIndicator, _extends$4({}, commonProps, {
      innerProps: innerProps,
      isDisabled: isDisabled,
      isFocused: isFocused
    }));
  };

  _proto.renderMenu = function renderMenu() {
    var _this5 = this;

    var _this$components3 = this.components,
        Group = _this$components3.Group,
        GroupHeading = _this$components3.GroupHeading,
        Menu = _this$components3.Menu,
        MenuList = _this$components3.MenuList,
        MenuPortal = _this$components3.MenuPortal,
        LoadingMessage = _this$components3.LoadingMessage,
        NoOptionsMessage = _this$components3.NoOptionsMessage,
        Option = _this$components3.Option;
    var commonProps = this.commonProps;
    var _this$state9 = this.state,
        focusedOption = _this$state9.focusedOption,
        menuOptions = _this$state9.menuOptions;
    var _this$props18 = this.props,
        captureMenuScroll = _this$props18.captureMenuScroll,
        inputValue = _this$props18.inputValue,
        isLoading = _this$props18.isLoading,
        loadingMessage = _this$props18.loadingMessage,
        minMenuHeight = _this$props18.minMenuHeight,
        maxMenuHeight = _this$props18.maxMenuHeight,
        menuIsOpen = _this$props18.menuIsOpen,
        menuPlacement = _this$props18.menuPlacement,
        menuPosition = _this$props18.menuPosition,
        menuPortalTarget = _this$props18.menuPortalTarget,
        menuShouldBlockScroll = _this$props18.menuShouldBlockScroll,
        menuShouldScrollIntoView = _this$props18.menuShouldScrollIntoView,
        noOptionsMessage = _this$props18.noOptionsMessage,
        onMenuScrollToTop = _this$props18.onMenuScrollToTop,
        onMenuScrollToBottom = _this$props18.onMenuScrollToBottom;
    if (!menuIsOpen) return null; // TODO: Internal Option Type here

    var render = function render(props) {
      // for performance, the menu options in state aren't changed when the
      // focused option changes so we calculate additional props based on that
      var isFocused = focusedOption === props.data;
      props.innerRef = isFocused ? _this5.getFocusedOptionRef : undefined;
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Option, _extends$4({}, commonProps, props, {
        isFocused: isFocused
      }), _this5.formatOptionLabel(props.data, 'menu'));
    };

    var menuUI;

    if (this.hasOptions()) {
      menuUI = menuOptions.render.map(function (item) {
        if (item.type === 'group') {
          var type = item.type,
              group = _objectWithoutPropertiesLoose$2(item, ["type"]);

          var headingId = item.key + "-heading";
          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Group, _extends$4({}, commonProps, group, {
            Heading: GroupHeading,
            headingProps: {
              id: headingId
            },
            label: _this5.formatGroupLabel(item.data)
          }), item.options.map(function (option) {
            return render(option);
          }));
        } else if (item.type === 'option') {
          return render(item);
        }
      });
    } else if (isLoading) {
      var message = loadingMessage({
        inputValue: inputValue
      });
      if (message === null) return null;
      menuUI = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(LoadingMessage, commonProps, message);
    } else {
      var _message = noOptionsMessage({
        inputValue: inputValue
      });

      if (_message === null) return null;
      menuUI = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(NoOptionsMessage, commonProps, _message);
    }

    var menuPlacementProps = {
      minMenuHeight: minMenuHeight,
      maxMenuHeight: maxMenuHeight,
      menuPlacement: menuPlacement,
      menuPosition: menuPosition,
      menuShouldScrollIntoView: menuShouldScrollIntoView
    };
    var menuElement = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__["M"], _extends$4({}, commonProps, menuPlacementProps), function (_ref8) {
      var ref = _ref8.ref,
          _ref8$placerProps = _ref8.placerProps,
          placement = _ref8$placerProps.placement,
          maxHeight = _ref8$placerProps.maxHeight;
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Menu, _extends$4({}, commonProps, menuPlacementProps, {
        innerRef: ref,
        innerProps: {
          onMouseDown: _this5.onMenuMouseDown,
          onMouseMove: _this5.onMenuMouseMove
        },
        isLoading: isLoading,
        placement: placement
      }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ScrollCaptorSwitch, {
        isEnabled: captureMenuScroll,
        onTopArrive: onMenuScrollToTop,
        onBottomArrive: onMenuScrollToBottom
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ScrollBlock, {
        isEnabled: menuShouldBlockScroll
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MenuList, _extends$4({}, commonProps, {
        innerRef: _this5.getMenuListRef,
        isLoading: isLoading,
        maxHeight: maxHeight
      }), menuUI))));
    }); // positioning behaviour is almost identical for portalled and fixed,
    // so we use the same component. the actual portalling logic is forked
    // within the component based on `menuPosition`

    return menuPortalTarget || menuPosition === 'fixed' ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MenuPortal, _extends$4({}, commonProps, {
      appendTo: menuPortalTarget,
      controlElement: this.controlRef,
      menuPlacement: menuPlacement,
      menuPosition: menuPosition
    }), menuElement) : menuElement;
  };

  _proto.renderFormField = function renderFormField() {
    var _this6 = this;

    var _this$props19 = this.props,
        delimiter = _this$props19.delimiter,
        isDisabled = _this$props19.isDisabled,
        isMulti = _this$props19.isMulti,
        name = _this$props19.name;
    var selectValue = this.state.selectValue;
    if (!name || isDisabled) return;

    if (isMulti) {
      if (delimiter) {
        var value = selectValue.map(function (opt) {
          return _this6.getOptionValue(opt);
        }).join(delimiter);
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
          name: name,
          type: "hidden",
          value: value
        });
      } else {
        var input = selectValue.length > 0 ? selectValue.map(function (opt, i) {
          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
            key: "i-" + i,
            name: name,
            type: "hidden",
            value: _this6.getOptionValue(opt)
          });
        }) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
          name: name,
          type: "hidden"
        });
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, input);
      }
    } else {
      var _value2 = selectValue[0] ? this.getOptionValue(selectValue[0]) : '';

      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
        name: name,
        type: "hidden",
        value: _value2
      });
    }
  };

  _proto.renderLiveRegion = function renderLiveRegion() {
    if (!this.state.isFocused) return null;
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(A11yText, {
      "aria-live": "polite"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", {
      id: "aria-selection-event"
    }, "\xA0", this.state.ariaLiveSelection), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", {
      id: "aria-context"
    }, "\xA0", this.constructAriaLiveMessage()));
  };

  _proto.render = function render() {
    var _this$components4 = this.components,
        Control = _this$components4.Control,
        IndicatorsContainer = _this$components4.IndicatorsContainer,
        SelectContainer = _this$components4.SelectContainer,
        ValueContainer = _this$components4.ValueContainer;
    var _this$props20 = this.props,
        className = _this$props20.className,
        id = _this$props20.id,
        isDisabled = _this$props20.isDisabled,
        menuIsOpen = _this$props20.menuIsOpen;
    var isFocused = this.state.isFocused;
    var commonProps = this.commonProps = this.getCommonProps();
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(SelectContainer, _extends$4({}, commonProps, {
      className: className,
      innerProps: {
        id: id,
        onKeyDown: this.onKeyDown
      },
      isDisabled: isDisabled,
      isFocused: isFocused
    }), this.renderLiveRegion(), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Control, _extends$4({}, commonProps, {
      innerRef: this.getControlRef,
      innerProps: {
        onMouseDown: this.onControlMouseDown,
        onTouchEnd: this.onControlTouchEnd
      },
      isDisabled: isDisabled,
      isFocused: isFocused,
      menuIsOpen: menuIsOpen
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ValueContainer, _extends$4({}, commonProps, {
      isDisabled: isDisabled
    }), this.renderPlaceholderOrValue(), this.renderInput()), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(IndicatorsContainer, _extends$4({}, commonProps, {
      isDisabled: isDisabled
    }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
  };

  return Select;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

Select.defaultProps = defaultProps;




/***/ }),

/***/ "./node_modules/react-select/dist/index-4322c0ed.browser.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-select/dist/index-4322c0ed.browser.esm.js ***!
  \**********************************************************************/
/*! exports provided: M, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return MenuPlacer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return containerCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return css; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return clearIndicatorCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return dropdownIndicatorCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return groupHeadingCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return indicatorSeparatorCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return groupCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return inputCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return indicatorsContainerCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return loadingMessageCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return menuListCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return loadingIndicatorCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return menuCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return menuPortalCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return multiValueCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return multiValueLabelCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return multiValueRemoveCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return noOptionsMessageCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return optionCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return placeholderCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return css$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return valueContainerCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return defaultComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return exportedEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return components; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emotion_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/core */ "./node_modules/@emotion/core/dist/core.browser.esm.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils-06b0d5a4.browser.esm.js */ "./node_modules/react-select/dist/utils-06b0d5a4.browser.esm.js");
/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/css */ "./node_modules/@emotion/css/dist/css.browser.esm.js");
/* harmony import */ var react_input_autosize__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-input-autosize */ "./node_modules/react-input-autosize/lib/AutosizeInput.js");
/* harmony import */ var react_input_autosize__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_input_autosize__WEBPACK_IMPORTED_MODULE_6__);








function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
function getMenuPlacement(_ref) {
  var maxHeight = _ref.maxHeight,
      menuEl = _ref.menuEl,
      minHeight = _ref.minHeight,
      placement = _ref.placement,
      shouldScroll = _ref.shouldScroll,
      isFixedPosition = _ref.isFixedPosition,
      theme = _ref.theme;
  var spacing = theme.spacing;
  var scrollParent = Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["a"])(menuEl);
  var defaultState = {
    placement: 'bottom',
    maxHeight: maxHeight
  }; // something went wrong, return default state

  if (!menuEl || !menuEl.offsetParent) return defaultState; // we can't trust `scrollParent.scrollHeight` --> it may increase when
  // the menu is rendered

  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
      scrollHeight = _scrollParent$getBoun.height;

  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
      menuBottom = _menuEl$getBoundingCl.bottom,
      menuHeight = _menuEl$getBoundingCl.height,
      menuTop = _menuEl$getBoundingCl.top;

  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
      containerTop = _menuEl$offsetParent$.top;

  var viewHeight = window.innerHeight;
  var scrollTop = Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["b"])(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;

  switch (placement) {
    case 'auto':
    case 'bottom':
      // 1: the menu will fit, do nothing
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      } // 2: the menu will fit, if scrolled


      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["c"])(scrollParent, scrollDown, scrollDuration);
        }

        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      } // 3: the menu will fit, if constrained


      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["c"])(scrollParent, scrollDown, scrollDuration);
        } // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.


        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: 'bottom',
          maxHeight: constrainedHeight
        };
      } // 4. Forked beviour when there isn't enough space below
      // AUTO: flip the menu, render above


      if (placement === 'auto' || isFixedPosition) {
        // may need to be constrained after flipping
        var _constrainedHeight = maxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;

        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - spacing.controlHeight, maxHeight);
        }

        return {
          placement: 'top',
          maxHeight: _constrainedHeight
        };
      } // BOTTOM: allow browser to increase scrollable area and immediately set scroll


      if (placement === 'bottom') {
        Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["s"])(scrollParent, scrollDown);
        return {
          placement: 'bottom',
          maxHeight: maxHeight
        };
      }

      break;

    case 'top':
      // 1: the menu will fit, do nothing
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: 'top',
          maxHeight: maxHeight
        };
      } // 2: the menu will fit, if scrolled


      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["c"])(scrollParent, scrollUp, scrollDuration);
        }

        return {
          placement: 'top',
          maxHeight: maxHeight
        };
      } // 3: the menu will fit, if constrained


      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = maxHeight; // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.

        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }

        if (shouldScroll) {
          Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["c"])(scrollParent, scrollUp, scrollDuration);
        }

        return {
          placement: 'top',
          maxHeight: _constrainedHeight2
        };
      } // 4. not enough space, the browser WILL NOT increase scrollable area when
      // absolutely positioned element rendered above the viewport (only below).
      // Flip the menu, render below


      return {
        placement: 'bottom',
        maxHeight: maxHeight
      };

    default:
      throw new Error("Invalid placement provided \"" + placement + "\".");
  } // fulfil contract with flow: implicit return value of undefined


  return defaultState;
} // Menu Component
// ------------------------------

function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: 'top',
    top: 'bottom'
  };
  return placement ? placementToCSSProp[placement] : 'bottom';
}

var coercePlacement = function coercePlacement(p) {
  return p === 'auto' ? 'bottom' : p;
};

var menuCSS = function menuCSS(_ref2) {
  var _ref3;

  var placement = _ref2.placement,
      _ref2$theme = _ref2.theme,
      borderRadius = _ref2$theme.borderRadius,
      spacing = _ref2$theme.spacing,
      colors = _ref2$theme.colors;
  return _ref3 = {
    label: 'menu'
  }, _ref3[alignToControl(placement)] = '100%', _ref3.backgroundColor = colors.neutral0, _ref3.borderRadius = borderRadius, _ref3.boxShadow = '0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)', _ref3.marginBottom = spacing.menuGutter, _ref3.marginTop = spacing.menuGutter, _ref3.position = 'absolute', _ref3.width = '100%', _ref3.zIndex = 1, _ref3;
}; // NOTE: internal only

var MenuPlacer =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(MenuPlacer, _Component);

  function MenuPlacer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.state = {
      maxHeight: _this.props.maxMenuHeight,
      placement: null
    };

    _this.getPlacement = function (ref) {
      var _this$props = _this.props,
          minMenuHeight = _this$props.minMenuHeight,
          maxMenuHeight = _this$props.maxMenuHeight,
          menuPlacement = _this$props.menuPlacement,
          menuPosition = _this$props.menuPosition,
          menuShouldScrollIntoView = _this$props.menuShouldScrollIntoView,
          theme = _this$props.theme;
      var getPortalPlacement = _this.context.getPortalPlacement;
      if (!ref) return; // DO NOT scroll if position is fixed

      var isFixedPosition = menuPosition === 'fixed';
      var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
      var state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl: ref,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll: shouldScroll,
        isFixedPosition: isFixedPosition,
        theme: theme
      });
      if (getPortalPlacement) getPortalPlacement(state);

      _this.setState(state);
    };

    _this.getUpdatedProps = function () {
      var menuPlacement = _this.props.menuPlacement;
      var placement = _this.state.placement || coercePlacement(menuPlacement);
      return _extends({}, _this.props, {
        placement: placement,
        maxHeight: _this.state.maxHeight
      });
    };

    return _this;
  }

  var _proto = MenuPlacer.prototype;

  _proto.render = function render() {
    var children = this.props.children;
    return children({
      ref: this.getPlacement,
      placerProps: this.getUpdatedProps()
    });
  };

  return MenuPlacer;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);
MenuPlacer.contextTypes = {
  getPortalPlacement: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
};

var Menu = function Menu(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerRef = props.innerRef,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends({
    css: getStyles('menu', props),
    className: cx({
      menu: true
    }, className)
  }, innerProps, {
    ref: innerRef
  }), children);
};
// Menu List
// ==============================

var menuListCSS = function menuListCSS(_ref4) {
  var maxHeight = _ref4.maxHeight,
      baseUnit = _ref4.theme.spacing.baseUnit;
  return {
    maxHeight: maxHeight,
    overflowY: 'auto',
    paddingBottom: baseUnit,
    paddingTop: baseUnit,
    position: 'relative',
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: 'touch'
  };
};
var MenuList = function MenuList(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      isMulti = props.isMulti,
      innerRef = props.innerRef;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", {
    css: getStyles('menuList', props),
    className: cx({
      'menu-list': true,
      'menu-list--is-multi': isMulti
    }, className),
    ref: innerRef
  }, children);
}; // ==============================
// Menu Notices
// ==============================

var noticeCSS = function noticeCSS(_ref5) {
  var _ref5$theme = _ref5.theme,
      baseUnit = _ref5$theme.spacing.baseUnit,
      colors = _ref5$theme.colors;
  return {
    color: colors.neutral40,
    padding: baseUnit * 2 + "px " + baseUnit * 3 + "px",
    textAlign: 'center'
  };
};

var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends({
    css: getStyles('noOptionsMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--no-options': true
    }, className)
  }, innerProps), children);
};
NoOptionsMessage.defaultProps = {
  children: 'No options'
};
var LoadingMessage = function LoadingMessage(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends({
    css: getStyles('loadingMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--loading': true
    }, className)
  }, innerProps), children);
};
LoadingMessage.defaultProps = {
  children: 'Loading...'
}; // ==============================
// Menu Portal
// ==============================

var menuPortalCSS = function menuPortalCSS(_ref6) {
  var rect = _ref6.rect,
      offset = _ref6.offset,
      position = _ref6.position;
  return {
    left: rect.left,
    position: position,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal =
/*#__PURE__*/
function (_Component2) {
  _inheritsLoose(MenuPortal, _Component2);

  function MenuPortal() {
    var _this2;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this2 = _Component2.call.apply(_Component2, [this].concat(args)) || this;
    _this2.state = {
      placement: null
    };

    _this2.getPortalPlacement = function (_ref7) {
      var placement = _ref7.placement;
      var initialPlacement = coercePlacement(_this2.props.menuPlacement); // avoid re-renders if the placement has not changed

      if (placement !== initialPlacement) {
        _this2.setState({
          placement: placement
        });
      }
    };

    return _this2;
  }

  var _proto2 = MenuPortal.prototype;

  _proto2.getChildContext = function getChildContext() {
    return {
      getPortalPlacement: this.getPortalPlacement
    };
  } // callback for occassions where the menu must "flip"
  ;

  _proto2.render = function render() {
    var _this$props2 = this.props,
        appendTo = _this$props2.appendTo,
        children = _this$props2.children,
        controlElement = _this$props2.controlElement,
        menuPlacement = _this$props2.menuPlacement,
        position = _this$props2.menuPosition,
        getStyles = _this$props2.getStyles;
    var isFixed = position === 'fixed'; // bail early if required elements aren't present

    if (!appendTo && !isFixed || !controlElement) {
      return null;
    }

    var placement = this.state.placement || coercePlacement(menuPlacement);
    var rect = Object(_utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__["g"])(controlElement);
    var scrollDistance = isFixed ? 0 : window.pageYOffset;
    var offset = rect[placement] + scrollDistance;
    var state = {
      offset: offset,
      position: position,
      rect: rect
    }; // same wrapper element whether fixed or portalled

    var menuWrapper = Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", {
      css: getStyles('menuPortal', state)
    }, children);
    return appendTo ? Object(react_dom__WEBPACK_IMPORTED_MODULE_2__["createPortal"])(menuWrapper, appendTo) : menuWrapper;
  };

  return MenuPortal;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);
MenuPortal.childContextTypes = {
  getPortalPlacement: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
};

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

function equal(a, b) {
  // fast-deep-equal index.js 2.0.1
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a),
        arrB = isArray(b),
        i,
        length,
        key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) {
        if (!equal(a[i], b[i])) return false;
      }

      return true;
    }

    if (arrA != arrB) return false;
    var dateA = a instanceof Date,
        dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();
    var regexpA = a instanceof RegExp,
        regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();
    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length) {
      return false;
    }

    for (i = length; i-- !== 0;) {
      if (!hasProp.call(b, keys[i])) return false;
    } // end fast-deep-equal
    // Custom handling for React


    for (i = length; i-- !== 0;) {
      key = keys[i];

      if (key === '_owner' && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner.
        //  _owner contains circular references
        // and is not needed when comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of a react element
        continue;
      } else {
        // all other properties should be traversed as usual
        if (!equal(a[key], b[key])) return false;
      }
    } // fast-deep-equal index.js 2.0.1


    return true;
  }

  return a !== a && b !== b;
} // end fast-deep-equal


function exportedEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (error.message && error.message.match(/stack|recursion/i)) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('Warning: react-fast-compare does not handle circular references.', error.name, error.message);
      return false;
    } // some other error. we should definitely know about these


    throw error;
  }
}

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
var containerCSS = function containerCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      isRtl = _ref.isRtl;
  return {
    label: 'container',
    direction: isRtl ? 'rtl' : null,
    pointerEvents: isDisabled ? 'none' : null,
    // cancel mouse events when disabled
    position: 'relative'
  };
};
var SelectContainer = function SelectContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isDisabled = props.isDisabled,
      isRtl = props.isRtl;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$1({
    css: getStyles('container', props),
    className: cx({
      '--is-disabled': isDisabled,
      '--is-rtl': isRtl
    }, className)
  }, innerProps), children);
}; // ==============================
// Value Container
// ==============================

var valueContainerCSS = function valueContainerCSS(_ref2) {
  var spacing = _ref2.theme.spacing;
  return {
    alignItems: 'center',
    display: 'flex',
    flex: 1,
    flexWrap: 'wrap',
    padding: spacing.baseUnit / 2 + "px " + spacing.baseUnit * 2 + "px",
    WebkitOverflowScrolling: 'touch',
    position: 'relative',
    overflow: 'hidden'
  };
};
var ValueContainer = function ValueContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      isMulti = props.isMulti,
      getStyles = props.getStyles,
      hasValue = props.hasValue;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", {
    css: getStyles('valueContainer', props),
    className: cx({
      'value-container': true,
      'value-container--is-multi': isMulti,
      'value-container--has-value': hasValue
    }, className)
  }, children);
}; // ==============================
// Indicator Container
// ==============================

var indicatorsContainerCSS = function indicatorsContainerCSS() {
  return {
    alignItems: 'center',
    alignSelf: 'stretch',
    display: 'flex',
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", {
    css: getStyles('indicatorsContainer', props),
    className: cx({
      indicators: true
    }, className)
  }, children);
};

function _templateObject() {
  var data = _taggedTemplateLiteralLoose(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var _ref2 =  false ? undefined : {
  name: "19bqh2r",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0JJIiwiZmlsZSI6ImluZGljYXRvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyB0eXBlIE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL2NvcmUnO1xuXG5pbXBvcnQgdHlwZSB7IENvbW1vblByb3BzLCBUaGVtZSB9IGZyb20gJy4uL3R5cGVzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHsgc2l6ZSwgLi4ucHJvcHMgfTogeyBzaXplOiBudW1iZXIgfSkgPT4gKFxuICA8c3ZnXG4gICAgaGVpZ2h0PXtzaXplfVxuICAgIHdpZHRoPXtzaXplfVxuICAgIHZpZXdCb3g9XCIwIDAgMjAgMjBcIlxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgIGNzcz17e1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBmaWxsOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgfX1cbiAgICB7Li4ucHJvcHN9XG4gIC8+XG4pO1xuXG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBhbnkpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogYW55KSA9PiAoXG4gIDxTdmcgc2l6ZT17MjB9IHsuLi5wcm9wc30+XG4gICAgPHBhdGggZD1cIk00LjUxNiA3LjU0OGMwLjQzNi0wLjQ0NiAxLjA0My0wLjQ4MSAxLjU3NiAwbDMuOTA4IDMuNzQ3IDMuOTA4LTMuNzQ3YzAuNTMzLTAuNDgxIDEuMTQxLTAuNDQ2IDEuNTc0IDAgMC40MzYgMC40NDUgMC40MDggMS4xOTcgMCAxLjYxNS0wLjQwNiAwLjQxOC00LjY5NSA0LjUwMi00LjY5NSA0LjUwMi0wLjIxNyAwLjIyMy0wLjUwMiAwLjMzNS0wLjc4NyAwLjMzNXMtMC41Ny0wLjExMi0wLjc4OS0wLjMzNWMwIDAtNC4yODctNC4wODQtNC42OTUtNC41MDJzLTAuNDM2LTEuMTcgMC0xLjYxNXpcIiAvPlxuICA8L1N2Zz5cbik7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRHJvcGRvd24gJiBDbGVhciBCdXR0b25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IHR5cGUgSW5kaWNhdG9yUHJvcHMgPSBDb21tb25Qcm9wcyAmIHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW46IE5vZGUsXG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogYW55LFxuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuLFxuICAvKiogV2hldGhlciB0aGUgdGV4dCBpcyByaWdodCB0byBsZWZ0ICovXG4gIGlzUnRsOiBib29sZWFuLFxufTtcblxuY29uc3QgYmFzZUNTUyA9ICh7XG4gIGlzRm9jdXNlZCxcbiAgdGhlbWU6IHtcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgY29sb3JzLFxuICB9LFxufTogSW5kaWNhdG9yUHJvcHMpID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yQ29udGFpbmVyJyxcbiAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcblxuICAnOmhvdmVyJzoge1xuICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDgwIDogY29sb3JzLm5ldXRyYWw0MCxcbiAgfSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gKHByb3BzOiBJbmRpY2F0b3JQcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2Ryb3Bkb3duSW5kaWNhdG9yJywgcHJvcHMpfVxuICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAge1xuICAgICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgICAnZHJvcGRvd24taW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICApfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gKHByb3BzOiBJbmRpY2F0b3JQcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2NsZWFySW5kaWNhdG9yJywgcHJvcHMpfVxuICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAge1xuICAgICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgICAnY2xlYXItaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICApfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG50eXBlIFNlcGFyYXRvclN0YXRlID0geyBpc0Rpc2FibGVkOiBib29sZWFuIH07XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSAoe1xuICBpc0Rpc2FibGVkLFxuICB0aGVtZToge1xuICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICBjb2xvcnMsXG4gIH0sXG59OiBDb21tb25Qcm9wcyAmIFNlcGFyYXRvclN0YXRlKSA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvclNlcGFyYXRvcicsXG4gIGFsaWduU2VsZjogJ3N0cmV0Y2gnLFxuICBiYWNrZ3JvdW5kQ29sb3I6IGlzRGlzYWJsZWQgPyBjb2xvcnMubmV1dHJhbDEwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgbWFyZ2luQm90dG9tOiBiYXNlVW5pdCAqIDIsXG4gIG1hcmdpblRvcDogYmFzZVVuaXQgKiAyLFxuICB3aWR0aDogMSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gKHByb3BzOiBJbmRpY2F0b3JQcm9wcykgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgY3gsIGdldFN0eWxlcywgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2luZGljYXRvclNlcGFyYXRvcicsIHByb3BzKX1cbiAgICAgIGNsYXNzTmFtZT17Y3goeyAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUgfSwgY2xhc3NOYW1lKX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gKHtcbiAgaXNGb2N1c2VkLFxuICBzaXplLFxuICB0aGVtZToge1xuICAgIGNvbG9ycyxcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gIH0sXG59OiB7XG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgc2l6ZTogbnVtYmVyLFxuICB0aGVtZTogVGhlbWUsXG59KSA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxufSk7XG5cbnR5cGUgRG90UHJvcHMgPSB7IGRlbGF5OiBudW1iZXIsIG9mZnNldDogYm9vbGVhbiB9O1xuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogRG90UHJvcHMpID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGFuaW1hdGlvbjogYCR7bG9hZGluZ0RvdEFuaW1hdGlvbnN9IDFzIGVhc2UtaW4tb3V0ICR7ZGVsYXl9bXMgaW5maW5pdGU7YCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxZW0nLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBtYXJnaW5MZWZ0OiBvZmZzZXQgPyAnMWVtJyA6IG51bGwsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIExvYWRpbmdJY29uUHJvcHMgPSB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogYW55LFxuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuLFxuICAvKiogV2hldGhlciB0aGUgdGV4dCBpcyByaWdodCB0byBsZWZ0ICovXG4gIGlzUnRsOiBib29sZWFuLFxufSAmIENvbW1vblByb3BzICYge1xuICAgIC8qKiBTZXQgc2l6ZSBvZiB0aGUgY29udGFpbmVyLiAqL1xuICAgIHNpemU6IG51bWJlcixcbiAgfTtcbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gKHByb3BzOiBMb2FkaW5nSWNvblByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzLCBpc1J0bCB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIGNzcz17Z2V0U3R5bGVzKCdsb2FkaW5nSW5kaWNhdG9yJywgcHJvcHMpfVxuICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAge1xuICAgICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgICAnbG9hZGluZy1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezB9IG9mZnNldD17aXNSdGx9IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MTYwfSBvZmZzZXQgLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXszMjB9IG9mZnNldD17IWlzUnRsfSAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcbkxvYWRpbmdJbmRpY2F0b3IuZGVmYXVsdFByb3BzID0geyBzaXplOiA0IH07XG4iXX0= */"
};

// ==============================
// Dropdown & Clear Icons
// ==============================
var Svg = function Svg(_ref) {
  var size = _ref.size,
      props = _objectWithoutPropertiesLoose(_ref, ["size"]);

  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("svg", _extends$2({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};

var CrossIcon = function CrossIcon(props) {
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(Svg, _extends$2({
    size: 20
  }, props), Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron(props) {
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(Svg, _extends$2({
    size: 20
  }, props), Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}; // ==============================
// Dropdown & Clear Buttons
// ==============================

var baseCSS = function baseCSS(_ref3) {
  var isFocused = _ref3.isFocused,
      _ref3$theme = _ref3.theme,
      baseUnit = _ref3$theme.spacing.baseUnit,
      colors = _ref3$theme.colors;
  return {
    label: 'indicatorContainer',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    ':hover': {
      color: isFocused ? colors.neutral80 : colors.neutral40
    }
  };
};

var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$2({}, innerProps, {
    css: getStyles('dropdownIndicator', props),
    className: cx({
      indicator: true,
      'dropdown-indicator': true
    }, className)
  }), children || Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$2({}, innerProps, {
    css: getStyles('clearIndicator', props),
    className: cx({
      indicator: true,
      'clear-indicator': true
    }, className)
  }), children || Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(CrossIcon, null));
}; // ==============================
// Separator
// ==============================

var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref4) {
  var isDisabled = _ref4.isDisabled,
      _ref4$theme = _ref4.theme,
      baseUnit = _ref4$theme.spacing.baseUnit,
      colors = _ref4$theme.colors;
  return {
    label: 'indicatorSeparator',
    alignSelf: 'stretch',
    backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
    marginBottom: baseUnit * 2,
    marginTop: baseUnit * 2,
    width: 1
  };
};
var IndicatorSeparator = function IndicatorSeparator(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("span", _extends$2({}, innerProps, {
    css: getStyles('indicatorSeparator', props),
    className: cx({
      'indicator-separator': true
    }, className)
  }));
}; // ==============================
// Loading
// ==============================

var loadingDotAnimations = Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["keyframes"])(_templateObject());
var loadingIndicatorCSS = function loadingIndicatorCSS(_ref5) {
  var isFocused = _ref5.isFocused,
      size = _ref5.size,
      _ref5$theme = _ref5.theme,
      colors = _ref5$theme.colors,
      baseUnit = _ref5$theme.spacing.baseUnit;
  return {
    label: 'loadingIndicator',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    alignSelf: 'center',
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: 'center',
    verticalAlign: 'middle'
  };
};

var LoadingDot = function LoadingDot(_ref6) {
  var delay = _ref6.delay,
      offset = _ref6.offset;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("span", {
    css:
    /*#__PURE__*/
    Object(_emotion_css__WEBPACK_IMPORTED_MODULE_5__["default"])({
      animation: loadingDotAnimations + " 1s ease-in-out " + delay + "ms infinite;",
      backgroundColor: 'currentColor',
      borderRadius: '1em',
      display: 'inline-block',
      marginLeft: offset ? '1em' : null,
      height: '1em',
      verticalAlign: 'top',
      width: '1em'
    },  false ? undefined : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc0xJIiwiZmlsZSI6ImluZGljYXRvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyB0eXBlIE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL2NvcmUnO1xuXG5pbXBvcnQgdHlwZSB7IENvbW1vblByb3BzLCBUaGVtZSB9IGZyb20gJy4uL3R5cGVzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHsgc2l6ZSwgLi4ucHJvcHMgfTogeyBzaXplOiBudW1iZXIgfSkgPT4gKFxuICA8c3ZnXG4gICAgaGVpZ2h0PXtzaXplfVxuICAgIHdpZHRoPXtzaXplfVxuICAgIHZpZXdCb3g9XCIwIDAgMjAgMjBcIlxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgIGNzcz17e1xuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBmaWxsOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgfX1cbiAgICB7Li4ucHJvcHN9XG4gIC8+XG4pO1xuXG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBhbnkpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogYW55KSA9PiAoXG4gIDxTdmcgc2l6ZT17MjB9IHsuLi5wcm9wc30+XG4gICAgPHBhdGggZD1cIk00LjUxNiA3LjU0OGMwLjQzNi0wLjQ0NiAxLjA0My0wLjQ4MSAxLjU3NiAwbDMuOTA4IDMuNzQ3IDMuOTA4LTMuNzQ3YzAuNTMzLTAuNDgxIDEuMTQxLTAuNDQ2IDEuNTc0IDAgMC40MzYgMC40NDUgMC40MDggMS4xOTcgMCAxLjYxNS0wLjQwNiAwLjQxOC00LjY5NSA0LjUwMi00LjY5NSA0LjUwMi0wLjIxNyAwLjIyMy0wLjUwMiAwLjMzNS0wLjc4NyAwLjMzNXMtMC41Ny0wLjExMi0wLjc4OS0wLjMzNWMwIDAtNC4yODctNC4wODQtNC42OTUtNC41MDJzLTAuNDM2LTEuMTcgMC0xLjYxNXpcIiAvPlxuICA8L1N2Zz5cbik7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRHJvcGRvd24gJiBDbGVhciBCdXR0b25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IHR5cGUgSW5kaWNhdG9yUHJvcHMgPSBDb21tb25Qcm9wcyAmIHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW46IE5vZGUsXG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogYW55LFxuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuLFxuICAvKiogV2hldGhlciB0aGUgdGV4dCBpcyByaWdodCB0byBsZWZ0ICovXG4gIGlzUnRsOiBib29sZWFuLFxufTtcblxuY29uc3QgYmFzZUNTUyA9ICh7XG4gIGlzRm9jdXNlZCxcbiAgdGhlbWU6IHtcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgY29sb3JzLFxuICB9LFxufTogSW5kaWNhdG9yUHJvcHMpID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yQ29udGFpbmVyJyxcbiAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcblxuICAnOmhvdmVyJzoge1xuICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDgwIDogY29sb3JzLm5ldXRyYWw0MCxcbiAgfSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gKHByb3BzOiBJbmRpY2F0b3JQcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2Ryb3Bkb3duSW5kaWNhdG9yJywgcHJvcHMpfVxuICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAge1xuICAgICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgICAnZHJvcGRvd24taW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICApfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gKHByb3BzOiBJbmRpY2F0b3JQcm9wcykgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2NsZWFySW5kaWNhdG9yJywgcHJvcHMpfVxuICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAge1xuICAgICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgICAnY2xlYXItaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICApfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG50eXBlIFNlcGFyYXRvclN0YXRlID0geyBpc0Rpc2FibGVkOiBib29sZWFuIH07XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSAoe1xuICBpc0Rpc2FibGVkLFxuICB0aGVtZToge1xuICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICBjb2xvcnMsXG4gIH0sXG59OiBDb21tb25Qcm9wcyAmIFNlcGFyYXRvclN0YXRlKSA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvclNlcGFyYXRvcicsXG4gIGFsaWduU2VsZjogJ3N0cmV0Y2gnLFxuICBiYWNrZ3JvdW5kQ29sb3I6IGlzRGlzYWJsZWQgPyBjb2xvcnMubmV1dHJhbDEwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgbWFyZ2luQm90dG9tOiBiYXNlVW5pdCAqIDIsXG4gIG1hcmdpblRvcDogYmFzZVVuaXQgKiAyLFxuICB3aWR0aDogMSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gKHByb3BzOiBJbmRpY2F0b3JQcm9wcykgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgY3gsIGdldFN0eWxlcywgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2luZGljYXRvclNlcGFyYXRvcicsIHByb3BzKX1cbiAgICAgIGNsYXNzTmFtZT17Y3goeyAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUgfSwgY2xhc3NOYW1lKX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gKHtcbiAgaXNGb2N1c2VkLFxuICBzaXplLFxuICB0aGVtZToge1xuICAgIGNvbG9ycyxcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gIH0sXG59OiB7XG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgc2l6ZTogbnVtYmVyLFxuICB0aGVtZTogVGhlbWUsXG59KSA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxufSk7XG5cbnR5cGUgRG90UHJvcHMgPSB7IGRlbGF5OiBudW1iZXIsIG9mZnNldDogYm9vbGVhbiB9O1xuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogRG90UHJvcHMpID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGFuaW1hdGlvbjogYCR7bG9hZGluZ0RvdEFuaW1hdGlvbnN9IDFzIGVhc2UtaW4tb3V0ICR7ZGVsYXl9bXMgaW5maW5pdGU7YCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxZW0nLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBtYXJnaW5MZWZ0OiBvZmZzZXQgPyAnMWVtJyA6IG51bGwsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIExvYWRpbmdJY29uUHJvcHMgPSB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogYW55LFxuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuLFxuICAvKiogV2hldGhlciB0aGUgdGV4dCBpcyByaWdodCB0byBsZWZ0ICovXG4gIGlzUnRsOiBib29sZWFuLFxufSAmIENvbW1vblByb3BzICYge1xuICAgIC8qKiBTZXQgc2l6ZSBvZiB0aGUgY29udGFpbmVyLiAqL1xuICAgIHNpemU6IG51bWJlcixcbiAgfTtcbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gKHByb3BzOiBMb2FkaW5nSWNvblByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzLCBpc1J0bCB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIGNzcz17Z2V0U3R5bGVzKCdsb2FkaW5nSW5kaWNhdG9yJywgcHJvcHMpfVxuICAgICAgY2xhc3NOYW1lPXtjeChcbiAgICAgICAge1xuICAgICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgICAnbG9hZGluZy1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezB9IG9mZnNldD17aXNSdGx9IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MTYwfSBvZmZzZXQgLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXszMjB9IG9mZnNldD17IWlzUnRsfSAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcbkxvYWRpbmdJbmRpY2F0b3IuZGVmYXVsdFByb3BzID0geyBzaXplOiA0IH07XG4iXX0= */")
  });
};

var LoadingIndicator = function LoadingIndicator(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isRtl = props.isRtl;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$2({}, innerProps, {
    css: getStyles('loadingIndicator', props),
    className: cx({
      indicator: true,
      'loading-indicator': true
    }, className)
  }), Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(LoadingDot, {
    delay: 160,
    offset: true
  }), Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
LoadingIndicator.defaultProps = {
  size: 4
};

function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
var css = function css(_ref) {
  var isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      _ref$theme = _ref.theme,
      colors = _ref$theme.colors,
      borderRadius = _ref$theme.borderRadius,
      spacing = _ref$theme.spacing;
  return {
    label: 'control',
    alignItems: 'center',
    backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
    borderColor: isDisabled ? colors.neutral10 : isFocused ? colors.primary : colors.neutral20,
    borderRadius: borderRadius,
    borderStyle: 'solid',
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px " + colors.primary : null,
    cursor: 'default',
    display: 'flex',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    minHeight: spacing.controlHeight,
    outline: '0 !important',
    position: 'relative',
    transition: 'all 100ms',
    '&:hover': {
      borderColor: isFocused ? colors.primary : colors.neutral30
    }
  };
};

var Control = function Control(props) {
  var children = props.children,
      cx = props.cx,
      getStyles = props.getStyles,
      className = props.className,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      innerRef = props.innerRef,
      innerProps = props.innerProps,
      menuIsOpen = props.menuIsOpen;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$3({
    ref: innerRef,
    css: getStyles('control', props),
    className: cx({
      control: true,
      'control--is-disabled': isDisabled,
      'control--is-focused': isFocused,
      'control--menu-is-open': menuIsOpen
    }, className)
  }, innerProps), children);
};

function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
var groupCSS = function groupCSS(_ref) {
  var spacing = _ref.theme.spacing;
  return {
    paddingBottom: spacing.baseUnit * 2,
    paddingTop: spacing.baseUnit * 2
  };
};

var Group = function Group(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      Heading = props.Heading,
      headingProps = props.headingProps,
      label = props.label,
      theme = props.theme,
      selectProps = props.selectProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", {
    css: getStyles('group', props),
    className: cx({
      group: true
    }, className)
  }, Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(Heading, _extends$4({}, headingProps, {
    selectProps: selectProps,
    theme: theme,
    getStyles: getStyles,
    cx: cx
  }), label), Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", null, children));
};

var groupHeadingCSS = function groupHeadingCSS(_ref2) {
  var spacing = _ref2.theme.spacing;
  return {
    label: 'group',
    color: '#999',
    cursor: 'default',
    display: 'block',
    fontSize: '75%',
    fontWeight: '500',
    marginBottom: '0.25em',
    paddingLeft: spacing.baseUnit * 3,
    paddingRight: spacing.baseUnit * 3,
    textTransform: 'uppercase'
  };
};
var GroupHeading = function GroupHeading(props) {
  var className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      theme = props.theme,
      selectProps = props.selectProps,
      cleanProps = _objectWithoutPropertiesLoose$1(props, ["className", "cx", "getStyles", "theme", "selectProps"]);

  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$4({
    css: getStyles('groupHeading', _extends$4({
      theme: theme
    }, cleanProps)),
    className: cx({
      'group-heading': true
    }, className)
  }, cleanProps));
};

function _extends$5() { _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }

function _objectWithoutPropertiesLoose$2(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
var inputCSS = function inputCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    margin: spacing.baseUnit / 2,
    paddingBottom: spacing.baseUnit / 2,
    paddingTop: spacing.baseUnit / 2,
    visibility: isDisabled ? 'hidden' : 'visible',
    color: colors.neutral80
  };
};

var inputStyle = function inputStyle(isHidden) {
  return {
    label: 'input',
    background: 0,
    border: 0,
    fontSize: 'inherit',
    opacity: isHidden ? 0 : 1,
    outline: 0,
    padding: 0,
    color: 'inherit'
  };
};

var Input = function Input(_ref2) {
  var className = _ref2.className,
      cx = _ref2.cx,
      getStyles = _ref2.getStyles,
      innerRef = _ref2.innerRef,
      isHidden = _ref2.isHidden,
      isDisabled = _ref2.isDisabled,
      theme = _ref2.theme,
      selectProps = _ref2.selectProps,
      props = _objectWithoutPropertiesLoose$2(_ref2, ["className", "cx", "getStyles", "innerRef", "isHidden", "isDisabled", "theme", "selectProps"]);

  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", {
    css: getStyles('input', _extends$5({
      theme: theme
    }, props))
  }, Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(react_input_autosize__WEBPACK_IMPORTED_MODULE_6___default.a, _extends$5({
    className: cx({
      input: true
    }, className),
    inputRef: innerRef,
    inputStyle: inputStyle(isHidden),
    disabled: isDisabled
  }, props)));
};

function _extends$6() { _extends$6 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }
var multiValueCSS = function multiValueCSS(_ref) {
  var _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      borderRadius = _ref$theme.borderRadius,
      colors = _ref$theme.colors;
  return {
    label: 'multiValue',
    backgroundColor: colors.neutral10,
    borderRadius: borderRadius / 2,
    display: 'flex',
    margin: spacing.baseUnit / 2,
    minWidth: 0 // resolves flex/text-overflow bug

  };
};
var multiValueLabelCSS = function multiValueLabelCSS(_ref2) {
  var _ref2$theme = _ref2.theme,
      borderRadius = _ref2$theme.borderRadius,
      colors = _ref2$theme.colors,
      cropWithEllipsis = _ref2.cropWithEllipsis;
  return {
    borderRadius: borderRadius / 2,
    color: colors.neutral80,
    fontSize: '85%',
    overflow: 'hidden',
    padding: 3,
    paddingLeft: 6,
    textOverflow: cropWithEllipsis ? 'ellipsis' : null,
    whiteSpace: 'nowrap'
  };
};
var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3) {
  var _ref3$theme = _ref3.theme,
      spacing = _ref3$theme.spacing,
      borderRadius = _ref3$theme.borderRadius,
      colors = _ref3$theme.colors,
      isFocused = _ref3.isFocused;
  return {
    alignItems: 'center',
    borderRadius: borderRadius / 2,
    backgroundColor: isFocused && colors.dangerLight,
    display: 'flex',
    paddingLeft: spacing.baseUnit,
    paddingRight: spacing.baseUnit,
    ':hover': {
      backgroundColor: colors.dangerLight,
      color: colors.danger
    }
  };
};
var MultiValueGeneric = function MultiValueGeneric(_ref4) {
  var children = _ref4.children,
      innerProps = _ref4.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children,
      innerProps = _ref5.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", innerProps, children || Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(CrossIcon, {
    size: 14
  }));
}

var MultiValue = function MultiValue(props) {
  var children = props.children,
      className = props.className,
      components = props.components,
      cx = props.cx,
      data = props.data,
      getStyles = props.getStyles,
      innerProps = props.innerProps,
      isDisabled = props.isDisabled,
      removeProps = props.removeProps,
      selectProps = props.selectProps;
  var Container = components.Container,
      Label = components.Label,
      Remove = components.Remove;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["ClassNames"], null, function (_ref6) {
    var css = _ref6.css,
        emotionCx = _ref6.cx;
    return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(Container, {
      data: data,
      innerProps: _extends$6({}, innerProps, {
        className: emotionCx(css(getStyles('multiValue', props)), cx({
          'multi-value': true,
          'multi-value--is-disabled': isDisabled
        }, className))
      }),
      selectProps: selectProps
    }, Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(Label, {
      data: data,
      innerProps: {
        className: emotionCx(css(getStyles('multiValueLabel', props)), cx({
          'multi-value__label': true
        }, className))
      },
      selectProps: selectProps
    }, children), Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])(Remove, {
      data: data,
      innerProps: _extends$6({
        className: emotionCx(css(getStyles('multiValueRemove', props)), cx({
          'multi-value__remove': true
        }, className))
      }, removeProps),
      selectProps: selectProps
    }));
  });
};

MultiValue.defaultProps = {
  cropWithEllipsis: true
};

function _extends$7() { _extends$7 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }
var optionCSS = function optionCSS(_ref) {
  var isDisabled = _ref.isDisabled,
      isFocused = _ref.isFocused,
      isSelected = _ref.isSelected,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'option',
    backgroundColor: isSelected ? colors.primary : isFocused ? colors.primary25 : 'transparent',
    color: isDisabled ? colors.neutral20 : isSelected ? colors.neutral0 : 'inherit',
    cursor: 'default',
    display: 'block',
    fontSize: 'inherit',
    padding: spacing.baseUnit * 2 + "px " + spacing.baseUnit * 3 + "px",
    width: '100%',
    userSelect: 'none',
    WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)',
    // provide some affordance on touch devices
    ':active': {
      backgroundColor: !isDisabled && (isSelected ? colors.primary : colors.primary50)
    }
  };
};

var Option = function Option(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      isDisabled = props.isDisabled,
      isFocused = props.isFocused,
      isSelected = props.isSelected,
      innerRef = props.innerRef,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$7({
    css: getStyles('option', props),
    className: cx({
      option: true,
      'option--is-disabled': isDisabled,
      'option--is-focused': isFocused,
      'option--is-selected': isSelected
    }, className),
    ref: innerRef
  }, innerProps), children);
};

function _extends$8() { _extends$8 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$8.apply(this, arguments); }
var placeholderCSS = function placeholderCSS(_ref) {
  var _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'placeholder',
    color: colors.neutral50,
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2,
    position: 'absolute',
    top: '50%',
    transform: 'translateY(-50%)'
  };
};

var Placeholder = function Placeholder(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$8({
    css: getStyles('placeholder', props),
    className: cx({
      placeholder: true
    }, className)
  }, innerProps), children);
};

function _extends$9() { _extends$9 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$9.apply(this, arguments); }
var css$1 = function css(_ref) {
  var isDisabled = _ref.isDisabled,
      _ref$theme = _ref.theme,
      spacing = _ref$theme.spacing,
      colors = _ref$theme.colors;
  return {
    label: 'singleValue',
    color: isDisabled ? colors.neutral40 : colors.neutral80,
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2,
    maxWidth: "calc(100% - " + spacing.baseUnit * 2 + "px)",
    overflow: 'hidden',
    position: 'absolute',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    top: '50%',
    transform: 'translateY(-50%)'
  };
};

var SingleValue = function SingleValue(props) {
  var children = props.children,
      className = props.className,
      cx = props.cx,
      getStyles = props.getStyles,
      isDisabled = props.isDisabled,
      innerProps = props.innerProps;
  return Object(_emotion_core__WEBPACK_IMPORTED_MODULE_1__["jsx"])("div", _extends$9({
    css: getStyles('singleValue', props),
    className: cx({
      'single-value': true,
      'single-value--is-disabled': isDisabled
    }, className)
  }, innerProps), children);
};

function _extends$a() { _extends$a = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$a.apply(this, arguments); }
var components = {
  ClearIndicator: ClearIndicator,
  Control: Control,
  DropdownIndicator: DropdownIndicator,
  DownChevron: DownChevron,
  CrossIcon: CrossIcon,
  Group: Group,
  GroupHeading: GroupHeading,
  IndicatorsContainer: IndicatorsContainer,
  IndicatorSeparator: IndicatorSeparator,
  Input: Input,
  LoadingIndicator: LoadingIndicator,
  Menu: Menu,
  MenuList: MenuList,
  MenuPortal: MenuPortal,
  LoadingMessage: LoadingMessage,
  NoOptionsMessage: NoOptionsMessage,
  MultiValue: MultiValue,
  MultiValueContainer: MultiValueContainer,
  MultiValueLabel: MultiValueLabel,
  MultiValueRemove: MultiValueRemove,
  Option: Option,
  Placeholder: Placeholder,
  SelectContainer: SelectContainer,
  SingleValue: SingleValue,
  ValueContainer: ValueContainer
};
var defaultComponents = function defaultComponents(props) {
  return _extends$a({}, components, props.components);
};




/***/ }),

/***/ "./node_modules/react-select/dist/react-select.browser.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-select/dist/react-select.browser.esm.js ***!
  \********************************************************************/
/*! exports provided: components, createFilter, defaultTheme, mergeStyles, default, NonceProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NonceProvider", function() { return NonceProvider; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! memoize-one */ "./node_modules/memoize-one/dist/memoize-one.esm.js");
/* harmony import */ var _emotion_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @emotion/core */ "./node_modules/@emotion/core/dist/core.browser.esm.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _utils_06b0d5a4_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils-06b0d5a4.browser.esm.js */ "./node_modules/react-select/dist/utils-06b0d5a4.browser.esm.js");
/* harmony import */ var _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./index-4322c0ed.browser.esm.js */ "./node_modules/react-select/dist/index-4322c0ed.browser.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "components", function() { return _index_4322c0ed_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__["y"]; });

/* harmony import */ var _Select_9fdb8cd0_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Select-9fdb8cd0.browser.esm.js */ "./node_modules/react-select/dist/Select-9fdb8cd0.browser.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFilter", function() { return _Select_9fdb8cd0_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultTheme", function() { return _Select_9fdb8cd0_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeStyles", function() { return _Select_9fdb8cd0_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__["m"]; });

/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @emotion/css */ "./node_modules/@emotion/css/dist/css.browser.esm.js");
/* harmony import */ var react_input_autosize__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-input-autosize */ "./node_modules/react-input-autosize/lib/AutosizeInput.js");
/* harmony import */ var react_input_autosize__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react_input_autosize__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _stateManager_04f734a2_browser_esm_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./stateManager-04f734a2.browser.esm.js */ "./node_modules/react-select/dist/stateManager-04f734a2.browser.esm.js");
/* harmony import */ var _emotion_cache__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @emotion/cache */ "./node_modules/@emotion/cache/dist/cache.browser.esm.js");














function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var NonceProvider =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(NonceProvider, _Component);

  function NonceProvider(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.createEmotionCache = function (nonce) {
      return Object(_emotion_cache__WEBPACK_IMPORTED_MODULE_11__["default"])({
        nonce: nonce
      });
    };

    _this.createEmotionCache = Object(memoize_one__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.createEmotionCache);
    return _this;
  }

  var _proto = NonceProvider.prototype;

  _proto.render = function render() {
    var emotionCache = this.createEmotionCache(this.props.nonce);
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_emotion_core__WEBPACK_IMPORTED_MODULE_2__["CacheProvider"], {
      value: emotionCache
    }, this.props.children);
  };

  return NonceProvider;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

var index = Object(_stateManager_04f734a2_browser_esm_js__WEBPACK_IMPORTED_MODULE_10__["m"])(_Select_9fdb8cd0_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__["S"]);

/* harmony default export */ __webpack_exports__["default"] = (index);



/***/ }),

/***/ "./node_modules/react-select/dist/stateManager-04f734a2.browser.esm.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-select/dist/stateManager-04f734a2.browser.esm.js ***!
  \*****************************************************************************/
/*! exports provided: m */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return manageState; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
var defaultProps = {
  defaultInputValue: '',
  defaultMenuIsOpen: false,
  defaultValue: null
};

var manageState = function manageState(SelectComponent) {
  var _class, _temp;

  return _temp = _class =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(StateManager, _Component);

    function StateManager() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Component.call.apply(_Component, [this].concat(args)) || this;
      _this.select = void 0;
      _this.state = {
        inputValue: _this.props.inputValue !== undefined ? _this.props.inputValue : _this.props.defaultInputValue,
        menuIsOpen: _this.props.menuIsOpen !== undefined ? _this.props.menuIsOpen : _this.props.defaultMenuIsOpen,
        value: _this.props.value !== undefined ? _this.props.value : _this.props.defaultValue
      };

      _this.onChange = function (value, actionMeta) {
        _this.callProp('onChange', value, actionMeta);

        _this.setState({
          value: value
        });
      };

      _this.onInputChange = function (value, actionMeta) {
        // TODO: for backwards compatibility, we allow the prop to return a new
        // value, but now inputValue is a controllable prop we probably shouldn't
        var newValue = _this.callProp('onInputChange', value, actionMeta);

        _this.setState({
          inputValue: newValue !== undefined ? newValue : value
        });
      };

      _this.onMenuOpen = function () {
        _this.callProp('onMenuOpen');

        _this.setState({
          menuIsOpen: true
        });
      };

      _this.onMenuClose = function () {
        _this.callProp('onMenuClose');

        _this.setState({
          menuIsOpen: false
        });
      };

      return _this;
    }

    var _proto = StateManager.prototype;

    _proto.focus = function focus() {
      this.select.focus();
    };

    _proto.blur = function blur() {
      this.select.blur();
    } // FIXME: untyped flow code, return any
    ;

    _proto.getProp = function getProp(key) {
      return this.props[key] !== undefined ? this.props[key] : this.state[key];
    } // FIXME: untyped flow code, return any
    ;

    _proto.callProp = function callProp(name) {
      if (typeof this.props[name] === 'function') {
        var _this$props;

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        return (_this$props = this.props)[name].apply(_this$props, args);
      }
    };

    _proto.render = function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          defaultInputValue = _this$props2.defaultInputValue,
          defaultMenuIsOpen = _this$props2.defaultMenuIsOpen,
          defaultValue = _this$props2.defaultValue,
          props = _objectWithoutPropertiesLoose(_this$props2, ["defaultInputValue", "defaultMenuIsOpen", "defaultValue"]);

      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(SelectComponent, _extends({}, props, {
        ref: function ref(_ref) {
          _this2.select = _ref;
        },
        inputValue: this.getProp('inputValue'),
        menuIsOpen: this.getProp('menuIsOpen'),
        onChange: this.onChange,
        onInputChange: this.onInputChange,
        onMenuClose: this.onMenuClose,
        onMenuOpen: this.onMenuOpen,
        value: this.getProp('value')
      }));
    };

    return StateManager;
  }(react__WEBPACK_IMPORTED_MODULE_0__["Component"]), _class.defaultProps = defaultProps, _temp;
};




/***/ }),

/***/ "./node_modules/react-select/dist/utils-06b0d5a4.browser.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-select/dist/utils-06b0d5a4.browser.esm.js ***!
  \**********************************************************************/
/*! exports provided: a, b, c, d, e, f, g, h, i, j, k, n, s */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getScrollParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getScrollTop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return animatedScrollTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isMobileDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return cleanValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return scrollIntoView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getBoundingClientObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return classNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return isTouchCapable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return isDocumentElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return handleInputChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return scrollTo; });
// ==============================
// NO OP
// ==============================
var noop = function noop() {};
// Class Name Prefixer
// ==============================

/**
 String representation of component state for styling with class names.

 Expects an array of strings OR a string/object pair:
 - className(['comp', 'comp-arg', 'comp-arg-2'])
   @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
 - className('comp', { some: true, state: false })
   @returns 'react-select__comp react-select__comp--some'
*/

function applyPrefixToName(prefix, name) {
  if (!name) {
    return prefix;
  } else if (name[0] === '-') {
    return prefix + name;
  } else {
    return prefix + '__' + name;
  }
}

function classNames(prefix, state, className) {
  var arr = [className];

  if (state && prefix) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("" + applyPrefixToName(prefix, key));
      }
    }
  }

  return arr.filter(function (i) {
    return i;
  }).map(function (i) {
    return String(i).trim();
  }).join(' ');
} // ==============================
// Clean Value
// ==============================

var cleanValue = function cleanValue(value) {
  if (Array.isArray(value)) return value.filter(Boolean);
  if (typeof value === 'object' && value !== null) return [value];
  return [];
}; // ==============================
// Handle Input Change
// ==============================

function handleInputChange(inputValue, actionMeta, onInputChange) {
  if (onInputChange) {
    var newValue = onInputChange(inputValue, actionMeta);
    if (typeof newValue === 'string') return newValue;
  }

  return inputValue;
} // ==============================
// Scroll Helpers
// ==============================

function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
} // Normalized Scroll Top
// ------------------------------

function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }

  return el.scrollTop;
}
function scrollTo(el, top) {
  // with a scroll distance, we perform scroll on the element
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }

  el.scrollTop = top;
} // Get Scroll Parent
// ------------------------------

function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === 'absolute';
  var overflowRx = /(auto|scroll)/;
  var docEl = document.documentElement; // suck it, flow...

  if (style.position === 'fixed') return docEl;

  for (var parent = element; parent = parent.parentElement;) {
    style = getComputedStyle(parent);

    if (excludeStaticParent && style.position === 'static') {
      continue;
    }

    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }

  return docEl;
} // Animated Scroll To
// ------------------------------

/**
  @param t: time (elapsed)
  @param b: initial value
  @param c: amount of change
  @param d: duration
*/

function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}

function animatedScrollTo(element, to, duration, callback) {
  if (duration === void 0) {
    duration = 200;
  }

  if (callback === void 0) {
    callback = noop;
  }

  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;

  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);

    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }

  animateScroll();
} // Scroll Into View
// ------------------------------

function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;

  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
} // ==============================
// Get bounding client object
// ==============================
// cannot get keys using array notation with DOMRect

function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
// Touch Capability Detector
// ==============================

function isTouchCapable() {
  try {
    document.createEvent('TouchEvent');
    return true;
  } catch (e) {
    return false;
  }
} // ==============================
// Mobile Device Detector
// ==============================

function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e) {
    return false;
  }
}




/***/ }),

/***/ "./node_modules/sanitize-html/dist/sanitize-html.js":
/*!**********************************************************!*\
  !*** ./node_modules/sanitize-html/dist/sanitize-html.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance");}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)==="[object Arguments]")return Array.from(iter);}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}}function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}(function(f){if(( false?undefined:_typeof(exports))==="object"&&typeof module!=="undefined"){module.exports=f();}else if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else{ var g; }})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a;}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r);},p,p.exports,r,e,n,t);}return n[i].exports;}for(var u="function"==typeof require&&require,i=0;i<t.length;i++){o(t[i]);}return o;}return r;}()({1:[function(require,module,exports){'use strict';exports.byteLength=byteLength;exports.toByteArray=toByteArray;exports.fromByteArray=fromByteArray;var lookup=[];var revLookup=[];var Arr=typeof Uint8Array!=='undefined'?Uint8Array:Array;var code='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';for(var i=0,len=code.length;i<len;++i){lookup[i]=code[i];revLookup[code.charCodeAt(i)]=i;}// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)]=62;revLookup['_'.charCodeAt(0)]=63;function getLens(b64){var len=b64.length;if(len%4>0){throw new Error('Invalid string. Length must be a multiple of 4');}// Trim off extra bytes after placeholder bytes are found
// See: https://github.com/beatgammit/base64-js/issues/42
var validLen=b64.indexOf('=');if(validLen===-1)validLen=len;var placeHoldersLen=validLen===len?0:4-validLen%4;return[validLen,placeHoldersLen];}// base64 is 4/3 + up to two characters of the original data
function byteLength(b64){var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function _byteLength(b64,validLen,placeHoldersLen){return(validLen+placeHoldersLen)*3/4-placeHoldersLen;}function toByteArray(b64){var tmp;var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];var arr=new Arr(_byteLength(b64,validLen,placeHoldersLen));var curByte=0;// if there are placeholders, only get up to the last complete 4 chars
var len=placeHoldersLen>0?validLen-4:validLen;var i;for(i=0;i<len;i+=4){tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)];arr[curByte++]=tmp>>16&0xFF;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===2){tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===1){tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}return arr;}function tripletToBase64(num){return lookup[num>>18&0x3F]+lookup[num>>12&0x3F]+lookup[num>>6&0x3F]+lookup[num&0x3F];}function encodeChunk(uint8,start,end){var tmp;var output=[];for(var i=start;i<end;i+=3){tmp=(uint8[i]<<16&0xFF0000)+(uint8[i+1]<<8&0xFF00)+(uint8[i+2]&0xFF);output.push(tripletToBase64(tmp));}return output.join('');}function fromByteArray(uint8){var tmp;var len=uint8.length;var extraBytes=len%3;// if we have 1 byte left, pad 2 bytes
var parts=[];var maxChunkLength=16383;// must be multiple of 3
// go through the array every three bytes, we'll deal with trailing stuff later
for(var i=0,len2=len-extraBytes;i<len2;i+=maxChunkLength){parts.push(encodeChunk(uint8,i,i+maxChunkLength>len2?len2:i+maxChunkLength));}// pad the end with zeros, but make sure to not forget the extra bytes
if(extraBytes===1){tmp=uint8[len-1];parts.push(lookup[tmp>>2]+lookup[tmp<<4&0x3F]+'==');}else if(extraBytes===2){tmp=(uint8[len-2]<<8)+uint8[len-1];parts.push(lookup[tmp>>10]+lookup[tmp>>4&0x3F]+lookup[tmp<<2&0x3F]+'=');}return parts.join('');}},{}],2:[function(require,module,exports){},{}],3:[function(require,module,exports){(function(Buffer){/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */'use strict';var base64=require('base64-js');var ieee754=require('ieee754');var customInspectSymbol=typeof Symbol==='function'&&typeof Symbol["for"]==='function'?Symbol["for"]('nodejs.util.inspect.custom'):null;exports.Buffer=Buffer;exports.SlowBuffer=SlowBuffer;exports.INSPECT_MAX_BYTES=50;var K_MAX_LENGTH=0x7fffffff;exports.kMaxLength=K_MAX_LENGTH;/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!=='undefined'&&typeof console.error==='function'){console.error('This browser lacks typed array (Uint8Array) support which is required by '+'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');}function typedArraySupport(){// Can typed array instances can be augmented?
try{var arr=new Uint8Array(1);var proto={foo:function foo(){return 42;}};Object.setPrototypeOf(proto,Uint8Array.prototype);Object.setPrototypeOf(arr,proto);return arr.foo()===42;}catch(e){return false;}}Object.defineProperty(Buffer.prototype,'parent',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.buffer;}});Object.defineProperty(Buffer.prototype,'offset',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset;}});function createBuffer(length){if(length>K_MAX_LENGTH){throw new RangeError('The value "'+length+'" is invalid for option "size"');}// Return an augmented `Uint8Array` instance
var buf=new Uint8Array(length);Object.setPrototypeOf(buf,Buffer.prototype);return buf;}/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */function Buffer(arg,encodingOrOffset,length){// Common case.
if(typeof arg==='number'){if(typeof encodingOrOffset==='string'){throw new TypeError('The "string" argument must be of type string. Received type number');}return allocUnsafe(arg);}return from(arg,encodingOrOffset,length);}// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if(typeof Symbol!=='undefined'&&Symbol.species!=null&&Buffer[Symbol.species]===Buffer){Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:true,enumerable:false,writable:false});}Buffer.poolSize=8192;// not used by this implementation
function from(value,encodingOrOffset,length){if(typeof value==='string'){return fromString(value,encodingOrOffset);}if(ArrayBuffer.isView(value)){return fromArrayLike(value);}if(value==null){throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}if(isInstance(value,ArrayBuffer)||value&&isInstance(value.buffer,ArrayBuffer)){return fromArrayBuffer(value,encodingOrOffset,length);}if(typeof SharedArrayBuffer!=='undefined'&&(isInstance(value,SharedArrayBuffer)||value&&isInstance(value.buffer,SharedArrayBuffer))){return fromArrayBuffer(value,encodingOrOffset,length);}if(typeof value==='number'){throw new TypeError('The "value" argument must not be of type number. Received type number');}var valueOf=value.valueOf&&value.valueOf();if(valueOf!=null&&valueOf!==value){return Buffer.from(valueOf,encodingOrOffset,length);}var b=fromObject(value);if(b)return b;if(typeof Symbol!=='undefined'&&Symbol.toPrimitive!=null&&typeof value[Symbol.toPrimitive]==='function'){return Buffer.from(value[Symbol.toPrimitive]('string'),encodingOrOffset,length);}throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length);};// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(size){if(typeof size!=='number'){throw new TypeError('"size" argument must be of type number');}else if(size<0){throw new RangeError('The value "'+size+'" is invalid for option "size"');}}function alloc(size,fill,encoding){assertSize(size);if(size<=0){return createBuffer(size);}if(fill!==undefined){// Only pay attention to encoding if it's a string. This
// prevents accidentally sending in a number that would
// be interpretted as a start offset.
return typeof encoding==='string'?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill);}return createBuffer(size);}/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/Buffer.alloc=function(size,fill,encoding){return alloc(size,fill,encoding);};function allocUnsafe(size){assertSize(size);return createBuffer(size<0?0:checked(size)|0);}/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */Buffer.allocUnsafe=function(size){return allocUnsafe(size);};/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size);};function fromString(string,encoding){if(typeof encoding!=='string'||encoding===''){encoding='utf8';}if(!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}var length=byteLength(string,encoding)|0;var buf=createBuffer(length);var actual=buf.write(string,encoding);if(actual!==length){// Writing a hex string, for example, that contains invalid characters will
// cause everything after the first invalid character to be ignored. (e.g.
// 'abxxcd' will be treated as 'ab')
buf=buf.slice(0,actual);}return buf;}function fromArrayLike(array){var length=array.length<0?0:checked(array.length)|0;var buf=createBuffer(length);for(var i=0;i<length;i+=1){buf[i]=array[i]&255;}return buf;}function fromArrayBuffer(array,byteOffset,length){if(byteOffset<0||array.byteLength<byteOffset){throw new RangeError('"offset" is outside of buffer bounds');}if(array.byteLength<byteOffset+(length||0)){throw new RangeError('"length" is outside of buffer bounds');}var buf;if(byteOffset===undefined&&length===undefined){buf=new Uint8Array(array);}else if(length===undefined){buf=new Uint8Array(array,byteOffset);}else{buf=new Uint8Array(array,byteOffset,length);}// Return an augmented `Uint8Array` instance
Object.setPrototypeOf(buf,Buffer.prototype);return buf;}function fromObject(obj){if(Buffer.isBuffer(obj)){var len=checked(obj.length)|0;var buf=createBuffer(len);if(buf.length===0){return buf;}obj.copy(buf,0,0,len);return buf;}if(obj.length!==undefined){if(typeof obj.length!=='number'||numberIsNaN(obj.length)){return createBuffer(0);}return fromArrayLike(obj);}if(obj.type==='Buffer'&&Array.isArray(obj.data)){return fromArrayLike(obj.data);}}function checked(length){// Note: cannot use `length < K_MAX_LENGTH` here because that fails when
// length is NaN (which is otherwise coerced to zero.)
if(length>=K_MAX_LENGTH){throw new RangeError('Attempt to allocate Buffer larger than maximum '+'size: 0x'+K_MAX_LENGTH.toString(16)+' bytes');}return length|0;}function SlowBuffer(length){if(+length!=length){// eslint-disable-line eqeqeq
length=0;}return Buffer.alloc(+length);}Buffer.isBuffer=function isBuffer(b){return b!=null&&b._isBuffer===true&&b!==Buffer.prototype;// so Buffer.isBuffer(Buffer.prototype) will be false
};Buffer.compare=function compare(a,b){if(isInstance(a,Uint8Array))a=Buffer.from(a,a.offset,a.byteLength);if(isInstance(b,Uint8Array))b=Buffer.from(b,b.offset,b.byteLength);if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b)){throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');}if(a===b)return 0;var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len;++i){if(a[i]!==b[i]){x=a[i];y=b[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};Buffer.isEncoding=function isEncoding(encoding){switch(String(encoding).toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return true;default:return false;}};Buffer.concat=function concat(list,length){if(!Array.isArray(list)){throw new TypeError('"list" argument must be an Array of Buffers');}if(list.length===0){return Buffer.alloc(0);}var i;if(length===undefined){length=0;for(i=0;i<list.length;++i){length+=list[i].length;}}var buffer=Buffer.allocUnsafe(length);var pos=0;for(i=0;i<list.length;++i){var buf=list[i];if(isInstance(buf,Uint8Array)){buf=Buffer.from(buf);}if(!Buffer.isBuffer(buf)){throw new TypeError('"list" argument must be an Array of Buffers');}buf.copy(buffer,pos);pos+=buf.length;}return buffer;};function byteLength(string,encoding){if(Buffer.isBuffer(string)){return string.length;}if(ArrayBuffer.isView(string)||isInstance(string,ArrayBuffer)){return string.byteLength;}if(typeof string!=='string'){throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. '+'Received type '+_typeof(string));}var len=string.length;var mustMatch=arguments.length>2&&arguments[2]===true;if(!mustMatch&&len===0)return 0;// Use a for loop to avoid recursion
var loweredCase=false;for(;;){switch(encoding){case'ascii':case'latin1':case'binary':return len;case'utf8':case'utf-8':return utf8ToBytes(string).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return len*2;case'hex':return len>>>1;case'base64':return base64ToBytes(string).length;default:if(loweredCase){return mustMatch?-1:utf8ToBytes(string).length;// assume utf8
}encoding=(''+encoding).toLowerCase();loweredCase=true;}}}Buffer.byteLength=byteLength;function slowToString(encoding,start,end){var loweredCase=false;// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
// property of a typed array.
// This behaves neither like String nor Uint8Array in that we set start/end
// to their upper/lower bounds if the value passed is out of range.
// undefined is handled specially as per ECMA-262 6th Edition,
// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
if(start===undefined||start<0){start=0;}// Return early if start > this.length. Done here to prevent potential uint32
// coercion fail below.
if(start>this.length){return'';}if(end===undefined||end>this.length){end=this.length;}if(end<=0){return'';}// Force coersion to uint32. This will also coerce falsey/NaN values to 0.
end>>>=0;start>>>=0;if(end<=start){return'';}if(!encoding)encoding='utf8';while(true){switch(encoding){case'hex':return hexSlice(this,start,end);case'utf8':case'utf-8':return utf8Slice(this,start,end);case'ascii':return asciiSlice(this,start,end);case'latin1':case'binary':return latin1Slice(this,start,end);case'base64':return base64Slice(this,start,end);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(encoding+'').toLowerCase();loweredCase=true;}}}// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer=true;function swap(b,n,m){var i=b[n];b[n]=b[m];b[m]=i;}Buffer.prototype.swap16=function swap16(){var len=this.length;if(len%2!==0){throw new RangeError('Buffer size must be a multiple of 16-bits');}for(var i=0;i<len;i+=2){swap(this,i,i+1);}return this;};Buffer.prototype.swap32=function swap32(){var len=this.length;if(len%4!==0){throw new RangeError('Buffer size must be a multiple of 32-bits');}for(var i=0;i<len;i+=4){swap(this,i,i+3);swap(this,i+1,i+2);}return this;};Buffer.prototype.swap64=function swap64(){var len=this.length;if(len%8!==0){throw new RangeError('Buffer size must be a multiple of 64-bits');}for(var i=0;i<len;i+=8){swap(this,i,i+7);swap(this,i+1,i+6);swap(this,i+2,i+5);swap(this,i+3,i+4);}return this;};Buffer.prototype.toString=function toString(){var length=this.length;if(length===0)return'';if(arguments.length===0)return utf8Slice(this,0,length);return slowToString.apply(this,arguments);};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(b){if(!Buffer.isBuffer(b))throw new TypeError('Argument must be a Buffer');if(this===b)return true;return Buffer.compare(this,b)===0;};Buffer.prototype.inspect=function inspect(){var str='';var max=exports.INSPECT_MAX_BYTES;str=this.toString('hex',0,max).replace(/(.{2})/g,'$1 ').trim();if(this.length>max)str+=' ... ';return'<Buffer '+str+'>';};if(customInspectSymbol){Buffer.prototype[customInspectSymbol]=Buffer.prototype.inspect;}Buffer.prototype.compare=function compare(target,start,end,thisStart,thisEnd){if(isInstance(target,Uint8Array)){target=Buffer.from(target,target.offset,target.byteLength);}if(!Buffer.isBuffer(target)){throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. '+'Received type '+_typeof(target));}if(start===undefined){start=0;}if(end===undefined){end=target?target.length:0;}if(thisStart===undefined){thisStart=0;}if(thisEnd===undefined){thisEnd=this.length;}if(start<0||end>target.length||thisStart<0||thisEnd>this.length){throw new RangeError('out of range index');}if(thisStart>=thisEnd&&start>=end){return 0;}if(thisStart>=thisEnd){return-1;}if(start>=end){return 1;}start>>>=0;end>>>=0;thisStart>>>=0;thisEnd>>>=0;if(this===target)return 0;var x=thisEnd-thisStart;var y=end-start;var len=Math.min(x,y);var thisCopy=this.slice(thisStart,thisEnd);var targetCopy=target.slice(start,end);for(var i=0;i<len;++i){if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i];y=targetCopy[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){// Empty buffer means no match
if(buffer.length===0)return-1;// Normalize byteOffset
if(typeof byteOffset==='string'){encoding=byteOffset;byteOffset=0;}else if(byteOffset>0x7fffffff){byteOffset=0x7fffffff;}else if(byteOffset<-0x80000000){byteOffset=-0x80000000;}byteOffset=+byteOffset;// Coerce to Number.
if(numberIsNaN(byteOffset)){// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
byteOffset=dir?0:buffer.length-1;}// Normalize byteOffset: negative offsets start from the end of the buffer
if(byteOffset<0)byteOffset=buffer.length+byteOffset;if(byteOffset>=buffer.length){if(dir)return-1;else byteOffset=buffer.length-1;}else if(byteOffset<0){if(dir)byteOffset=0;else return-1;}// Normalize val
if(typeof val==='string'){val=Buffer.from(val,encoding);}// Finally, search either indexOf (if dir is true) or lastIndexOf
if(Buffer.isBuffer(val)){// Special case: looking for empty string/buffer always fails
if(val.length===0){return-1;}return arrayIndexOf(buffer,val,byteOffset,encoding,dir);}else if(typeof val==='number'){val=val&0xFF;// Search for a byte value [0-255]
if(typeof Uint8Array.prototype.indexOf==='function'){if(dir){return Uint8Array.prototype.indexOf.call(buffer,val,byteOffset);}else{return Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset);}}return arrayIndexOf(buffer,[val],byteOffset,encoding,dir);}throw new TypeError('val must be string, number or Buffer');}function arrayIndexOf(arr,val,byteOffset,encoding,dir){var indexSize=1;var arrLength=arr.length;var valLength=val.length;if(encoding!==undefined){encoding=String(encoding).toLowerCase();if(encoding==='ucs2'||encoding==='ucs-2'||encoding==='utf16le'||encoding==='utf-16le'){if(arr.length<2||val.length<2){return-1;}indexSize=2;arrLength/=2;valLength/=2;byteOffset/=2;}}function read(buf,i){if(indexSize===1){return buf[i];}else{return buf.readUInt16BE(i*indexSize);}}var i;if(dir){var foundIndex=-1;for(i=byteOffset;i<arrLength;i++){if(read(arr,i)===read(val,foundIndex===-1?0:i-foundIndex)){if(foundIndex===-1)foundIndex=i;if(i-foundIndex+1===valLength)return foundIndex*indexSize;}else{if(foundIndex!==-1)i-=i-foundIndex;foundIndex=-1;}}}else{if(byteOffset+valLength>arrLength)byteOffset=arrLength-valLength;for(i=byteOffset;i>=0;i--){var found=true;for(var j=0;j<valLength;j++){if(read(arr,i+j)!==read(val,j)){found=false;break;}}if(found)return i;}}return-1;}Buffer.prototype.includes=function includes(val,byteOffset,encoding){return this.indexOf(val,byteOffset,encoding)!==-1;};Buffer.prototype.indexOf=function indexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,true);};Buffer.prototype.lastIndexOf=function lastIndexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,false);};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining;}else{length=Number(length);if(length>remaining){length=remaining;}}var strLen=string.length;if(length>strLen/2){length=strLen/2;}for(var i=0;i<length;++i){var parsed=parseInt(string.substr(i*2,2),16);if(numberIsNaN(parsed))return i;buf[offset+i]=parsed;}return i;}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length);}function asciiWrite(buf,string,offset,length){return blitBuffer(asciiToBytes(string),buf,offset,length);}function latin1Write(buf,string,offset,length){return asciiWrite(buf,string,offset,length);}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length);}function ucs2Write(buf,string,offset,length){return blitBuffer(utf16leToBytes(string,buf.length-offset),buf,offset,length);}Buffer.prototype.write=function write(string,offset,length,encoding){// Buffer#write(string)
if(offset===undefined){encoding='utf8';length=this.length;offset=0;// Buffer#write(string, encoding)
}else if(length===undefined&&typeof offset==='string'){encoding=offset;length=this.length;offset=0;// Buffer#write(string, offset[, length][, encoding])
}else if(isFinite(offset)){offset=offset>>>0;if(isFinite(length)){length=length>>>0;if(encoding===undefined)encoding='utf8';}else{encoding=length;length=undefined;}}else{throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');}var remaining=this.length-offset;if(length===undefined||length>remaining)length=remaining;if(string.length>0&&(length<0||offset<0)||offset>this.length){throw new RangeError('Attempt to write outside buffer bounds');}if(!encoding)encoding='utf8';var loweredCase=false;for(;;){switch(encoding){case'hex':return hexWrite(this,string,offset,length);case'utf8':case'utf-8':return utf8Write(this,string,offset,length);case'ascii':return asciiWrite(this,string,offset,length);case'latin1':case'binary':return latin1Write(this,string,offset,length);case'base64':// Warning: maxLength not taken into account in base64Write
return base64Write(this,string,offset,length);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(''+encoding).toLowerCase();loweredCase=true;}}};Buffer.prototype.toJSON=function toJSON(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)};};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf);}else{return base64.fromByteArray(buf.slice(start,end));}}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);var res=[];var i=start;while(i<end){var firstByte=buf[i];var codePoint=null;var bytesPerSequence=firstByte>0xEF?4:firstByte>0xDF?3:firstByte>0xBF?2:1;if(i+bytesPerSequence<=end){var secondByte,thirdByte,fourthByte,tempCodePoint;switch(bytesPerSequence){case 1:if(firstByte<0x80){codePoint=firstByte;}break;case 2:secondByte=buf[i+1];if((secondByte&0xC0)===0x80){tempCodePoint=(firstByte&0x1F)<<0x6|secondByte&0x3F;if(tempCodePoint>0x7F){codePoint=tempCodePoint;}}break;case 3:secondByte=buf[i+1];thirdByte=buf[i+2];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0xC|(secondByte&0x3F)<<0x6|thirdByte&0x3F;if(tempCodePoint>0x7FF&&(tempCodePoint<0xD800||tempCodePoint>0xDFFF)){codePoint=tempCodePoint;}}break;case 4:secondByte=buf[i+1];thirdByte=buf[i+2];fourthByte=buf[i+3];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80&&(fourthByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0x12|(secondByte&0x3F)<<0xC|(thirdByte&0x3F)<<0x6|fourthByte&0x3F;if(tempCodePoint>0xFFFF&&tempCodePoint<0x110000){codePoint=tempCodePoint;}}}}if(codePoint===null){// we did not generate a valid codePoint so insert a
// replacement char (U+FFFD) and advance only 1 byte
codePoint=0xFFFD;bytesPerSequence=1;}else if(codePoint>0xFFFF){// encode to utf16 (surrogate pair dance)
codePoint-=0x10000;res.push(codePoint>>>10&0x3FF|0xD800);codePoint=0xDC00|codePoint&0x3FF;}res.push(codePoint);i+=bytesPerSequence;}return decodeCodePointsArray(res);}// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH=0x1000;function decodeCodePointsArray(codePoints){var len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH){return String.fromCharCode.apply(String,codePoints);// avoid extra slice()
}// Decode in chunks to avoid "call stack size exceeded".
var res='';var i=0;while(i<len){res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));}return res;}function asciiSlice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]&0x7F);}return ret;}function latin1Slice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]);}return ret;}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out='';for(var i=start;i<end;++i){out+=hexSliceLookupTable[buf[i]];}return out;}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res='';for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256);}return res;}Buffer.prototype.slice=function slice(start,end){var len=this.length;start=~~start;end=end===undefined?len:~~end;if(start<0){start+=len;if(start<0)start=0;}else if(start>len){start=len;}if(end<0){end+=len;if(end<0)end=0;}else if(end>len){end=len;}if(end<start)end=start;var newBuf=this.subarray(start,end);// Return an augmented `Uint8Array` instance
Object.setPrototypeOf(newBuf,Buffer.prototype);return newBuf;};/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */function checkOffset(offset,ext,length){if(offset%1!==0||offset<0)throw new RangeError('offset is not uint');if(offset+ext>length)throw new RangeError('Trying to access beyond buffer length');}Buffer.prototype.readUIntLE=function readUIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}return val;};Buffer.prototype.readUIntBE=function readUIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){checkOffset(offset,byteLength,this.length);}var val=this[offset+--byteLength];var mul=1;while(byteLength>0&&(mul*=0x100)){val+=this[offset+--byteLength]*mul;}return val;};Buffer.prototype.readUInt8=function readUInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);return this[offset];};Buffer.prototype.readUInt16LE=function readUInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]|this[offset+1]<<8;};Buffer.prototype.readUInt16BE=function readUInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]<<8|this[offset+1];};Buffer.prototype.readUInt32LE=function readUInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+this[offset+3]*0x1000000;};Buffer.prototype.readUInt32BE=function readUInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]*0x1000000+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3]);};Buffer.prototype.readIntLE=function readIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readIntBE=function readIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var i=byteLength;var mul=1;var val=this[offset+--i];while(i>0&&(mul*=0x100)){val+=this[offset+--i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readInt8=function readInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);if(!(this[offset]&0x80))return this[offset];return(0xff-this[offset]+1)*-1;};Buffer.prototype.readInt16LE=function readInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset]|this[offset+1]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt16BE=function readInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset+1]|this[offset]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt32LE=function readInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24;};Buffer.prototype.readInt32BE=function readInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3];};Buffer.prototype.readFloatLE=function readFloatLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,true,23,4);};Buffer.prototype.readFloatBE=function readFloatBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,false,23,4);};Buffer.prototype.readDoubleLE=function readDoubleLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,true,52,8);};Buffer.prototype.readDoubleBE=function readDoubleBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,false,52,8);};function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');if(value>max||value<min)throw new RangeError('"value" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError('Index out of range');}Buffer.prototype.writeUIntLE=function writeUIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var mul=1;var i=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUIntBE=function writeUIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var i=byteLength-1;var mul=1;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUInt8=function writeUInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0xff,0);this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeUInt16LE=function writeUInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeUInt16BE=function writeUInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeUInt32LE=function writeUInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset+3]=value>>>24;this[offset+2]=value>>>16;this[offset+1]=value>>>8;this[offset]=value&0xff;return offset+4;};Buffer.prototype.writeUInt32BE=function writeUInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};Buffer.prototype.writeIntLE=function writeIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=0;var mul=1;var sub=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i-1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeIntBE=function writeIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=byteLength-1;var mul=1;var sub=0;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i+1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeInt8=function writeInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0x7f,-0x80);if(value<0)value=0xff+value+1;this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeInt16LE=function writeInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeInt16BE=function writeInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeInt32LE=function writeInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);this[offset]=value&0xff;this[offset+1]=value>>>8;this[offset+2]=value>>>16;this[offset+3]=value>>>24;return offset+4;};Buffer.prototype.writeInt32BE=function writeInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);if(value<0)value=0xffffffff+value+1;this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError('Index out of range');if(offset<0)throw new RangeError('Index out of range');}function writeFloat(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,4,3.4028234663852886e+38,-3.4028234663852886e+38);}ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4;}Buffer.prototype.writeFloatLE=function writeFloatLE(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert);};Buffer.prototype.writeFloatBE=function writeFloatBE(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert);};function writeDouble(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,8,1.7976931348623157E+308,-1.7976931348623157E+308);}ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8;}Buffer.prototype.writeDoubleLE=function writeDoubleLE(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert);};Buffer.prototype.writeDoubleBE=function writeDoubleBE(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert);};// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy=function copy(target,targetStart,start,end){if(!Buffer.isBuffer(target))throw new TypeError('argument should be a Buffer');if(!start)start=0;if(!end&&end!==0)end=this.length;if(targetStart>=target.length)targetStart=target.length;if(!targetStart)targetStart=0;if(end>0&&end<start)end=start;// Copy 0 bytes; we're done
if(end===start)return 0;if(target.length===0||this.length===0)return 0;// Fatal error conditions
if(targetStart<0){throw new RangeError('targetStart out of bounds');}if(start<0||start>=this.length)throw new RangeError('Index out of range');if(end<0)throw new RangeError('sourceEnd out of bounds');// Are we oob?
if(end>this.length)end=this.length;if(target.length-targetStart<end-start){end=target.length-targetStart+start;}var len=end-start;if(this===target&&typeof Uint8Array.prototype.copyWithin==='function'){// Use built-in when available, missing from IE11
this.copyWithin(targetStart,start,end);}else if(this===target&&start<targetStart&&targetStart<end){// descending copy from end
for(var i=len-1;i>=0;--i){target[i+targetStart]=this[i+start];}}else{Uint8Array.prototype.set.call(target,this.subarray(start,end),targetStart);}return len;};// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill=function fill(val,start,end,encoding){// Handle string cases:
if(typeof val==='string'){if(typeof start==='string'){encoding=start;start=0;end=this.length;}else if(typeof end==='string'){encoding=end;end=this.length;}if(encoding!==undefined&&typeof encoding!=='string'){throw new TypeError('encoding must be a string');}if(typeof encoding==='string'&&!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}if(val.length===1){var code=val.charCodeAt(0);if(encoding==='utf8'&&code<128||encoding==='latin1'){// Fast path: If `val` fits into a single byte, use that numeric value.
val=code;}}}else if(typeof val==='number'){val=val&255;}else if(typeof val==='boolean'){val=Number(val);}// Invalid ranges are not set to a default, so can range check early.
if(start<0||this.length<start||this.length<end){throw new RangeError('Out of range index');}if(end<=start){return this;}start=start>>>0;end=end===undefined?this.length:end>>>0;if(!val)val=0;var i;if(typeof val==='number'){for(i=start;i<end;++i){this[i]=val;}}else{var bytes=Buffer.isBuffer(val)?val:Buffer.from(val,encoding);var len=bytes.length;if(len===0){throw new TypeError('The value "'+val+'" is invalid for argument "value"');}for(i=0;i<end-start;++i){this[i+start]=bytes[i%len];}}return this;};// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function base64clean(str){// Node takes equal signs as end of the Base64 encoding
str=str.split('=')[0];// Node strips out invalid characters like \n and \t from the string, base64-js does not
str=str.trim().replace(INVALID_BASE64_RE,'');// Node converts strings with length < 2 to ''
if(str.length<2)return'';// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
while(str.length%4!==0){str=str+'=';}return str;}function utf8ToBytes(string,units){units=units||Infinity;var codePoint;var length=string.length;var leadSurrogate=null;var bytes=[];for(var i=0;i<length;++i){codePoint=string.charCodeAt(i);// is surrogate component
if(codePoint>0xD7FF&&codePoint<0xE000){// last char was a lead
if(!leadSurrogate){// no lead yet
if(codePoint>0xDBFF){// unexpected trail
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}else if(i+1===length){// unpaired lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}// valid lead
leadSurrogate=codePoint;continue;}// 2 leads in a row
if(codePoint<0xDC00){if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);leadSurrogate=codePoint;continue;}// valid surrogate pair
codePoint=(leadSurrogate-0xD800<<10|codePoint-0xDC00)+0x10000;}else if(leadSurrogate){// valid bmp char, but last char was a lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);}leadSurrogate=null;// encode utf8
if(codePoint<0x80){if((units-=1)<0)break;bytes.push(codePoint);}else if(codePoint<0x800){if((units-=2)<0)break;bytes.push(codePoint>>0x6|0xC0,codePoint&0x3F|0x80);}else if(codePoint<0x10000){if((units-=3)<0)break;bytes.push(codePoint>>0xC|0xE0,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else if(codePoint<0x110000){if((units-=4)<0)break;bytes.push(codePoint>>0x12|0xF0,codePoint>>0xC&0x3F|0x80,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else{throw new Error('Invalid code point');}}return bytes;}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;++i){// Node's code seems to be doing this and not & 0x7F..
byteArray.push(str.charCodeAt(i)&0xFF);}return byteArray;}function utf16leToBytes(str,units){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;++i){if((units-=2)<0)break;c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi);}return byteArray;}function base64ToBytes(str){return base64.toByteArray(base64clean(str));}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;++i){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i];}return i;}// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj,type){return obj instanceof type||obj!=null&&obj.constructor!=null&&obj.constructor.name!=null&&obj.constructor.name===type.name;}function numberIsNaN(obj){// For IE11 support
return obj!==obj;// eslint-disable-line no-self-compare
}// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable=function(){var alphabet='0123456789abcdef';var table=new Array(256);for(var i=0;i<16;++i){var i16=i*16;for(var j=0;j<16;++j){table[i16+j]=alphabet[i]+alphabet[j];}}return table;}();}).call(this,require("buffer").Buffer);},{"base64-js":1,"buffer":3,"ieee754":32}],4:[function(require,module,exports){module.exports={"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}};},{}],5:[function(require,module,exports){/*
  Module dependencies
*/var ElementType=require('domelementtype');var entities=require('entities');/* mixed-case SVG and MathML tags & attributes
   recognized by the HTML parser, see
   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
*/var foreignNames=require('./foreignNames.json');foreignNames.elementNames.__proto__=null;/* use as a simple dictionary */foreignNames.attributeNames.__proto__=null;var unencodedElements={__proto__:null,style:true,script:true,xmp:true,iframe:true,noembed:true,noframes:true,plaintext:true,noscript:true};/*
  Format attributes
*/function formatAttrs(attributes,opts){if(!attributes)return;var output='';var value;// Loop through the attributes
for(var key in attributes){value=attributes[key];if(output){output+=' ';}if(opts.xmlMode==='foreign'){/* fix up mixed-case attribute names */key=foreignNames.attributeNames[key]||key;}output+=key;if(value!==null&&value!==''||opts.xmlMode){output+='="'+(opts.decodeEntities?entities.encodeXML(value):value.replace(/\"/g,'&quot;'))+'"';}}return output;}/*
  Self-enclosing tags (stolen from node-htmlparser)
*/var singleTag={__proto__:null,area:true,base:true,basefont:true,br:true,col:true,command:true,embed:true,frame:true,hr:true,img:true,input:true,isindex:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};var render=module.exports=function(dom,opts){if(!Array.isArray(dom)&&!dom.cheerio)dom=[dom];opts=opts||{};var output='';for(var i=0;i<dom.length;i++){var elem=dom[i];if(elem.type==='root')output+=render(elem.children,opts);else if(ElementType.isTag(elem))output+=renderTag(elem,opts);else if(elem.type===ElementType.Directive)output+=renderDirective(elem);else if(elem.type===ElementType.Comment)output+=renderComment(elem);else if(elem.type===ElementType.CDATA)output+=renderCdata(elem);else output+=renderText(elem,opts);}return output;};var foreignModeIntegrationPoints=['mi','mo','mn','ms','mtext','annotation-xml','foreignObject','desc','title'];function renderTag(elem,opts){// Handle SVG / MathML in HTML
if(opts.xmlMode==='foreign'){/* fix up mixed-case element names */elem.name=foreignNames.elementNames[elem.name]||elem.name;/* exit foreign mode at integration points */if(elem.parent&&foreignModeIntegrationPoints.indexOf(elem.parent.name)>=0)opts=Object.assign({},opts,{xmlMode:false});}if(!opts.xmlMode&&['svg','math'].indexOf(elem.name)>=0){opts=Object.assign({},opts,{xmlMode:'foreign'});}var tag='<'+elem.name;var attribs=formatAttrs(elem.attribs,opts);if(attribs){tag+=' '+attribs;}if(opts.xmlMode&&(!elem.children||elem.children.length===0)){tag+='/>';}else{tag+='>';if(elem.children){tag+=render(elem.children,opts);}if(!singleTag[elem.name]||opts.xmlMode){tag+='</'+elem.name+'>';}}return tag;}function renderDirective(elem){return'<'+elem.data+'>';}function renderText(elem,opts){var data=elem.data||'';// if entities weren't decoded, no need to encode them back
if(opts.decodeEntities&&!(elem.parent&&elem.parent.name in unencodedElements)){data=entities.encodeXML(data);}return data;}function renderCdata(elem){return'<![CDATA['+elem.children[0].data+']]>';}function renderComment(elem){return'<!--'+elem.data+'-->';}},{"./foreignNames.json":4,"domelementtype":6,"entities":20}],6:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */function isTag(elem){return elem.type==="tag"/* Tag */||elem.type==="script"/* Script */||elem.type==="style"/* Style */;}exports.isTag=isTag;// Exports for backwards compatibility
exports.Text="text"/* Text */;//Text
exports.Directive="directive"/* Directive */;//<? ... ?>
exports.Comment="comment"/* Comment */;//<!-- ... -->
exports.Script="script"/* Script */;//<script> tags
exports.Style="style"/* Style */;//<style> tags
exports.Tag="tag"/* Tag */;//Any tag
exports.CDATA="cdata"/* CDATA */;//<![CDATA[ ... ]]>
exports.Doctype="doctype"/* Doctype */;},{}],7:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var node_1=require("./node");exports.Node=node_1.Node;exports.Element=node_1.Element;exports.DataNode=node_1.DataNode;exports.NodeWithChildren=node_1.NodeWithChildren;var reWhitespace=/\s+/g;// Default options
var defaultOpts={normalizeWhitespace:false,withStartIndices:false,withEndIndices:false};var DomHandler=/** @class */function(){/**
     * Initiate a new DomHandler.
     *
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */function DomHandler(callback,options,elementCB){/** The constructed DOM */this.dom=[];/** Indicated whether parsing has been completed. */this._done=false;/** Stack of open tags. */this._tagStack=[];/** A data node that is still being written to. */this._lastNode=null;/** Reference to the parser instance. Used for location information. */this._parser=null;// Make it possible to skip arguments, for backwards-compatibility
if(typeof options==="function"){elementCB=options;options=defaultOpts;}if(_typeof(callback)==="object"){options=callback;callback=undefined;}this._callback=callback||null;this._options=options||defaultOpts;this._elementCB=elementCB||null;}DomHandler.prototype.onparserinit=function(parser){this._parser=parser;};// Resets the handler back to starting state
DomHandler.prototype.onreset=function(){this.dom=[];this._done=false;this._tagStack=[];this._lastNode=null;this._parser=this._parser||null;};// Signals the handler that parsing is done
DomHandler.prototype.onend=function(){if(this._done)return;this._done=true;this._parser=null;this.handleCallback(null);};DomHandler.prototype.onerror=function(error){this.handleCallback(error);};DomHandler.prototype.onclosetag=function(){this._lastNode=null;// If(this._tagStack.pop().name !== name) this.handleCallback(Error("Tagname didn't match!"));
var elem=this._tagStack.pop();if(!elem||!this._parser){return;}if(this._options.withEndIndices){elem.endIndex=this._parser.endIndex;}if(this._elementCB)this._elementCB(elem);};DomHandler.prototype.onopentag=function(name,attribs){var element=new node_1.Element(name,attribs);this.addNode(element);this._tagStack.push(element);};DomHandler.prototype.ontext=function(data){var normalize=this._options.normalizeWhitespace;var _lastNode=this._lastNode;if(_lastNode&&_lastNode.type==="text"/* Text */){if(normalize){_lastNode.data=(_lastNode.data+data).replace(reWhitespace," ");}else{_lastNode.data+=data;}}else{if(normalize){data=data.replace(reWhitespace," ");}var node=new node_1.DataNode("text"/* Text */,data);this.addNode(node);this._lastNode=node;}};DomHandler.prototype.oncomment=function(data){if(this._lastNode&&this._lastNode.type==="comment"/* Comment */){this._lastNode.data+=data;return;}var node=new node_1.DataNode("comment"/* Comment */,data);this.addNode(node);this._lastNode=node;};DomHandler.prototype.oncommentend=function(){this._lastNode=null;};DomHandler.prototype.oncdatastart=function(){var text=new node_1.DataNode("text"/* Text */,"");var node=new node_1.NodeWithChildren("cdata"/* CDATA */,[text]);this.addNode(node);text.parent=node;this._lastNode=text;};DomHandler.prototype.oncdataend=function(){this._lastNode=null;};DomHandler.prototype.onprocessinginstruction=function(name,data){var node=new node_1.ProcessingInstruction(name,data);this.addNode(node);};DomHandler.prototype.handleCallback=function(error){if(typeof this._callback==="function"){this._callback(error,this.dom);}else if(error){throw error;}};DomHandler.prototype.addNode=function(node){var parent=this._tagStack[this._tagStack.length-1];var siblings=parent?parent.children:this.dom;var previousSibling=siblings[siblings.length-1];if(this._parser){if(this._options.withStartIndices){node.startIndex=this._parser.startIndex;}if(this._options.withEndIndices){node.endIndex=this._parser.endIndex;}}siblings.push(node);if(previousSibling){node.prev=previousSibling;previousSibling.next=node;}if(parent){node.parent=parent;}this._lastNode=null;};DomHandler.prototype.addDataNode=function(node){this.addNode(node);this._lastNode=node;};return DomHandler;}();exports.DomHandler=DomHandler;exports["default"]=DomHandler;},{"./node":8}],8:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics(d,b);};return function(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var nodeTypes=new Map([["tag"/* Tag */,1],["script"/* Script */,1],["style"/* Style */,1],["directive"/* Directive */,1],["text"/* Text */,3],["cdata"/* CDATA */,4],["comment"/* Comment */,8]]);// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var Node=/** @class */function(){/**
     *
     * @param type The type of the node.
     */function Node(type){this.type=type;/** Parent of the node */this.parent=null;/** Previous sibling */this.prev=null;/** Next sibling */this.next=null;/** The start index of the node. Requires `withStartIndices` on the handler to be `true. */this.startIndex=null;/** The end index of the node. Requires `withEndIndices` on the handler to be `true. */this.endIndex=null;}Object.defineProperty(Node.prototype,"nodeType",{// Read-only aliases
get:function get(){return nodeTypes.get(this.type)||1;},enumerable:true,configurable:true});Object.defineProperty(Node.prototype,"parentNode",{// Read-write aliases for properties
get:function get(){return this.parent||null;},set:function set(parent){this.parent=parent;},enumerable:true,configurable:true});Object.defineProperty(Node.prototype,"previousSibling",{get:function get(){return this.prev||null;},set:function set(prev){this.prev=prev;},enumerable:true,configurable:true});Object.defineProperty(Node.prototype,"nextSibling",{get:function get(){return this.next||null;},set:function set(next){this.next=next;},enumerable:true,configurable:true});return Node;}();exports.Node=Node;var DataNode=/** @class */function(_super){__extends(DataNode,_super);/**
     *
     * @param type The type of the node
     * @param data The content of the data node
     */function DataNode(type,data){var _this=_super.call(this,type)||this;_this.data=data;return _this;}Object.defineProperty(DataNode.prototype,"nodeValue",{get:function get(){return this.data;},set:function set(data){this.data=data;},enumerable:true,configurable:true});return DataNode;}(Node);exports.DataNode=DataNode;var ProcessingInstruction=/** @class */function(_super){__extends(ProcessingInstruction,_super);function ProcessingInstruction(name,data){var _this=_super.call(this,"directive"/* Directive */,data)||this;_this.name=name;return _this;}return ProcessingInstruction;}(DataNode);exports.ProcessingInstruction=ProcessingInstruction;var NodeWithChildren=/** @class */function(_super){__extends(NodeWithChildren,_super);/**
     *
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */function NodeWithChildren(type,children){var _this=_super.call(this,type)||this;_this.children=children;return _this;}Object.defineProperty(NodeWithChildren.prototype,"firstChild",{// Aliases
get:function get(){return this.children[0]||null;},enumerable:true,configurable:true});Object.defineProperty(NodeWithChildren.prototype,"lastChild",{get:function get(){return this.children[this.children.length-1]||null;},enumerable:true,configurable:true});Object.defineProperty(NodeWithChildren.prototype,"childNodes",{get:function get(){return this.children;},set:function set(children){this.children=children;},enumerable:true,configurable:true});return NodeWithChildren;}(Node);exports.NodeWithChildren=NodeWithChildren;var Element=/** @class */function(_super){__extends(Element,_super);/**
     *
     * @param name Name of the tag, eg. `div`, `span`
     * @param attribs Object mapping attribute names to attribute values
     */function Element(name,attribs){var _this=_super.call(this,name==="script"?"script"/* Script */:name==="style"?"style"/* Style */:"tag"/* Tag */,[])||this;_this.name=name;_this.attribs=attribs;_this.attribs=attribs;return _this;}Object.defineProperty(Element.prototype,"tagName",{// DOM Level 1 aliases
get:function get(){return this.name;},set:function set(name){this.name=name;},enumerable:true,configurable:true});return Element;}(NodeWithChildren);exports.Element=Element;},{}],9:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tagtypes_1=require("./tagtypes");/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes — Nodes to filter.
 */function removeSubsets(nodes){var idx=nodes.length;// Check if each node (or one of its ancestors) is already contained in the
// array.
while(--idx>=0){var node=nodes[idx];// Remove the node if it is not unique.
// We are going through the array from the end, so we only
// have to check nodes that preceed the node under consideration in the array.
if(idx>0&&nodes.lastIndexOf(node,idx-1)>=0){nodes.splice(idx,1);continue;}for(var ancestor=node.parent;ancestor;ancestor=ancestor.parent){if(nodes.indexOf(ancestor)>-1){nodes.splice(idx,1);break;}}}return nodes;}exports.removeSubsets=removeSubsets;/***
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 * @argument nodaA The first node to use in the comparison
 * @argument nodeB The second node to use in the comparison
 *
 * @return A bitmask describing the input nodes' relative position.
 *
 *        See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 *        a description of these values.
 */function compareDocumentPosition(nodeA,nodeB){var aParents=[];var bParents=[];if(nodeA===nodeB){return 0;}var current=tagtypes_1.hasChildren(nodeA)?nodeA:nodeA.parent;while(current){aParents.unshift(current);current=current.parent;}current=tagtypes_1.hasChildren(nodeB)?nodeB:nodeB.parent;while(current){bParents.unshift(current);current=current.parent;}var idx=0;while(aParents[idx]===bParents[idx]){idx++;}if(idx===0){return 1/* DISCONNECTED */;}var sharedParent=aParents[idx-1];var siblings=sharedParent.children;var aSibling=aParents[idx];var bSibling=bParents[idx];if(siblings.indexOf(aSibling)>siblings.indexOf(bSibling)){if(sharedParent===nodeB){return 4/* FOLLOWING */|16/* CONTAINED_BY */;}return 4/* FOLLOWING */;}else{if(sharedParent===nodeA){return 2/* PRECEDING */|8/* CONTAINS */;}return 2/* PRECEDING */;}}exports.compareDocumentPosition=compareDocumentPosition;/***
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @argument nodes Array of DOM nodes
 * @returns collection of unique nodes, sorted in document order
 */function uniqueSort(nodes){nodes=nodes.filter(function(node,i,arr){return!arr.includes(node,i+1);});nodes.sort(function(a,b){var relative=compareDocumentPosition(a,b);if(relative&2/* PRECEDING */){return-1;}else if(relative&4/* FOLLOWING */){return 1;}return 0;});return nodes;}exports.uniqueSort=uniqueSort;},{"./tagtypes":15}],10:[function(require,module,exports){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}}Object.defineProperty(exports,"__esModule",{value:true});__export(require("./stringify"));__export(require("./traversal"));__export(require("./manipulation"));__export(require("./querying"));__export(require("./legacy"));__export(require("./helpers"));__export(require("./tagtypes"));},{"./helpers":9,"./legacy":11,"./manipulation":12,"./querying":13,"./stringify":14,"./tagtypes":15,"./traversal":16}],11:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var querying_1=require("./querying");var tagtypes_1=require("./tagtypes");function isTextNode(node){return node.type==="text"/* Text */;}/* eslint-disable @typescript-eslint/camelcase */var Checks={tag_name:function tag_name(name){if(typeof name==="function"){return function(elem){return tagtypes_1.isTag(elem)&&name(elem.name);};}else if(name==="*"){return tagtypes_1.isTag;}else{return function(elem){return tagtypes_1.isTag(elem)&&elem.name===name;};}},tag_type:function tag_type(type){if(typeof type==="function"){return function(elem){return type(elem.type);};}else{return function(elem){return elem.type===type;};}},tag_contains:function tag_contains(data){if(typeof data==="function"){return function(elem){return isTextNode(elem)&&data(elem.data);};}else{return function(elem){return isTextNode(elem)&&elem.data===data;};}}};/* eslint-enable @typescript-eslint/camelcase */function getAttribCheck(attrib,value){if(typeof value==="function"){return function(elem){return tagtypes_1.isTag(elem)&&value(elem.attribs[attrib]);};}else{return function(elem){return tagtypes_1.isTag(elem)&&elem.attribs[attrib]===value;};}}function combineFuncs(a,b){return function(elem){return a(elem)||b(elem);};}function compileTest(options){var funcs=Object.keys(options).map(function(key){var value=options[key];// @ts-ignore
return key in Checks?Checks[key](value):getAttribCheck(key,value);});return funcs.length===0?null:funcs.reduce(combineFuncs);}function testElement(options,element){var test=compileTest(options);return test?test(element):true;}exports.testElement=testElement;function getElements(options,element,recurse,limit){if(limit===void 0){limit=Infinity;}var test=compileTest(options);return test?querying_1.filter(test,element,recurse,limit):[];}exports.getElements=getElements;function getElementById(id,element,recurse){if(recurse===void 0){recurse=true;}if(!Array.isArray(element))element=[element];return querying_1.findOne(getAttribCheck("id",id),element,recurse);}exports.getElementById=getElementById;function getElementsByTagName(name,element,recurse,limit){if(limit===void 0){limit=Infinity;}return querying_1.filter(Checks.tag_name(name),element,recurse,limit);}exports.getElementsByTagName=getElementsByTagName;function getElementsByTagType(type,element,recurse,limit){if(recurse===void 0){recurse=true;}if(limit===void 0){limit=Infinity;}return querying_1.filter(Checks.tag_type(type),element,recurse,limit);}exports.getElementsByTagType=getElementsByTagType;},{"./querying":13,"./tagtypes":15}],12:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});/***
 * Remove an element from the dom
 *
 * @argument elem The element to be removed
 */function removeElement(elem){if(elem.prev)elem.prev.next=elem.next;if(elem.next)elem.next.prev=elem.prev;if(elem.parent){var childs=elem.parent.children;childs.splice(childs.lastIndexOf(elem),1);}}exports.removeElement=removeElement;/***
 * Replace an element in the dom
 *
 * @argument elem The element to be replaced
 * @argument replacement The element to be added
 */function replaceElement(elem,replacement){var prev=replacement.prev=elem.prev;if(prev){prev.next=replacement;}var next=replacement.next=elem.next;if(next){next.prev=replacement;}var parent=replacement.parent=elem.parent;if(parent){var childs=parent.children;childs[childs.lastIndexOf(elem)]=replacement;}}exports.replaceElement=replaceElement;/***
 * Append a child to an element
 *
 * @argument elem The element to append to
 * @argument child The element to be added as a child
 */function appendChild(elem,child){child.parent=elem;if(elem.children.push(child)!==1){var sibling=elem.children[elem.children.length-2];sibling.next=child;child.prev=sibling;child.next=null;}}exports.appendChild=appendChild;/***
 * Append an element after another
 *
 * @argument elem The element to append to
 * @argument next The element be added
 */function append(elem,next){var parent=elem.parent,currNext=elem.next;next.next=currNext;next.prev=elem;elem.next=next;next.parent=parent;if(currNext){currNext.prev=next;if(parent){var childs=parent.children;childs.splice(childs.lastIndexOf(currNext),0,next);}}else if(parent){parent.children.push(next);}}exports.append=append;/***
 * Prepend an element before another
 *
 * @argument elem The element to append to
 * @argument prev The element be added
 */function prepend(elem,prev){var parent=elem.parent;if(parent){var childs=parent.children;childs.splice(childs.lastIndexOf(elem),0,prev);}if(elem.prev){elem.prev.next=prev;}prev.parent=parent;prev.prev=elem.prev;prev.next=elem;elem.prev=prev;}exports.prepend=prepend;},{}],13:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var tagtypes_1=require("./tagtypes");function filter(test,element,recurse,limit){if(recurse===void 0){recurse=true;}if(limit===void 0){limit=Infinity;}if(!Array.isArray(element))element=[element];return find(test,element,recurse,limit);}exports.filter=filter;function find(test,elems,recurse,limit){var result=[];for(var i=0;i<elems.length;i++){var elem=elems[i];if(test(elem)){result.push(elem);if(--limit<=0)break;}if(recurse&&tagtypes_1.hasChildren(elem)&&elem.children.length>0){var children=find(test,elem.children,recurse,limit);result=result.concat(children);limit-=children.length;if(limit<=0)break;}}return result;}exports.find=find;function findOneChild(test,elems){for(var i=0;i<elems.length;i++){if(test(elems[i]))return elems[i];}return null;}exports.findOneChild=findOneChild;function findOne(test,elems,recurse){if(recurse===void 0){recurse=true;}var elem=null;for(var i=0;i<elems.length&&!elem;i++){var checked=elems[i];if(!tagtypes_1.isTag(checked)){continue;}else if(test(checked)){elem=checked;}else if(recurse&&checked.children.length>0){elem=findOne(test,checked.children);}}return elem;}exports.findOne=findOne;function existsOne(test,elems){for(var i=0;i<elems.length;i++){var checked=elems[i];if(tagtypes_1.isTag(checked)&&(test(checked)||checked.children.length>0&&existsOne(test,checked.children))){return true;}}return false;}exports.existsOne=existsOne;function findAll(test,rootElems){var result=[];var stack=rootElems.slice();while(stack.length){var elem=stack.shift();if(!elem||!tagtypes_1.isTag(elem))continue;if(elem.children&&elem.children.length>0){stack.unshift.apply(stack,elem.children);}if(test(elem))result.push(elem);}return result;}exports.findAll=findAll;},{"./tagtypes":15}],14:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var tagtypes_1=require("./tagtypes");var dom_serializer_1=__importDefault(require("dom-serializer"));exports.getOuterHTML=dom_serializer_1["default"];function getInnerHTML(node,options){return tagtypes_1.hasChildren(node)?node.children.map(function(node){return exports.getOuterHTML(node,options);}).join(""):"";}exports.getInnerHTML=getInnerHTML;function getText(node){if(Array.isArray(node))return node.map(getText).join("");if(tagtypes_1.isTag(node))return node.name==="br"?"\n":getText(node.children);if(tagtypes_1.isCDATA(node))return getText(node.children);if(tagtypes_1.isText(node))return node.data;return"";}exports.getText=getText;},{"./tagtypes":15,"dom-serializer":5}],15:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var domelementtype_1=require("domelementtype");function isTag(node){return domelementtype_1.isTag(node);}exports.isTag=isTag;function isCDATA(node){return"cdata"/* CDATA */===node.type;}exports.isCDATA=isCDATA;function isText(node){return node.type==="text"/* Text */;}exports.isText=isText;function isComment(node){return node.type==="comment"/* Comment */;}exports.isComment=isComment;function hasChildren(node){return Object.prototype.hasOwnProperty.call(node,"children");}exports.hasChildren=hasChildren;},{"domelementtype":6}],16:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function getChildren(elem){// @ts-ignore
return elem.children||null;}exports.getChildren=getChildren;function getParent(elem){return elem.parent||null;}exports.getParent=getParent;function getSiblings(elem){var parent=getParent(elem);return parent?getChildren(parent):[elem];}exports.getSiblings=getSiblings;function getAttributeValue(elem,name){return elem.attribs&&elem.attribs[name];}exports.getAttributeValue=getAttributeValue;function hasAttrib(elem,name){return!!getAttributeValue(elem,name);}exports.hasAttrib=hasAttrib;/***
 * Returns the name property of an element
 *
 * @argument elem The element to get the name for
 */function getName(elem){return elem.name;}exports.getName=getName;},{}],17:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var entities_json_1=__importDefault(require("./maps/entities.json"));var legacy_json_1=__importDefault(require("./maps/legacy.json"));var xml_json_1=__importDefault(require("./maps/xml.json"));var decode_codepoint_1=__importDefault(require("./decode_codepoint"));exports.decodeXML=getStrictDecoder(xml_json_1["default"]);exports.decodeHTMLStrict=getStrictDecoder(entities_json_1["default"]);function getStrictDecoder(map){var keys=Object.keys(map).join("|");var replace=getReplacer(map);keys+="|#[xX][\\da-fA-F]+|#\\d+";var re=new RegExp("&(?:"+keys+");","g");return function(str){return String(str).replace(re,replace);};}var sorter=function sorter(a,b){return a<b?1:-1;};exports.decodeHTML=function(){var legacy=Object.keys(legacy_json_1["default"]).sort(sorter);var keys=Object.keys(entities_json_1["default"]).sort(sorter);for(var i=0,j=0;i<keys.length;i++){if(legacy[j]===keys[i]){keys[i]+=";?";j++;}else{keys[i]+=";";}}var re=new RegExp("&(?:"+keys.join("|")+"|#[xX][\\da-fA-F]+;?|#\\d+;?)","g");var replace=getReplacer(entities_json_1["default"]);function replacer(str){if(str.substr(-1)!==";")str+=";";return replace(str);}//TODO consider creating a merged map
return function(str){return String(str).replace(re,replacer);};}();function getReplacer(map){return function replace(str){if(str.charAt(1)==="#"){if(str.charAt(2)==="X"||str.charAt(2)==="x"){return decode_codepoint_1["default"](parseInt(str.substr(3),16));}return decode_codepoint_1["default"](parseInt(str.substr(2),10));}return map[str.slice(1,-1)];};}},{"./decode_codepoint":18,"./maps/entities.json":22,"./maps/legacy.json":23,"./maps/xml.json":24}],18:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var decode_json_1=__importDefault(require("./maps/decode.json"));// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint){if(codePoint>=0xd800&&codePoint<=0xdfff||codePoint>0x10ffff){return"\uFFFD";}if(codePoint in decode_json_1["default"]){// @ts-ignore
codePoint=decode_json_1["default"][codePoint];}var output="";if(codePoint>0xffff){codePoint-=0x10000;output+=String.fromCharCode(codePoint>>>10&0x3ff|0xd800);codePoint=0xdc00|codePoint&0x3ff;}output+=String.fromCharCode(codePoint);return output;}exports["default"]=decodeCodePoint;},{"./maps/decode.json":21}],19:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var xml_json_1=__importDefault(require("./maps/xml.json"));var inverseXML=getInverseObj(xml_json_1["default"]);var xmlReplacer=getInverseReplacer(inverseXML);exports.encodeXML=getInverse(inverseXML,xmlReplacer);var entities_json_1=__importDefault(require("./maps/entities.json"));var inverseHTML=getInverseObj(entities_json_1["default"]);var htmlReplacer=getInverseReplacer(inverseHTML);exports.encodeHTML=getInverse(inverseHTML,htmlReplacer);function getInverseObj(obj){return Object.keys(obj).sort().reduce(function(inverse,name){inverse[obj[name]]="&"+name+";";return inverse;},{});}function getInverseReplacer(inverse){var single=[];var multiple=[];Object.keys(inverse).forEach(function(k){return k.length===1?// Add value to single array
single.push("\\"+k):// Add value to multiple array
multiple.push(k);});//TODO add ranges
multiple.unshift("["+single.join("")+"]");return new RegExp(multiple.join("|"),"g");}var reNonASCII=/[^\0-\x7F]/g;var reAstralSymbols=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g;function singleCharReplacer(c){return"&#x"+c.charCodeAt(0).toString(16).toUpperCase()+";";}// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
function astralReplacer(c,_){// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
var high=c.charCodeAt(0);var low=c.charCodeAt(1);var codePoint=(high-0xd800)*0x400+low-0xdc00+0x10000;return"&#x"+codePoint.toString(16).toUpperCase()+";";}function getInverse(inverse,re){return function(data){return data.replace(re,function(name){return inverse[name];}).replace(reAstralSymbols,astralReplacer).replace(reNonASCII,singleCharReplacer);};}var reXmlChars=getInverseReplacer(inverseXML);function escape(data){return data.replace(reXmlChars,singleCharReplacer).replace(reAstralSymbols,astralReplacer).replace(reNonASCII,singleCharReplacer);}exports.escape=escape;},{"./maps/entities.json":22,"./maps/xml.json":24}],20:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var decode_1=require("./decode");var encode_1=require("./encode");function decode(data,level){return(!level||level<=0?decode_1.decodeXML:decode_1.decodeHTML)(data);}exports.decode=decode;function decodeStrict(data,level){return(!level||level<=0?decode_1.decodeXML:decode_1.decodeHTMLStrict)(data);}exports.decodeStrict=decodeStrict;function encode(data,level){return(!level||level<=0?encode_1.encodeXML:encode_1.encodeHTML)(data);}exports.encode=encode;var encode_2=require("./encode");exports.encodeXML=encode_2.encodeXML;exports.encodeHTML=encode_2.encodeHTML;exports.escape=encode_2.escape;// Legacy aliases
exports.encodeHTML4=encode_2.encodeHTML;exports.encodeHTML5=encode_2.encodeHTML;var decode_2=require("./decode");exports.decodeXML=decode_2.decodeXML;exports.decodeHTML=decode_2.decodeHTML;exports.decodeHTMLStrict=decode_2.decodeHTMLStrict;// Legacy aliases
exports.decodeHTML4=decode_2.decodeHTML;exports.decodeHTML5=decode_2.decodeHTML;exports.decodeHTML4Strict=decode_2.decodeHTMLStrict;exports.decodeHTML5Strict=decode_2.decodeHTMLStrict;exports.decodeXMLStrict=decode_2.decodeXML;},{"./decode":17,"./encode":19}],21:[function(require,module,exports){module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376};},{}],22:[function(require,module,exports){module.exports={"Aacute":"\xC1","aacute":"\xE1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\xC2","acirc":"\xE2","acute":"\xB4","Acy":"\u0410","acy":"\u0430","AElig":"\xC6","aelig":"\xE6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\xC0","agrave":"\xE0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\xC5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\xC5","aring":"\xE5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\xC3","atilde":"\xE3","Auml":"\xC4","auml":"\xE4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\xA6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\xC7","ccedil":"\xE7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\xB8","Cedilla":"\xB8","cemptyv":"\u29B2","cent":"\xA2","centerdot":"\xB7","CenterDot":"\xB7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\xAE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\xA9","COPY":"\xA9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\xA4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\xB0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\xB4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\xA8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\xF7","divide":"\xF7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\xA8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\xA8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\xC9","eacute":"\xE9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\xCA","ecirc":"\xEA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\xC8","egrave":"\xE8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\xD0","eth":"\xF0","Euml":"\xCB","euml":"\xEB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\xBD","frac13":"\u2153","frac14":"\xBC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\xBE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\xBD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\xCD","iacute":"\xED","ic":"\u2063","Icirc":"\xCE","icirc":"\xEE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\xA1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\xCC","igrave":"\xEC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\xBF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\xCF","iuml":"\xEF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\xAB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\xAF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\xB5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\xB7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\xA0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\xA0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\xAC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\xD1","ntilde":"\xF1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\xD3","oacute":"\xF3","oast":"\u229B","Ocirc":"\xD4","ocirc":"\xF4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\xD2","ograve":"\xF2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\xAA","ordm":"\xBA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\xD8","oslash":"\xF8","osol":"\u2298","Otilde":"\xD5","otilde":"\xF5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\xD6","ouml":"\xF6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\xB6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\xB1","plusmn":"\xB1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\xB1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\xA3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\xBB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\xAE","REG":"\xAE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\xA7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\xAD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\xAF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\xB9","sup2":"\xB2","sup3":"\xB3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\xDF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\xDE","thorn":"\xFE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\xD7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\xDA","uacute":"\xFA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\xDB","ucirc":"\xFB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\xD9","ugrave":"\xF9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\xA8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\xDC","uuml":"\xFC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\xDD","yacute":"\xFD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\xA5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\xFF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"};},{}],23:[function(require,module,exports){module.exports={"Aacute":"\xC1","aacute":"\xE1","Acirc":"\xC2","acirc":"\xE2","acute":"\xB4","AElig":"\xC6","aelig":"\xE6","Agrave":"\xC0","agrave":"\xE0","amp":"&","AMP":"&","Aring":"\xC5","aring":"\xE5","Atilde":"\xC3","atilde":"\xE3","Auml":"\xC4","auml":"\xE4","brvbar":"\xA6","Ccedil":"\xC7","ccedil":"\xE7","cedil":"\xB8","cent":"\xA2","copy":"\xA9","COPY":"\xA9","curren":"\xA4","deg":"\xB0","divide":"\xF7","Eacute":"\xC9","eacute":"\xE9","Ecirc":"\xCA","ecirc":"\xEA","Egrave":"\xC8","egrave":"\xE8","ETH":"\xD0","eth":"\xF0","Euml":"\xCB","euml":"\xEB","frac12":"\xBD","frac14":"\xBC","frac34":"\xBE","gt":">","GT":">","Iacute":"\xCD","iacute":"\xED","Icirc":"\xCE","icirc":"\xEE","iexcl":"\xA1","Igrave":"\xCC","igrave":"\xEC","iquest":"\xBF","Iuml":"\xCF","iuml":"\xEF","laquo":"\xAB","lt":"<","LT":"<","macr":"\xAF","micro":"\xB5","middot":"\xB7","nbsp":"\xA0","not":"\xAC","Ntilde":"\xD1","ntilde":"\xF1","Oacute":"\xD3","oacute":"\xF3","Ocirc":"\xD4","ocirc":"\xF4","Ograve":"\xD2","ograve":"\xF2","ordf":"\xAA","ordm":"\xBA","Oslash":"\xD8","oslash":"\xF8","Otilde":"\xD5","otilde":"\xF5","Ouml":"\xD6","ouml":"\xF6","para":"\xB6","plusmn":"\xB1","pound":"\xA3","quot":"\"","QUOT":"\"","raquo":"\xBB","reg":"\xAE","REG":"\xAE","sect":"\xA7","shy":"\xAD","sup1":"\xB9","sup2":"\xB2","sup3":"\xB3","szlig":"\xDF","THORN":"\xDE","thorn":"\xFE","times":"\xD7","Uacute":"\xDA","uacute":"\xFA","Ucirc":"\xDB","ucirc":"\xFB","Ugrave":"\xD9","ugrave":"\xF9","uml":"\xA8","Uuml":"\xDC","uuml":"\xFC","Yacute":"\xDD","yacute":"\xFD","yen":"\xA5","yuml":"\xFF"};},{}],24:[function(require,module,exports){module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""};},{}],25:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var objectCreate=Object.create||objectCreatePolyfill;var objectKeys=Object.keys||objectKeysPolyfill;var bind=Function.prototype.bind||functionBindPolyfill;function EventEmitter(){if(!this._events||!Object.prototype.hasOwnProperty.call(this,'_events')){this._events=objectCreate(null);this._eventsCount=0;}this._maxListeners=this._maxListeners||undefined;}module.exports=EventEmitter;// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners=10;var hasDefineProperty;try{var o={};if(Object.defineProperty)Object.defineProperty(o,'x',{value:0});hasDefineProperty=o.x===0;}catch(err){hasDefineProperty=false;}if(hasDefineProperty){Object.defineProperty(EventEmitter,'defaultMaxListeners',{enumerable:true,get:function get(){return defaultMaxListeners;},set:function set(arg){// check whether the input is a positive number (whose value is zero or
// greater and not a NaN).
if(typeof arg!=='number'||arg<0||arg!==arg)throw new TypeError('"defaultMaxListeners" must be a positive number');defaultMaxListeners=arg;}});}else{EventEmitter.defaultMaxListeners=defaultMaxListeners;}// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners=function setMaxListeners(n){if(typeof n!=='number'||n<0||isNaN(n))throw new TypeError('"n" argument must be a positive number');this._maxListeners=n;return this;};function $getMaxListeners(that){if(that._maxListeners===undefined)return EventEmitter.defaultMaxListeners;return that._maxListeners;}EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return $getMaxListeners(this);};// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler,isFn,self){if(isFn)handler.call(self);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self);}}}function emitOne(handler,isFn,self,arg1){if(isFn)handler.call(self,arg1);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1);}}}function emitTwo(handler,isFn,self,arg1,arg2){if(isFn)handler.call(self,arg1,arg2);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2);}}}function emitThree(handler,isFn,self,arg1,arg2,arg3){if(isFn)handler.call(self,arg1,arg2,arg3);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2,arg3);}}}function emitMany(handler,isFn,self,args){if(isFn)handler.apply(self,args);else{var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].apply(self,args);}}}EventEmitter.prototype.emit=function emit(type){var er,handler,len,args,i,events;var doError=type==='error';events=this._events;if(events)doError=doError&&events.error==null;else if(!doError)return false;// If there is no 'error' event listener then throw.
if(doError){if(arguments.length>1)er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event
}else{// At least give some kind of context to the user
var err=new Error('Unhandled "error" event. ('+er+')');err.context=er;throw err;}return false;}handler=events[type];if(!handler)return false;var isFn=typeof handler==='function';len=arguments.length;switch(len){// fast cases
case 1:emitNone(handler,isFn,this);break;case 2:emitOne(handler,isFn,this,arguments[1]);break;case 3:emitTwo(handler,isFn,this,arguments[1],arguments[2]);break;case 4:emitThree(handler,isFn,this,arguments[1],arguments[2],arguments[3]);break;// slower
default:args=new Array(len-1);for(i=1;i<len;i++){args[i-1]=arguments[i];}emitMany(handler,isFn,this,args);}return true;};function _addListener(target,type,listener,prepend){var m;var events;var existing;if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');events=target._events;if(!events){events=target._events=objectCreate(null);target._eventsCount=0;}else{// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
if(events.newListener){target.emit('newListener',type,listener.listener?listener.listener:listener);// Re-assign `events` because a newListener handler could have caused the
// this._events to be assigned to a new object
events=target._events;}existing=events[type];}if(!existing){// Optimize the case of one listener. Don't need the extra array object.
existing=events[type]=listener;++target._eventsCount;}else{if(typeof existing==='function'){// Adding the second element, need to change to array.
existing=events[type]=prepend?[listener,existing]:[existing,listener];}else{// If we've already got an array, just append.
if(prepend){existing.unshift(listener);}else{existing.push(listener);}}// Check for listener leak
if(!existing.warned){m=$getMaxListeners(target);if(m&&m>0&&existing.length>m){existing.warned=true;var w=new Error('Possible EventEmitter memory leak detected. '+existing.length+' "'+String(type)+'" listeners '+'added. Use emitter.setMaxListeners() to '+'increase limit.');w.name='MaxListenersExceededWarning';w.emitter=target;w.type=type;w.count=existing.length;if((typeof console==="undefined"?"undefined":_typeof(console))==='object'&&console.warn){console.warn('%s: %s',w.name,w.message);}}}}return target;}EventEmitter.prototype.addListener=function addListener(type,listener){return _addListener(this,type,listener,false);};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.prependListener=function prependListener(type,listener){return _addListener(this,type,listener,true);};function onceWrapper(){if(!this.fired){this.target.removeListener(this.type,this.wrapFn);this.fired=true;switch(arguments.length){case 0:return this.listener.call(this.target);case 1:return this.listener.call(this.target,arguments[0]);case 2:return this.listener.call(this.target,arguments[0],arguments[1]);case 3:return this.listener.call(this.target,arguments[0],arguments[1],arguments[2]);default:var args=new Array(arguments.length);for(var i=0;i<args.length;++i){args[i]=arguments[i];}this.listener.apply(this.target,args);}}}function _onceWrap(target,type,listener){var state={fired:false,wrapFn:undefined,target:target,type:type,listener:listener};var wrapped=bind.call(onceWrapper,state);wrapped.listener=listener;state.wrapFn=wrapped;return wrapped;}EventEmitter.prototype.once=function once(type,listener){if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');this.on(type,_onceWrap(this,type,listener));return this;};EventEmitter.prototype.prependOnceListener=function prependOnceListener(type,listener){if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');this.prependListener(type,_onceWrap(this,type,listener));return this;};// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener=function removeListener(type,listener){var list,events,position,i,originalListener;if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');events=this._events;if(!events)return this;list=events[type];if(!list)return this;if(list===listener||list.listener===listener){if(--this._eventsCount===0)this._events=objectCreate(null);else{delete events[type];if(events.removeListener)this.emit('removeListener',type,list.listener||listener);}}else if(typeof list!=='function'){position=-1;for(i=list.length-1;i>=0;i--){if(list[i]===listener||list[i].listener===listener){originalListener=list[i].listener;position=i;break;}}if(position<0)return this;if(position===0)list.shift();else spliceOne(list,position);if(list.length===1)events[type]=list[0];if(events.removeListener)this.emit('removeListener',type,originalListener||listener);}return this;};EventEmitter.prototype.removeAllListeners=function removeAllListeners(type){var listeners,events,i;events=this._events;if(!events)return this;// not listening for removeListener, no need to emit
if(!events.removeListener){if(arguments.length===0){this._events=objectCreate(null);this._eventsCount=0;}else if(events[type]){if(--this._eventsCount===0)this._events=objectCreate(null);else delete events[type];}return this;}// emit removeListener for all listeners on all events
if(arguments.length===0){var keys=objectKeys(events);var key;for(i=0;i<keys.length;++i){key=keys[i];if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events=objectCreate(null);this._eventsCount=0;return this;}listeners=events[type];if(typeof listeners==='function'){this.removeListener(type,listeners);}else if(listeners){// LIFO order
for(i=listeners.length-1;i>=0;i--){this.removeListener(type,listeners[i]);}}return this;};function _listeners(target,type,unwrap){var events=target._events;if(!events)return[];var evlistener=events[type];if(!evlistener)return[];if(typeof evlistener==='function')return unwrap?[evlistener.listener||evlistener]:[evlistener];return unwrap?unwrapListeners(evlistener):arrayClone(evlistener,evlistener.length);}EventEmitter.prototype.listeners=function listeners(type){return _listeners(this,type,true);};EventEmitter.prototype.rawListeners=function rawListeners(type){return _listeners(this,type,false);};EventEmitter.listenerCount=function(emitter,type){if(typeof emitter.listenerCount==='function'){return emitter.listenerCount(type);}else{return listenerCount.call(emitter,type);}};EventEmitter.prototype.listenerCount=listenerCount;function listenerCount(type){var events=this._events;if(events){var evlistener=events[type];if(typeof evlistener==='function'){return 1;}else if(evlistener){return evlistener.length;}}return 0;}EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?Reflect.ownKeys(this._events):[];};// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list,index){for(var i=index,k=i+1,n=list.length;k<n;i+=1,k+=1){list[i]=list[k];}list.pop();}function arrayClone(arr,n){var copy=new Array(n);for(var i=0;i<n;++i){copy[i]=arr[i];}return copy;}function unwrapListeners(arr){var ret=new Array(arr.length);for(var i=0;i<ret.length;++i){ret[i]=arr[i].listener||arr[i];}return ret;}function objectCreatePolyfill(proto){var F=function F(){};F.prototype=proto;return new F();}function objectKeysPolyfill(obj){var keys=[];for(var k in obj){if(Object.prototype.hasOwnProperty.call(obj,k)){keys.push(k);}}return k;}function functionBindPolyfill(context){var fn=this;return function(){return fn.apply(context,arguments);};}},{}],26:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var _extendStatics2=function extendStatics(d,b){_extendStatics2=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics2(d,b);};return function(d,b){_extendStatics2(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var MultiplexHandler_1=__importDefault(require("./MultiplexHandler"));var CollectingHandler=/** @class */function(_super){__extends(CollectingHandler,_super);function CollectingHandler(cbs){if(cbs===void 0){cbs={};}var _this=_super.call(this,function(name){var _a;var args=[];for(var _i=1;_i<arguments.length;_i++){args[_i-1]=arguments[_i];}_this.events.push([name].concat(args));// @ts-ignore
if(_this._cbs[name])(_a=_this._cbs)[name].apply(_a,args);})||this;_this._cbs=cbs;_this.events=[];return _this;}CollectingHandler.prototype.onreset=function(){this.events=[];if(this._cbs.onreset)this._cbs.onreset();};CollectingHandler.prototype.restart=function(){var _a;if(this._cbs.onreset)this._cbs.onreset();for(var i=0;i<this.events.length;i++){var _b=this.events[i],name_1=_b[0],args=_b.slice(1);if(!this._cbs[name_1]){continue;}// @ts-ignore
(_a=this._cbs)[name_1].apply(_a,args);}};return CollectingHandler;}(MultiplexHandler_1["default"]);exports.CollectingHandler=CollectingHandler;},{"./MultiplexHandler":28}],27:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var _extendStatics3=function extendStatics(d,b){_extendStatics3=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics3(d,b);};return function(d,b){_extendStatics3(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result["default"]=mod;return result;};Object.defineProperty(exports,"__esModule",{value:true});var domhandler_1=__importDefault(require("domhandler"));var DomUtils=__importStar(require("domutils"));var Parser_1=require("./Parser");//TODO: Consume data as it is coming in
var FeedHandler=/** @class */function(_super){__extends(FeedHandler,_super);/**
     *
     * @param callback
     * @param options
     */function FeedHandler(callback,options){var _this=this;if(_typeof(callback)==="object"&&callback!==null){callback=undefined;options=callback;}_this=_super.call(this,callback,options)||this;return _this;}FeedHandler.prototype.onend=function(){var feed={};var feedRoot=getOneElement(isValidFeed,this.dom);if(feedRoot){if(feedRoot.name==="feed"){var childs=feedRoot.children;feed.type="atom";addConditionally(feed,"id","id",childs);addConditionally(feed,"title","title",childs);var href=getAttribute("href",getOneElement("link",childs));if(href){feed.link=href;}addConditionally(feed,"description","subtitle",childs);var updated=fetch("updated",childs);if(updated){feed.updated=new Date(updated);}addConditionally(feed,"author","email",childs,true);feed.items=getElements("entry",childs).map(function(item){var entry={};var children=item.children;addConditionally(entry,"id","id",children);addConditionally(entry,"title","title",children);var href=getAttribute("href",getOneElement("link",children));if(href){entry.link=href;}var description=fetch("summary",children)||fetch("content",children);if(description){entry.description=description;}var pubDate=fetch("updated",children);if(pubDate){entry.pubDate=new Date(pubDate);}return entry;});}else{var childs=getOneElement("channel",feedRoot.children).children;feed.type=feedRoot.name.substr(0,3);feed.id="";addConditionally(feed,"title","title",childs);addConditionally(feed,"link","link",childs);addConditionally(feed,"description","description",childs);var updated=fetch("lastBuildDate",childs);if(updated){feed.updated=new Date(updated);}addConditionally(feed,"author","managingEditor",childs,true);feed.items=getElements("item",feedRoot.children).map(function(item){var entry={};var children=item.children;addConditionally(entry,"id","guid",children);addConditionally(entry,"title","title",children);addConditionally(entry,"link","link",children);addConditionally(entry,"description","description",children);var pubDate=fetch("pubDate",children);if(pubDate)entry.pubDate=new Date(pubDate);return entry;});}}this.feed=feed;this.handleCallback(feedRoot?null:Error("couldn't find root of feed"));};return FeedHandler;}(domhandler_1["default"]);exports.FeedHandler=FeedHandler;function getElements(what,where){return DomUtils.getElementsByTagName(what,where,true);}function getOneElement(what,where){return DomUtils.getElementsByTagName(what,where,true,1)[0];}function fetch(what,where,recurse){if(recurse===void 0){recurse=false;}return DomUtils.getText(DomUtils.getElementsByTagName(what,where,recurse,1)).trim();}function getAttribute(name,elem){if(!elem){return null;}var attribs=elem.attribs;return attribs[name];}function addConditionally(obj,prop,what,where,recurse){if(recurse===void 0){recurse=false;}var tmp=fetch(what,where,recurse);// @ts-ignore
if(tmp)obj[prop]=tmp;}function isValidFeed(value){return value==="rss"||value==="feed"||value==="rdf:RDF";}var defaultOptions={xmlMode:true};/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this option, you probably want to set `xmlMode` to `true`.
 */function parseFeed(feed,options){if(options===void 0){options=defaultOptions;}var handler=new FeedHandler(options);new Parser_1.Parser(handler,options).end(feed);return handler.feed;}exports.parseFeed=parseFeed;},{"./Parser":29,"domhandler":7,"domutils":10}],28:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});/**
 * Calls a specific handler function for all events that are encountered.
 *
 * @param func — The function to multiplex all events to.
 */var MultiplexHandler=/** @class */function(){function MultiplexHandler(func){this._func=func;}/* Format: eventname: number of arguments */MultiplexHandler.prototype.onattribute=function(name,value){this._func("onattribute",name,value);};MultiplexHandler.prototype.oncdatastart=function(){this._func("oncdatastart");};MultiplexHandler.prototype.oncdataend=function(){this._func("oncdataend");};MultiplexHandler.prototype.ontext=function(text){this._func("ontext",text);};MultiplexHandler.prototype.onprocessinginstruction=function(name,value){this._func("onprocessinginstruction",name,value);};MultiplexHandler.prototype.oncomment=function(comment){this._func("oncomment",comment);};MultiplexHandler.prototype.oncommentend=function(){this._func("oncommentend");};MultiplexHandler.prototype.onclosetag=function(name){this._func("onclosetag",name);};MultiplexHandler.prototype.onopentag=function(name,attribs){this._func("onopentag",name,attribs);};MultiplexHandler.prototype.onopentagname=function(name){this._func("onopentagname",name);};MultiplexHandler.prototype.onerror=function(error){this._func("onerror",error);};MultiplexHandler.prototype.onend=function(){this._func("onend");};MultiplexHandler.prototype.onparserinit=function(parser){this._func("onparserinit",parser);};MultiplexHandler.prototype.onreset=function(){this._func("onreset");};return MultiplexHandler;}();exports["default"]=MultiplexHandler;},{}],29:[function(require,module,exports){"use strict";var __extends=this&&this.__extends||function(){var _extendStatics4=function extendStatics(d,b){_extendStatics4=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics4(d,b);};return function(d,b){_extendStatics4(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var Tokenizer_1=__importDefault(require("./Tokenizer"));var events_1=require("events");var formTags=new Set(["input","option","optgroup","select","button","datalist","textarea"]);var pTag=new Set(["p"]);var openImpliesClose={tr:new Set(["tr","th","td"]),th:new Set(["th"]),td:new Set(["thead","th","td"]),body:new Set(["head","link","script"]),li:new Set(["li"]),p:pTag,h1:pTag,h2:pTag,h3:pTag,h4:pTag,h5:pTag,h6:pTag,select:formTags,input:formTags,output:formTags,button:formTags,datalist:formTags,textarea:formTags,option:new Set(["option"]),optgroup:new Set(["optgroup","option"]),dd:new Set(["dt","dd"]),dt:new Set(["dt","dd"]),address:pTag,article:pTag,aside:pTag,blockquote:pTag,details:pTag,div:pTag,dl:pTag,fieldset:pTag,figcaption:pTag,figure:pTag,footer:pTag,form:pTag,header:pTag,hr:pTag,main:pTag,nav:pTag,ol:pTag,pre:pTag,section:pTag,table:pTag,ul:pTag,rt:new Set(["rt","rp"]),rp:new Set(["rt","rp"]),tbody:new Set(["thead","tbody"]),tfoot:new Set(["thead","tbody"])};var voidElements=new Set(["area","base","basefont","br","col","command","embed","frame","hr","img","input","isindex","keygen","link","meta","param","source","track","wbr"]);var foreignContextElements=new Set(["math","svg"]);var htmlIntegrationElements=new Set(["mi","mo","mn","ms","mtext","annotation-xml","foreignObject","desc","title"]);var reNameEnd=/\s|\//;var Parser=/** @class */function(_super){__extends(Parser,_super);function Parser(cbs,options){var _this=_super.call(this)||this;_this._tagname="";_this._attribname="";_this._attribvalue="";_this._attribs=null;_this._stack=[];_this._foreignContext=[];_this.startIndex=0;_this.endIndex=null;// Aliases for backwards compatibility
_this.parseChunk=Parser.prototype.write;_this.done=Parser.prototype.end;_this._options=options||{};_this._cbs=cbs||{};_this._tagname="";_this._attribname="";_this._attribvalue="";_this._attribs=null;_this._stack=[];_this._foreignContext=[];_this.startIndex=0;_this.endIndex=null;_this._lowerCaseTagNames="lowerCaseTags"in _this._options?!!_this._options.lowerCaseTags:!_this._options.xmlMode;_this._lowerCaseAttributeNames="lowerCaseAttributeNames"in _this._options?!!_this._options.lowerCaseAttributeNames:!_this._options.xmlMode;_this._tokenizer=new(_this._options.Tokenizer||Tokenizer_1["default"])(_this._options,_this);if(_this._cbs.onparserinit)_this._cbs.onparserinit(_this);return _this;}Parser.prototype._updatePosition=function(initialOffset){if(this.endIndex===null){if(this._tokenizer._sectionStart<=initialOffset){this.startIndex=0;}else{this.startIndex=this._tokenizer._sectionStart-initialOffset;}}else this.startIndex=this.endIndex+1;this.endIndex=this._tokenizer.getAbsoluteIndex();};//Tokenizer event handlers
Parser.prototype.ontext=function(data){this._updatePosition(1);// @ts-ignore
this.endIndex--;if(this._cbs.ontext)this._cbs.ontext(data);};Parser.prototype.onopentagname=function(name){if(this._lowerCaseTagNames){name=name.toLowerCase();}this._tagname=name;if(!this._options.xmlMode&&Object.prototype.hasOwnProperty.call(openImpliesClose,name)){for(var el=void 0;// @ts-ignore
openImpliesClose[name].has(el=this._stack[this._stack.length-1]);this.onclosetag(el)){;}}if(this._options.xmlMode||!voidElements.has(name)){this._stack.push(name);if(foreignContextElements.has(name)){this._foreignContext.push(true);}else if(htmlIntegrationElements.has(name)){this._foreignContext.push(false);}}if(this._cbs.onopentagname)this._cbs.onopentagname(name);if(this._cbs.onopentag)this._attribs={};};Parser.prototype.onopentagend=function(){this._updatePosition(1);if(this._attribs){if(this._cbs.onopentag){this._cbs.onopentag(this._tagname,this._attribs);}this._attribs=null;}if(!this._options.xmlMode&&this._cbs.onclosetag&&voidElements.has(this._tagname)){this._cbs.onclosetag(this._tagname);}this._tagname="";};Parser.prototype.onclosetag=function(name){this._updatePosition(1);if(this._lowerCaseTagNames){name=name.toLowerCase();}if(foreignContextElements.has(name)||htmlIntegrationElements.has(name)){this._foreignContext.pop();}if(this._stack.length&&(this._options.xmlMode||!voidElements.has(name))){var pos=this._stack.lastIndexOf(name);if(pos!==-1){if(this._cbs.onclosetag){pos=this._stack.length-pos;// @ts-ignore
while(pos--){this._cbs.onclosetag(this._stack.pop());}}else this._stack.length=pos;}else if(name==="p"&&!this._options.xmlMode){this.onopentagname(name);this._closeCurrentTag();}}else if(!this._options.xmlMode&&(name==="br"||name==="p")){this.onopentagname(name);this._closeCurrentTag();}};Parser.prototype.onselfclosingtag=function(){if(this._options.xmlMode||this._options.recognizeSelfClosing||this._foreignContext[this._foreignContext.length-1]){this._closeCurrentTag();}else{this.onopentagend();}};Parser.prototype._closeCurrentTag=function(){var name=this._tagname;this.onopentagend();//self-closing tags will be on the top of the stack
//(cheaper check than in onclosetag)
if(this._stack[this._stack.length-1]===name){if(this._cbs.onclosetag){this._cbs.onclosetag(name);}this._stack.pop();}};Parser.prototype.onattribname=function(name){if(this._lowerCaseAttributeNames){name=name.toLowerCase();}this._attribname=name;};Parser.prototype.onattribdata=function(value){this._attribvalue+=value;};Parser.prototype.onattribend=function(){if(this._cbs.onattribute)this._cbs.onattribute(this._attribname,this._attribvalue);if(this._attribs&&!Object.prototype.hasOwnProperty.call(this._attribs,this._attribname)){this._attribs[this._attribname]=this._attribvalue;}this._attribname="";this._attribvalue="";};Parser.prototype._getInstructionName=function(value){var idx=value.search(reNameEnd);var name=idx<0?value:value.substr(0,idx);if(this._lowerCaseTagNames){name=name.toLowerCase();}return name;};Parser.prototype.ondeclaration=function(value){if(this._cbs.onprocessinginstruction){var name_1=this._getInstructionName(value);this._cbs.onprocessinginstruction("!"+name_1,"!"+value);}};Parser.prototype.onprocessinginstruction=function(value){if(this._cbs.onprocessinginstruction){var name_2=this._getInstructionName(value);this._cbs.onprocessinginstruction("?"+name_2,"?"+value);}};Parser.prototype.oncomment=function(value){this._updatePosition(4);if(this._cbs.oncomment)this._cbs.oncomment(value);if(this._cbs.oncommentend)this._cbs.oncommentend();};Parser.prototype.oncdata=function(value){this._updatePosition(1);if(this._options.xmlMode||this._options.recognizeCDATA){if(this._cbs.oncdatastart)this._cbs.oncdatastart();if(this._cbs.ontext)this._cbs.ontext(value);if(this._cbs.oncdataend)this._cbs.oncdataend();}else{this.oncomment("[CDATA["+value+"]]");}};Parser.prototype.onerror=function(err){if(this._cbs.onerror)this._cbs.onerror(err);};Parser.prototype.onend=function(){if(this._cbs.onclosetag){for(var i=this._stack.length;i>0;this._cbs.onclosetag(this._stack[--i])){;}}if(this._cbs.onend)this._cbs.onend();};//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset=function(){if(this._cbs.onreset)this._cbs.onreset();this._tokenizer.reset();this._tagname="";this._attribname="";this._attribs=null;this._stack=[];if(this._cbs.onparserinit)this._cbs.onparserinit(this);};//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete=function(data){this.reset();this.end(data);};Parser.prototype.write=function(chunk){this._tokenizer.write(chunk);};Parser.prototype.end=function(chunk){this._tokenizer.end(chunk);};Parser.prototype.pause=function(){this._tokenizer.pause();};Parser.prototype.resume=function(){this._tokenizer.resume();};return Parser;}(events_1.EventEmitter);exports.Parser=Parser;},{"./Tokenizer":30,"events":25}],30:[function(require,module,exports){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{"default":mod};};Object.defineProperty(exports,"__esModule",{value:true});var decode_codepoint_1=__importDefault(require("entities/lib/decode_codepoint"));var entities_json_1=__importDefault(require("entities/lib/maps/entities.json"));var legacy_json_1=__importDefault(require("entities/lib/maps/legacy.json"));var xml_json_1=__importDefault(require("entities/lib/maps/xml.json"));function whitespace(c){return c===" "||c==="\n"||c==="\t"||c==="\f"||c==="\r";}function ifElseState(upper,SUCCESS,FAILURE){var lower=upper.toLowerCase();if(upper===lower){return function(t,c){if(c===lower){t._state=SUCCESS;}else{t._state=FAILURE;t._index--;}};}else{return function(t,c){if(c===lower||c===upper){t._state=SUCCESS;}else{t._state=FAILURE;t._index--;}};}}function consumeSpecialNameChar(upper,NEXT_STATE){var lower=upper.toLowerCase();return function(t,c){if(c===lower||c===upper){t._state=NEXT_STATE;}else{t._state=3/* InTagName */;t._index--;//consume the token again
}};}var stateBeforeCdata1=ifElseState("C",23/* BeforeCdata2 */,16/* InDeclaration */);var stateBeforeCdata2=ifElseState("D",24/* BeforeCdata3 */,16/* InDeclaration */);var stateBeforeCdata3=ifElseState("A",25/* BeforeCdata4 */,16/* InDeclaration */);var stateBeforeCdata4=ifElseState("T",26/* BeforeCdata5 */,16/* InDeclaration */);var stateBeforeCdata5=ifElseState("A",27/* BeforeCdata6 */,16/* InDeclaration */);var stateBeforeScript1=consumeSpecialNameChar("R",34/* BeforeScript2 */);var stateBeforeScript2=consumeSpecialNameChar("I",35/* BeforeScript3 */);var stateBeforeScript3=consumeSpecialNameChar("P",36/* BeforeScript4 */);var stateBeforeScript4=consumeSpecialNameChar("T",37/* BeforeScript5 */);var stateAfterScript1=ifElseState("R",39/* AfterScript2 */,1/* Text */);var stateAfterScript2=ifElseState("I",40/* AfterScript3 */,1/* Text */);var stateAfterScript3=ifElseState("P",41/* AfterScript4 */,1/* Text */);var stateAfterScript4=ifElseState("T",42/* AfterScript5 */,1/* Text */);var stateBeforeStyle1=consumeSpecialNameChar("Y",44/* BeforeStyle2 */);var stateBeforeStyle2=consumeSpecialNameChar("L",45/* BeforeStyle3 */);var stateBeforeStyle3=consumeSpecialNameChar("E",46/* BeforeStyle4 */);var stateAfterStyle1=ifElseState("Y",48/* AfterStyle2 */,1/* Text */);var stateAfterStyle2=ifElseState("L",49/* AfterStyle3 */,1/* Text */);var stateAfterStyle3=ifElseState("E",50/* AfterStyle4 */,1/* Text */);var stateBeforeEntity=ifElseState("#",52/* BeforeNumericEntity */,53/* InNamedEntity */);var stateBeforeNumericEntity=ifElseState("X",55/* InHexEntity */,54/* InNumericEntity */);var Tokenizer=/** @class */function(){function Tokenizer(options,cbs){/** The current state the tokenizer is in. */this._state=1/* Text */;/** The read buffer. */this._buffer="";/** The beginning of the section that is currently being read. */this._sectionStart=0;/** The index within the buffer that we are currently looking at. */this._index=0;/**
         * Data that has already been processed will be removed from the buffer occasionally.
         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
         */this._bufferOffset=0;/** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */this._baseState=1/* Text */;/** For special parsing behavior inside of script and style tags. */this._special=1/* None */;/** Indicates whether the tokenizer has been paused. */this._running=true;/** Indicates whether the tokenizer has finished running / `.end` has been called. */this._ended=false;this._cbs=cbs;this._xmlMode=!!(options&&options.xmlMode);this._decodeEntities=!!(options&&options.decodeEntities);}Tokenizer.prototype.reset=function(){this._state=1/* Text */;this._buffer="";this._sectionStart=0;this._index=0;this._bufferOffset=0;this._baseState=1/* Text */;this._special=1/* None */;this._running=true;this._ended=false;};Tokenizer.prototype._stateText=function(c){if(c==="<"){if(this._index>this._sectionStart){this._cbs.ontext(this._getSection());}this._state=2/* BeforeTagName */;this._sectionStart=this._index;}else if(this._decodeEntities&&this._special===1/* None */&&c==="&"){if(this._index>this._sectionStart){this._cbs.ontext(this._getSection());}this._baseState=1/* Text */;this._state=51/* BeforeEntity */;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeTagName=function(c){if(c==="/"){this._state=5/* BeforeClosingTagName */;}else if(c==="<"){this._cbs.ontext(this._getSection());this._sectionStart=this._index;}else if(c===">"||this._special!==1/* None */||whitespace(c)){this._state=1/* Text */;}else if(c==="!"){this._state=15/* BeforeDeclaration */;this._sectionStart=this._index+1;}else if(c==="?"){this._state=17/* InProcessingInstruction */;this._sectionStart=this._index+1;}else{this._state=!this._xmlMode&&(c==="s"||c==="S")?31/* BeforeSpecial */:3/* InTagName */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInTagName=function(c){if(c==="/"||c===">"||whitespace(c)){this._emitToken("onopentagname");this._state=8/* BeforeAttributeName */;this._index--;}};Tokenizer.prototype._stateBeforeClosingTagName=function(c){if(whitespace(c)){// ignore
}else if(c===">"){this._state=1/* Text */;}else if(this._special!==1/* None */){if(c==="s"||c==="S"){this._state=32/* BeforeSpecialEnd */;}else{this._state=1/* Text */;this._index--;}}else{this._state=6/* InClosingTagName */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInClosingTagName=function(c){if(c===">"||whitespace(c)){this._emitToken("onclosetag");this._state=7/* AfterClosingTagName */;this._index--;}};Tokenizer.prototype._stateAfterClosingTagName=function(c){//skip everything until ">"
if(c===">"){this._state=1/* Text */;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateBeforeAttributeName=function(c){if(c===">"){this._cbs.onopentagend();this._state=1/* Text */;this._sectionStart=this._index+1;}else if(c==="/"){this._state=4/* InSelfClosingTag */;}else if(!whitespace(c)){this._state=9/* InAttributeName */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInSelfClosingTag=function(c){if(c===">"){this._cbs.onselfclosingtag();this._state=1/* Text */;this._sectionStart=this._index+1;}else if(!whitespace(c)){this._state=8/* BeforeAttributeName */;this._index--;}};Tokenizer.prototype._stateInAttributeName=function(c){if(c==="="||c==="/"||c===">"||whitespace(c)){this._cbs.onattribname(this._getSection());this._sectionStart=-1;this._state=10/* AfterAttributeName */;this._index--;}};Tokenizer.prototype._stateAfterAttributeName=function(c){if(c==="="){this._state=11/* BeforeAttributeValue */;}else if(c==="/"||c===">"){this._cbs.onattribend();this._state=8/* BeforeAttributeName */;this._index--;}else if(!whitespace(c)){this._cbs.onattribend();this._state=9/* InAttributeName */;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeAttributeValue=function(c){if(c==='"'){this._state=12/* InAttributeValueDq */;this._sectionStart=this._index+1;}else if(c==="'"){this._state=13/* InAttributeValueSq */;this._sectionStart=this._index+1;}else if(!whitespace(c)){this._state=14/* InAttributeValueNq */;this._sectionStart=this._index;this._index--;//reconsume token
}};Tokenizer.prototype._stateInAttributeValueDoubleQuotes=function(c){if(c==='"'){this._emitToken("onattribdata");this._cbs.onattribend();this._state=8/* BeforeAttributeName */;}else if(this._decodeEntities&&c==="&"){this._emitToken("onattribdata");this._baseState=this._state;this._state=51/* BeforeEntity */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInAttributeValueSingleQuotes=function(c){if(c==="'"){this._emitToken("onattribdata");this._cbs.onattribend();this._state=8/* BeforeAttributeName */;}else if(this._decodeEntities&&c==="&"){this._emitToken("onattribdata");this._baseState=this._state;this._state=51/* BeforeEntity */;this._sectionStart=this._index;}};Tokenizer.prototype._stateInAttributeValueNoQuotes=function(c){if(whitespace(c)||c===">"){this._emitToken("onattribdata");this._cbs.onattribend();this._state=8/* BeforeAttributeName */;this._index--;}else if(this._decodeEntities&&c==="&"){this._emitToken("onattribdata");this._baseState=this._state;this._state=51/* BeforeEntity */;this._sectionStart=this._index;}};Tokenizer.prototype._stateBeforeDeclaration=function(c){this._state=c==="["?22/* BeforeCdata1 */:c==="-"?18/* BeforeComment */:16/* InDeclaration */;};Tokenizer.prototype._stateInDeclaration=function(c){if(c===">"){this._cbs.ondeclaration(this._getSection());this._state=1/* Text */;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateInProcessingInstruction=function(c){if(c===">"){this._cbs.onprocessinginstruction(this._getSection());this._state=1/* Text */;this._sectionStart=this._index+1;}};Tokenizer.prototype._stateBeforeComment=function(c){if(c==="-"){this._state=19/* InComment */;this._sectionStart=this._index+1;}else{this._state=16/* InDeclaration */;}};Tokenizer.prototype._stateInComment=function(c){if(c==="-")this._state=20/* AfterComment1 */;};Tokenizer.prototype._stateAfterComment1=function(c){if(c==="-"){this._state=21/* AfterComment2 */;}else{this._state=19/* InComment */;}};Tokenizer.prototype._stateAfterComment2=function(c){if(c===">"){//remove 2 trailing chars
this._cbs.oncomment(this._buffer.substring(this._sectionStart,this._index-2));this._state=1/* Text */;this._sectionStart=this._index+1;}else if(c!=="-"){this._state=19/* InComment */;}// else: stay in AFTER_COMMENT_2 (`--->`)
};Tokenizer.prototype._stateBeforeCdata6=function(c){if(c==="["){this._state=28/* InCdata */;this._sectionStart=this._index+1;}else{this._state=16/* InDeclaration */;this._index--;}};Tokenizer.prototype._stateInCdata=function(c){if(c==="]")this._state=29/* AfterCdata1 */;};Tokenizer.prototype._stateAfterCdata1=function(c){if(c==="]")this._state=30/* AfterCdata2 */;else this._state=28/* InCdata */;};Tokenizer.prototype._stateAfterCdata2=function(c){if(c===">"){//remove 2 trailing chars
this._cbs.oncdata(this._buffer.substring(this._sectionStart,this._index-2));this._state=1/* Text */;this._sectionStart=this._index+1;}else if(c!=="]"){this._state=28/* InCdata */;}//else: stay in AFTER_CDATA_2 (`]]]>`)
};Tokenizer.prototype._stateBeforeSpecial=function(c){if(c==="c"||c==="C"){this._state=33/* BeforeScript1 */;}else if(c==="t"||c==="T"){this._state=43/* BeforeStyle1 */;}else{this._state=3/* InTagName */;this._index--;//consume the token again
}};Tokenizer.prototype._stateBeforeSpecialEnd=function(c){if(this._special===2/* Script */&&(c==="c"||c==="C")){this._state=38/* AfterScript1 */;}else if(this._special===3/* Style */&&(c==="t"||c==="T")){this._state=47/* AfterStyle1 */;}else this._state=1/* Text */;};Tokenizer.prototype._stateBeforeScript5=function(c){if(c==="/"||c===">"||whitespace(c)){this._special=2/* Script */;}this._state=3/* InTagName */;this._index--;//consume the token again
};Tokenizer.prototype._stateAfterScript5=function(c){if(c===">"||whitespace(c)){this._special=1/* None */;this._state=6/* InClosingTagName */;this._sectionStart=this._index-6;this._index--;//reconsume the token
}else this._state=1/* Text */;};Tokenizer.prototype._stateBeforeStyle4=function(c){if(c==="/"||c===">"||whitespace(c)){this._special=3/* Style */;}this._state=3/* InTagName */;this._index--;//consume the token again
};Tokenizer.prototype._stateAfterStyle4=function(c){if(c===">"||whitespace(c)){this._special=1/* None */;this._state=6/* InClosingTagName */;this._sectionStart=this._index-5;this._index--;//reconsume the token
}else this._state=1/* Text */;};//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict=function(){//offset = 1
if(this._sectionStart+1<this._index){var entity=this._buffer.substring(this._sectionStart+1,this._index),map=this._xmlMode?xml_json_1["default"]:entities_json_1["default"];if(Object.prototype.hasOwnProperty.call(map,entity)){// @ts-ignore
this._emitPartial(map[entity]);this._sectionStart=this._index+1;}}};//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity=function(){var start=this._sectionStart+1;var limit=this._index-start;if(limit>6)limit=6;// The max length of legacy entities is 6
while(limit>=2){// The min length of legacy entities is 2
var entity=this._buffer.substr(start,limit);if(Object.prototype.hasOwnProperty.call(legacy_json_1["default"],entity)){// @ts-ignore
this._emitPartial(legacy_json_1["default"][entity]);this._sectionStart+=limit+1;return;}else{limit--;}}};Tokenizer.prototype._stateInNamedEntity=function(c){if(c===";"){this._parseNamedEntityStrict();if(this._sectionStart+1<this._index&&!this._xmlMode){this._parseLegacyEntity();}this._state=this._baseState;}else if((c<"a"||c>"z")&&(c<"A"||c>"Z")&&(c<"0"||c>"9")){if(this._xmlMode||this._sectionStart+1===this._index){// ignore
}else if(this._baseState!==1/* Text */){if(c!=="="){this._parseNamedEntityStrict();}}else{this._parseLegacyEntity();}this._state=this._baseState;this._index--;}};Tokenizer.prototype._decodeNumericEntity=function(offset,base){var sectionStart=this._sectionStart+offset;if(sectionStart!==this._index){//parse entity
var entity=this._buffer.substring(sectionStart,this._index);var parsed=parseInt(entity,base);this._emitPartial(decode_codepoint_1["default"](parsed));this._sectionStart=this._index;}else{this._sectionStart--;}this._state=this._baseState;};Tokenizer.prototype._stateInNumericEntity=function(c){if(c===";"){this._decodeNumericEntity(2,10);this._sectionStart++;}else if(c<"0"||c>"9"){if(!this._xmlMode){this._decodeNumericEntity(2,10);}else{this._state=this._baseState;}this._index--;}};Tokenizer.prototype._stateInHexEntity=function(c){if(c===";"){this._decodeNumericEntity(3,16);this._sectionStart++;}else if((c<"a"||c>"f")&&(c<"A"||c>"F")&&(c<"0"||c>"9")){if(!this._xmlMode){this._decodeNumericEntity(3,16);}else{this._state=this._baseState;}this._index--;}};Tokenizer.prototype._cleanup=function(){if(this._sectionStart<0){this._buffer="";this._bufferOffset+=this._index;this._index=0;}else if(this._running){if(this._state===1/* Text */){if(this._sectionStart!==this._index){this._cbs.ontext(this._buffer.substr(this._sectionStart));}this._buffer="";this._bufferOffset+=this._index;this._index=0;}else if(this._sectionStart===this._index){//the section just started
this._buffer="";this._bufferOffset+=this._index;this._index=0;}else{//remove everything unnecessary
this._buffer=this._buffer.substr(this._sectionStart);this._index-=this._sectionStart;this._bufferOffset+=this._sectionStart;}this._sectionStart=0;}};//TODO make events conditional
Tokenizer.prototype.write=function(chunk){if(this._ended)this._cbs.onerror(Error(".write() after done!"));this._buffer+=chunk;this._parse();};// Iterates through the buffer, calling the function corresponding to the current state.
// States that are more likely to be hit are higher up, as a performance improvement.
Tokenizer.prototype._parse=function(){while(this._index<this._buffer.length&&this._running){var c=this._buffer.charAt(this._index);if(this._state===1/* Text */){this._stateText(c);}else if(this._state===12/* InAttributeValueDq */){this._stateInAttributeValueDoubleQuotes(c);}else if(this._state===9/* InAttributeName */){this._stateInAttributeName(c);}else if(this._state===19/* InComment */){this._stateInComment(c);}else if(this._state===8/* BeforeAttributeName */){this._stateBeforeAttributeName(c);}else if(this._state===3/* InTagName */){this._stateInTagName(c);}else if(this._state===6/* InClosingTagName */){this._stateInClosingTagName(c);}else if(this._state===2/* BeforeTagName */){this._stateBeforeTagName(c);}else if(this._state===10/* AfterAttributeName */){this._stateAfterAttributeName(c);}else if(this._state===13/* InAttributeValueSq */){this._stateInAttributeValueSingleQuotes(c);}else if(this._state===11/* BeforeAttributeValue */){this._stateBeforeAttributeValue(c);}else if(this._state===5/* BeforeClosingTagName */){this._stateBeforeClosingTagName(c);}else if(this._state===7/* AfterClosingTagName */){this._stateAfterClosingTagName(c);}else if(this._state===31/* BeforeSpecial */){this._stateBeforeSpecial(c);}else if(this._state===20/* AfterComment1 */){this._stateAfterComment1(c);}else if(this._state===14/* InAttributeValueNq */){this._stateInAttributeValueNoQuotes(c);}else if(this._state===4/* InSelfClosingTag */){this._stateInSelfClosingTag(c);}else if(this._state===16/* InDeclaration */){this._stateInDeclaration(c);}else if(this._state===15/* BeforeDeclaration */){this._stateBeforeDeclaration(c);}else if(this._state===21/* AfterComment2 */){this._stateAfterComment2(c);}else if(this._state===18/* BeforeComment */){this._stateBeforeComment(c);}else if(this._state===32/* BeforeSpecialEnd */){this._stateBeforeSpecialEnd(c);}else if(this._state===38/* AfterScript1 */){stateAfterScript1(this,c);}else if(this._state===39/* AfterScript2 */){stateAfterScript2(this,c);}else if(this._state===40/* AfterScript3 */){stateAfterScript3(this,c);}else if(this._state===33/* BeforeScript1 */){stateBeforeScript1(this,c);}else if(this._state===34/* BeforeScript2 */){stateBeforeScript2(this,c);}else if(this._state===35/* BeforeScript3 */){stateBeforeScript3(this,c);}else if(this._state===36/* BeforeScript4 */){stateBeforeScript4(this,c);}else if(this._state===37/* BeforeScript5 */){this._stateBeforeScript5(c);}else if(this._state===41/* AfterScript4 */){stateAfterScript4(this,c);}else if(this._state===42/* AfterScript5 */){this._stateAfterScript5(c);}else if(this._state===43/* BeforeStyle1 */){stateBeforeStyle1(this,c);}else if(this._state===28/* InCdata */){this._stateInCdata(c);}else if(this._state===44/* BeforeStyle2 */){stateBeforeStyle2(this,c);}else if(this._state===45/* BeforeStyle3 */){stateBeforeStyle3(this,c);}else if(this._state===46/* BeforeStyle4 */){this._stateBeforeStyle4(c);}else if(this._state===47/* AfterStyle1 */){stateAfterStyle1(this,c);}else if(this._state===48/* AfterStyle2 */){stateAfterStyle2(this,c);}else if(this._state===49/* AfterStyle3 */){stateAfterStyle3(this,c);}else if(this._state===50/* AfterStyle4 */){this._stateAfterStyle4(c);}else if(this._state===17/* InProcessingInstruction */){this._stateInProcessingInstruction(c);}else if(this._state===53/* InNamedEntity */){this._stateInNamedEntity(c);}else if(this._state===22/* BeforeCdata1 */){stateBeforeCdata1(this,c);}else if(this._state===51/* BeforeEntity */){stateBeforeEntity(this,c);}else if(this._state===23/* BeforeCdata2 */){stateBeforeCdata2(this,c);}else if(this._state===24/* BeforeCdata3 */){stateBeforeCdata3(this,c);}else if(this._state===29/* AfterCdata1 */){this._stateAfterCdata1(c);}else if(this._state===30/* AfterCdata2 */){this._stateAfterCdata2(c);}else if(this._state===25/* BeforeCdata4 */){stateBeforeCdata4(this,c);}else if(this._state===26/* BeforeCdata5 */){stateBeforeCdata5(this,c);}else if(this._state===27/* BeforeCdata6 */){this._stateBeforeCdata6(c);}else if(this._state===55/* InHexEntity */){this._stateInHexEntity(c);}else if(this._state===54/* InNumericEntity */){this._stateInNumericEntity(c);}else if(this._state===52/* BeforeNumericEntity */){stateBeforeNumericEntity(this,c);}else{this._cbs.onerror(Error("unknown _state"),this._state);}this._index++;}this._cleanup();};Tokenizer.prototype.pause=function(){this._running=false;};Tokenizer.prototype.resume=function(){this._running=true;if(this._index<this._buffer.length){this._parse();}if(this._ended){this._finish();}};Tokenizer.prototype.end=function(chunk){if(this._ended)this._cbs.onerror(Error(".end() after done!"));if(chunk)this.write(chunk);this._ended=true;if(this._running)this._finish();};Tokenizer.prototype._finish=function(){//if there is remaining data, emit it in a reasonable way
if(this._sectionStart<this._index){this._handleTrailingData();}this._cbs.onend();};Tokenizer.prototype._handleTrailingData=function(){var data=this._buffer.substr(this._sectionStart);if(this._state===28/* InCdata */||this._state===29/* AfterCdata1 */||this._state===30/* AfterCdata2 */){this._cbs.oncdata(data);}else if(this._state===19/* InComment */||this._state===20/* AfterComment1 */||this._state===21/* AfterComment2 */){this._cbs.oncomment(data);}else if(this._state===53/* InNamedEntity */&&!this._xmlMode){this._parseLegacyEntity();if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state===54/* InNumericEntity */&&!this._xmlMode){this._decodeNumericEntity(2,10);if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state===55/* InHexEntity */&&!this._xmlMode){this._decodeNumericEntity(3,16);if(this._sectionStart<this._index){this._state=this._baseState;this._handleTrailingData();}}else if(this._state!==3/* InTagName */&&this._state!==8/* BeforeAttributeName */&&this._state!==11/* BeforeAttributeValue */&&this._state!==10/* AfterAttributeName */&&this._state!==9/* InAttributeName */&&this._state!==13/* InAttributeValueSq */&&this._state!==12/* InAttributeValueDq */&&this._state!==14/* InAttributeValueNq */&&this._state!==6/* InClosingTagName */){this._cbs.ontext(data);}//else, ignore remaining data
//TODO add a way to remove current tag
};Tokenizer.prototype.getAbsoluteIndex=function(){return this._bufferOffset+this._index;};Tokenizer.prototype._getSection=function(){return this._buffer.substring(this._sectionStart,this._index);};Tokenizer.prototype._emitToken=function(name){this._cbs[name](this._getSection());this._sectionStart=-1;};Tokenizer.prototype._emitPartial=function(value){if(this._baseState!==1/* Text */){this._cbs.onattribdata(value);//TODO implement the new event
}else{this._cbs.ontext(value);}};return Tokenizer;}();exports["default"]=Tokenizer;},{"entities/lib/decode_codepoint":18,"entities/lib/maps/entities.json":22,"entities/lib/maps/legacy.json":23,"entities/lib/maps/xml.json":24}],31:[function(require,module,exports){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}}var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result["default"]=mod;return result;};Object.defineProperty(exports,"__esModule",{value:true});var Parser_1=require("./Parser");exports.Parser=Parser_1.Parser;var domhandler_1=require("domhandler");exports.DomHandler=domhandler_1.DomHandler;exports.DefaultHandler=domhandler_1.DomHandler;// Helper methods
/**
 * Parses data, returns the resulting DOM.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */function parseDOM(data,options){var handler=new domhandler_1.DomHandler(void 0,options);new Parser_1.Parser(handler,options).end(data);return handler.dom;}exports.parseDOM=parseDOM;/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */function createDomStream(cb,options,elementCb){var handler=new domhandler_1.DomHandler(cb,options,elementCb);return new Parser_1.Parser(handler,options);}exports.createDomStream=createDomStream;var Tokenizer_1=require("./Tokenizer");exports.Tokenizer=Tokenizer_1["default"];var ElementType=__importStar(require("domelementtype"));exports.ElementType=ElementType;/**
 * List of all events that the parser emits.
 *
 * Format: eventname: number of arguments.
 */exports.EVENTS={attribute:2,cdatastart:0,cdataend:0,text:1,processinginstruction:2,comment:1,commentend:0,closetag:1,opentag:2,opentagname:1,error:1,end:0};/*
    All of the following exports exist for backwards-compatibility.
    They should probably be removed eventually.
*/__export(require("./FeedHandler"));__export(require("./WritableStream"));__export(require("./CollectingHandler"));var DomUtils=__importStar(require("domutils"));exports.DomUtils=DomUtils;var FeedHandler_1=require("./FeedHandler");exports.RssHandler=FeedHandler_1.FeedHandler;},{"./CollectingHandler":26,"./FeedHandler":27,"./Parser":29,"./Tokenizer":30,"./WritableStream":2,"domelementtype":6,"domhandler":7,"domutils":10}],32:[function(require,module,exports){exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var nBits=-7;var i=isLE?nBytes-1:0;var d=isLE?-1:1;var s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8){}m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8){}if(e===0){e=1-eBias;}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity;}else{m=m+Math.pow(2,mLen);e=e-eBias;}return(s?-1:1)*m*Math.pow(2,e-mLen);};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0;var i=isLE?0:nBytes-1;var d=isLE?1:-1;var s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax;}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2;}if(e+eBias>=1){value+=rt/c;}else{value+=rt*Math.pow(2,1-eBias);}if(value*c>=2){e++;c/=2;}if(e+eBias>=eMax){m=0;e=eMax;}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias;}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0;}}for(;mLen>=8;buffer[offset+i]=m&0xff,i+=d,m/=256,mLen-=8){}e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&0xff,i+=d,e/=256,eLen-=8){}buffer[offset+i-d]|=s*128;};},{}],33:[function(require,module,exports){(function(global){/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',promiseTag='[object Promise]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(global)=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&_typeof(module)=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */function addMapEntry(map,pair){// Don't return `map.set` because it's not chainable in IE 11.
map.set(pair[0],pair[1]);return map;}/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */function addSetEntry(set,value){// Don't return `set.add` because it's not chainable in IE 11.
set.add(value);return set;}/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */function arrayEach(array,iteratee){var index=-1,length=array?array.length:0;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array?array.length:0;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(object,key){return object==null?undefined:object[key];}/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */function isHostObject(value){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var result=false;if(value!=null&&typeof value.toString!='function'){try{result=!!(value+'');}catch(e){}}return result;}/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=root['__core-js_shared__'];/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var objectToString=objectProto.toString;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?root.Buffer:undefined,_Symbol=root.Symbol,Uint8Array=root.Uint8Array,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeKeys=overArg(Object.keys,Object);/* Built-in method references that are verified to be native. */var DataView=getNative(root,'DataView'),Map=getNative(root,'Map'),Promise=getNative(root,'Promise'),Set=getNative(root,'Set'),WeakMap=getNative(root,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined;/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};}/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(key){return this.has(key)&&delete this.__data__[key];}/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(key,value){var data=this.__data__;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[];}/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}return true;}/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(entries){var index=-1,length=entries?entries.length:0;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(key){return getMapData(this,key)['delete'](key);}/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(key,value){getMapData(this,key).set(key,value);return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Stack(entries){this.__data__=new ListCache(entries);}/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */function stackClear(){this.__data__=new ListCache();}/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function stackDelete(key){return this.__data__['delete'](key);}/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function stackGet(key){return this.__data__.get(key);}/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function stackHas(key){return this.__data__.has(key);}/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */function stackSet(key,value){var cache=this.__data__;if(cache instanceof ListCache){var pairs=cache.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);return this;}cache=this.__data__=new MapCache(pairs);}cache.set(key,value);return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */function arrayLikeKeys(value,inherited){// Safari 8.1 makes `arguments.callee` enumerable in strict mode.
// Safari 9 makes `arguments.length` enumerable in strict mode.
var result=isArray(value)||isArguments(value)?baseTimes(value.length,String):[];var length=result.length,skipIndexes=!!length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(key=='length'||isIndex(key,length)))){result.push(key);}}return result;}/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){object[key]=value;}}/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */function baseClone(value,isDeep,isFull,customizer,key,object,stack){var result;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){if(isHostObject(value)){return object?value:{};}result=initCloneObject(isFunc?{}:value);if(!isDeep){return copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,baseClone,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(!isArr){var props=isFull?getAllKeys(value):keys(value);}arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,isDeep,isFull,customizer,key,value,stack));});return result;}/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */function baseCreate(proto){return isObject(proto)?objectCreate(proto):{};}/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */function baseGetTag(value){return objectToString.call(value);}/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)||isHostObject(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var result=new buffer.constructor(buffer.length);buffer.copy(result);return result;}/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */function cloneMap(map,isDeep,cloneFunc){var array=isDeep?cloneFunc(mapToArray(map),true):mapToArray(map);return arrayReduce(array,addMapEntry,new map.constructor());}/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */function cloneSet(set,isDeep,cloneFunc){var array=isDeep?cloneFunc(setToArray(set),true):setToArray(set);return arrayReduce(array,addSetEntry,new set.constructor());}/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */function copyObject(source,props,object,customizer){object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;assignValue(object,key,newValue===undefined?source[key]:newValue);}return object;}/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */var getSymbols=nativeGetSymbols?overArg(nativeGetSymbols,Object):stubArray;/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=objectToString.call(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):undefined;if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */function initCloneArray(array){var length=array.length,result=array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */function initCloneByTag(object,tag,cloneFunc,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return cloneMap(object,isDeep,cloneFunc);case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return cloneSet(object,isDeep,cloneFunc);case symbolTag:return cloneSymbol(object);}}/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */function cloneDeep(value){return baseClone(value,true,true);}/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(value,other){return value===other||value!==value&&other!==other;}/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */function isArguments(value){// Safari 8.1 makes `arguments.callee` enumerable in strict mode.
return isArrayLikeObject(value)&&hasOwnProperty.call(value,'callee')&&(!propertyIsEnumerable.call(value,'callee')||objectToString.call(value)==argsTag);}/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */var isBuffer=nativeIsBuffer||stubFalse;/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(value){// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 8-9 which returns 'object' for typed array and other constructors.
var tag=isObject(value)?objectToString.call(value):'';return tag==funcTag||tag==genTag;}/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(value){var type=_typeof(value);return!!value&&(type=='object'||type=='function');}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return!!value&&_typeof(value)=='object';}/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */function stubArray(){return[];}/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */function stubFalse(){return false;}module.exports=cloneDeep;}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],34:[function(require,module,exports){(function(global){/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as references for various `Number` constants. */var INFINITY=1/0;/** `Object#toString` result references. */var symbolTag='[object Symbol]';/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(global)=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Used for built-in method references. */var objectProto=Object.prototype;/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */var objectToString=objectProto.toString;/** Built-in value references. */var _Symbol2=root.Symbol;/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol2?_Symbol2.prototype:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return!!value&&_typeof(value)=='object';}/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&objectToString.call(value)==symbolTag;}/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */function toString(value){return value==null?'':baseToString(value);}/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}module.exports=escapeRegExp;}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],35:[function(require,module,exports){/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** `Object#toString` result references. */var objectTag='[object Object]';/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */function isHostObject(value){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var result=false;if(value!=null&&typeof value.toString!='function'){try{result=!!(value+'');}catch(e){}}return result;}/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */function overArg(func,transform){return function(arg){return func(transform(arg));};}/** Used for built-in method references. */var funcProto=Function.prototype,objectProto=Object.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var objectToString=objectProto.toString;/** Built-in value references. */var getPrototype=overArg(Object.getPrototypeOf,Object);/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return!!value&&_typeof(value)=='object';}/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */function isPlainObject(value){if(!isObjectLike(value)||objectToString.call(value)!=objectTag||isHostObject(value)){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}module.exports=isPlainObject;},{}],36:[function(require,module,exports){/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */ /** `Object#toString` result references. */var stringTag='[object String]';/** Used for built-in method references. */var objectProto=Object.prototype;/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */var objectToString=objectProto.toString;/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return!!value&&_typeof(value)=='object';}/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&objectToString.call(value)==stringTag;}module.exports=isString;},{}],37:[function(require,module,exports){(function(global){/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof(global)=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&_typeof(module)=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */function baseUnary(func){return function(value){return func(value);};}/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(object,key){return object==null?undefined:object[key];}/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */function overArg(func,transform){return function(arg){return func(transform(arg));};}/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=root['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?root.Buffer:undefined,_Symbol3=root.Symbol,Uint8Array=root.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,symToStringTag=_Symbol3?_Symbol3.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/* Built-in method references for those with the same name as other `lodash` methods. */var nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeMax=Math.max,nativeNow=Date.now;/* Built-in method references that are verified to be native. */var Map=getNative(root,'Map'),nativeCreate=getNative(Object,'create');/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[];this.size=0;}/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function stackGet(key){return this.__data__.get(key);}/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function stackHas(key){return this.__data__.has(key);}/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */var baseFor=createBaseFor();/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */function objectToString(value){return nativeObjectToString.call(value);}/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */var setToString=shortOut(baseSetToString);/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(value,other){return value===other||value!==value&&other!==other;}/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */var isBuffer=nativeIsBuffer||stubFalse;/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */function constant(value){return function(){return value;};}/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */function identity(value){return value;}/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */function stubFalse(){return false;}module.exports=mergeWith;}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],38:[function(require,module,exports){(function(process){// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts,allowAboveRoot){// if the path tries to go above the root, `up` ends up > 0
var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==='.'){parts.splice(i,1);}else if(last==='..'){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s
if(allowAboveRoot){for(;up--;up){parts.unshift('..');}}return parts;}// path.resolve([from ...], to)
// posix version
exports.resolve=function(){var resolvedPath='',resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:process.cwd();// Skip empty and invalid entries
if(typeof path!=='string'){throw new TypeError('Arguments to path.resolve must be strings');}else if(!path){continue;}resolvedPath=path+'/'+resolvedPath;resolvedAbsolute=path.charAt(0)==='/';}// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)
// Normalize the path
resolvedPath=normalizeArray(filter(resolvedPath.split('/'),function(p){return!!p;}),!resolvedAbsolute).join('/');return(resolvedAbsolute?'/':'')+resolvedPath||'.';};// path.normalize(path)
// posix version
exports.normalize=function(path){var isAbsolute=exports.isAbsolute(path),trailingSlash=substr(path,-1)==='/';// Normalize the path
path=normalizeArray(filter(path.split('/'),function(p){return!!p;}),!isAbsolute).join('/');if(!path&&!isAbsolute){path='.';}if(path&&trailingSlash){path+='/';}return(isAbsolute?'/':'')+path;};// posix version
exports.isAbsolute=function(path){return path.charAt(0)==='/';};// posix version
exports.join=function(){var paths=Array.prototype.slice.call(arguments,0);return exports.normalize(filter(paths,function(p,index){if(typeof p!=='string'){throw new TypeError('Arguments to path.join must be strings');}return p;}).join('/'));};// path.relative(from, to)
// posix version
exports.relative=function(from,to){from=exports.resolve(from).substr(1);to=exports.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=='')break;}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=='')break;}if(start>end)return[];return arr.slice(start,end-start+1);}var fromParts=trim(from.split('/'));var toParts=trim(to.split('/'));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break;}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push('..');}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join('/');};exports.sep='/';exports.delimiter=':';exports.dirname=function(path){if(typeof path!=='string')path=path+'';if(path.length===0)return'.';var code=path.charCodeAt(0);var hasRoot=code===47/*/*/;var end=-1;var matchedSlash=true;for(var i=path.length-1;i>=1;--i){code=path.charCodeAt(i);if(code===47/*/*/){if(!matchedSlash){end=i;break;}}else{// We saw the first non-path separator
matchedSlash=false;}}if(end===-1)return hasRoot?'/':'.';if(hasRoot&&end===1){// return '//';
// Backwards-compat fix:
return'/';}return path.slice(0,end);};function basename(path){if(typeof path!=='string')path=path+'';var start=0;var end=-1;var matchedSlash=true;var i;for(i=path.length-1;i>=0;--i){if(path.charCodeAt(i)===47/*/*/){// If we reached a path separator that was not part of a set of path
// separators at the end of the string, stop now
if(!matchedSlash){start=i+1;break;}}else if(end===-1){// We saw the first non-path separator, mark this as the end of our
// path component
matchedSlash=false;end=i+1;}}if(end===-1)return'';return path.slice(start,end);}// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename=function(path,ext){var f=basename(path);if(ext&&f.substr(-1*ext.length)===ext){f=f.substr(0,f.length-ext.length);}return f;};exports.extname=function(path){if(typeof path!=='string')path=path+'';var startDot=-1;var startPart=0;var end=-1;var matchedSlash=true;// Track the state of characters (if any) we see before our first dot and
// after any path separator we find
var preDotState=0;for(var i=path.length-1;i>=0;--i){var code=path.charCodeAt(i);if(code===47/*/*/){// If we reached a path separator that was not part of a set of path
// separators at the end of the string, stop now
if(!matchedSlash){startPart=i+1;break;}continue;}if(end===-1){// We saw the first non-path separator, mark this as the end of our
// extension
matchedSlash=false;end=i+1;}if(code===46/*.*/){// If this is our first dot, mark it as the start of our extension
if(startDot===-1)startDot=i;else if(preDotState!==1)preDotState=1;}else if(startDot!==-1){// We saw a non-dot and non-path separator before our dot, so we should
// have a good chance at having a non-empty extension
preDotState=-1;}}if(startDot===-1||end===-1||// We saw a non-dot character immediately before the dot
preDotState===0||// The (right-most) trimmed path component is exactly '..'
preDotState===1&&startDot===end-1&&startDot===startPart+1){return'';}return path.slice(startDot,end);};function filter(xs,f){if(xs.filter)return xs.filter(f);var res=[];for(var i=0;i<xs.length;i++){if(f(xs[i],i,xs))res.push(xs[i]);}return res;}// String.prototype.substr - negative index don't work in IE8
var substr='ab'.substr(-1)==='b'?function(str,start,len){return str.substr(start,len);}:function(str,start,len){if(start<0)start=str.length+start;return str.substr(start,len);};}).call(this,require('_process'));},{"_process":63}],39:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _container=_interopRequireDefault(require("./container"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents an at-rule.
 *
 * If it’s followed in the CSS by a {} block, this node will have
 * a nodes property representing its children.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('@charset "UTF-8"; @media print {}')
 *
 * const charset = root.first
 * charset.type  //=> 'atrule'
 * charset.nodes //=> undefined
 *
 * const media = root.last
 * media.nodes   //=> []
 */var AtRule=/*#__PURE__*/function(_Container){_inheritsLoose(AtRule,_Container);function AtRule(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='atrule';return _this;}var _proto=AtRule.prototype;_proto.append=function append(){var _Container$prototype$;if(!this.nodes)this.nodes=[];for(var _len=arguments.length,children=new Array(_len),_key=0;_key<_len;_key++){children[_key]=arguments[_key];}return(_Container$prototype$=_Container.prototype.append).call.apply(_Container$prototype$,[this].concat(children));};_proto.prepend=function prepend(){var _Container$prototype$2;if(!this.nodes)this.nodes=[];for(var _len2=arguments.length,children=new Array(_len2),_key2=0;_key2<_len2;_key2++){children[_key2]=arguments[_key2];}return(_Container$prototype$2=_Container.prototype.prepend).call.apply(_Container$prototype$2,[this].concat(children));}/**
   * @memberof AtRule#
   * @member {string} name The at-rule’s name immediately follows the `@`.
   *
   * @example
   * const root  = postcss.parse('@media print {}')
   * media.name //=> 'media'
   * const media = root.first
   */ /**
   * @memberof AtRule#
   * @member {string} params The at-rule’s parameters, the values
   *                         that follow the at-rule’s name but precede
   *                         any {} block.
   *
   * @example
   * const root  = postcss.parse('@media print, screen {}')
   * const media = root.first
   * media.params //=> 'print, screen'
   */ /**
   * @memberof AtRule#
   * @member {object} raws Information to generate byte-to-byte equal
   *                        node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   *
   * PostCSS cleans at-rule parameters from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('  @media\nprint {\n}')
   * root.first.first.raws //=> { before: '  ',
   *                       //     between: ' ',
   *                       //     afterName: '\n',
   *                       //     after: '\n' }
   */;return AtRule;}(_container["default"]);var _default=AtRule;exports["default"]=_default;module.exports=exports["default"];},{"./container":41}],40:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _node=_interopRequireDefault(require("./node"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents a comment between declarations or statements (rule and at-rules).
 *
 * Comments inside selectors, at-rule parameters, or declaration values
 * will be stored in the `raws` properties explained above.
 *
 * @extends Node
 */var Comment=/*#__PURE__*/function(_Node){_inheritsLoose(Comment,_Node);function Comment(defaults){var _this;_this=_Node.call(this,defaults)||this;_this.type='comment';return _this;}/**
   * @memberof Comment#
   * @member {string} text The comment’s text.
   */ /**
   * @memberof Comment#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node.
   * * `left`: the space symbols between `/*` and the comment’s text.
   * * `right`: the space symbols between the comment’s text.
   */return Comment;}(_node["default"]);var _default=Comment;exports["default"]=_default;module.exports=exports["default"];},{"./node":48}],41:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _declaration=_interopRequireDefault(require("./declaration"));var _comment=_interopRequireDefault(require("./comment"));var _node=_interopRequireDefault(require("./node"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function cleanSource(nodes){return nodes.map(function(i){if(i.nodes)i.nodes=cleanSource(i.nodes);delete i.source;return i;});}/**
 * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 *
 * @extends Node
 * @abstract
 */var Container=/*#__PURE__*/function(_Node){_inheritsLoose(Container,_Node);function Container(){return _Node.apply(this,arguments)||this;}var _proto=Container.prototype;_proto.push=function push(child){child.parent=this;this.nodes.push(child);return this;}/**
   * Iterates through the container’s immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the container’s immediate children.
   * If you need to recursively iterate through all the container’s descendant
   * nodes, use {@link Container#walk}.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   */;_proto.each=function each(callback){if(!this.lastEach)this.lastEach=0;if(!this.indexes)this.indexes={};this.lastEach+=1;var id=this.lastEach;this.indexes[id]=0;if(!this.nodes)return undefined;var index,result;while(this.indexes[id]<this.nodes.length){index=this.indexes[id];result=callback(this.nodes[index],index);if(result===false)break;this.indexes[id]+=1;}delete this.indexes[id];return result;}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each node.
   *
   * Like container.each(), this method is safe to use
   * if you are mutating arrays during iteration.
   *
   * If you only need to iterate through the container’s immediate children,
   * use {@link Container#each}.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walk(node => {
   *   // Traverses all descendant nodes.
   * })
   */;_proto.walk=function walk(callback){return this.each(function(child,i){var result;try{result=callback(child,i);}catch(e){e.postcssNode=child;if(e.stack&&child.source&&/\n\s{4}at /.test(e.stack)){var s=child.source;e.stack=e.stack.replace(/\n\s{4}at /,"$&"+s.input.from+":"+s.start.line+":"+s.start.column+"$&");}throw e;}if(result!==false&&child.walk){result=child.walk(callback);}return result;});}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each declaration node.
   *
   * If you pass a filter, iteration will only happen over declarations
   * with matching properties.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [prop]   String or regular expression
   *                                 to filter declarations by property name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkDecls(decl => {
   *   checkPropertySupport(decl.prop)
   * })
   *
   * root.walkDecls('border-radius', decl => {
   *   decl.remove()
   * })
   *
   * root.walkDecls(/^background/, decl => {
   *   decl.value = takeFirstColorFromGradient(decl.value)
   * })
   */;_proto.walkDecls=function walkDecls(prop,callback){if(!callback){callback=prop;return this.walk(function(child,i){if(child.type==='decl'){return callback(child,i);}});}if(prop instanceof RegExp){return this.walk(function(child,i){if(child.type==='decl'&&prop.test(child.prop)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='decl'&&child.prop===prop){return callback(child,i);}});}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each rule node.
   *
   * If you pass a filter, iteration will only happen over rules
   * with matching selectors.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [selector] String or regular expression
   *                                   to filter rules by selector.
   * @param {childIterator} callback   Iterator receives each node and index.
   *
   * @return {false|undefined} returns `false` if iteration was broke.
   *
   * @example
   * const selectors = []
   * root.walkRules(rule => {
   *   selectors.push(rule.selector)
   * })
   * console.log(`Your CSS uses ${ selectors.length } selectors`)
   */;_proto.walkRules=function walkRules(selector,callback){if(!callback){callback=selector;return this.walk(function(child,i){if(child.type==='rule'){return callback(child,i);}});}if(selector instanceof RegExp){return this.walk(function(child,i){if(child.type==='rule'&&selector.test(child.selector)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='rule'&&child.selector===selector){return callback(child,i);}});}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each at-rule node.
   *
   * If you pass a filter, iteration will only happen over at-rules
   * that have matching names.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {string|RegExp} [name]   String or regular expression
   *                                 to filter at-rules by name.
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkAtRules(rule => {
   *   if (isOld(rule.name)) rule.remove()
   * })
   *
   * let first = false
   * root.walkAtRules('charset', rule => {
   *   if (!first) {
   *     first = true
   *   } else {
   *     rule.remove()
   *   }
   * })
   */;_proto.walkAtRules=function walkAtRules(name,callback){if(!callback){callback=name;return this.walk(function(child,i){if(child.type==='atrule'){return callback(child,i);}});}if(name instanceof RegExp){return this.walk(function(child,i){if(child.type==='atrule'&&name.test(child.name)){return callback(child,i);}});}return this.walk(function(child,i){if(child.type==='atrule'&&child.name===name){return callback(child,i);}});}/**
   * Traverses the container’s descendant nodes, calling callback
   * for each comment node.
   *
   * Like {@link Container#each}, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param {childIterator} callback Iterator receives each node and index.
   *
   * @return {false|undefined} Returns `false` if iteration was broke.
   *
   * @example
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   */;_proto.walkComments=function walkComments(callback){return this.walk(function(child,i){if(child.type==='comment'){return callback(child,i);}});}/**
   * Inserts new nodes to the end of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */;_proto.append=function append(){for(var _len=arguments.length,children=new Array(_len),_key=0;_key<_len;_key++){children[_key]=arguments[_key];}for(var _i=0,_children=children;_i<_children.length;_i++){var child=_children[_i];var nodes=this.normalize(child,this.last);for(var _iterator=nodes,_isArray=Array.isArray(_iterator),_i2=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i2>=_iterator.length)break;_ref=_iterator[_i2++];}else{_i2=_iterator.next();if(_i2.done)break;_ref=_i2.value;}var node=_ref;this.nodes.push(node);}}return this;}/**
   * Inserts new nodes to the start of the container.
   *
   * @param {...(Node|object|string|Node[])} children New nodes.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * const decl1 = postcss.decl({ prop: 'color', value: 'black' })
   * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   */;_proto.prepend=function prepend(){for(var _len2=arguments.length,children=new Array(_len2),_key2=0;_key2<_len2;_key2++){children[_key2]=arguments[_key2];}children=children.reverse();for(var _iterator2=children,_isArray2=Array.isArray(_iterator2),_i3=0,_iterator2=_isArray2?_iterator2:_iterator2[Symbol.iterator]();;){var _ref2;if(_isArray2){if(_i3>=_iterator2.length)break;_ref2=_iterator2[_i3++];}else{_i3=_iterator2.next();if(_i3.done)break;_ref2=_i3.value;}var child=_ref2;var nodes=this.normalize(child,this.first,'prepend').reverse();for(var _iterator3=nodes,_isArray3=Array.isArray(_iterator3),_i4=0,_iterator3=_isArray3?_iterator3:_iterator3[Symbol.iterator]();;){var _ref3;if(_isArray3){if(_i4>=_iterator3.length)break;_ref3=_iterator3[_i4++];}else{_i4=_iterator3.next();if(_i4.done)break;_ref3=_i4.value;}var node=_ref3;this.nodes.unshift(node);}for(var id in this.indexes){this.indexes[id]=this.indexes[id]+nodes.length;}}return this;};_proto.cleanRaws=function cleanRaws(keepBetween){_Node.prototype.cleanRaws.call(this,keepBetween);if(this.nodes){for(var _iterator4=this.nodes,_isArray4=Array.isArray(_iterator4),_i5=0,_iterator4=_isArray4?_iterator4:_iterator4[Symbol.iterator]();;){var _ref4;if(_isArray4){if(_i5>=_iterator4.length)break;_ref4=_iterator4[_i5++];}else{_i5=_iterator4.next();if(_i5.done)break;_ref4=_i5.value;}var node=_ref4;node.cleanRaws(keepBetween);}}}/**
   * Insert new node before old node within the container.
   *
   * @param {Node|number} exist             Child or child’s index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   */;_proto.insertBefore=function insertBefore(exist,add){exist=this.index(exist);var type=exist===0?'prepend':false;var nodes=this.normalize(add,this.nodes[exist],type).reverse();for(var _iterator5=nodes,_isArray5=Array.isArray(_iterator5),_i6=0,_iterator5=_isArray5?_iterator5:_iterator5[Symbol.iterator]();;){var _ref5;if(_isArray5){if(_i6>=_iterator5.length)break;_ref5=_iterator5[_i6++];}else{_i6=_iterator5.next();if(_i6.done)break;_ref5=_i6.value;}var node=_ref5;this.nodes.splice(exist,0,node);}var index;for(var id in this.indexes){index=this.indexes[id];if(exist<=index){this.indexes[id]=index+nodes.length;}}return this;}/**
   * Insert new node after old node within the container.
   *
   * @param {Node|number} exist             Child or child’s index.
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   */;_proto.insertAfter=function insertAfter(exist,add){exist=this.index(exist);var nodes=this.normalize(add,this.nodes[exist]).reverse();for(var _iterator6=nodes,_isArray6=Array.isArray(_iterator6),_i7=0,_iterator6=_isArray6?_iterator6:_iterator6[Symbol.iterator]();;){var _ref6;if(_isArray6){if(_i7>=_iterator6.length)break;_ref6=_iterator6[_i7++];}else{_i7=_iterator6.next();if(_i7.done)break;_ref6=_i7.value;}var node=_ref6;this.nodes.splice(exist+1,0,node);}var index;for(var id in this.indexes){index=this.indexes[id];if(exist<index){this.indexes[id]=index+nodes.length;}}return this;}/**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * @param {Node|number} child Child or child’s index.
   *
   * @return {Node} This node for methods chain
   *
   * @example
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   */;_proto.removeChild=function removeChild(child){child=this.index(child);this.nodes[child].parent=undefined;this.nodes.splice(child,1);var index;for(var id in this.indexes){index=this.indexes[id];if(index>=child){this.indexes[id]=index-1;}}return this;}/**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * rule.removeAll()
   * rule.nodes.length //=> 0
   */;_proto.removeAll=function removeAll(){for(var _iterator7=this.nodes,_isArray7=Array.isArray(_iterator7),_i8=0,_iterator7=_isArray7?_iterator7:_iterator7[Symbol.iterator]();;){var _ref7;if(_isArray7){if(_i8>=_iterator7.length)break;_ref7=_iterator7[_i8++];}else{_i8=_iterator7.next();if(_i8.done)break;_ref7=_i8.value;}var node=_ref7;node.parent=undefined;}this.nodes=[];return this;}/**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * @param {string|RegExp} pattern      Replace pattern.
   * @param {object} opts                Options to speed up the search.
   * @param {string|string[]} opts.props An array of property names.
   * @param {string} opts.fast           String that’s used to narrow down
   *                                     values and speed up the regexp search.
   * @param {function|string} callback   String to replace pattern or callback
   *                                     that returns a new value. The callback
   *                                     will receive the same arguments
   *                                     as those passed to a function parameter
   *                                     of `String#replace`.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   */;_proto.replaceValues=function replaceValues(pattern,opts,callback){if(!callback){callback=opts;opts={};}this.walkDecls(function(decl){if(opts.props&&opts.props.indexOf(decl.prop)===-1)return;if(opts.fast&&decl.value.indexOf(opts.fast)===-1)return;decl.value=decl.value.replace(pattern,callback);});return this;}/**
   * Returns `true` if callback returns `true`
   * for all of the container’s children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is every child pass condition.
   *
   * @example
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   */;_proto.every=function every(condition){return this.nodes.every(condition);}/**
   * Returns `true` if callback returns `true` for (at least) one
   * of the container’s children.
   *
   * @param {childCondition} condition Iterator returns true or false.
   *
   * @return {boolean} Is some child pass condition.
   *
   * @example
   * const hasPrefix = rule.some(i => i.prop[0] === '-')
   */;_proto.some=function some(condition){return this.nodes.some(condition);}/**
   * Returns a `child`’s index within the {@link Container#nodes} array.
   *
   * @param {Node} child Child of the current container.
   *
   * @return {number} Child index.
   *
   * @example
   * rule.index( rule.nodes[2] ) //=> 2
   */;_proto.index=function index(child){if(typeof child==='number'){return child;}return this.nodes.indexOf(child);}/**
   * The container’s first child.
   *
   * @type {Node}
   *
   * @example
   * rule.first === rules.nodes[0]
   */;_proto.normalize=function normalize(nodes,sample){var _this=this;if(typeof nodes==='string'){var parse=require('./parse');nodes=cleanSource(parse(nodes).nodes);}else if(Array.isArray(nodes)){nodes=nodes.slice(0);for(var _iterator8=nodes,_isArray8=Array.isArray(_iterator8),_i9=0,_iterator8=_isArray8?_iterator8:_iterator8[Symbol.iterator]();;){var _ref8;if(_isArray8){if(_i9>=_iterator8.length)break;_ref8=_iterator8[_i9++];}else{_i9=_iterator8.next();if(_i9.done)break;_ref8=_i9.value;}var i=_ref8;if(i.parent)i.parent.removeChild(i,'ignore');}}else if(nodes.type==='root'){nodes=nodes.nodes.slice(0);for(var _iterator9=nodes,_isArray9=Array.isArray(_iterator9),_i10=0,_iterator9=_isArray9?_iterator9:_iterator9[Symbol.iterator]();;){var _ref9;if(_isArray9){if(_i10>=_iterator9.length)break;_ref9=_iterator9[_i10++];}else{_i10=_iterator9.next();if(_i10.done)break;_ref9=_i10.value;}var _i11=_ref9;if(_i11.parent)_i11.parent.removeChild(_i11,'ignore');}}else if(nodes.type){nodes=[nodes];}else if(nodes.prop){if(typeof nodes.value==='undefined'){throw new Error('Value field is missed in node creation');}else if(typeof nodes.value!=='string'){nodes.value=String(nodes.value);}nodes=[new _declaration["default"](nodes)];}else if(nodes.selector){var Rule=require('./rule');nodes=[new Rule(nodes)];}else if(nodes.name){var AtRule=require('./at-rule');nodes=[new AtRule(nodes)];}else if(nodes.text){nodes=[new _comment["default"](nodes)];}else{throw new Error('Unknown node type in node creation');}var processed=nodes.map(function(i){if(i.parent)i.parent.removeChild(i);if(typeof i.raws.before==='undefined'){if(sample&&typeof sample.raws.before!=='undefined'){i.raws.before=sample.raws.before.replace(/[^\s]/g,'');}}i.parent=_this;return i;});return processed;}/**
   * @memberof Container#
   * @member {Node[]} nodes An array containing the container’s children.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   */;_createClass(Container,[{key:"first",get:function get(){if(!this.nodes)return undefined;return this.nodes[0];}/**
     * The container’s last child.
     *
     * @type {Node}
     *
     * @example
     * rule.last === rule.nodes[rule.nodes.length - 1]
     */},{key:"last",get:function get(){if(!this.nodes)return undefined;return this.nodes[this.nodes.length-1];}}]);return Container;}(_node["default"]);var _default=Container;/**
 * @callback childCondition
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @param {Node[]} nodes All container children.
 * @return {boolean}
 */ /**
 * @callback childIterator
 * @param {Node} node    Container child.
 * @param {number} index Child index.
 * @return {false|undefined} Returning `false` will break iteration.
 */exports["default"]=_default;module.exports=exports["default"];},{"./at-rule":39,"./comment":40,"./declaration":43,"./node":48,"./parse":49,"./rule":56}],42:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _supportsColor=_interopRequireDefault(require("supports-color"));var _chalk=_interopRequireDefault(require("chalk"));var _terminalHighlight=_interopRequireDefault(require("./terminal-highlight"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function _wrapNativeSuper(Class){var _cache=typeof Map==="function"?new Map():undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function");}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){return _construct(Class,arguments,_getPrototypeOf(this).constructor);}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf(Wrapper,Class);};return _wrapNativeSuper(Class);}function isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _construct(Parent,args,Class){if(isNativeReflectConstruct()){_construct=Reflect.construct;}else{_construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor();if(Class)_setPrototypeOf(instance,Class.prototype);return instance;};}return _construct.apply(null,arguments);}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf("[native code]")!==-1;}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}/**
 * The CSS parser throws this error for broken CSS.
 *
 * Custom parsers can throw this error for broken custom syntax using
 * the {@link Node#error} method.
 *
 * PostCSS will use the input source map to detect the original error location.
 * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
 * PostCSS will show the original position in the Sass file.
 *
 * If you need the position in the PostCSS input
 * (e.g., to debug the previous compiler), use `error.input.file`.
 *
 * @example
 * // Catching and checking syntax error
 * try {
 *   postcss.parse('a{')
 * } catch (error) {
 *   if (error.name === 'CssSyntaxError') {
 *     error //=> CssSyntaxError
 *   }
 * }
 *
 * @example
 * // Raising error from plugin
 * throw node.error('Unknown variable', { plugin: 'postcss-vars' })
 */var CssSyntaxError=/*#__PURE__*/function(_Error){_inheritsLoose(CssSyntaxError,_Error);/**
   * @param {string} message  Error message.
   * @param {number} [line]   Source line of the error.
   * @param {number} [column] Source column of the error.
   * @param {string} [source] Source code of the broken file.
   * @param {string} [file]   Absolute path to the broken file.
   * @param {string} [plugin] PostCSS plugin name, if error came from plugin.
   */function CssSyntaxError(message,line,column,source,file,plugin){var _this;_this=_Error.call(this,message)||this;/**
     * Always equal to `'CssSyntaxError'`. You should always check error type
     * by `error.name === 'CssSyntaxError'`
     * instead of `error instanceof CssSyntaxError`,
     * because npm could have several PostCSS versions.
     *
     * @type {string}
     *
     * @example
     * if (error.name === 'CssSyntaxError') {
     *   error //=> CssSyntaxError
     * }
     */_this.name='CssSyntaxError';/**
     * Error message.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'Unclosed block'
     */_this.reason=message;if(file){/**
       * Absolute path to the broken file.
       *
       * @type {string}
       *
       * @example
       * error.file       //=> 'a.sass'
       * error.input.file //=> 'a.css'
       */_this.file=file;}if(source){/**
       * Source code of the broken file.
       *
       * @type {string}
       *
       * @example
       * error.source       //=> 'a { b {} }'
       * error.input.column //=> 'a b { }'
       */_this.source=source;}if(plugin){/**
       * Plugin name, if error came from plugin.
       *
       * @type {string}
       *
       * @example
       * error.plugin //=> 'postcss-vars'
       */_this.plugin=plugin;}if(typeof line!=='undefined'&&typeof column!=='undefined'){/**
       * Source line of the error.
       *
       * @type {number}
       *
       * @example
       * error.line       //=> 2
       * error.input.line //=> 4
       */_this.line=line;/**
       * Source column of the error.
       *
       * @type {number}
       *
       * @example
       * error.column       //=> 1
       * error.input.column //=> 4
       */_this.column=column;}_this.setMessage();if(Error.captureStackTrace){Error.captureStackTrace(_assertThisInitialized(_this),CssSyntaxError);}return _this;}var _proto=CssSyntaxError.prototype;_proto.setMessage=function setMessage(){/**
     * Full error text in the GNU error format
     * with plugin, file, line and column.
     *
     * @type {string}
     *
     * @example
     * error.message //=> 'a.css:1:1: Unclosed block'
     */this.message=this.plugin?this.plugin+': ':'';this.message+=this.file?this.file:'<css input>';if(typeof this.line!=='undefined'){this.message+=':'+this.line+':'+this.column;}this.message+=': '+this.reason;}/**
   * Returns a few lines of CSS source that caused the error.
   *
   * If the CSS has an input source map without `sourceContent`,
   * this method will return an empty string.
   *
   * @param {boolean} [color] Whether arrow will be colored red by terminal
   *                          color codes. By default, PostCSS will detect
   *                          color support by `process.stdout.isTTY`
   *                          and `process.env.NODE_DISABLE_COLORS`.
   *
   * @example
   * error.showSourceCode() //=> "  4 | }
   *                        //      5 | a {
   *                        //    > 6 |   bad
   *                        //        |   ^
   *                        //      7 | }
   *                        //      8 | b {"
   *
   * @return {string} Few lines of CSS source that caused the error.
   */;_proto.showSourceCode=function showSourceCode(color){var _this2=this;if(!this.source)return'';var css=this.source;if(_terminalHighlight["default"]){if(typeof color==='undefined')color=_supportsColor["default"].stdout;if(color)css=(0,_terminalHighlight["default"])(css);}var lines=css.split(/\r?\n/);var start=Math.max(this.line-3,0);var end=Math.min(this.line+2,lines.length);var maxWidth=String(end).length;function mark(text){if(color&&_chalk["default"].red){return _chalk["default"].red.bold(text);}return text;}function aside(text){if(color&&_chalk["default"].gray){return _chalk["default"].gray(text);}return text;}return lines.slice(start,end).map(function(line,index){var number=start+1+index;var gutter=' '+(' '+number).slice(-maxWidth)+' | ';if(number===_this2.line){var spacing=aside(gutter.replace(/\d/g,' '))+line.slice(0,_this2.column-1).replace(/[^\t]/g,' ');return mark('>')+aside(gutter)+line+'\n '+spacing+mark('^');}return' '+aside(gutter)+line;}).join('\n');}/**
   * Returns error position, message and source code of the broken part.
   *
   * @example
   * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
   *                  //    > 1 | a {
   *                  //        | ^"
   *
   * @return {string} Error position, message and source code.
   */;_proto.toString=function toString(){var code=this.showSourceCode();if(code){code='\n\n'+code+'\n';}return this.name+': '+this.message+code;}/**
   * @memberof CssSyntaxError#
   * @member {Input} input Input object with PostCSS internal information
   *                       about input file. If input has source map
   *                       from previous tool, PostCSS will use origin
   *                       (for example, Sass) source. You can use this
   *                       object to get PostCSS input source.
   *
   * @example
   * error.input.file //=> 'a.css'
   * error.file       //=> 'a.sass'
   */;return CssSyntaxError;}(_wrapNativeSuper(Error));var _default=CssSyntaxError;exports["default"]=_default;module.exports=exports["default"];},{"./terminal-highlight":2,"chalk":2,"supports-color":2}],43:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _node=_interopRequireDefault(require("./node"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents a CSS declaration.
 *
 * @extends Node
 *
 * @example
 * const root = postcss.parse('a { color: black }')
 * const decl = root.first.first
 * decl.type       //=> 'decl'
 * decl.toString() //=> ' color: black'
 */var Declaration=/*#__PURE__*/function(_Node){_inheritsLoose(Declaration,_Node);function Declaration(defaults){var _this;_this=_Node.call(this,defaults)||this;_this.type='decl';return _this;}/**
   * @memberof Declaration#
   * @member {string} prop The declaration’s property name.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.prop //=> 'color'
   */ /**
   * @memberof Declaration#
   * @member {string} value The declaration’s value.
   *
   * @example
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   * decl.value //=> 'black'
   */ /**
   * @memberof Declaration#
   * @member {boolean} important `true` if the declaration
   *                             has an !important annotation.
   *
   * @example
   * const root = postcss.parse('a { color: black !important; color: red }')
   * root.first.first.important //=> true
   * root.first.last.important  //=> undefined
   */ /**
   * @memberof Declaration#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `between`: the symbols between the property and value
   *   for declarations.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans declaration from comments and extra spaces,
   * but it stores origin content in raws properties.
   * As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */return Declaration;}(_node["default"]);var _default=Declaration;exports["default"]=_default;module.exports=exports["default"];},{"./node":48}],44:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _path=_interopRequireDefault(require("path"));var _cssSyntaxError=_interopRequireDefault(require("./css-syntax-error"));var _previousMap=_interopRequireDefault(require("./previous-map"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}var sequence=0;/**
 * Represents the source CSS.
 *
 * @example
 * const root  = postcss.parse(css, { from: file })
 * const input = root.source.input
 */var Input=/*#__PURE__*/function(){/**
   * @param {string} css    Input CSS source.
   * @param {object} [opts] {@link Processor#process} options.
   */function Input(css,opts){if(opts===void 0){opts={};}if(css===null||_typeof(css)==='object'&&!css.toString){throw new Error("PostCSS received "+css+" instead of CSS string");}/**
     * Input CSS source
     *
     * @type {string}
     *
     * @example
     * const input = postcss.parse('a{}', { from: file }).input
     * input.css //=> "a{}"
     */this.css=css.toString();if(this.css[0]==="\uFEFF"||this.css[0]==="\uFFFE"){this.hasBOM=true;this.css=this.css.slice(1);}else{this.hasBOM=false;}if(opts.from){if(/^\w+:\/\//.test(opts.from)||_path["default"].isAbsolute(opts.from)){/**
         * The absolute path to the CSS source file defined
         * with the `from` option.
         *
         * @type {string}
         *
         * @example
         * const root = postcss.parse(css, { from: 'a.css' })
         * root.source.input.file //=> '/home/ai/a.css'
         */this.file=opts.from;}else{this.file=_path["default"].resolve(opts.from);}}var map=new _previousMap["default"](this.css,opts);if(map.text){/**
       * The input source map passed from a compilation step before PostCSS
       * (for example, from Sass compiler).
       *
       * @type {PreviousMap}
       *
       * @example
       * root.source.input.map.consumer().sources //=> ['a.sass']
       */this.map=map;var file=map.consumer().file;if(!this.file&&file)this.file=this.mapResolve(file);}if(!this.file){sequence+=1;/**
       * The unique ID of the CSS source. It will be created if `from` option
       * is not provided (because PostCSS does not know the file path).
       *
       * @type {string}
       *
       * @example
       * const root = postcss.parse(css)
       * root.source.input.file //=> undefined
       * root.source.input.id   //=> "<input css 1>"
       */this.id='<input css '+sequence+'>';}if(this.map)this.map.file=this.from;}var _proto=Input.prototype;_proto.error=function error(message,line,column,opts){if(opts===void 0){opts={};}var result;var origin=this.origin(line,column);if(origin){result=new _cssSyntaxError["default"](message,origin.line,origin.column,origin.source,origin.file,opts.plugin);}else{result=new _cssSyntaxError["default"](message,line,column,this.css,this.file,opts.plugin);}result.input={line:line,column:column,source:this.css};if(this.file)result.input.file=this.file;return result;}/**
   * Reads the input source map and returns a symbol position
   * in the input source (e.g., in a Sass file that was compiled
   * to CSS before being passed to PostCSS).
   *
   * @param {number} line   Line in input CSS.
   * @param {number} column Column in input CSS.
   *
   * @return {filePosition} Position in input source.
   *
   * @example
   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
   */;_proto.origin=function origin(line,column){if(!this.map)return false;var consumer=this.map.consumer();var from=consumer.originalPositionFor({line:line,column:column});if(!from.source)return false;var result={file:this.mapResolve(from.source),line:from.line,column:from.column};var source=consumer.sourceContentFor(from.source);if(source)result.source=source;return result;};_proto.mapResolve=function mapResolve(file){if(/^\w+:\/\//.test(file)){return file;}return _path["default"].resolve(this.map.consumer().sourceRoot||'.',file);}/**
   * The CSS source identifier. Contains {@link Input#file} if the user
   * set the `from` option, or {@link Input#id} if they did not.
   *
   * @type {string}
   *
   * @example
   * const root = postcss.parse(css, { from: 'a.css' })
   * root.source.input.from //=> "/home/ai/a.css"
   *
   * const root = postcss.parse(css)
   * root.source.input.from //=> "<input css 1>"
   */;_createClass(Input,[{key:"from",get:function get(){return this.file||this.id;}}]);return Input;}();var _default=Input;/**
 * @typedef  {object} filePosition
 * @property {string} file   Path to file.
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */exports["default"]=_default;module.exports=exports["default"];},{"./css-syntax-error":42,"./previous-map":52,"path":38}],45:[function(require,module,exports){(function(process){"use strict";exports.__esModule=true;exports["default"]=void 0;var _mapGenerator=_interopRequireDefault(require("./map-generator"));var _stringify2=_interopRequireDefault(require("./stringify"));var _warnOnce=_interopRequireDefault(require("./warn-once"));var _result=_interopRequireDefault(require("./result"));var _parse=_interopRequireDefault(require("./parse"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function isPromise(obj){return _typeof(obj)==='object'&&typeof obj.then==='function';}/**
 * A Promise proxy for the result of PostCSS transformations.
 *
 * A `LazyResult` instance is returned by {@link Processor#process}.
 *
 * @example
 * const lazy = postcss([autoprefixer]).process(css)
 */var LazyResult=/*#__PURE__*/function(){function LazyResult(processor,css,opts){this.stringified=false;this.processed=false;var root;if(_typeof(css)==='object'&&css!==null&&css.type==='root'){root=css;}else if(css instanceof LazyResult||css instanceof _result["default"]){root=css.root;if(css.map){if(typeof opts.map==='undefined')opts.map={};if(!opts.map.inline)opts.map.inline=false;opts.map.prev=css.map;}}else{var parser=_parse["default"];if(opts.syntax)parser=opts.syntax.parse;if(opts.parser)parser=opts.parser;if(parser.parse)parser=parser.parse;try{root=parser(css,opts);}catch(error){this.error=error;}}this.result=new _result["default"](processor,root,opts);}/**
   * Returns a {@link Processor} instance, which will be used
   * for CSS transformations.
   *
   * @type {Processor}
   */var _proto=LazyResult.prototype;/**
   * Processes input CSS through synchronous plugins
   * and calls {@link Result#warnings()}.
   *
   * @return {Warning[]} Warnings from plugins.
   */_proto.warnings=function warnings(){return this.sync().warnings();}/**
   * Alias for the {@link LazyResult#css} property.
   *
   * @example
   * lazy + '' === lazy.css
   *
   * @return {string} Output CSS.
   */;_proto.toString=function toString(){return this.css;}/**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls `onFulfilled` with a Result instance. If a plugin throws
   * an error, the `onRejected` callback will be executed.
   *
   * It implements standard Promise API.
   *
   * @param {onFulfilled} onFulfilled Callback will be executed
   *                                  when all plugins will finish work.
   * @param {onRejected}  onRejected  Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {
   *   console.log(result.css)
   * })
   */;_proto.then=function then(onFulfilled,onRejected){if(process.env.NODE_ENV!=='production'){if(!('from'in this.opts)){(0,_warnOnce["default"])('Without `from` option PostCSS could generate wrong source map '+'and will not find Browserslist config. Set it to CSS file path '+'or to `undefined` to prevent this warning.');}}return this.async().then(onFulfilled,onRejected);}/**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onRejected for each error thrown in any plugin.
   *
   * It implements standard Promise API.
   *
   * @param {onRejected} onRejected Callback will be executed on any error.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).then(result => {
   *   console.log(result.css)
   * }).catch(error => {
   *   console.error(error)
   * })
   */;_proto["catch"]=function _catch(onRejected){return this.async()["catch"](onRejected);}/**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onFinally on any error or when all plugins will finish work.
   *
   * It implements standard Promise API.
   *
   * @param {onFinally} onFinally Callback will be executed on any error or
   *                              when all plugins will finish work.
   *
   * @return {Promise} Promise API to make queue.
   *
   * @example
   * postcss([autoprefixer]).process(css).finally(() => {
   *   console.log('processing ended')
   * })
   */;_proto["finally"]=function _finally(onFinally){return this.async().then(onFinally,onFinally);};_proto.handleError=function handleError(error,plugin){try{this.error=error;if(error.name==='CssSyntaxError'&&!error.plugin){error.plugin=plugin.postcssPlugin;error.setMessage();}else if(plugin.postcssVersion){if(process.env.NODE_ENV!=='production'){var pluginName=plugin.postcssPlugin;var pluginVer=plugin.postcssVersion;var runtimeVer=this.result.processor.version;var a=pluginVer.split('.');var b=runtimeVer.split('.');if(a[0]!==b[0]||parseInt(a[1])>parseInt(b[1])){console.error('Unknown error from PostCSS plugin. Your current PostCSS '+'version is '+runtimeVer+', but '+pluginName+' uses '+pluginVer+'. Perhaps this is the source of the error below.');}}}}catch(err){if(console&&console.error)console.error(err);}};_proto.asyncTick=function asyncTick(resolve,reject){var _this=this;if(this.plugin>=this.processor.plugins.length){this.processed=true;return resolve();}try{var plugin=this.processor.plugins[this.plugin];var promise=this.run(plugin);this.plugin+=1;if(isPromise(promise)){promise.then(function(){_this.asyncTick(resolve,reject);})["catch"](function(error){_this.handleError(error,plugin);_this.processed=true;reject(error);});}else{this.asyncTick(resolve,reject);}}catch(error){this.processed=true;reject(error);}};_proto.async=function async(){var _this2=this;if(this.processed){return new Promise(function(resolve,reject){if(_this2.error){reject(_this2.error);}else{resolve(_this2.stringify());}});}if(this.processing){return this.processing;}this.processing=new Promise(function(resolve,reject){if(_this2.error)return reject(_this2.error);_this2.plugin=0;_this2.asyncTick(resolve,reject);}).then(function(){_this2.processed=true;return _this2.stringify();});return this.processing;};_proto.sync=function sync(){if(this.processed)return this.result;this.processed=true;if(this.processing){throw new Error('Use process(css).then(cb) to work with async plugins');}if(this.error)throw this.error;for(var _iterator=this.result.processor.plugins,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var plugin=_ref;var promise=this.run(plugin);if(isPromise(promise)){throw new Error('Use process(css).then(cb) to work with async plugins');}}return this.result;};_proto.run=function run(plugin){this.result.lastPlugin=plugin;try{return plugin(this.result.root,this.result);}catch(error){this.handleError(error,plugin);throw error;}};_proto.stringify=function stringify(){if(this.stringified)return this.result;this.stringified=true;this.sync();var opts=this.result.opts;var str=_stringify2["default"];if(opts.syntax)str=opts.syntax.stringify;if(opts.stringifier)str=opts.stringifier;if(str.stringify)str=str.stringify;var map=new _mapGenerator["default"](str,this.result.root,this.result.opts);var data=map.generate();this.result.css=data[0];this.result.map=data[1];return this.result;};_createClass(LazyResult,[{key:"processor",get:function get(){return this.result.processor;}/**
     * Options from the {@link Processor#process} call.
     *
     * @type {processOptions}
     */},{key:"opts",get:function get(){return this.result.opts;}/**
     * Processes input CSS through synchronous plugins, converts `Root`
     * to a CSS string and returns {@link Result#css}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#css
     */},{key:"css",get:function get(){return this.stringify().css;}/**
     * An alias for the `css` property. Use it with syntaxes
     * that generate non-CSS output.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {string}
     * @see Result#content
     */},{key:"content",get:function get(){return this.stringify().content;}/**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#map}.
     *
     * This property will only work with synchronous plugins.
     * If the processor contains any asynchronous plugins
     * it will throw an error. This is why this method is only
     * for debug purpose, you should always use {@link LazyResult#then}.
     *
     * @type {SourceMapGenerator}
     * @see Result#map
     */},{key:"map",get:function get(){return this.stringify().map;}/**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#root}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Root}
     * @see Result#root
     */},{key:"root",get:function get(){return this.sync().root;}/**
     * Processes input CSS through synchronous plugins
     * and returns {@link Result#messages}.
     *
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error.
     *
     * This is why this method is only for debug purpose,
     * you should always use {@link LazyResult#then}.
     *
     * @type {Message[]}
     * @see Result#messages
     */},{key:"messages",get:function get(){return this.sync().messages;}}]);return LazyResult;}();var _default=LazyResult;/**
 * @callback onFulfilled
 * @param {Result} result
 */ /**
 * @callback onRejected
 * @param {Error} error
 */exports["default"]=_default;module.exports=exports["default"];}).call(this,require('_process'));},{"./map-generator":47,"./parse":49,"./result":54,"./stringify":58,"./warn-once":61,"_process":63}],46:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;/**
 * Contains helpers for safely splitting lists of CSS values,
 * preserving parentheses and quotes.
 *
 * @example
 * const list = postcss.list
 *
 * @namespace list
 */var list={split:function split(string,separators,last){var array=[];var current='';var split=false;var func=0;var quote=false;var escape=false;for(var i=0;i<string.length;i++){var letter=string[i];if(quote){if(escape){escape=false;}else if(letter==='\\'){escape=true;}else if(letter===quote){quote=false;}}else if(letter==='"'||letter==='\''){quote=letter;}else if(letter==='('){func+=1;}else if(letter===')'){if(func>0)func-=1;}else if(func===0){if(separators.indexOf(letter)!==-1)split=true;}if(split){if(current!=='')array.push(current.trim());current='';split=false;}else{current+=letter;}}if(last||current!=='')array.push(current.trim());return array;},/**
   * Safely splits space-separated values (such as those for `background`,
   * `border-radius`, and other shorthand properties).
   *
   * @param {string} string Space-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
   */space:function space(string){var spaces=[' ','\n','\t'];return list.split(string,spaces);},/**
   * Safely splits comma-separated values (such as those for `transition-*`
   * and `background` properties).
   *
   * @param {string} string Comma-separated values.
   *
   * @return {string[]} Split values.
   *
   * @example
   * postcss.list.comma('black, linear-gradient(white, black)')
   * //=> ['black', 'linear-gradient(white, black)']
   */comma:function comma(string){return list.split(string,[','],true);}};var _default=list;exports["default"]=_default;module.exports=exports["default"];},{}],47:[function(require,module,exports){(function(Buffer){"use strict";exports.__esModule=true;exports["default"]=void 0;var _sourceMap=_interopRequireDefault(require("source-map"));var _path=_interopRequireDefault(require("path"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}var MapGenerator=/*#__PURE__*/function(){function MapGenerator(stringify,root,opts){this.stringify=stringify;this.mapOpts=opts.map||{};this.root=root;this.opts=opts;}var _proto=MapGenerator.prototype;_proto.isMap=function isMap(){if(typeof this.opts.map!=='undefined'){return!!this.opts.map;}return this.previous().length>0;};_proto.previous=function previous(){var _this=this;if(!this.previousMaps){this.previousMaps=[];this.root.walk(function(node){if(node.source&&node.source.input.map){var map=node.source.input.map;if(_this.previousMaps.indexOf(map)===-1){_this.previousMaps.push(map);}}});}return this.previousMaps;};_proto.isInline=function isInline(){if(typeof this.mapOpts.inline!=='undefined'){return this.mapOpts.inline;}var annotation=this.mapOpts.annotation;if(typeof annotation!=='undefined'&&annotation!==true){return false;}if(this.previous().length){return this.previous().some(function(i){return i.inline;});}return true;};_proto.isSourcesContent=function isSourcesContent(){if(typeof this.mapOpts.sourcesContent!=='undefined'){return this.mapOpts.sourcesContent;}if(this.previous().length){return this.previous().some(function(i){return i.withContent();});}return true;};_proto.clearAnnotation=function clearAnnotation(){if(this.mapOpts.annotation===false)return;var node;for(var i=this.root.nodes.length-1;i>=0;i--){node=this.root.nodes[i];if(node.type!=='comment')continue;if(node.text.indexOf('# sourceMappingURL=')===0){this.root.removeChild(i);}}};_proto.setSourcesContent=function setSourcesContent(){var _this2=this;var already={};this.root.walk(function(node){if(node.source){var from=node.source.input.from;if(from&&!already[from]){already[from]=true;var relative=_this2.relative(from);_this2.map.setSourceContent(relative,node.source.input.css);}}});};_proto.applyPrevMaps=function applyPrevMaps(){for(var _iterator=this.previous(),_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var prev=_ref;var from=this.relative(prev.file);var root=prev.root||_path["default"].dirname(prev.file);var map=void 0;if(this.mapOpts.sourcesContent===false){map=new _sourceMap["default"].SourceMapConsumer(prev.text);if(map.sourcesContent){map.sourcesContent=map.sourcesContent.map(function(){return null;});}}else{map=prev.consumer();}this.map.applySourceMap(map,from,this.relative(root));}};_proto.isAnnotation=function isAnnotation(){if(this.isInline()){return true;}if(typeof this.mapOpts.annotation!=='undefined'){return this.mapOpts.annotation;}if(this.previous().length){return this.previous().some(function(i){return i.annotation;});}return true;};_proto.toBase64=function toBase64(str){if(Buffer){return Buffer.from(str).toString('base64');}return window.btoa(unescape(encodeURIComponent(str)));};_proto.addAnnotation=function addAnnotation(){var content;if(this.isInline()){content='data:application/json;base64,'+this.toBase64(this.map.toString());}else if(typeof this.mapOpts.annotation==='string'){content=this.mapOpts.annotation;}else{content=this.outputFile()+'.map';}var eol='\n';if(this.css.indexOf('\r\n')!==-1)eol='\r\n';this.css+=eol+'/*# sourceMappingURL='+content+' */';};_proto.outputFile=function outputFile(){if(this.opts.to){return this.relative(this.opts.to);}if(this.opts.from){return this.relative(this.opts.from);}return'to.css';};_proto.generateMap=function generateMap(){this.generateString();if(this.isSourcesContent())this.setSourcesContent();if(this.previous().length>0)this.applyPrevMaps();if(this.isAnnotation())this.addAnnotation();if(this.isInline()){return[this.css];}return[this.css,this.map];};_proto.relative=function relative(file){if(file.indexOf('<')===0)return file;if(/^\w+:\/\//.test(file))return file;var from=this.opts.to?_path["default"].dirname(this.opts.to):'.';if(typeof this.mapOpts.annotation==='string'){from=_path["default"].dirname(_path["default"].resolve(from,this.mapOpts.annotation));}file=_path["default"].relative(from,file);if(_path["default"].sep==='\\'){return file.replace(/\\/g,'/');}return file;};_proto.sourcePath=function sourcePath(node){if(this.mapOpts.from){return this.mapOpts.from;}return this.relative(node.source.input.from);};_proto.generateString=function generateString(){var _this3=this;this.css='';this.map=new _sourceMap["default"].SourceMapGenerator({file:this.outputFile()});var line=1;var column=1;var lines,last;this.stringify(this.root,function(str,node,type){_this3.css+=str;if(node&&type!=='end'){if(node.source&&node.source.start){_this3.map.addMapping({source:_this3.sourcePath(node),generated:{line:line,column:column-1},original:{line:node.source.start.line,column:node.source.start.column-1}});}else{_this3.map.addMapping({source:'<no source>',original:{line:1,column:0},generated:{line:line,column:column-1}});}}lines=str.match(/\n/g);if(lines){line+=lines.length;last=str.lastIndexOf('\n');column=str.length-last;}else{column+=str.length;}if(node&&type!=='start'){var p=node.parent||{raws:{}};if(node.type!=='decl'||node!==p.last||p.raws.semicolon){if(node.source&&node.source.end){_this3.map.addMapping({source:_this3.sourcePath(node),generated:{line:line,column:column-2},original:{line:node.source.end.line,column:node.source.end.column-1}});}else{_this3.map.addMapping({source:'<no source>',original:{line:1,column:0},generated:{line:line,column:column-1}});}}}});};_proto.generate=function generate(){this.clearAnnotation();if(this.isMap()){return this.generateMap();}var result='';this.stringify(this.root,function(i){result+=i;});return[result];};return MapGenerator;}();var _default=MapGenerator;exports["default"]=_default;module.exports=exports["default"];}).call(this,require("buffer").Buffer);},{"buffer":3,"path":38,"source-map":78}],48:[function(require,module,exports){(function(process){"use strict";exports.__esModule=true;exports["default"]=void 0;var _cssSyntaxError=_interopRequireDefault(require("./css-syntax-error"));var _stringifier=_interopRequireDefault(require("./stringifier"));var _stringify=_interopRequireDefault(require("./stringify"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function cloneNode(obj,parent){var cloned=new obj.constructor();for(var i in obj){if(!obj.hasOwnProperty(i))continue;var value=obj[i];var type=_typeof(value);if(i==='parent'&&type==='object'){if(parent)cloned[i]=parent;}else if(i==='source'){cloned[i]=value;}else if(value instanceof Array){cloned[i]=value.map(function(j){return cloneNode(j,cloned);});}else{if(type==='object'&&value!==null)value=cloneNode(value);cloned[i]=value;}}return cloned;}/**
 * All node classes inherit the following common methods.
 *
 * @abstract
 */var Node=/*#__PURE__*/function(){/**
   * @param {object} [defaults] Value for node properties.
   */function Node(defaults){if(defaults===void 0){defaults={};}this.raws={};if(process.env.NODE_ENV!=='production'){if(_typeof(defaults)!=='object'&&typeof defaults!=='undefined'){throw new Error('PostCSS nodes constructor accepts object, not '+JSON.stringify(defaults));}}for(var name in defaults){this[name]=defaults[name];}}/**
   * Returns a `CssSyntaxError` instance containing the original position
   * of the node in the source, showing line and column numbers and also
   * a small excerpt to facilitate debugging.
   *
   * If present, an input source map will be used to get the original position
   * of the source, even from a previous compilation step
   * (e.g., from Sass compilation).
   *
   * This method produces very useful error messages.
   *
   * @param {string} message     Error description.
   * @param {object} [opts]      Options.
   * @param {string} opts.plugin Plugin name that created this error.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a node’s string that should
   *                             be highlighted as the source of the error.
   * @param {number} opts.index  An index inside a node’s string that should
   *                             be highlighted as the source of the error.
   *
   * @return {CssSyntaxError} Error object to throw it.
   *
   * @example
   * if (!variables[name]) {
   *   throw decl.error('Unknown variable ' + name, { word: name })
   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
   *   //   color: $black
   *   // a
   *   //          ^
   *   //   background: white
   * }
   */var _proto=Node.prototype;_proto.error=function error(message,opts){if(opts===void 0){opts={};}if(this.source){var pos=this.positionBy(opts);return this.source.input.error(message,pos.line,pos.column,opts);}return new _cssSyntaxError["default"](message);}/**
   * This method is provided as a convenience wrapper for {@link Result#warn}.
   *
   * @param {Result} result      The {@link Result} instance
   *                             that will receive the warning.
   * @param {string} text        Warning message.
   * @param {object} [opts]      Options
   * @param {string} opts.plugin Plugin name that created this warning.
   *                             PostCSS will set it automatically.
   * @param {string} opts.word   A word inside a node’s string that should
   *                             be highlighted as the source of the warning.
   * @param {number} opts.index  An index inside a node’s string that should
   *                             be highlighted as the source of the warning.
   *
   * @return {Warning} Created warning object.
   *
   * @example
   * const plugin = postcss.plugin('postcss-deprecated', () => {
   *   return (root, result) => {
   *     root.walkDecls('bad', decl => {
   *       decl.warn(result, 'Deprecated property bad')
   *     })
   *   }
   * })
   */;_proto.warn=function warn(result,text,opts){var data={node:this};for(var i in opts){data[i]=opts[i];}return result.warn(text,data);}/**
   * Removes the node from its parent and cleans the parent properties
   * from the node and its children.
   *
   * @example
   * if (decl.prop.match(/^-webkit-/)) {
   *   decl.remove()
   * }
   *
   * @return {Node} Node to make calls chain.
   */;_proto.remove=function remove(){if(this.parent){this.parent.removeChild(this);}this.parent=undefined;return this;}/**
   * Returns a CSS string representing the node.
   *
   * @param {stringifier|syntax} [stringifier] A syntax to use
   *                                           in string generation.
   *
   * @return {string} CSS string of this node.
   *
   * @example
   * postcss.rule({ selector: 'a' }).toString() //=> "a {}"
   */;_proto.toString=function toString(stringifier){if(stringifier===void 0){stringifier=_stringify["default"];}if(stringifier.stringify)stringifier=stringifier.stringify;var result='';stringifier(this,function(i){result+=i;});return result;}/**
   * Returns an exact clone of the node.
   *
   * The resulting cloned node and its (cloned) children will retain
   * code style properties.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @example
   * decl.raws.before    //=> "\n  "
   * const cloned = decl.clone({ prop: '-moz-' + decl.prop })
   * cloned.raws.before  //=> "\n  "
   * cloned.toString()   //=> -moz-transform: scale(0)
   *
   * @return {Node} Clone of the node.
   */;_proto.clone=function clone(overrides){if(overrides===void 0){overrides={};}var cloned=cloneNode(this);for(var name in overrides){cloned[name]=overrides[name];}return cloned;}/**
   * Shortcut to clone the node and insert the resulting cloned node
   * before the current node.
   *
   * @param {object} [overrides] Mew properties to override in the clone.
   *
   * @example
   * decl.cloneBefore({ prop: '-moz-' + decl.prop })
   *
   * @return {Node} New node
   */;_proto.cloneBefore=function cloneBefore(overrides){if(overrides===void 0){overrides={};}var cloned=this.clone(overrides);this.parent.insertBefore(this,cloned);return cloned;}/**
   * Shortcut to clone the node and insert the resulting cloned node
   * after the current node.
   *
   * @param {object} [overrides] New properties to override in the clone.
   *
   * @return {Node} New node.
   */;_proto.cloneAfter=function cloneAfter(overrides){if(overrides===void 0){overrides={};}var cloned=this.clone(overrides);this.parent.insertAfter(this,cloned);return cloned;}/**
   * Inserts node(s) before the current node and removes the current node.
   *
   * @param {...Node} nodes Mode(s) to replace current one.
   *
   * @example
   * if (atrule.name === 'mixin') {
   *   atrule.replaceWith(mixinRules[atrule.params])
   * }
   *
   * @return {Node} Current node to methods chain.
   */;_proto.replaceWith=function replaceWith(){if(this.parent){for(var _len=arguments.length,nodes=new Array(_len),_key=0;_key<_len;_key++){nodes[_key]=arguments[_key];}for(var _i=0,_nodes=nodes;_i<_nodes.length;_i++){var node=_nodes[_i];this.parent.insertBefore(this,node);}this.remove();}return this;}/**
   * Returns the next child of the node’s parent.
   * Returns `undefined` if the current node is the last child.
   *
   * @return {Node|undefined} Next node.
   *
   * @example
   * if (comment.text === 'delete next') {
   *   const next = comment.next()
   *   if (next) {
   *     next.remove()
   *   }
   * }
   */;_proto.next=function next(){if(!this.parent)return undefined;var index=this.parent.index(this);return this.parent.nodes[index+1];}/**
   * Returns the previous child of the node’s parent.
   * Returns `undefined` if the current node is the first child.
   *
   * @return {Node|undefined} Previous node.
   *
   * @example
   * const annotation = decl.prev()
   * if (annotation.type === 'comment') {
   *   readAnnotation(annotation.text)
   * }
   */;_proto.prev=function prev(){if(!this.parent)return undefined;var index=this.parent.index(this);return this.parent.nodes[index-1];}/**
   * Insert new node before current node to current node’s parent.
   *
   * Just alias for `node.parent.insertBefore(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.before('content: ""')
   */;_proto.before=function before(add){this.parent.insertBefore(this,add);return this;}/**
   * Insert new node after current node to current node’s parent.
   *
   * Just alias for `node.parent.insertAfter(node, add)`.
   *
   * @param {Node|object|string|Node[]} add New node.
   *
   * @return {Node} This node for methods chain.
   *
   * @example
   * decl.after('color: black')
   */;_proto.after=function after(add){this.parent.insertAfter(this,add);return this;};_proto.toJSON=function toJSON(){var fixed={};for(var name in this){if(!this.hasOwnProperty(name))continue;if(name==='parent')continue;var value=this[name];if(value instanceof Array){fixed[name]=value.map(function(i){if(_typeof(i)==='object'&&i.toJSON){return i.toJSON();}else{return i;}});}else if(_typeof(value)==='object'&&value.toJSON){fixed[name]=value.toJSON();}else{fixed[name]=value;}}return fixed;}/**
   * Returns a {@link Node#raws} value. If the node is missing
   * the code style property (because the node was manually built or cloned),
   * PostCSS will try to autodetect the code style property by looking
   * at other nodes in the tree.
   *
   * @param {string} prop          Name of code style property.
   * @param {string} [defaultType] Name of default value, it can be missed
   *                               if the value is the same as prop.
   *
   * @example
   * const root = postcss.parse('a { background: white }')
   * root.nodes[0].append({ prop: 'color', value: 'black' })
   * root.nodes[0].nodes[1].raws.before   //=> undefined
   * root.nodes[0].nodes[1].raw('before') //=> ' '
   *
   * @return {string} Code style value.
   */;_proto.raw=function raw(prop,defaultType){var str=new _stringifier["default"]();return str.raw(this,prop,defaultType);}/**
   * Finds the Root instance of the node’s tree.
   *
   * @example
   * root.nodes[0].nodes[0].root() === root
   *
   * @return {Root} Root parent.
   */;_proto.root=function root(){var result=this;while(result.parent){result=result.parent;}return result;}/**
   * Clear the code style properties for the node and its children.
   *
   * @param {boolean} [keepBetween] Keep the raws.between symbols.
   *
   * @return {undefined}
   *
   * @example
   * node.raws.before  //=> ' '
   * node.cleanRaws()
   * node.raws.before  //=> undefined
   */;_proto.cleanRaws=function cleanRaws(keepBetween){delete this.raws.before;delete this.raws.after;if(!keepBetween)delete this.raws.between;};_proto.positionInside=function positionInside(index){var string=this.toString();var column=this.source.start.column;var line=this.source.start.line;for(var i=0;i<index;i++){if(string[i]==='\n'){column=1;line+=1;}else{column+=1;}}return{line:line,column:column};};_proto.positionBy=function positionBy(opts){var pos=this.source.start;if(opts.index){pos=this.positionInside(opts.index);}else if(opts.word){var index=this.toString().indexOf(opts.word);if(index!==-1)pos=this.positionInside(index);}return pos;}/**
   * @memberof Node#
   * @member {string} type String representing the node’s type.
   *                       Possible values are `root`, `atrule`, `rule`,
   *                       `decl`, or `comment`.
   *
   * @example
   * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'
   */ /**
   * @memberof Node#
   * @member {Container} parent The node’s parent node.
   *
   * @example
   * root.nodes[0].parent === root
   */ /**
   * @memberof Node#
   * @member {source} source The input source of the node.
   *
   * The property is used in source map generation.
   *
   * If you create a node manually (e.g., with `postcss.decl()`),
   * that node will not have a `source` property and will be absent
   * from the source map. For this reason, the plugin developer should
   * consider cloning nodes to create new ones (in which case the new node’s
   * source will reference the original, cloned node) or setting
   * the `source` property manually.
   *
   * ```js
   * // Bad
   * const prefixed = postcss.decl({
   *   prop: '-moz-' + decl.prop,
   *   value: decl.value
   * })
   *
   * // Good
   * const prefixed = decl.clone({ prop: '-moz-' + decl.prop })
   * ```
   *
   * ```js
   * if (atrule.name === 'add-link') {
   *   const rule = postcss.rule({ selector: 'a', source: atrule.source })
   *   atrule.parent.insertBefore(atrule, rule)
   * }
   * ```
   *
   * @example
   * decl.source.input.from //=> '/home/ai/a.sass'
   * decl.source.start      //=> { line: 10, column: 2 }
   * decl.source.end        //=> { line: 10, column: 12 }
   */ /**
   * @memberof Node#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   * * `left`: the space symbols between `/*` and the comment’s text.
   * * `right`: the space symbols between the comment’s text
   *   and <code>*&#47;</code>.
   * * `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS cleans selectors, declaration values and at-rule parameters
   * from comments and extra spaces, but it stores origin content in raws
   * properties. As such, if you don’t change a declaration’s value,
   * PostCSS will use the raw value with comments.
   *
   * @example
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   */;return Node;}();var _default=Node;/**
 * @typedef {object} position
 * @property {number} line   Source line in file.
 * @property {number} column Source column in file.
 */ /**
 * @typedef {object} source
 * @property {Input} input    {@link Input} with input file
 * @property {position} start The starting position of the node’s source.
 * @property {position} end   The ending position of the node’s source.
 */exports["default"]=_default;module.exports=exports["default"];}).call(this,require('_process'));},{"./css-syntax-error":42,"./stringifier":57,"./stringify":58,"_process":63}],49:[function(require,module,exports){(function(process){"use strict";exports.__esModule=true;exports["default"]=void 0;var _parser=_interopRequireDefault(require("./parser"));var _input=_interopRequireDefault(require("./input"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function parse(css,opts){var input=new _input["default"](css,opts);var parser=new _parser["default"](input);try{parser.parse();}catch(e){if(process.env.NODE_ENV!=='production'){if(e.name==='CssSyntaxError'&&opts&&opts.from){if(/\.scss$/i.test(opts.from)){e.message+='\nYou tried to parse SCSS with '+'the standard CSS parser; '+'try again with the postcss-scss parser';}else if(/\.sass/i.test(opts.from)){e.message+='\nYou tried to parse Sass with '+'the standard CSS parser; '+'try again with the postcss-sass parser';}else if(/\.less$/i.test(opts.from)){e.message+='\nYou tried to parse Less with '+'the standard CSS parser; '+'try again with the postcss-less parser';}}}throw e;}return parser.root;}var _default=parse;exports["default"]=_default;module.exports=exports["default"];}).call(this,require('_process'));},{"./input":44,"./parser":50,"_process":63}],50:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _declaration=_interopRequireDefault(require("./declaration"));var _tokenize=_interopRequireDefault(require("./tokenize"));var _comment=_interopRequireDefault(require("./comment"));var _atRule=_interopRequireDefault(require("./at-rule"));var _root=_interopRequireDefault(require("./root"));var _rule=_interopRequireDefault(require("./rule"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}var Parser=/*#__PURE__*/function(){function Parser(input){this.input=input;this.root=new _root["default"]();this.current=this.root;this.spaces='';this.semicolon=false;this.createTokenizer();this.root.source={input:input,start:{line:1,column:1}};}var _proto=Parser.prototype;_proto.createTokenizer=function createTokenizer(){this.tokenizer=(0,_tokenize["default"])(this.input);};_proto.parse=function parse(){var token;while(!this.tokenizer.endOfFile()){token=this.tokenizer.nextToken();switch(token[0]){case'space':this.spaces+=token[1];break;case';':this.freeSemicolon(token);break;case'}':this.end(token);break;case'comment':this.comment(token);break;case'at-word':this.atrule(token);break;case'{':this.emptyRule(token);break;default:this.other(token);break;}}this.endFile();};_proto.comment=function comment(token){var node=new _comment["default"]();this.init(node,token[2],token[3]);node.source.end={line:token[4],column:token[5]};var text=token[1].slice(2,-2);if(/^\s*$/.test(text)){node.text='';node.raws.left=text;node.raws.right='';}else{var match=text.match(/^(\s*)([^]*[^\s])(\s*)$/);node.text=match[2];node.raws.left=match[1];node.raws.right=match[3];}};_proto.emptyRule=function emptyRule(token){var node=new _rule["default"]();this.init(node,token[2],token[3]);node.selector='';node.raws.between='';this.current=node;};_proto.other=function other(start){var end=false;var type=null;var colon=false;var bracket=null;var brackets=[];var tokens=[];var token=start;while(token){type=token[0];tokens.push(token);if(type==='('||type==='['){if(!bracket)bracket=token;brackets.push(type==='('?')':']');}else if(brackets.length===0){if(type===';'){if(colon){this.decl(tokens);return;}else{break;}}else if(type==='{'){this.rule(tokens);return;}else if(type==='}'){this.tokenizer.back(tokens.pop());end=true;break;}else if(type===':'){colon=true;}}else if(type===brackets[brackets.length-1]){brackets.pop();if(brackets.length===0)bracket=null;}token=this.tokenizer.nextToken();}if(this.tokenizer.endOfFile())end=true;if(brackets.length>0)this.unclosedBracket(bracket);if(end&&colon){while(tokens.length){token=tokens[tokens.length-1][0];if(token!=='space'&&token!=='comment')break;this.tokenizer.back(tokens.pop());}this.decl(tokens);}else{this.unknownWord(tokens);}};_proto.rule=function rule(tokens){tokens.pop();var node=new _rule["default"]();this.init(node,tokens[0][2],tokens[0][3]);node.raws.between=this.spacesAndCommentsFromEnd(tokens);this.raw(node,'selector',tokens);this.current=node;};_proto.decl=function decl(tokens){var node=new _declaration["default"]();this.init(node);var last=tokens[tokens.length-1];if(last[0]===';'){this.semicolon=true;tokens.pop();}if(last[4]){node.source.end={line:last[4],column:last[5]};}else{node.source.end={line:last[2],column:last[3]};}while(tokens[0][0]!=='word'){if(tokens.length===1)this.unknownWord(tokens);node.raws.before+=tokens.shift()[1];}node.source.start={line:tokens[0][2],column:tokens[0][3]};node.prop='';while(tokens.length){var type=tokens[0][0];if(type===':'||type==='space'||type==='comment'){break;}node.prop+=tokens.shift()[1];}node.raws.between='';var token;while(tokens.length){token=tokens.shift();if(token[0]===':'){node.raws.between+=token[1];break;}else{if(token[0]==='word'&&/\w/.test(token[1])){this.unknownWord([token]);}node.raws.between+=token[1];}}if(node.prop[0]==='_'||node.prop[0]==='*'){node.raws.before+=node.prop[0];node.prop=node.prop.slice(1);}node.raws.between+=this.spacesAndCommentsFromStart(tokens);this.precheckMissedSemicolon(tokens);for(var i=tokens.length-1;i>0;i--){token=tokens[i];if(token[1].toLowerCase()==='!important'){node.important=true;var string=this.stringFrom(tokens,i);string=this.spacesFromEnd(tokens)+string;if(string!==' !important')node.raws.important=string;break;}else if(token[1].toLowerCase()==='important'){var cache=tokens.slice(0);var str='';for(var j=i;j>0;j--){var _type=cache[j][0];if(str.trim().indexOf('!')===0&&_type!=='space'){break;}str=cache.pop()[1]+str;}if(str.trim().indexOf('!')===0){node.important=true;node.raws.important=str;tokens=cache;}}if(token[0]!=='space'&&token[0]!=='comment'){break;}}this.raw(node,'value',tokens);if(node.value.indexOf(':')!==-1)this.checkMissedSemicolon(tokens);};_proto.atrule=function atrule(token){var node=new _atRule["default"]();node.name=token[1].slice(1);if(node.name===''){this.unnamedAtrule(node,token);}this.init(node,token[2],token[3]);var prev;var shift;var last=false;var open=false;var params=[];while(!this.tokenizer.endOfFile()){token=this.tokenizer.nextToken();if(token[0]===';'){node.source.end={line:token[2],column:token[3]};this.semicolon=true;break;}else if(token[0]==='{'){open=true;break;}else if(token[0]==='}'){if(params.length>0){shift=params.length-1;prev=params[shift];while(prev&&prev[0]==='space'){prev=params[--shift];}if(prev){node.source.end={line:prev[4],column:prev[5]};}}this.end(token);break;}else{params.push(token);}if(this.tokenizer.endOfFile()){last=true;break;}}node.raws.between=this.spacesAndCommentsFromEnd(params);if(params.length){node.raws.afterName=this.spacesAndCommentsFromStart(params);this.raw(node,'params',params);if(last){token=params[params.length-1];node.source.end={line:token[4],column:token[5]};this.spaces=node.raws.between;node.raws.between='';}}else{node.raws.afterName='';node.params='';}if(open){node.nodes=[];this.current=node;}};_proto.end=function end(token){if(this.current.nodes&&this.current.nodes.length){this.current.raws.semicolon=this.semicolon;}this.semicolon=false;this.current.raws.after=(this.current.raws.after||'')+this.spaces;this.spaces='';if(this.current.parent){this.current.source.end={line:token[2],column:token[3]};this.current=this.current.parent;}else{this.unexpectedClose(token);}};_proto.endFile=function endFile(){if(this.current.parent)this.unclosedBlock();if(this.current.nodes&&this.current.nodes.length){this.current.raws.semicolon=this.semicolon;}this.current.raws.after=(this.current.raws.after||'')+this.spaces;};_proto.freeSemicolon=function freeSemicolon(token){this.spaces+=token[1];if(this.current.nodes){var prev=this.current.nodes[this.current.nodes.length-1];if(prev&&prev.type==='rule'&&!prev.raws.ownSemicolon){prev.raws.ownSemicolon=this.spaces;this.spaces='';}}}// Helpers
;_proto.init=function init(node,line,column){this.current.push(node);node.source={start:{line:line,column:column},input:this.input};node.raws.before=this.spaces;this.spaces='';if(node.type!=='comment')this.semicolon=false;};_proto.raw=function raw(node,prop,tokens){var token,type;var length=tokens.length;var value='';var clean=true;var next,prev;var pattern=/^([.|#])?([\w])+/i;for(var i=0;i<length;i+=1){token=tokens[i];type=token[0];if(type==='comment'&&node.type==='rule'){prev=tokens[i-1];next=tokens[i+1];if(prev[0]!=='space'&&next[0]!=='space'&&pattern.test(prev[1])&&pattern.test(next[1])){value+=token[1];}else{clean=false;}continue;}if(type==='comment'||type==='space'&&i===length-1){clean=false;}else{value+=token[1];}}if(!clean){var raw=tokens.reduce(function(all,i){return all+i[1];},'');node.raws[prop]={value:value,raw:raw};}node[prop]=value;};_proto.spacesAndCommentsFromEnd=function spacesAndCommentsFromEnd(tokens){var lastTokenType;var spaces='';while(tokens.length){lastTokenType=tokens[tokens.length-1][0];if(lastTokenType!=='space'&&lastTokenType!=='comment')break;spaces=tokens.pop()[1]+spaces;}return spaces;};_proto.spacesAndCommentsFromStart=function spacesAndCommentsFromStart(tokens){var next;var spaces='';while(tokens.length){next=tokens[0][0];if(next!=='space'&&next!=='comment')break;spaces+=tokens.shift()[1];}return spaces;};_proto.spacesFromEnd=function spacesFromEnd(tokens){var lastTokenType;var spaces='';while(tokens.length){lastTokenType=tokens[tokens.length-1][0];if(lastTokenType!=='space')break;spaces=tokens.pop()[1]+spaces;}return spaces;};_proto.stringFrom=function stringFrom(tokens,from){var result='';for(var i=from;i<tokens.length;i++){result+=tokens[i][1];}tokens.splice(from,tokens.length-from);return result;};_proto.colon=function colon(tokens){var brackets=0;var token,type,prev;for(var i=0;i<tokens.length;i++){token=tokens[i];type=token[0];if(type==='('){brackets+=1;}if(type===')'){brackets-=1;}if(brackets===0&&type===':'){if(!prev){this.doubleColon(token);}else if(prev[0]==='word'&&prev[1]==='progid'){continue;}else{return i;}}prev=token;}return false;}// Errors
;_proto.unclosedBracket=function unclosedBracket(bracket){throw this.input.error('Unclosed bracket',bracket[2],bracket[3]);};_proto.unknownWord=function unknownWord(tokens){throw this.input.error('Unknown word',tokens[0][2],tokens[0][3]);};_proto.unexpectedClose=function unexpectedClose(token){throw this.input.error('Unexpected }',token[2],token[3]);};_proto.unclosedBlock=function unclosedBlock(){var pos=this.current.source.start;throw this.input.error('Unclosed block',pos.line,pos.column);};_proto.doubleColon=function doubleColon(token){throw this.input.error('Double colon',token[2],token[3]);};_proto.unnamedAtrule=function unnamedAtrule(node,token){throw this.input.error('At-rule without name',token[2],token[3]);};_proto.precheckMissedSemicolon=function precheckMissedSemicolon()/* tokens */{// Hook for Safe Parser
};_proto.checkMissedSemicolon=function checkMissedSemicolon(tokens){var colon=this.colon(tokens);if(colon===false)return;var founded=0;var token;for(var j=colon-1;j>=0;j--){token=tokens[j];if(token[0]!=='space'){founded+=1;if(founded===2)break;}}throw this.input.error('Missed semicolon',token[2],token[3]);};return Parser;}();exports["default"]=Parser;module.exports=exports["default"];},{"./at-rule":39,"./comment":40,"./declaration":43,"./root":55,"./rule":56,"./tokenize":59}],51:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _declaration=_interopRequireDefault(require("./declaration"));var _processor=_interopRequireDefault(require("./processor"));var _stringify=_interopRequireDefault(require("./stringify"));var _comment=_interopRequireDefault(require("./comment"));var _atRule=_interopRequireDefault(require("./at-rule"));var _vendor=_interopRequireDefault(require("./vendor"));var _parse=_interopRequireDefault(require("./parse"));var _list=_interopRequireDefault(require("./list"));var _rule=_interopRequireDefault(require("./rule"));var _root=_interopRequireDefault(require("./root"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}/**
 * Create a new {@link Processor} instance that will apply `plugins`
 * as CSS processors.
 *
 * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
 *        See {@link Processor#use} for plugin format.
 *
 * @return {Processor} Processor to process multiple CSS.
 *
 * @example
 * import postcss from 'postcss'
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css)
 * })
 *
 * @namespace postcss
 */function postcss(){for(var _len=arguments.length,plugins=new Array(_len),_key=0;_key<_len;_key++){plugins[_key]=arguments[_key];}if(plugins.length===1&&Array.isArray(plugins[0])){plugins=plugins[0];}return new _processor["default"](plugins);}/**
 * Creates a PostCSS plugin with a standard API.
 *
 * The newly-wrapped function will provide both the name and PostCSS
 * version of the plugin.
 *
 * ```js
 * const processor = postcss([replace])
 * processor.plugins[0].postcssPlugin  //=> 'postcss-replace'
 * processor.plugins[0].postcssVersion //=> '6.0.0'
 * ```
 *
 * The plugin function receives 2 arguments: {@link Root}
 * and {@link Result} instance. The function should mutate the provided
 * `Root` node. Alternatively, you can create a new `Root` node
 * and override the `result.root` property.
 *
 * ```js
 * const cleaner = postcss.plugin('postcss-cleaner', () => {
 *   return (root, result) => {
 *     result.root = postcss.root()
 *   }
 * })
 * ```
 *
 * As a convenience, plugins also expose a `process` method so that you can use
 * them as standalone tools.
 *
 * ```js
 * cleaner.process(css, processOpts, pluginOpts)
 * // This is equivalent to:
 * postcss([ cleaner(pluginOpts) ]).process(css, processOpts)
 * ```
 *
 * Asynchronous plugins should return a `Promise` instance.
 *
 * ```js
 * postcss.plugin('postcss-import', () => {
 *   return (root, result) => {
 *     return new Promise( (resolve, reject) => {
 *       fs.readFile('base.css', (base) => {
 *         root.prepend(base)
 *         resolve()
 *       })
 *     })
 *   }
 * })
 * ```
 *
 * Add warnings using the {@link Node#warn} method.
 * Send data to other plugins using the {@link Result#messages} array.
 *
 * ```js
 * postcss.plugin('postcss-caniuse-test', () => {
 *   return (root, result) => {
 *     root.walkDecls(decl => {
 *       if (!caniuse.support(decl.prop)) {
 *         decl.warn(result, 'Some browsers do not support ' + decl.prop)
 *       }
 *     })
 *   }
 * })
 * ```
 *
 * @param {string} name          PostCSS plugin name. Same as in `name`
 *                               property in `package.json`. It will be saved
 *                               in `plugin.postcssPlugin` property.
 * @param {function} initializer Will receive plugin options
 *                               and should return {@link pluginFunction}
 *
 * @return {Plugin} PostCSS plugin.
 */postcss.plugin=function plugin(name,initializer){function creator(){var transformer=initializer.apply(void 0,arguments);transformer.postcssPlugin=name;transformer.postcssVersion=new _processor["default"]().version;return transformer;}var cache;Object.defineProperty(creator,'postcss',{get:function get(){if(!cache)cache=creator();return cache;}});creator.process=function(css,processOpts,pluginOpts){return postcss([creator(pluginOpts)]).process(css,processOpts);};return creator;};/**
 * Default function to convert a node tree into a CSS string.
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from node’s parts
 *                          or generate string and source map.
 *
 * @return {void}
 *
 * @function
 */postcss.stringify=_stringify["default"];/**
 * Parses source css and returns a new {@link Root} node,
 * which contains the source CSS nodes.
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST.
 *
 * @example
 * // Simple CSS concatenation with source map support
 * const root1 = postcss.parse(css1, { from: file1 })
 * const root2 = postcss.parse(css2, { from: file2 })
 * root1.append(root2).toResult().css
 *
 * @function
 */postcss.parse=_parse["default"];/**
 * Contains the {@link vendor} module.
 *
 * @type {vendor}
 *
 * @example
 * postcss.vendor.unprefixed('-moz-tab') //=> ['tab']
 */postcss.vendor=_vendor["default"];/**
 * Contains the {@link list} module.
 *
 * @member {list}
 *
 * @example
 * postcss.list.space('5px calc(10% + 5px)') //=> ['5px', 'calc(10% + 5px)']
 */postcss.list=_list["default"];/**
 * Creates a new {@link Comment} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Comment} New comment node
 *
 * @example
 * postcss.comment({ text: 'test' })
 */postcss.comment=function(defaults){return new _comment["default"](defaults);};/**
 * Creates a new {@link AtRule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {AtRule} new at-rule node
 *
 * @example
 * postcss.atRule({ name: 'charset' }).toString() //=> "@charset"
 */postcss.atRule=function(defaults){return new _atRule["default"](defaults);};/**
 * Creates a new {@link Declaration} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Declaration} new declaration node
 *
 * @example
 * postcss.decl({ prop: 'color', value: 'red' }).toString() //=> "color: red"
 */postcss.decl=function(defaults){return new _declaration["default"](defaults);};/**
 * Creates a new {@link Rule} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Rule} new rule node
 *
 * @example
 * postcss.rule({ selector: 'a' }).toString() //=> "a {\n}"
 */postcss.rule=function(defaults){return new _rule["default"](defaults);};/**
 * Creates a new {@link Root} node.
 *
 * @param {object} [defaults] Properties for the new node.
 *
 * @return {Root} new root node.
 *
 * @example
 * postcss.root({ after: '\n' }).toString() //=> "\n"
 */postcss.root=function(defaults){return new _root["default"](defaults);};var _default=postcss;exports["default"]=_default;module.exports=exports["default"];},{"./at-rule":39,"./comment":40,"./declaration":43,"./list":46,"./parse":49,"./processor":53,"./root":55,"./rule":56,"./stringify":58,"./vendor":60}],52:[function(require,module,exports){(function(Buffer){"use strict";exports.__esModule=true;exports["default"]=void 0;var _sourceMap=_interopRequireDefault(require("source-map"));var _path=_interopRequireDefault(require("path"));var _fs=_interopRequireDefault(require("fs"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function fromBase64(str){if(Buffer){return Buffer.from(str,'base64').toString();}else{return window.atob(str);}}/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * @example
 * const root = postcss.parse(css, { from: 'a.sass.css' })
 * root.input.map //=> PreviousMap
 */var PreviousMap=/*#__PURE__*/function(){/**
   * @param {string}         css    Input CSS source.
   * @param {processOptions} [opts] {@link Processor#process} options.
   */function PreviousMap(css,opts){this.loadAnnotation(css);/**
     * Was source map inlined by data-uri to input CSS.
     *
     * @type {boolean}
     */this.inline=this.startWith(this.annotation,'data:');var prev=opts.map?opts.map.prev:undefined;var text=this.loadMap(opts.from,prev);if(text)this.text=text;}/**
   * Create a instance of `SourceMapGenerator` class
   * from the `source-map` library to work with source map information.
   *
   * It is lazy method, so it will create object only on first call
   * and then it will use cache.
   *
   * @return {SourceMapGenerator} Object with source map information.
   */var _proto=PreviousMap.prototype;_proto.consumer=function consumer(){if(!this.consumerCache){this.consumerCache=new _sourceMap["default"].SourceMapConsumer(this.text);}return this.consumerCache;}/**
   * Does source map contains `sourcesContent` with input source text.
   *
   * @return {boolean} Is `sourcesContent` present.
   */;_proto.withContent=function withContent(){return!!(this.consumer().sourcesContent&&this.consumer().sourcesContent.length>0);};_proto.startWith=function startWith(string,start){if(!string)return false;return string.substr(0,start.length)===start;};_proto.loadAnnotation=function loadAnnotation(css){var match=css.match(/\/\*\s*# sourceMappingURL=(.*)\s*\*\//);if(match)this.annotation=match[1].trim();};_proto.decodeInline=function decodeInline(text){var baseCharsetUri=/^data:application\/json;charset=utf-?8;base64,/;var baseUri=/^data:application\/json;base64,/;var uri='data:application/json,';if(this.startWith(text,uri)){return decodeURIComponent(text.substr(uri.length));}if(baseCharsetUri.test(text)||baseUri.test(text)){return fromBase64(text.substr(RegExp.lastMatch.length));}var encoding=text.match(/data:application\/json;([^,]+),/)[1];throw new Error('Unsupported source map encoding '+encoding);};_proto.loadMap=function loadMap(file,prev){if(prev===false)return false;if(prev){if(typeof prev==='string'){return prev;}else if(typeof prev==='function'){var prevPath=prev(file);if(prevPath&&_fs["default"].existsSync&&_fs["default"].existsSync(prevPath)){return _fs["default"].readFileSync(prevPath,'utf-8').toString().trim();}else{throw new Error('Unable to load previous source map: '+prevPath.toString());}}else if(prev instanceof _sourceMap["default"].SourceMapConsumer){return _sourceMap["default"].SourceMapGenerator.fromSourceMap(prev).toString();}else if(prev instanceof _sourceMap["default"].SourceMapGenerator){return prev.toString();}else if(this.isMap(prev)){return JSON.stringify(prev);}else{throw new Error('Unsupported previous source map format: '+prev.toString());}}else if(this.inline){return this.decodeInline(this.annotation);}else if(this.annotation){var map=this.annotation;if(file)map=_path["default"].join(_path["default"].dirname(file),map);this.root=_path["default"].dirname(map);if(_fs["default"].existsSync&&_fs["default"].existsSync(map)){return _fs["default"].readFileSync(map,'utf-8').toString().trim();}else{return false;}}};_proto.isMap=function isMap(map){if(_typeof(map)!=='object')return false;return typeof map.mappings==='string'||typeof map._mappings==='string';};return PreviousMap;}();var _default=PreviousMap;exports["default"]=_default;module.exports=exports["default"];}).call(this,require("buffer").Buffer);},{"buffer":3,"fs":2,"path":38,"source-map":78}],53:[function(require,module,exports){(function(process){"use strict";exports.__esModule=true;exports["default"]=void 0;var _lazyResult=_interopRequireDefault(require("./lazy-result"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * @example
 * const processor = postcss([autoprefixer, precss])
 * processor.process(css1).then(result => console.log(result.css))
 * processor.process(css2).then(result => console.log(result.css))
 */var Processor=/*#__PURE__*/function(){/**
   * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.
   *        See {@link Processor#use} for plugin format.
   */function Processor(plugins){if(plugins===void 0){plugins=[];}/**
     * Current PostCSS version.
     *
     * @type {string}
     *
     * @example
     * if (result.processor.version.split('.')[0] !== '6') {
     *   throw new Error('This plugin works only with PostCSS 6')
     * }
     */this.version='7.0.27';/**
     * Plugins added to this processor.
     *
     * @type {pluginFunction[]}
     *
     * @example
     * const processor = postcss([autoprefixer, precss])
     * processor.plugins.length //=> 2
     */this.plugins=this.normalize(plugins);}/**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin created by {@link postcss.plugin} method.
   * * A function. PostCSS will pass the function a @{link Root}
   *   as the first argument and current {@link Result} instance
   *   as the second.
   * * An object with a `postcss` method. PostCSS will use that method
   *   as described in #2.
   * * Another {@link Processor} instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * @param {Plugin|pluginFunction|Processor} plugin PostCSS plugin
   *                                                 or {@link Processor}
   *                                                 with plugins.
   *
   * @example
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(precss)
   *
   * @return {Processes} Current processor to make methods chain.
   */var _proto=Processor.prototype;_proto.use=function use(plugin){this.plugins=this.plugins.concat(this.normalize([plugin]));return this;}/**
   * Parses source CSS and returns a {@link LazyResult} Promise proxy.
   * Because some plugins can be asynchronous it doesn’t make
   * any transformations. Transformations will be applied
   * in the {@link LazyResult} methods.
   *
   * @param {string|toString|Result} css String with input CSS or any object
   *                                     with a `toString()` method,
   *                                     like a Buffer. Optionally, send
   *                                     a {@link Result} instance
   *                                     and the processor will take
   *                                     the {@link Root} from it.
   * @param {processOptions} [opts]      Options.
   *
   * @return {LazyResult} Promise proxy.
   *
   * @example
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css)
   *   })
   */;_proto.process=function(_process){function process(_x){return _process.apply(this,arguments);}process.toString=function(){return _process.toString();};return process;}(function(css,opts){if(opts===void 0){opts={};}if(this.plugins.length===0&&opts.parser===opts.stringifier){if(process.env.NODE_ENV!=='production'){if(typeof console!=='undefined'&&console.warn){console.warn('You did not set any plugins, parser, or stringifier. '+'Right now, PostCSS does nothing. Pick plugins for your case '+'on https://www.postcss.parts/ and use them in postcss.config.js.');}}}return new _lazyResult["default"](this,css,opts);});_proto.normalize=function normalize(plugins){var normalized=[];for(var _iterator=plugins,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var i=_ref;if(i.postcss)i=i.postcss;if(_typeof(i)==='object'&&Array.isArray(i.plugins)){normalized=normalized.concat(i.plugins);}else if(typeof i==='function'){normalized.push(i);}else if(_typeof(i)==='object'&&(i.parse||i.stringify)){if(process.env.NODE_ENV!=='production'){throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use '+'one of the syntax/parser/stringifier options as outlined '+'in your PostCSS runner documentation.');}}else{throw new Error(i+' is not a PostCSS plugin');}}return normalized;};return Processor;}();var _default=Processor;/**
 * @callback builder
 * @param {string} part          Part of generated CSS connected to this node.
 * @param {Node}   node          AST node.
 * @param {"start"|"end"} [type] Node’s part type.
 */ /**
 * @callback parser
 *
 * @param {string|toString} css   String with input CSS or any object
 *                                with toString() method, like a Buffer.
 * @param {processOptions} [opts] Options with only `from` and `map` keys.
 *
 * @return {Root} PostCSS AST
 */ /**
 * @callback stringifier
 *
 * @param {Node} node       Start node for stringifing. Usually {@link Root}.
 * @param {builder} builder Function to concatenate CSS from node’s parts
 *                          or generate string and source map.
 *
 * @return {void}
 */ /**
 * @typedef {object} syntax
 * @property {parser} parse          Function to generate AST by string.
 * @property {stringifier} stringify Function to generate string by AST.
 */ /**
 * @typedef {object} toString
 * @property {function} toString
 */ /**
 * @callback pluginFunction
 * @param {Root} root     Parsed input CSS.
 * @param {Result} result Result to set warnings or check other plugins.
 */ /**
 * @typedef {object} Plugin
 * @property {function} postcss PostCSS plugin function.
 */ /**
 * @typedef {object} processOptions
 * @property {string} from             The path of the CSS source file.
 *                                     You should always set `from`,
 *                                     because it is used in source map
 *                                     generation and syntax error messages.
 * @property {string} to               The path where you’ll put the output
 *                                     CSS file. You should always set `to`
 *                                     to generate correct source maps.
 * @property {parser} parser           Function to generate AST by string.
 * @property {stringifier} stringifier Class to generate string by AST.
 * @property {syntax} syntax           Object with `parse` and `stringify`.
 * @property {object} map              Source map options.
 * @property {boolean} map.inline                    Does source map should
 *                                                   be embedded in the output
 *                                                   CSS as a base64-encoded
 *                                                   comment.
 * @property {string|object|false|function} map.prev Source map content
 *                                                   from a previous
 *                                                   processing step
 *                                                   (for example, Sass).
 *                                                   PostCSS will try to find
 *                                                   previous map automatically,
 *                                                   so you could disable it by
 *                                                   `false` value.
 * @property {boolean} map.sourcesContent            Does PostCSS should set
 *                                                   the origin content to map.
 * @property {string|false} map.annotation           Does PostCSS should set
 *                                                   annotation comment to map.
 * @property {string} map.from                       Override `from` in map’s
 *                                                   sources`.
 */exports["default"]=_default;module.exports=exports["default"];}).call(this,require('_process'));},{"./lazy-result":45,"_process":63}],54:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _warning=_interopRequireDefault(require("./warning"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}/**
 * Provides the result of the PostCSS transformations.
 *
 * A Result instance is returned by {@link LazyResult#then}
 * or {@link Root#toResult} methods.
 *
 * @example
 * postcss([autoprefixer]).process(css).then(result => {
 *  console.log(result.css)
 * })
 *
 * @example
 * const result2 = postcss.parse(css).toResult()
 */var Result=/*#__PURE__*/function(){/**
   * @param {Processor} processor Processor used for this transformation.
   * @param {Root}      root      Root node after all transformations.
   * @param {processOptions} opts Options from the {@link Processor#process}
   *                              or {@link Root#toResult}.
   */function Result(processor,root,opts){/**
     * The Processor instance used for this transformation.
     *
     * @type {Processor}
     *
     * @example
     * for (const plugin of result.processor.plugins) {
     *   if (plugin.postcssPlugin === 'postcss-bad') {
     *     throw 'postcss-good is incompatible with postcss-bad'
     *   }
     * })
     */this.processor=processor;/**
     * Contains messages from plugins (e.g., warnings or custom messages).
     * Each message should have type and plugin properties.
     *
     * @type {Message[]}
     *
     * @example
     * postcss.plugin('postcss-min-browser', () => {
     *   return (root, result) => {
     *     const browsers = detectMinBrowsersByCanIUse(root)
     *     result.messages.push({
     *       type: 'min-browser',
     *       plugin: 'postcss-min-browser',
     *       browsers
     *     })
     *   }
     * })
     */this.messages=[];/**
     * Root node after all transformations.
     *
     * @type {Root}
     *
     * @example
     * root.toResult().root === root
     */this.root=root;/**
     * Options from the {@link Processor#process} or {@link Root#toResult} call
     * that produced this Result instance.
     *
     * @type {processOptions}
     *
     * @example
     * root.toResult(opts).opts === opts
     */this.opts=opts;/**
     * A CSS string representing of {@link Result#root}.
     *
     * @type {string}
     *
     * @example
     * postcss.parse('a{}').toResult().css //=> "a{}"
     */this.css=undefined;/**
     * An instance of `SourceMapGenerator` class from the `source-map` library,
     * representing changes to the {@link Result#root} instance.
     *
     * @type {SourceMapGenerator}
     *
     * @example
     * result.map.toJSON() //=> { version: 3, file: 'a.css', … }
     *
     * @example
     * if (result.map) {
     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())
     * }
     */this.map=undefined;}/**
   * Returns for @{link Result#css} content.
   *
   * @example
   * result + '' === result.css
   *
   * @return {string} String representing of {@link Result#root}.
   */var _proto=Result.prototype;_proto.toString=function toString(){return this.css;}/**
   * Creates an instance of {@link Warning} and adds it
   * to {@link Result#messages}.
   *
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   *
   * @return {Warning} Created warning.
   */;_proto.warn=function warn(text,opts){if(opts===void 0){opts={};}if(!opts.plugin){if(this.lastPlugin&&this.lastPlugin.postcssPlugin){opts.plugin=this.lastPlugin.postcssPlugin;}}var warning=new _warning["default"](text,opts);this.messages.push(warning);return warning;}/**
     * Returns warnings from plugins. Filters {@link Warning} instances
     * from {@link Result#messages}.
     *
     * @example
     * result.warnings().forEach(warn => {
     *   console.warn(warn.toString())
     * })
     *
     * @return {Warning[]} Warnings from plugins.
     */;_proto.warnings=function warnings(){return this.messages.filter(function(i){return i.type==='warning';});}/**
   * An alias for the {@link Result#css} property.
   * Use it with syntaxes that generate non-CSS output.
   *
   * @type {string}
   *
   * @example
   * result.css === result.content
   */;_createClass(Result,[{key:"content",get:function get(){return this.css;}}]);return Result;}();var _default=Result;/**
 * @typedef  {object} Message
 * @property {string} type   Message type.
 * @property {string} plugin Source PostCSS plugin name.
 */exports["default"]=_default;module.exports=exports["default"];},{"./warning":62}],55:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _container=_interopRequireDefault(require("./container"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents a CSS file and contains all its parsed nodes.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{color:black} b{z-index:2}')
 * root.type         //=> 'root'
 * root.nodes.length //=> 2
 */var Root=/*#__PURE__*/function(_Container){_inheritsLoose(Root,_Container);function Root(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='root';if(!_this.nodes)_this.nodes=[];return _this;}var _proto=Root.prototype;_proto.removeChild=function removeChild(child,ignore){var index=this.index(child);if(!ignore&&index===0&&this.nodes.length>1){this.nodes[1].raws.before=this.nodes[index].raws.before;}return _Container.prototype.removeChild.call(this,child);};_proto.normalize=function normalize(child,sample,type){var nodes=_Container.prototype.normalize.call(this,child);if(sample){if(type==='prepend'){if(this.nodes.length>1){sample.raws.before=this.nodes[1].raws.before;}else{delete sample.raws.before;}}else if(this.first!==sample){for(var _iterator=nodes,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var node=_ref;node.raws.before=sample.raws.before;}}}return nodes;}/**
   * Returns a {@link Result} instance representing the root’s CSS.
   *
   * @param {processOptions} [opts] Options with only `to` and `map` keys.
   *
   * @return {Result} Result with current root’s CSS.
   *
   * @example
   * const root1 = postcss.parse(css1, { from: 'a.css' })
   * const root2 = postcss.parse(css2, { from: 'b.css' })
   * root1.append(root2)
   * const result = root1.toResult({ to: 'all.css', map: true })
   */;_proto.toResult=function toResult(opts){if(opts===void 0){opts={};}var LazyResult=require('./lazy-result');var Processor=require('./processor');var lazy=new LazyResult(new Processor(),this,opts);return lazy.stringify();}/**
   * @memberof Root#
   * @member {object} raws Information to generate byte-to-byte equal
   *                       node string as it was in the origin input.
   *
   * Every parser saves its own properties,
   * but the default CSS parser uses:
   *
   * * `after`: the space symbols after the last child to the end of file.
   * * `semicolon`: is the last child has an (optional) semicolon.
   *
   * @example
   * postcss.parse('a {}\n').raws //=> { after: '\n' }
   * postcss.parse('a {}').raws   //=> { after: '' }
   */;return Root;}(_container["default"]);var _default=Root;exports["default"]=_default;module.exports=exports["default"];},{"./container":41,"./lazy-result":45,"./processor":53}],56:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _container=_interopRequireDefault(require("./container"));var _list=_interopRequireDefault(require("./list"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}/**
 * Represents a CSS rule: a selector followed by a declaration block.
 *
 * @extends Container
 *
 * @example
 * const root = postcss.parse('a{}')
 * const rule = root.first
 * rule.type       //=> 'rule'
 * rule.toString() //=> 'a{}'
 */var Rule=/*#__PURE__*/function(_Container){_inheritsLoose(Rule,_Container);function Rule(defaults){var _this;_this=_Container.call(this,defaults)||this;_this.type='rule';if(!_this.nodes)_this.nodes=[];return _this;}/**
   * An array containing the rule’s individual selectors.
   * Groups of selectors are split at commas.
   *
   * @type {string[]}
   *
   * @example
   * const root = postcss.parse('a, b { }')
   * const rule = root.first
   *
   * rule.selector  //=> 'a, b'
   * rule.selectors //=> ['a', 'b']
   *
   * rule.selectors = ['a', 'strong']
   * rule.selector //=> 'a, strong'
   */_createClass(Rule,[{key:"selectors",get:function get(){return _list["default"].comma(this.selector);},set:function set(values){var match=this.selector?this.selector.match(/,\s*/):null;var sep=match?match[0]:','+this.raw('between','beforeOpen');this.selector=values.join(sep);}/**
     * @memberof Rule#
     * @member {string} selector The rule’s full selector represented
     *                           as a string.
     *
     * @example
     * const root = postcss.parse('a, b { }')
     * const rule = root.first
     * rule.selector //=> 'a, b'
     */ /**
     * @memberof Rule#
     * @member {object} raws Information to generate byte-to-byte equal
     *                       node string as it was in the origin input.
     *
     * Every parser saves its own properties,
     * but the default CSS parser uses:
     *
     * * `before`: the space symbols before the node. It also stores `*`
     *   and `_` symbols before the declaration (IE hack).
     * * `after`: the space symbols after the last child of the node
     *   to the end of the node.
     * * `between`: the symbols between the property and value
     *   for declarations, selector and `{` for rules, or last parameter
     *   and `{` for at-rules.
     * * `semicolon`: contains `true` if the last child has
     *   an (optional) semicolon.
     * * `ownSemicolon`: contains `true` if there is semicolon after rule.
     *
     * PostCSS cleans selectors from comments and extra spaces,
     * but it stores origin content in raws properties.
     * As such, if you don’t change a declaration’s value,
     * PostCSS will use the raw value with comments.
     *
     * @example
     * const root = postcss.parse('a {\n  color:black\n}')
     * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
     */}]);return Rule;}(_container["default"]);var _default=Rule;exports["default"]=_default;module.exports=exports["default"];},{"./container":41,"./list":46}],57:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var DEFAULT_RAW={colon:': ',indent:'    ',beforeDecl:'\n',beforeRule:'\n',beforeOpen:' ',beforeClose:'\n',beforeComment:'\n',after:'\n',emptyBody:'',commentLeft:' ',commentRight:' ',semicolon:false};function capitalize(str){return str[0].toUpperCase()+str.slice(1);}var Stringifier=/*#__PURE__*/function(){function Stringifier(builder){this.builder=builder;}var _proto=Stringifier.prototype;_proto.stringify=function stringify(node,semicolon){this[node.type](node,semicolon);};_proto.root=function root(node){this.body(node);if(node.raws.after)this.builder(node.raws.after);};_proto.comment=function comment(node){var left=this.raw(node,'left','commentLeft');var right=this.raw(node,'right','commentRight');this.builder('/*'+left+node.text+right+'*/',node);};_proto.decl=function decl(node,semicolon){var between=this.raw(node,'between','colon');var string=node.prop+between+this.rawValue(node,'value');if(node.important){string+=node.raws.important||' !important';}if(semicolon)string+=';';this.builder(string,node);};_proto.rule=function rule(node){this.block(node,this.rawValue(node,'selector'));if(node.raws.ownSemicolon){this.builder(node.raws.ownSemicolon,node,'end');}};_proto.atrule=function atrule(node,semicolon){var name='@'+node.name;var params=node.params?this.rawValue(node,'params'):'';if(typeof node.raws.afterName!=='undefined'){name+=node.raws.afterName;}else if(params){name+=' ';}if(node.nodes){this.block(node,name+params);}else{var end=(node.raws.between||'')+(semicolon?';':'');this.builder(name+params+end,node);}};_proto.body=function body(node){var last=node.nodes.length-1;while(last>0){if(node.nodes[last].type!=='comment')break;last-=1;}var semicolon=this.raw(node,'semicolon');for(var i=0;i<node.nodes.length;i++){var child=node.nodes[i];var before=this.raw(child,'before');if(before)this.builder(before);this.stringify(child,last!==i||semicolon);}};_proto.block=function block(node,start){var between=this.raw(node,'between','beforeOpen');this.builder(start+between+'{',node,'start');var after;if(node.nodes&&node.nodes.length){this.body(node);after=this.raw(node,'after');}else{after=this.raw(node,'after','emptyBody');}if(after)this.builder(after);this.builder('}',node,'end');};_proto.raw=function raw(node,own,detect){var value;if(!detect)detect=own;// Already had
if(own){value=node.raws[own];if(typeof value!=='undefined')return value;}var parent=node.parent;// Hack for first rule in CSS
if(detect==='before'){if(!parent||parent.type==='root'&&parent.first===node){return'';}}// Floating child without parent
if(!parent)return DEFAULT_RAW[detect];// Detect style by other nodes
var root=node.root();if(!root.rawCache)root.rawCache={};if(typeof root.rawCache[detect]!=='undefined'){return root.rawCache[detect];}if(detect==='before'||detect==='after'){return this.beforeAfter(node,detect);}else{var method='raw'+capitalize(detect);if(this[method]){value=this[method](root,node);}else{root.walk(function(i){value=i.raws[own];if(typeof value!=='undefined')return false;});}}if(typeof value==='undefined')value=DEFAULT_RAW[detect];root.rawCache[detect]=value;return value;};_proto.rawSemicolon=function rawSemicolon(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length&&i.last.type==='decl'){value=i.raws.semicolon;if(typeof value!=='undefined')return false;}});return value;};_proto.rawEmptyBody=function rawEmptyBody(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length===0){value=i.raws.after;if(typeof value!=='undefined')return false;}});return value;};_proto.rawIndent=function rawIndent(root){if(root.raws.indent)return root.raws.indent;var value;root.walk(function(i){var p=i.parent;if(p&&p!==root&&p.parent&&p.parent===root){if(typeof i.raws.before!=='undefined'){var parts=i.raws.before.split('\n');value=parts[parts.length-1];value=value.replace(/[^\s]/g,'');return false;}}});return value;};_proto.rawBeforeComment=function rawBeforeComment(root,node){var value;root.walkComments(function(i){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\n')!==-1){value=value.replace(/[^\n]+$/,'');}return false;}});if(typeof value==='undefined'){value=this.raw(node,null,'beforeDecl');}else if(value){value=value.replace(/[^\s]/g,'');}return value;};_proto.rawBeforeDecl=function rawBeforeDecl(root,node){var value;root.walkDecls(function(i){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\n')!==-1){value=value.replace(/[^\n]+$/,'');}return false;}});if(typeof value==='undefined'){value=this.raw(node,null,'beforeRule');}else if(value){value=value.replace(/[^\s]/g,'');}return value;};_proto.rawBeforeRule=function rawBeforeRule(root){var value;root.walk(function(i){if(i.nodes&&(i.parent!==root||root.first!==i)){if(typeof i.raws.before!=='undefined'){value=i.raws.before;if(value.indexOf('\n')!==-1){value=value.replace(/[^\n]+$/,'');}return false;}}});if(value)value=value.replace(/[^\s]/g,'');return value;};_proto.rawBeforeClose=function rawBeforeClose(root){var value;root.walk(function(i){if(i.nodes&&i.nodes.length>0){if(typeof i.raws.after!=='undefined'){value=i.raws.after;if(value.indexOf('\n')!==-1){value=value.replace(/[^\n]+$/,'');}return false;}}});if(value)value=value.replace(/[^\s]/g,'');return value;};_proto.rawBeforeOpen=function rawBeforeOpen(root){var value;root.walk(function(i){if(i.type!=='decl'){value=i.raws.between;if(typeof value!=='undefined')return false;}});return value;};_proto.rawColon=function rawColon(root){var value;root.walkDecls(function(i){if(typeof i.raws.between!=='undefined'){value=i.raws.between.replace(/[^\s:]/g,'');return false;}});return value;};_proto.beforeAfter=function beforeAfter(node,detect){var value;if(node.type==='decl'){value=this.raw(node,null,'beforeDecl');}else if(node.type==='comment'){value=this.raw(node,null,'beforeComment');}else if(detect==='before'){value=this.raw(node,null,'beforeRule');}else{value=this.raw(node,null,'beforeClose');}var buf=node.parent;var depth=0;while(buf&&buf.type!=='root'){depth+=1;buf=buf.parent;}if(value.indexOf('\n')!==-1){var indent=this.raw(node,null,'indent');if(indent.length){for(var step=0;step<depth;step++){value+=indent;}}}return value;};_proto.rawValue=function rawValue(node,prop){var value=node[prop];var raw=node.raws[prop];if(raw&&raw.value===value){return raw.raw;}return value;};return Stringifier;}();var _default=Stringifier;exports["default"]=_default;module.exports=exports["default"];},{}],58:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;var _stringifier=_interopRequireDefault(require("./stringifier"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function stringify(node,builder){var str=new _stringifier["default"](builder);str.stringify(node);}var _default=stringify;exports["default"]=_default;module.exports=exports["default"];},{"./stringifier":57}],59:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=tokenizer;var SINGLE_QUOTE='\''.charCodeAt(0);var DOUBLE_QUOTE='"'.charCodeAt(0);var BACKSLASH='\\'.charCodeAt(0);var SLASH='/'.charCodeAt(0);var NEWLINE='\n'.charCodeAt(0);var SPACE=' '.charCodeAt(0);var FEED='\f'.charCodeAt(0);var TAB='\t'.charCodeAt(0);var CR='\r'.charCodeAt(0);var OPEN_SQUARE='['.charCodeAt(0);var CLOSE_SQUARE=']'.charCodeAt(0);var OPEN_PARENTHESES='('.charCodeAt(0);var CLOSE_PARENTHESES=')'.charCodeAt(0);var OPEN_CURLY='{'.charCodeAt(0);var CLOSE_CURLY='}'.charCodeAt(0);var SEMICOLON=';'.charCodeAt(0);var ASTERISK='*'.charCodeAt(0);var COLON=':'.charCodeAt(0);var AT='@'.charCodeAt(0);var RE_AT_END=/[ \n\t\r\f{}()'"\\;/[\]#]/g;var RE_WORD_END=/[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g;var RE_BAD_BRACKET=/.[\\/("'\n]/;var RE_HEX_ESCAPE=/[a-f0-9]/i;function tokenizer(input,options){if(options===void 0){options={};}var css=input.css.valueOf();var ignore=options.ignoreErrors;var code,next,quote,lines,last,content,escape;var nextLine,nextOffset,escaped,escapePos,prev,n,currentToken;var length=css.length;var offset=-1;var line=1;var pos=0;var buffer=[];var returned=[];function position(){return pos;}function unclosed(what){throw input.error('Unclosed '+what,line,pos-offset);}function endOfFile(){return returned.length===0&&pos>=length;}function nextToken(opts){if(returned.length)return returned.pop();if(pos>=length)return;var ignoreUnclosed=opts?opts.ignoreUnclosed:false;code=css.charCodeAt(pos);if(code===NEWLINE||code===FEED||code===CR&&css.charCodeAt(pos+1)!==NEWLINE){offset=pos;line+=1;}switch(code){case NEWLINE:case SPACE:case TAB:case CR:case FEED:next=pos;do{next+=1;code=css.charCodeAt(next);if(code===NEWLINE){offset=next;line+=1;}}while(code===SPACE||code===NEWLINE||code===TAB||code===CR||code===FEED);currentToken=['space',css.slice(pos,next)];pos=next-1;break;case OPEN_SQUARE:case CLOSE_SQUARE:case OPEN_CURLY:case CLOSE_CURLY:case COLON:case SEMICOLON:case CLOSE_PARENTHESES:var controlChar=String.fromCharCode(code);currentToken=[controlChar,controlChar,line,pos-offset];break;case OPEN_PARENTHESES:prev=buffer.length?buffer.pop()[1]:'';n=css.charCodeAt(pos+1);if(prev==='url'&&n!==SINGLE_QUOTE&&n!==DOUBLE_QUOTE&&n!==SPACE&&n!==NEWLINE&&n!==TAB&&n!==FEED&&n!==CR){next=pos;do{escaped=false;next=css.indexOf(')',next+1);if(next===-1){if(ignore||ignoreUnclosed){next=pos;break;}else{unclosed('bracket');}}escapePos=next;while(css.charCodeAt(escapePos-1)===BACKSLASH){escapePos-=1;escaped=!escaped;}}while(escaped);currentToken=['brackets',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;}else{next=css.indexOf(')',pos+1);content=css.slice(pos,next+1);if(next===-1||RE_BAD_BRACKET.test(content)){currentToken=['(','(',line,pos-offset];}else{currentToken=['brackets',content,line,pos-offset,line,next-offset];pos=next;}}break;case SINGLE_QUOTE:case DOUBLE_QUOTE:quote=code===SINGLE_QUOTE?'\'':'"';next=pos;do{escaped=false;next=css.indexOf(quote,next+1);if(next===-1){if(ignore||ignoreUnclosed){next=pos+1;break;}else{unclosed('string');}}escapePos=next;while(css.charCodeAt(escapePos-1)===BACKSLASH){escapePos-=1;escaped=!escaped;}}while(escaped);content=css.slice(pos,next+1);lines=content.split('\n');last=lines.length-1;if(last>0){nextLine=line+last;nextOffset=next-lines[last].length;}else{nextLine=line;nextOffset=offset;}currentToken=['string',css.slice(pos,next+1),line,pos-offset,nextLine,next-nextOffset];offset=nextOffset;line=nextLine;pos=next;break;case AT:RE_AT_END.lastIndex=pos+1;RE_AT_END.test(css);if(RE_AT_END.lastIndex===0){next=css.length-1;}else{next=RE_AT_END.lastIndex-2;}currentToken=['at-word',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;break;case BACKSLASH:next=pos;escape=true;while(css.charCodeAt(next+1)===BACKSLASH){next+=1;escape=!escape;}code=css.charCodeAt(next+1);if(escape&&code!==SLASH&&code!==SPACE&&code!==NEWLINE&&code!==TAB&&code!==CR&&code!==FEED){next+=1;if(RE_HEX_ESCAPE.test(css.charAt(next))){while(RE_HEX_ESCAPE.test(css.charAt(next+1))){next+=1;}if(css.charCodeAt(next+1)===SPACE){next+=1;}}}currentToken=['word',css.slice(pos,next+1),line,pos-offset,line,next-offset];pos=next;break;default:if(code===SLASH&&css.charCodeAt(pos+1)===ASTERISK){next=css.indexOf('*/',pos+2)+1;if(next===0){if(ignore||ignoreUnclosed){next=css.length;}else{unclosed('comment');}}content=css.slice(pos,next+1);lines=content.split('\n');last=lines.length-1;if(last>0){nextLine=line+last;nextOffset=next-lines[last].length;}else{nextLine=line;nextOffset=offset;}currentToken=['comment',content,line,pos-offset,nextLine,next-nextOffset];offset=nextOffset;line=nextLine;pos=next;}else{RE_WORD_END.lastIndex=pos+1;RE_WORD_END.test(css);if(RE_WORD_END.lastIndex===0){next=css.length-1;}else{next=RE_WORD_END.lastIndex-2;}currentToken=['word',css.slice(pos,next+1),line,pos-offset,line,next-offset];buffer.push(currentToken);pos=next;}break;}pos++;return currentToken;}function back(token){returned.push(token);}return{back:back,nextToken:nextToken,endOfFile:endOfFile,position:position};}module.exports=exports["default"];},{}],60:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;/**
 * Contains helpers for working with vendor prefixes.
 *
 * @example
 * const vendor = postcss.vendor
 *
 * @namespace vendor
 */var vendor={/**
   * Returns the vendor prefix extracted from an input string.
   *
   * @param {string} prop String with or without vendor prefix.
   *
   * @return {string} vendor prefix or empty string
   *
   * @example
   * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
   * postcss.vendor.prefix('tab-size')      //=> ''
   */prefix:function prefix(prop){var match=prop.match(/^(-\w+-)/);if(match){return match[0];}return'';},/**
     * Returns the input string stripped of its vendor prefix.
     *
     * @param {string} prop String with or without vendor prefix.
     *
     * @return {string} String name without vendor prefixes.
     *
     * @example
     * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
     */unprefixed:function unprefixed(prop){return prop.replace(/^-\w+-/,'');}};var _default=vendor;exports["default"]=_default;module.exports=exports["default"];},{}],61:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=warnOnce;var printed={};function warnOnce(message){if(printed[message])return;printed[message]=true;if(typeof console!=='undefined'&&console.warn){console.warn(message);}}module.exports=exports["default"];},{}],62:[function(require,module,exports){"use strict";exports.__esModule=true;exports["default"]=void 0;/**
 * Represents a plugin’s warning. It can be created using {@link Node#warn}.
 *
 * @example
 * if (decl.important) {
 *   decl.warn(result, 'Avoid !important', { word: '!important' })
 * }
 */var Warning=/*#__PURE__*/function(){/**
   * @param {string} text        Warning message.
   * @param {Object} [opts]      Warning options.
   * @param {Node}   opts.node   CSS node that caused the warning.
   * @param {string} opts.word   Word in CSS source that caused the warning.
   * @param {number} opts.index  Index in CSS node string that caused
   *                             the warning.
   * @param {string} opts.plugin Name of the plugin that created
   *                             this warning. {@link Result#warn} fills
   *                             this property automatically.
   */function Warning(text,opts){if(opts===void 0){opts={};}/**
     * Type to filter warnings from {@link Result#messages}.
     * Always equal to `"warning"`.
     *
     * @type {string}
     *
     * @example
     * const nonWarning = result.messages.filter(i => i.type !== 'warning')
     */this.type='warning';/**
     * The warning message.
     *
     * @type {string}
     *
     * @example
     * warning.text //=> 'Try to avoid !important'
     */this.text=text;if(opts.node&&opts.node.source){var pos=opts.node.positionBy(opts);/**
       * Line in the input file with this warning’s source.
       * @type {number}
       *
       * @example
       * warning.line //=> 5
       */this.line=pos.line;/**
       * Column in the input file with this warning’s source.
       *
       * @type {number}
       *
       * @example
       * warning.column //=> 6
       */this.column=pos.column;}for(var opt in opts){this[opt]=opts[opt];}}/**
   * Returns a warning position and message.
   *
   * @example
   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
   *
   * @return {string} Warning position and message.
   */var _proto=Warning.prototype;_proto.toString=function toString(){if(this.node){return this.node.error(this.text,{plugin:this.plugin,index:this.index,word:this.word}).message;}if(this.plugin){return this.plugin+': '+this.text;}return this.text;}/**
   * @memberof Warning#
   * @member {string} plugin The name of the plugin that created
   *                         it will fill this property automatically.
   *                         this warning. When you call {@link Node#warn}
   *
   * @example
   * warning.plugin //=> 'postcss-important'
   */ /**
   * @memberof Warning#
   * @member {Node} node Contains the CSS node that caused the warning.
   *
   * @example
   * warning.node.toString() //=> 'color: white !important'
   */;return Warning;}();var _default=Warning;exports["default"]=_default;module.exports=exports["default"];},{}],63:[function(require,module,exports){// shim for using process in browser
var process=module.exports={};// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}(function(){try{if(typeof setTimeout==='function'){cachedSetTimeout=setTimeout;}else{cachedSetTimeout=defaultSetTimout;}}catch(e){cachedSetTimeout=defaultSetTimout;}try{if(typeof clearTimeout==='function'){cachedClearTimeout=clearTimeout;}else{cachedClearTimeout=defaultClearTimeout;}}catch(e){cachedClearTimeout=defaultClearTimeout;}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations
return setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined
if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
return cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
return cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations
return clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined
if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
return cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
// Some versions of I.E. have different rules for clearTimeout vs setTimeout
return cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else{queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}};// v8 likes predictible objects
function Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};process.title='browser';process.browser=true;process.env={};process.argv=[];process.version='';// empty string to avoid regexp issues
process.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return[];};process.binding=function(name){throw new Error('process.binding is not supported');};process.cwd=function(){return'/';};process.chdir=function(dir){throw new Error('process.chdir is not supported');};process.umask=function(){return 0;};},{}],64:[function(require,module,exports){(function(global){/*! https://mths.be/punycode v1.4.1 by @mathias */;(function(root){/** Detect free variables */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;var freeModule=_typeof(module)=='object'&&module&&!module.nodeType&&module;var freeGlobal=_typeof(global)=='object'&&global;if(freeGlobal.global===freeGlobal||freeGlobal.window===freeGlobal||freeGlobal.self===freeGlobal){root=freeGlobal;}/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */var punycode,/** Highest positive signed 32-bit float value */maxInt=2147483647,// aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */base=36,tMin=1,tMax=26,skew=38,damp=700,initialBias=72,initialN=128,// 0x80
delimiter='-',// '\x2D'
/** Regular expressions */regexPunycode=/^xn--/,regexNonASCII=/[^\x20-\x7E]/,// unprintable ASCII chars + non-ASCII chars
regexSeparators=/[\x2E\u3002\uFF0E\uFF61]/g,// RFC 3490 separators
/** Error messages */errors={'overflow':'Overflow: input needs wider integers to process','not-basic':'Illegal input >= 0x80 (not a basic code point)','invalid-input':'Invalid input'},/** Convenience shortcuts */baseMinusTMin=base-tMin,floor=Math.floor,stringFromCharCode=String.fromCharCode,/** Temporary variable */key;/*--------------------------------------------------------------------------*/ /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */function error(type){throw new RangeError(errors[type]);}/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */function map(array,fn){var length=array.length;var result=[];while(length--){result[length]=fn(array[length]);}return result;}/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */function mapDomain(string,fn){var parts=string.split('@');var result='';if(parts.length>1){// In email addresses, only the domain name should be punycoded. Leave
// the local part (i.e. everything up to `@`) intact.
result=parts[0]+'@';string=parts[1];}// Avoid `split(regex)` for IE8 compatibility. See #17.
string=string.replace(regexSeparators,'\x2E');var labels=string.split('.');var encoded=map(labels,fn).join('.');return result+encoded;}/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */function ucs2decode(string){var output=[],counter=0,length=string.length,value,extra;while(counter<length){value=string.charCodeAt(counter++);if(value>=0xD800&&value<=0xDBFF&&counter<length){// high surrogate, and there is a next character
extra=string.charCodeAt(counter++);if((extra&0xFC00)==0xDC00){// low surrogate
output.push(((value&0x3FF)<<10)+(extra&0x3FF)+0x10000);}else{// unmatched surrogate; only append this code unit, in case the next
// code unit is the high surrogate of a surrogate pair
output.push(value);counter--;}}else{output.push(value);}}return output;}/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */function ucs2encode(array){return map(array,function(value){var output='';if(value>0xFFFF){value-=0x10000;output+=stringFromCharCode(value>>>10&0x3FF|0xD800);value=0xDC00|value&0x3FF;}output+=stringFromCharCode(value);return output;}).join('');}/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */function basicToDigit(codePoint){if(codePoint-48<10){return codePoint-22;}if(codePoint-65<26){return codePoint-65;}if(codePoint-97<26){return codePoint-97;}return base;}/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */function digitToBasic(digit,flag){//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return digit+22+75*(digit<26)-((flag!=0)<<5);}/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */function adapt(delta,numPoints,firstTime){var k=0;delta=firstTime?floor(delta/damp):delta>>1;delta+=floor(delta/numPoints);for(;/* no initialization */delta>baseMinusTMin*tMax>>1;k+=base){delta=floor(delta/baseMinusTMin);}return floor(k+(baseMinusTMin+1)*delta/(delta+skew));}/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */function decode(input){// Don't use UCS-2
var output=[],inputLength=input.length,out,i=0,n=initialN,bias=initialBias,basic,j,index,oldi,w,k,digit,t,/** Cached calculation results */baseMinusT;// Handle the basic code points: let `basic` be the number of input code
// points before the last delimiter, or `0` if there is none, then copy
// the first basic code points to the output.
basic=input.lastIndexOf(delimiter);if(basic<0){basic=0;}for(j=0;j<basic;++j){// if it's not a basic code point
if(input.charCodeAt(j)>=0x80){error('not-basic');}output.push(input.charCodeAt(j));}// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for(index=basic>0?basic+1:0;index<inputLength;)/* no final expression */{// `index` is the index of the next character to be consumed.
// Decode a generalized variable-length integer into `delta`,
// which gets added to `i`. The overflow checking is easier
// if we increase `i` as we go, then subtract off its starting
// value at the end to obtain `delta`.
for(oldi=i,w=1,k=base;;/* no condition */k+=base){if(index>=inputLength){error('invalid-input');}digit=basicToDigit(input.charCodeAt(index++));if(digit>=base||digit>floor((maxInt-i)/w)){error('overflow');}i+=digit*w;t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(digit<t){break;}baseMinusT=base-t;if(w>floor(maxInt/baseMinusT)){error('overflow');}w*=baseMinusT;}out=output.length+1;bias=adapt(i-oldi,out,oldi==0);// `i` was supposed to wrap around from `out` to `0`,
// incrementing `n` each time, so we'll fix that now:
if(floor(i/out)>maxInt-n){error('overflow');}n+=floor(i/out);i%=out;// Insert `n` at position `i` of the output
output.splice(i++,0,n);}return ucs2encode(output);}/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */function encode(input){var n,delta,handledCPCount,basicLength,bias,j,m,q,k,t,currentValue,output=[],/** `inputLength` will hold the number of code points in `input`. */inputLength,/** Cached calculation results */handledCPCountPlusOne,baseMinusT,qMinusT;// Convert the input in UCS-2 to Unicode
input=ucs2decode(input);// Cache the length
inputLength=input.length;// Initialize the state
n=initialN;delta=0;bias=initialBias;// Handle the basic code points
for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<0x80){output.push(stringFromCharCode(currentValue));}}handledCPCount=basicLength=output.length;// `handledCPCount` is the number of code points that have been handled;
// `basicLength` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if(basicLength){output.push(delimiter);}// Main encoding loop:
while(handledCPCount<inputLength){// All non-basic code points < n have been handled already. Find the next
// larger one:
for(m=maxInt,j=0;j<inputLength;++j){currentValue=input[j];if(currentValue>=n&&currentValue<m){m=currentValue;}}// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
// but guard against overflow
handledCPCountPlusOne=handledCPCount+1;if(m-n>floor((maxInt-delta)/handledCPCountPlusOne)){error('overflow');}delta+=(m-n)*handledCPCountPlusOne;n=m;for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<n&&++delta>maxInt){error('overflow');}if(currentValue==n){// Represent delta as a generalized variable-length integer
for(q=delta,k=base;;/* no condition */k+=base){t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(q<t){break;}qMinusT=q-t;baseMinusT=base-t;output.push(stringFromCharCode(digitToBasic(t+qMinusT%baseMinusT,0)));q=floor(qMinusT/baseMinusT);}output.push(stringFromCharCode(digitToBasic(q,0)));bias=adapt(delta,handledCPCountPlusOne,handledCPCount==basicLength);delta=0;++handledCPCount;}}++delta;++n;}return output.join('');}/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */function toUnicode(input){return mapDomain(input,function(string){return regexPunycode.test(string)?decode(string.slice(4).toLowerCase()):string;});}/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */function toASCII(input){return mapDomain(input,function(string){return regexNonASCII.test(string)?'xn--'+encode(string):string;});}/*--------------------------------------------------------------------------*/ /** Define the public API */punycode={/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */'version':'1.4.1',/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */'ucs2':{'decode':ucs2decode,'encode':ucs2encode},'decode':decode,'encode':encode,'toASCII':toASCII,'toUnicode':toUnicode};/** Expose `punycode` */ // Some AMD build optimizers, like r.js, check for specific condition patterns
// like the following:
if(typeof define=='function'&&_typeof(define.amd)=='object'&&define.amd){define('punycode',function(){return punycode;});}else if(freeExports&&freeModule){if(module.exports==freeExports){// in Node.js, io.js, or RingoJS v0.8.0+
freeModule.exports=punycode;}else{// in Narwhal or RingoJS v0.7.0-
for(key in punycode){punycode.hasOwnProperty(key)&&(freeExports[key]=punycode[key]);}}}else{// in Rhino or a web browser
root.punycode=punycode;}})(this);}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],65:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);}module.exports=function(qs,sep,eq,options){sep=sep||'&';eq=eq||'=';var obj={};if(typeof qs!=='string'||qs.length===0){return obj;}var regexp=/\+/g;qs=qs.split(sep);var maxKeys=1000;if(options&&typeof options.maxKeys==='number'){maxKeys=options.maxKeys;}var len=qs.length;// maxKeys <= 0 means that we should not limit keys count
if(maxKeys>0&&len>maxKeys){len=maxKeys;}for(var i=0;i<len;++i){var x=qs[i].replace(regexp,'%20'),idx=x.indexOf(eq),kstr,vstr,k,v;if(idx>=0){kstr=x.substr(0,idx);vstr=x.substr(idx+1);}else{kstr=x;vstr='';}k=decodeURIComponent(kstr);v=decodeURIComponent(vstr);if(!hasOwnProperty(obj,k)){obj[k]=v;}else if(isArray(obj[k])){obj[k].push(v);}else{obj[k]=[obj[k],v];}}return obj;};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};},{}],66:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';var stringifyPrimitive=function stringifyPrimitive(v){switch(_typeof(v)){case'string':return v;case'boolean':return v?'true':'false';case'number':return isFinite(v)?v:'';default:return'';}};module.exports=function(obj,sep,eq,name){sep=sep||'&';eq=eq||'=';if(obj===null){obj=undefined;}if(_typeof(obj)==='object'){return map(objectKeys(obj),function(k){var ks=encodeURIComponent(stringifyPrimitive(k))+eq;if(isArray(obj[k])){return map(obj[k],function(v){return ks+encodeURIComponent(stringifyPrimitive(v));}).join(sep);}else{return ks+encodeURIComponent(stringifyPrimitive(obj[k]));}}).join(sep);}if(!name)return'';return encodeURIComponent(stringifyPrimitive(name))+eq+encodeURIComponent(stringifyPrimitive(obj));};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};function map(xs,f){if(xs.map)return xs.map(f);var res=[];for(var i=0;i<xs.length;i++){res.push(f(xs[i],i));}return res;}var objectKeys=Object.keys||function(obj){var res=[];for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))res.push(key);}return res;};},{}],67:[function(require,module,exports){'use strict';exports.decode=exports.parse=require('./decode');exports.encode=exports.stringify=require('./encode');},{"./decode":65,"./encode":66}],68:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var util=require('./util');var has=Object.prototype.hasOwnProperty;var hasNativeMap=typeof Map!=="undefined";/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */function ArraySet(){this._array=[];this._set=hasNativeMap?new Map():Object.create(null);}/**
 * Static method for creating ArraySet instances from an existing array.
 */ArraySet.fromArray=function ArraySet_fromArray(aArray,aAllowDuplicates){var set=new ArraySet();for(var i=0,len=aArray.length;i<len;i++){set.add(aArray[i],aAllowDuplicates);}return set;};/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */ArraySet.prototype.size=function ArraySet_size(){return hasNativeMap?this._set.size:Object.getOwnPropertyNames(this._set).length;};/**
 * Add the given string to this set.
 *
 * @param String aStr
 */ArraySet.prototype.add=function ArraySet_add(aStr,aAllowDuplicates){var sStr=hasNativeMap?aStr:util.toSetString(aStr);var isDuplicate=hasNativeMap?this.has(aStr):has.call(this._set,sStr);var idx=this._array.length;if(!isDuplicate||aAllowDuplicates){this._array.push(aStr);}if(!isDuplicate){if(hasNativeMap){this._set.set(aStr,idx);}else{this._set[sStr]=idx;}}};/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */ArraySet.prototype.has=function ArraySet_has(aStr){if(hasNativeMap){return this._set.has(aStr);}else{var sStr=util.toSetString(aStr);return has.call(this._set,sStr);}};/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */ArraySet.prototype.indexOf=function ArraySet_indexOf(aStr){if(hasNativeMap){var idx=this._set.get(aStr);if(idx>=0){return idx;}}else{var sStr=util.toSetString(aStr);if(has.call(this._set,sStr)){return this._set[sStr];}}throw new Error('"'+aStr+'" is not in the set.');};/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */ArraySet.prototype.at=function ArraySet_at(aIdx){if(aIdx>=0&&aIdx<this._array.length){return this._array[aIdx];}throw new Error('No element indexed by '+aIdx);};/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */ArraySet.prototype.toArray=function ArraySet_toArray(){return this._array.slice();};exports.ArraySet=ArraySet;},{"./util":77}],69:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */var base64=require('./base64');// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011
var VLQ_BASE_SHIFT=5;// binary: 100000
var VLQ_BASE=1<<VLQ_BASE_SHIFT;// binary: 011111
var VLQ_BASE_MASK=VLQ_BASE-1;// binary: 100000
var VLQ_CONTINUATION_BIT=VLQ_BASE;/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */function toVLQSigned(aValue){return aValue<0?(-aValue<<1)+1:(aValue<<1)+0;}/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */function fromVLQSigned(aValue){var isNegative=(aValue&1)===1;var shifted=aValue>>1;return isNegative?-shifted:shifted;}/**
 * Returns the base 64 VLQ encoded value.
 */exports.encode=function base64VLQ_encode(aValue){var encoded="";var digit;var vlq=toVLQSigned(aValue);do{digit=vlq&VLQ_BASE_MASK;vlq>>>=VLQ_BASE_SHIFT;if(vlq>0){// There are still more digits in this value, so we must make sure the
// continuation bit is marked.
digit|=VLQ_CONTINUATION_BIT;}encoded+=base64.encode(digit);}while(vlq>0);return encoded;};/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */exports.decode=function base64VLQ_decode(aStr,aIndex,aOutParam){var strLen=aStr.length;var result=0;var shift=0;var continuation,digit;do{if(aIndex>=strLen){throw new Error("Expected more digits in base 64 VLQ value.");}digit=base64.decode(aStr.charCodeAt(aIndex++));if(digit===-1){throw new Error("Invalid base64 digit: "+aStr.charAt(aIndex-1));}continuation=!!(digit&VLQ_CONTINUATION_BIT);digit&=VLQ_BASE_MASK;result=result+(digit<<shift);shift+=VLQ_BASE_SHIFT;}while(continuation);aOutParam.value=fromVLQSigned(result);aOutParam.rest=aIndex;};},{"./base64":70}],70:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var intToCharMap='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */exports.encode=function(number){if(0<=number&&number<intToCharMap.length){return intToCharMap[number];}throw new TypeError("Must be between 0 and 63: "+number);};/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */exports.decode=function(charCode){var bigA=65;// 'A'
var bigZ=90;// 'Z'
var littleA=97;// 'a'
var littleZ=122;// 'z'
var zero=48;// '0'
var nine=57;// '9'
var plus=43;// '+'
var slash=47;// '/'
var littleOffset=26;var numberOffset=52;// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
if(bigA<=charCode&&charCode<=bigZ){return charCode-bigA;}// 26 - 51: abcdefghijklmnopqrstuvwxyz
if(littleA<=charCode&&charCode<=littleZ){return charCode-littleA+littleOffset;}// 52 - 61: 0123456789
if(zero<=charCode&&charCode<=nine){return charCode-zero+numberOffset;}// 62: +
if(charCode==plus){return 62;}// 63: /
if(charCode==slash){return 63;}// Invalid base64 digit.
return-1;};},{}],71:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */exports.GREATEST_LOWER_BOUND=1;exports.LEAST_UPPER_BOUND=2;/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */function recursiveSearch(aLow,aHigh,aNeedle,aHaystack,aCompare,aBias){// This function terminates when one of the following is true:
//
//   1. We find the exact element we are looking for.
//
//   2. We did not find the exact element, but we can return the index of
//      the next-closest element.
//
//   3. We did not find the exact element, and there is no next-closest
//      element than the one we are searching for, so we return -1.
var mid=Math.floor((aHigh-aLow)/2)+aLow;var cmp=aCompare(aNeedle,aHaystack[mid],true);if(cmp===0){// Found the element we are looking for.
return mid;}else if(cmp>0){// Our needle is greater than aHaystack[mid].
if(aHigh-mid>1){// The element is in the upper half.
return recursiveSearch(mid,aHigh,aNeedle,aHaystack,aCompare,aBias);}// The exact needle element was not found in this haystack. Determine if
// we are in termination case (3) or (2) and return the appropriate thing.
if(aBias==exports.LEAST_UPPER_BOUND){return aHigh<aHaystack.length?aHigh:-1;}else{return mid;}}else{// Our needle is less than aHaystack[mid].
if(mid-aLow>1){// The element is in the lower half.
return recursiveSearch(aLow,mid,aNeedle,aHaystack,aCompare,aBias);}// we are in termination case (3) or (2) and return the appropriate thing.
if(aBias==exports.LEAST_UPPER_BOUND){return mid;}else{return aLow<0?-1:aLow;}}}/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */exports.search=function search(aNeedle,aHaystack,aCompare,aBias){if(aHaystack.length===0){return-1;}var index=recursiveSearch(-1,aHaystack.length,aNeedle,aHaystack,aCompare,aBias||exports.GREATEST_LOWER_BOUND);if(index<0){return-1;}// We have found either the exact element, or the next-closest element than
// the one we are searching for. However, there may be more than one such
// element. Make sure we always return the smallest of these.
while(index-1>=0){if(aCompare(aHaystack[index],aHaystack[index-1],true)!==0){break;}--index;}return index;};},{}],72:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var util=require('./util');/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */function generatedPositionAfter(mappingA,mappingB){// Optimized for most common case
var lineA=mappingA.generatedLine;var lineB=mappingB.generatedLine;var columnA=mappingA.generatedColumn;var columnB=mappingB.generatedColumn;return lineB>lineA||lineB==lineA&&columnB>=columnA||util.compareByGeneratedPositionsInflated(mappingA,mappingB)<=0;}/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */function MappingList(){this._array=[];this._sorted=true;// Serves as infimum
this._last={generatedLine:-1,generatedColumn:0};}/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */MappingList.prototype.unsortedForEach=function MappingList_forEach(aCallback,aThisArg){this._array.forEach(aCallback,aThisArg);};/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */MappingList.prototype.add=function MappingList_add(aMapping){if(generatedPositionAfter(this._last,aMapping)){this._last=aMapping;this._array.push(aMapping);}else{this._sorted=false;this._array.push(aMapping);}};/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */MappingList.prototype.toArray=function MappingList_toArray(){if(!this._sorted){this._array.sort(util.compareByGeneratedPositionsInflated);this._sorted=true;}return this._array;};exports.MappingList=MappingList;},{"./util":77}],73:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ // It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.
/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */function swap(ary,x,y){var temp=ary[x];ary[x]=ary[y];ary[y]=temp;}/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */function randomIntInRange(low,high){return Math.round(low+Math.random()*(high-low));}/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */function doQuickSort(ary,comparator,p,r){// If our lower bound is less than our upper bound, we (1) partition the
// array into two pieces and (2) recurse on each half. If it is not, this is
// the empty array and our base case.
if(p<r){// (1) Partitioning.
//
// The partitioning chooses a pivot between `p` and `r` and moves all
// elements that are less than or equal to the pivot to the before it, and
// all the elements that are greater than it after it. The effect is that
// once partition is done, the pivot is in the exact place it will be when
// the array is put in sorted order, and it will not need to be moved
// again. This runs in O(n) time.
// Always choose a random pivot so that an input array which is reverse
// sorted does not cause O(n^2) running time.
var pivotIndex=randomIntInRange(p,r);var i=p-1;swap(ary,pivotIndex,r);var pivot=ary[r];// Immediately after `j` is incremented in this loop, the following hold
// true:
//
//   * Every element in `ary[p .. i]` is less than or equal to the pivot.
//
//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
for(var j=p;j<r;j++){if(comparator(ary[j],pivot)<=0){i+=1;swap(ary,i,j);}}swap(ary,i+1,j);var q=i+1;// (2) Recurse on each half.
doQuickSort(ary,comparator,p,q-1);doQuickSort(ary,comparator,q+1,r);}}/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */exports.quickSort=function(ary,comparator){doQuickSort(ary,comparator,0,ary.length-1);};},{}],74:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var util=require('./util');var binarySearch=require('./binary-search');var ArraySet=require('./array-set').ArraySet;var base64VLQ=require('./base64-vlq');var quickSort=require('./quick-sort').quickSort;function SourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}return sourceMap.sections!=null?new IndexedSourceMapConsumer(sourceMap,aSourceMapURL):new BasicSourceMapConsumer(sourceMap,aSourceMapURL);}SourceMapConsumer.fromSourceMap=function(aSourceMap,aSourceMapURL){return BasicSourceMapConsumer.fromSourceMap(aSourceMap,aSourceMapURL);};/**
 * The version of the source mapping spec that we are consuming.
 */SourceMapConsumer.prototype._version=3;// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.
SourceMapConsumer.prototype.__generatedMappings=null;Object.defineProperty(SourceMapConsumer.prototype,'_generatedMappings',{configurable:true,enumerable:true,get:function get(){if(!this.__generatedMappings){this._parseMappings(this._mappings,this.sourceRoot);}return this.__generatedMappings;}});SourceMapConsumer.prototype.__originalMappings=null;Object.defineProperty(SourceMapConsumer.prototype,'_originalMappings',{configurable:true,enumerable:true,get:function get(){if(!this.__originalMappings){this._parseMappings(this._mappings,this.sourceRoot);}return this.__originalMappings;}});SourceMapConsumer.prototype._charIsMappingSeparator=function SourceMapConsumer_charIsMappingSeparator(aStr,index){var c=aStr.charAt(index);return c===";"||c===",";};/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */SourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(aStr,aSourceRoot){throw new Error("Subclasses must implement _parseMappings");};SourceMapConsumer.GENERATED_ORDER=1;SourceMapConsumer.ORIGINAL_ORDER=2;SourceMapConsumer.GREATEST_LOWER_BOUND=1;SourceMapConsumer.LEAST_UPPER_BOUND=2;/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */SourceMapConsumer.prototype.eachMapping=function SourceMapConsumer_eachMapping(aCallback,aContext,aOrder){var context=aContext||null;var order=aOrder||SourceMapConsumer.GENERATED_ORDER;var mappings;switch(order){case SourceMapConsumer.GENERATED_ORDER:mappings=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:mappings=this._originalMappings;break;default:throw new Error("Unknown order of iteration.");}var sourceRoot=this.sourceRoot;mappings.map(function(mapping){var source=mapping.source===null?null:this._sources.at(mapping.source);source=util.computeSourceURL(sourceRoot,source,this._sourceMapURL);return{source:source,generatedLine:mapping.generatedLine,generatedColumn:mapping.generatedColumn,originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:mapping.name===null?null:this._names.at(mapping.name)};},this).forEach(aCallback,context);};/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */SourceMapConsumer.prototype.allGeneratedPositionsFor=function SourceMapConsumer_allGeneratedPositionsFor(aArgs){var line=util.getArg(aArgs,'line');// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
// returns the index of the closest mapping less than the needle. By
// setting needle.originalColumn to 0, we thus find the last mapping for
// the given line, provided such a mapping exists.
var needle={source:util.getArg(aArgs,'source'),originalLine:line,originalColumn:util.getArg(aArgs,'column',0)};needle.source=this._findSourceIndex(needle.source);if(needle.source<0){return[];}var mappings=[];var index=this._findMapping(needle,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,binarySearch.LEAST_UPPER_BOUND);if(index>=0){var mapping=this._originalMappings[index];if(aArgs.column===undefined){var originalLine=mapping.originalLine;// Iterate until either we run out of mappings, or we run into
// a mapping for a different line than the one we found. Since
// mappings are sorted, this is guaranteed to find all mappings for
// the line we found.
while(mapping&&mapping.originalLine===originalLine){mappings.push({line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)});mapping=this._originalMappings[++index];}}else{var originalColumn=mapping.originalColumn;// Iterate until either we run out of mappings, or we run into
// a mapping for a different line than the one we were searching for.
// Since mappings are sorted, this is guaranteed to find all mappings for
// the line we are searching for.
while(mapping&&mapping.originalLine===line&&mapping.originalColumn==originalColumn){mappings.push({line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)});mapping=this._originalMappings[++index];}}}return mappings;};exports.SourceMapConsumer=SourceMapConsumer;/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */function BasicSourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}var version=util.getArg(sourceMap,'version');var sources=util.getArg(sourceMap,'sources');// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
// requires the array) to play nice here.
var names=util.getArg(sourceMap,'names',[]);var sourceRoot=util.getArg(sourceMap,'sourceRoot',null);var sourcesContent=util.getArg(sourceMap,'sourcesContent',null);var mappings=util.getArg(sourceMap,'mappings');var file=util.getArg(sourceMap,'file',null);// Once again, Sass deviates from the spec and supplies the version as a
// string rather than a number, so we use loose equality checking here.
if(version!=this._version){throw new Error('Unsupported version: '+version);}if(sourceRoot){sourceRoot=util.normalize(sourceRoot);}sources=sources.map(String)// Some source maps produce relative source paths like "./foo.js" instead of
// "foo.js".  Normalize these first so that future comparisons will succeed.
// See bugzil.la/1090768.
.map(util.normalize)// Always ensure that absolute sources are internally stored relative to
// the source root, if the source root is absolute. Not doing this would
// be particularly problematic when the source root is a prefix of the
// source (valid, but why??). See github issue #199 and bugzil.la/1188982.
.map(function(source){return sourceRoot&&util.isAbsolute(sourceRoot)&&util.isAbsolute(source)?util.relative(sourceRoot,source):source;});// Pass `true` below to allow duplicate names and sources. While source maps
// are intended to be compressed and deduplicated, the TypeScript compiler
// sometimes generates source maps with duplicates in them. See Github issue
// #72 and bugzil.la/889492.
this._names=ArraySet.fromArray(names.map(String),true);this._sources=ArraySet.fromArray(sources,true);this._absoluteSources=this._sources.toArray().map(function(s){return util.computeSourceURL(sourceRoot,s,aSourceMapURL);});this.sourceRoot=sourceRoot;this.sourcesContent=sourcesContent;this._mappings=mappings;this._sourceMapURL=aSourceMapURL;this.file=file;}BasicSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer;/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */BasicSourceMapConsumer.prototype._findSourceIndex=function(aSource){var relativeSource=aSource;if(this.sourceRoot!=null){relativeSource=util.relative(this.sourceRoot,relativeSource);}if(this._sources.has(relativeSource)){return this._sources.indexOf(relativeSource);}// Maybe aSource is an absolute URL as returned by |sources|.  In
// this case we can't simply undo the transform.
var i;for(i=0;i<this._absoluteSources.length;++i){if(this._absoluteSources[i]==aSource){return i;}}return-1;};/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */BasicSourceMapConsumer.fromSourceMap=function SourceMapConsumer_fromSourceMap(aSourceMap,aSourceMapURL){var smc=Object.create(BasicSourceMapConsumer.prototype);var names=smc._names=ArraySet.fromArray(aSourceMap._names.toArray(),true);var sources=smc._sources=ArraySet.fromArray(aSourceMap._sources.toArray(),true);smc.sourceRoot=aSourceMap._sourceRoot;smc.sourcesContent=aSourceMap._generateSourcesContent(smc._sources.toArray(),smc.sourceRoot);smc.file=aSourceMap._file;smc._sourceMapURL=aSourceMapURL;smc._absoluteSources=smc._sources.toArray().map(function(s){return util.computeSourceURL(smc.sourceRoot,s,aSourceMapURL);});// Because we are modifying the entries (by converting string sources and
// names to indices into the sources and names ArraySets), we have to make
// a copy of the entry or else bad things happen. Shared mutable state
// strikes again! See github issue #191.
var generatedMappings=aSourceMap._mappings.toArray().slice();var destGeneratedMappings=smc.__generatedMappings=[];var destOriginalMappings=smc.__originalMappings=[];for(var i=0,length=generatedMappings.length;i<length;i++){var srcMapping=generatedMappings[i];var destMapping=new Mapping();destMapping.generatedLine=srcMapping.generatedLine;destMapping.generatedColumn=srcMapping.generatedColumn;if(srcMapping.source){destMapping.source=sources.indexOf(srcMapping.source);destMapping.originalLine=srcMapping.originalLine;destMapping.originalColumn=srcMapping.originalColumn;if(srcMapping.name){destMapping.name=names.indexOf(srcMapping.name);}destOriginalMappings.push(destMapping);}destGeneratedMappings.push(destMapping);}quickSort(smc.__originalMappings,util.compareByOriginalPositions);return smc;};/**
 * The version of the source mapping spec that we are consuming.
 */BasicSourceMapConsumer.prototype._version=3;/**
 * The list of original sources.
 */Object.defineProperty(BasicSourceMapConsumer.prototype,'sources',{get:function get(){return this._absoluteSources.slice();}});/**
 * Provide the JIT with a nice shape / hidden class.
 */function Mapping(){this.generatedLine=0;this.generatedColumn=0;this.source=null;this.originalLine=null;this.originalColumn=null;this.name=null;}/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */BasicSourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(aStr,aSourceRoot){var generatedLine=1;var previousGeneratedColumn=0;var previousOriginalLine=0;var previousOriginalColumn=0;var previousSource=0;var previousName=0;var length=aStr.length;var index=0;var cachedSegments={};var temp={};var originalMappings=[];var generatedMappings=[];var mapping,str,segment,end,value;while(index<length){if(aStr.charAt(index)===';'){generatedLine++;index++;previousGeneratedColumn=0;}else if(aStr.charAt(index)===','){index++;}else{mapping=new Mapping();mapping.generatedLine=generatedLine;// Because each offset is encoded relative to the previous one,
// many segments often have the same encoding. We can exploit this
// fact by caching the parsed variable length fields of each segment,
// allowing us to avoid a second parse if we encounter the same
// segment again.
for(end=index;end<length;end++){if(this._charIsMappingSeparator(aStr,end)){break;}}str=aStr.slice(index,end);segment=cachedSegments[str];if(segment){index+=str.length;}else{segment=[];while(index<end){base64VLQ.decode(aStr,index,temp);value=temp.value;index=temp.rest;segment.push(value);}if(segment.length===2){throw new Error('Found a source, but no line and column');}if(segment.length===3){throw new Error('Found a source and line, but no column');}cachedSegments[str]=segment;}// Generated column.
mapping.generatedColumn=previousGeneratedColumn+segment[0];previousGeneratedColumn=mapping.generatedColumn;if(segment.length>1){// Original source.
mapping.source=previousSource+segment[1];previousSource+=segment[1];// Original line.
mapping.originalLine=previousOriginalLine+segment[2];previousOriginalLine=mapping.originalLine;// Lines are stored 0-based
mapping.originalLine+=1;// Original column.
mapping.originalColumn=previousOriginalColumn+segment[3];previousOriginalColumn=mapping.originalColumn;if(segment.length>4){// Original name.
mapping.name=previousName+segment[4];previousName+=segment[4];}}generatedMappings.push(mapping);if(typeof mapping.originalLine==='number'){originalMappings.push(mapping);}}}quickSort(generatedMappings,util.compareByGeneratedPositionsDeflated);this.__generatedMappings=generatedMappings;quickSort(originalMappings,util.compareByOriginalPositions);this.__originalMappings=originalMappings;};/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */BasicSourceMapConsumer.prototype._findMapping=function SourceMapConsumer_findMapping(aNeedle,aMappings,aLineName,aColumnName,aComparator,aBias){// To return the position we are searching for, we must first find the
// mapping for the given position and then return the opposite position it
// points to. Because the mappings are sorted, we can use binary search to
// find the best mapping.
if(aNeedle[aLineName]<=0){throw new TypeError('Line must be greater than or equal to 1, got '+aNeedle[aLineName]);}if(aNeedle[aColumnName]<0){throw new TypeError('Column must be greater than or equal to 0, got '+aNeedle[aColumnName]);}return binarySearch.search(aNeedle,aMappings,aComparator,aBias);};/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */BasicSourceMapConsumer.prototype.computeColumnSpans=function SourceMapConsumer_computeColumnSpans(){for(var index=0;index<this._generatedMappings.length;++index){var mapping=this._generatedMappings[index];// Mappings do not contain a field for the last generated columnt. We
// can come up with an optimistic estimate, however, by assuming that
// mappings are contiguous (i.e. given two consecutive mappings, the
// first mapping ends where the second one starts).
if(index+1<this._generatedMappings.length){var nextMapping=this._generatedMappings[index+1];if(mapping.generatedLine===nextMapping.generatedLine){mapping.lastGeneratedColumn=nextMapping.generatedColumn-1;continue;}}// The last mapping for each line spans the entire line.
mapping.lastGeneratedColumn=Infinity;}};/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */BasicSourceMapConsumer.prototype.originalPositionFor=function SourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,'line'),generatedColumn:util.getArg(aArgs,'column')};var index=this._findMapping(needle,this._generatedMappings,"generatedLine","generatedColumn",util.compareByGeneratedPositionsDeflated,util.getArg(aArgs,'bias',SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._generatedMappings[index];if(mapping.generatedLine===needle.generatedLine){var source=util.getArg(mapping,'source',null);if(source!==null){source=this._sources.at(source);source=util.computeSourceURL(this.sourceRoot,source,this._sourceMapURL);}var name=util.getArg(mapping,'name',null);if(name!==null){name=this._names.at(name);}return{source:source,line:util.getArg(mapping,'originalLine',null),column:util.getArg(mapping,'originalColumn',null),name:name};}}return{source:null,line:null,column:null,name:null};};/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */BasicSourceMapConsumer.prototype.hasContentsOfAllSources=function BasicSourceMapConsumer_hasContentsOfAllSources(){if(!this.sourcesContent){return false;}return this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(sc){return sc==null;});};/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */BasicSourceMapConsumer.prototype.sourceContentFor=function SourceMapConsumer_sourceContentFor(aSource,nullOnMissing){if(!this.sourcesContent){return null;}var index=this._findSourceIndex(aSource);if(index>=0){return this.sourcesContent[index];}var relativeSource=aSource;if(this.sourceRoot!=null){relativeSource=util.relative(this.sourceRoot,relativeSource);}var url;if(this.sourceRoot!=null&&(url=util.urlParse(this.sourceRoot))){// XXX: file:// URIs and absolute paths lead to unexpected behavior for
// many users. We can help them out when they expect file:// URIs to
// behave like it would if they were running a local HTTP server. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
var fileUriAbsPath=relativeSource.replace(/^file:\/\//,"");if(url.scheme=="file"&&this._sources.has(fileUriAbsPath)){return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];}if((!url.path||url.path=="/")&&this._sources.has("/"+relativeSource)){return this.sourcesContent[this._sources.indexOf("/"+relativeSource)];}}// This function is used recursively from
// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
// don't want to throw if we can't find the source - we just want to
// return null, so we provide a flag to exit gracefully.
if(nullOnMissing){return null;}else{throw new Error('"'+relativeSource+'" is not in the SourceMap.');}};/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */BasicSourceMapConsumer.prototype.generatedPositionFor=function SourceMapConsumer_generatedPositionFor(aArgs){var source=util.getArg(aArgs,'source');source=this._findSourceIndex(source);if(source<0){return{line:null,column:null,lastColumn:null};}var needle={source:source,originalLine:util.getArg(aArgs,'line'),originalColumn:util.getArg(aArgs,'column')};var index=this._findMapping(needle,this._originalMappings,"originalLine","originalColumn",util.compareByOriginalPositions,util.getArg(aArgs,'bias',SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._originalMappings[index];if(mapping.source===needle.source){return{line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)};}}return{line:null,column:null,lastColumn:null};};exports.BasicSourceMapConsumer=BasicSourceMapConsumer;/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */function IndexedSourceMapConsumer(aSourceMap,aSourceMapURL){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=util.parseSourceMapInput(aSourceMap);}var version=util.getArg(sourceMap,'version');var sections=util.getArg(sourceMap,'sections');if(version!=this._version){throw new Error('Unsupported version: '+version);}this._sources=new ArraySet();this._names=new ArraySet();var lastOffset={line:-1,column:0};this._sections=sections.map(function(s){if(s.url){// The url field will require support for asynchronicity.
// See https://github.com/mozilla/source-map/issues/16
throw new Error('Support for url field in sections not implemented.');}var offset=util.getArg(s,'offset');var offsetLine=util.getArg(offset,'line');var offsetColumn=util.getArg(offset,'column');if(offsetLine<lastOffset.line||offsetLine===lastOffset.line&&offsetColumn<lastOffset.column){throw new Error('Section offsets must be ordered and non-overlapping.');}lastOffset=offset;return{generatedOffset:{// The offset fields are 0-based, but we use 1-based indices when
// encoding/decoding from VLQ.
generatedLine:offsetLine+1,generatedColumn:offsetColumn+1},consumer:new SourceMapConsumer(util.getArg(s,'map'),aSourceMapURL)};});}IndexedSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);IndexedSourceMapConsumer.prototype.constructor=SourceMapConsumer;/**
 * The version of the source mapping spec that we are consuming.
 */IndexedSourceMapConsumer.prototype._version=3;/**
 * The list of original sources.
 */Object.defineProperty(IndexedSourceMapConsumer.prototype,'sources',{get:function get(){var sources=[];for(var i=0;i<this._sections.length;i++){for(var j=0;j<this._sections[i].consumer.sources.length;j++){sources.push(this._sections[i].consumer.sources[j]);}}return sources;}});/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */IndexedSourceMapConsumer.prototype.originalPositionFor=function IndexedSourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,'line'),generatedColumn:util.getArg(aArgs,'column')};// Find the section containing the generated position we're trying to map
// to an original position.
var sectionIndex=binarySearch.search(needle,this._sections,function(needle,section){var cmp=needle.generatedLine-section.generatedOffset.generatedLine;if(cmp){return cmp;}return needle.generatedColumn-section.generatedOffset.generatedColumn;});var section=this._sections[sectionIndex];if(!section){return{source:null,line:null,column:null,name:null};}return section.consumer.originalPositionFor({line:needle.generatedLine-(section.generatedOffset.generatedLine-1),column:needle.generatedColumn-(section.generatedOffset.generatedLine===needle.generatedLine?section.generatedOffset.generatedColumn-1:0),bias:aArgs.bias});};/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */IndexedSourceMapConsumer.prototype.hasContentsOfAllSources=function IndexedSourceMapConsumer_hasContentsOfAllSources(){return this._sections.every(function(s){return s.consumer.hasContentsOfAllSources();});};/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */IndexedSourceMapConsumer.prototype.sourceContentFor=function IndexedSourceMapConsumer_sourceContentFor(aSource,nullOnMissing){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var content=section.consumer.sourceContentFor(aSource,true);if(content){return content;}}if(nullOnMissing){return null;}else{throw new Error('"'+aSource+'" is not in the SourceMap.');}};/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */IndexedSourceMapConsumer.prototype.generatedPositionFor=function IndexedSourceMapConsumer_generatedPositionFor(aArgs){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];// Only consider this section if the requested source is in the list of
// sources of the consumer.
if(section.consumer._findSourceIndex(util.getArg(aArgs,'source'))===-1){continue;}var generatedPosition=section.consumer.generatedPositionFor(aArgs);if(generatedPosition){var ret={line:generatedPosition.line+(section.generatedOffset.generatedLine-1),column:generatedPosition.column+(section.generatedOffset.generatedLine===generatedPosition.line?section.generatedOffset.generatedColumn-1:0)};return ret;}}return{line:null,column:null};};/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */IndexedSourceMapConsumer.prototype._parseMappings=function IndexedSourceMapConsumer_parseMappings(aStr,aSourceRoot){this.__generatedMappings=[];this.__originalMappings=[];for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var sectionMappings=section.consumer._generatedMappings;for(var j=0;j<sectionMappings.length;j++){var mapping=sectionMappings[j];var source=section.consumer._sources.at(mapping.source);source=util.computeSourceURL(section.consumer.sourceRoot,source,this._sourceMapURL);this._sources.add(source);source=this._sources.indexOf(source);var name=null;if(mapping.name){name=section.consumer._names.at(mapping.name);this._names.add(name);name=this._names.indexOf(name);}// The mappings coming from the consumer for the section have
// generated positions relative to the start of the section, so we
// need to offset them to be relative to the start of the concatenated
// generated file.
var adjustedMapping={source:source,generatedLine:mapping.generatedLine+(section.generatedOffset.generatedLine-1),generatedColumn:mapping.generatedColumn+(section.generatedOffset.generatedLine===mapping.generatedLine?section.generatedOffset.generatedColumn-1:0),originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:name};this.__generatedMappings.push(adjustedMapping);if(typeof adjustedMapping.originalLine==='number'){this.__originalMappings.push(adjustedMapping);}}}quickSort(this.__generatedMappings,util.compareByGeneratedPositionsDeflated);quickSort(this.__originalMappings,util.compareByOriginalPositions);};exports.IndexedSourceMapConsumer=IndexedSourceMapConsumer;},{"./array-set":68,"./base64-vlq":69,"./binary-search":71,"./quick-sort":73,"./util":77}],75:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var base64VLQ=require('./base64-vlq');var util=require('./util');var ArraySet=require('./array-set').ArraySet;var MappingList=require('./mapping-list').MappingList;/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */function SourceMapGenerator(aArgs){if(!aArgs){aArgs={};}this._file=util.getArg(aArgs,'file',null);this._sourceRoot=util.getArg(aArgs,'sourceRoot',null);this._skipValidation=util.getArg(aArgs,'skipValidation',false);this._sources=new ArraySet();this._names=new ArraySet();this._mappings=new MappingList();this._sourcesContents=null;}SourceMapGenerator.prototype._version=3;/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */SourceMapGenerator.fromSourceMap=function SourceMapGenerator_fromSourceMap(aSourceMapConsumer){var sourceRoot=aSourceMapConsumer.sourceRoot;var generator=new SourceMapGenerator({file:aSourceMapConsumer.file,sourceRoot:sourceRoot});aSourceMapConsumer.eachMapping(function(mapping){var newMapping={generated:{line:mapping.generatedLine,column:mapping.generatedColumn}};if(mapping.source!=null){newMapping.source=mapping.source;if(sourceRoot!=null){newMapping.source=util.relative(sourceRoot,newMapping.source);}newMapping.original={line:mapping.originalLine,column:mapping.originalColumn};if(mapping.name!=null){newMapping.name=mapping.name;}}generator.addMapping(newMapping);});aSourceMapConsumer.sources.forEach(function(sourceFile){var sourceRelative=sourceFile;if(sourceRoot!==null){sourceRelative=util.relative(sourceRoot,sourceFile);}if(!generator._sources.has(sourceRelative)){generator._sources.add(sourceRelative);}var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){generator.setSourceContent(sourceFile,content);}});return generator;};/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */SourceMapGenerator.prototype.addMapping=function SourceMapGenerator_addMapping(aArgs){var generated=util.getArg(aArgs,'generated');var original=util.getArg(aArgs,'original',null);var source=util.getArg(aArgs,'source',null);var name=util.getArg(aArgs,'name',null);if(!this._skipValidation){this._validateMapping(generated,original,source,name);}if(source!=null){source=String(source);if(!this._sources.has(source)){this._sources.add(source);}}if(name!=null){name=String(name);if(!this._names.has(name)){this._names.add(name);}}this._mappings.add({generatedLine:generated.line,generatedColumn:generated.column,originalLine:original!=null&&original.line,originalColumn:original!=null&&original.column,source:source,name:name});};/**
 * Set the source content for a source file.
 */SourceMapGenerator.prototype.setSourceContent=function SourceMapGenerator_setSourceContent(aSourceFile,aSourceContent){var source=aSourceFile;if(this._sourceRoot!=null){source=util.relative(this._sourceRoot,source);}if(aSourceContent!=null){// Add the source content to the _sourcesContents map.
// Create a new _sourcesContents map if the property is null.
if(!this._sourcesContents){this._sourcesContents=Object.create(null);}this._sourcesContents[util.toSetString(source)]=aSourceContent;}else if(this._sourcesContents){// Remove the source file from the _sourcesContents map.
// If the _sourcesContents map is empty, set the property to null.
delete this._sourcesContents[util.toSetString(source)];if(Object.keys(this._sourcesContents).length===0){this._sourcesContents=null;}}};/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */SourceMapGenerator.prototype.applySourceMap=function SourceMapGenerator_applySourceMap(aSourceMapConsumer,aSourceFile,aSourceMapPath){var sourceFile=aSourceFile;// If aSourceFile is omitted, we will use the file property of the SourceMap
if(aSourceFile==null){if(aSourceMapConsumer.file==null){throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, '+'or the source map\'s "file" property. Both were omitted.');}sourceFile=aSourceMapConsumer.file;}var sourceRoot=this._sourceRoot;// Make "sourceFile" relative if an absolute Url is passed.
if(sourceRoot!=null){sourceFile=util.relative(sourceRoot,sourceFile);}// Applying the SourceMap can add and remove items from the sources and
// the names array.
var newSources=new ArraySet();var newNames=new ArraySet();// Find mappings for the "sourceFile"
this._mappings.unsortedForEach(function(mapping){if(mapping.source===sourceFile&&mapping.originalLine!=null){// Check if it can be mapped by the source map, then update the mapping.
var original=aSourceMapConsumer.originalPositionFor({line:mapping.originalLine,column:mapping.originalColumn});if(original.source!=null){// Copy mapping
mapping.source=original.source;if(aSourceMapPath!=null){mapping.source=util.join(aSourceMapPath,mapping.source);}if(sourceRoot!=null){mapping.source=util.relative(sourceRoot,mapping.source);}mapping.originalLine=original.line;mapping.originalColumn=original.column;if(original.name!=null){mapping.name=original.name;}}}var source=mapping.source;if(source!=null&&!newSources.has(source)){newSources.add(source);}var name=mapping.name;if(name!=null&&!newNames.has(name)){newNames.add(name);}},this);this._sources=newSources;this._names=newNames;// Copy sourcesContents of applied map.
aSourceMapConsumer.sources.forEach(function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){if(aSourceMapPath!=null){sourceFile=util.join(aSourceMapPath,sourceFile);}if(sourceRoot!=null){sourceFile=util.relative(sourceRoot,sourceFile);}this.setSourceContent(sourceFile,content);}},this);};/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */SourceMapGenerator.prototype._validateMapping=function SourceMapGenerator_validateMapping(aGenerated,aOriginal,aSource,aName){// When aOriginal is truthy but has empty values for .line and .column,
// it is most likely a programmer error. In this case we throw a very
// specific error message to try to guide them the right way.
// For example: https://github.com/Polymer/polymer-bundler/pull/519
if(aOriginal&&typeof aOriginal.line!=='number'&&typeof aOriginal.column!=='number'){throw new Error('original.line and original.column are not numbers -- you probably meant to omit '+'the original mapping entirely and only map the generated position. If so, pass '+'null for the original mapping instead of an object with empty or null values.');}if(aGenerated&&'line'in aGenerated&&'column'in aGenerated&&aGenerated.line>0&&aGenerated.column>=0&&!aOriginal&&!aSource&&!aName){// Case 1.
return;}else if(aGenerated&&'line'in aGenerated&&'column'in aGenerated&&aOriginal&&'line'in aOriginal&&'column'in aOriginal&&aGenerated.line>0&&aGenerated.column>=0&&aOriginal.line>0&&aOriginal.column>=0&&aSource){// Cases 2 and 3.
return;}else{throw new Error('Invalid mapping: '+JSON.stringify({generated:aGenerated,source:aSource,original:aOriginal,name:aName}));}};/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */SourceMapGenerator.prototype._serializeMappings=function SourceMapGenerator_serializeMappings(){var previousGeneratedColumn=0;var previousGeneratedLine=1;var previousOriginalColumn=0;var previousOriginalLine=0;var previousName=0;var previousSource=0;var result='';var next;var mapping;var nameIdx;var sourceIdx;var mappings=this._mappings.toArray();for(var i=0,len=mappings.length;i<len;i++){mapping=mappings[i];next='';if(mapping.generatedLine!==previousGeneratedLine){previousGeneratedColumn=0;while(mapping.generatedLine!==previousGeneratedLine){next+=';';previousGeneratedLine++;}}else{if(i>0){if(!util.compareByGeneratedPositionsInflated(mapping,mappings[i-1])){continue;}next+=',';}}next+=base64VLQ.encode(mapping.generatedColumn-previousGeneratedColumn);previousGeneratedColumn=mapping.generatedColumn;if(mapping.source!=null){sourceIdx=this._sources.indexOf(mapping.source);next+=base64VLQ.encode(sourceIdx-previousSource);previousSource=sourceIdx;// lines are stored 0-based in SourceMap spec version 3
next+=base64VLQ.encode(mapping.originalLine-1-previousOriginalLine);previousOriginalLine=mapping.originalLine-1;next+=base64VLQ.encode(mapping.originalColumn-previousOriginalColumn);previousOriginalColumn=mapping.originalColumn;if(mapping.name!=null){nameIdx=this._names.indexOf(mapping.name);next+=base64VLQ.encode(nameIdx-previousName);previousName=nameIdx;}}result+=next;}return result;};SourceMapGenerator.prototype._generateSourcesContent=function SourceMapGenerator_generateSourcesContent(aSources,aSourceRoot){return aSources.map(function(source){if(!this._sourcesContents){return null;}if(aSourceRoot!=null){source=util.relative(aSourceRoot,source);}var key=util.toSetString(source);return Object.prototype.hasOwnProperty.call(this._sourcesContents,key)?this._sourcesContents[key]:null;},this);};/**
 * Externalize the source map.
 */SourceMapGenerator.prototype.toJSON=function SourceMapGenerator_toJSON(){var map={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};if(this._file!=null){map.file=this._file;}if(this._sourceRoot!=null){map.sourceRoot=this._sourceRoot;}if(this._sourcesContents){map.sourcesContent=this._generateSourcesContent(map.sources,map.sourceRoot);}return map;};/**
 * Render the source map being generated to a string.
 */SourceMapGenerator.prototype.toString=function SourceMapGenerator_toString(){return JSON.stringify(this.toJSON());};exports.SourceMapGenerator=SourceMapGenerator;},{"./array-set":68,"./base64-vlq":69,"./mapping-list":72,"./util":77}],76:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */var SourceMapGenerator=require('./source-map-generator').SourceMapGenerator;var util=require('./util');// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE=/(\r?\n)/;// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE=10;// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode="$$$isSourceNode$$$";/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */function SourceNode(aLine,aColumn,aSource,aChunks,aName){this.children=[];this.sourceContents={};this.line=aLine==null?null:aLine;this.column=aColumn==null?null:aColumn;this.source=aSource==null?null:aSource;this.name=aName==null?null:aName;this[isSourceNode]=true;if(aChunks!=null)this.add(aChunks);}/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */SourceNode.fromStringWithSourceMap=function SourceNode_fromStringWithSourceMap(aGeneratedCode,aSourceMapConsumer,aRelativePath){// The SourceNode we want to fill with the generated code
// and the SourceMap
var node=new SourceNode();// All even indices of this array are one line of the generated code,
// while all odd indices are the newlines between two adjacent lines
// (since `REGEX_NEWLINE` captures its match).
// Processed fragments are accessed by calling `shiftNextLine`.
var remainingLines=aGeneratedCode.split(REGEX_NEWLINE);var remainingLinesIndex=0;var shiftNextLine=function shiftNextLine(){var lineContents=getNextLine();// The last line of a file might not have a newline.
var newLine=getNextLine()||"";return lineContents+newLine;function getNextLine(){return remainingLinesIndex<remainingLines.length?remainingLines[remainingLinesIndex++]:undefined;}};// We need to remember the position of "remainingLines"
var lastGeneratedLine=1,lastGeneratedColumn=0;// The generate SourceNodes we need a code range.
// To extract it current and last mapping is used.
// Here we store the last mapping.
var lastMapping=null;aSourceMapConsumer.eachMapping(function(mapping){if(lastMapping!==null){// We add the code from "lastMapping" to "mapping":
// First check if there is a new line in between.
if(lastGeneratedLine<mapping.generatedLine){// Associate first line with "lastMapping"
addMappingWithCode(lastMapping,shiftNextLine());lastGeneratedLine++;lastGeneratedColumn=0;// The remaining code is added without mapping
}else{// There is no new line in between.
// Associate the code between "lastGeneratedColumn" and
// "mapping.generatedColumn" with "lastMapping"
var nextLine=remainingLines[remainingLinesIndex]||'';var code=nextLine.substr(0,mapping.generatedColumn-lastGeneratedColumn);remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn-lastGeneratedColumn);lastGeneratedColumn=mapping.generatedColumn;addMappingWithCode(lastMapping,code);// No more remaining code, continue
lastMapping=mapping;return;}}// We add the generated code until the first mapping
// to the SourceNode without any mapping.
// Each line is added as separate string.
while(lastGeneratedLine<mapping.generatedLine){node.add(shiftNextLine());lastGeneratedLine++;}if(lastGeneratedColumn<mapping.generatedColumn){var nextLine=remainingLines[remainingLinesIndex]||'';node.add(nextLine.substr(0,mapping.generatedColumn));remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn);lastGeneratedColumn=mapping.generatedColumn;}lastMapping=mapping;},this);// We have processed all mappings.
if(remainingLinesIndex<remainingLines.length){if(lastMapping){// Associate the remaining code in the current line with "lastMapping"
addMappingWithCode(lastMapping,shiftNextLine());}// and add the remaining lines without any mapping
node.add(remainingLines.splice(remainingLinesIndex).join(""));}// Copy sourcesContent into SourceNode
aSourceMapConsumer.sources.forEach(function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){if(aRelativePath!=null){sourceFile=util.join(aRelativePath,sourceFile);}node.setSourceContent(sourceFile,content);}});return node;function addMappingWithCode(mapping,code){if(mapping===null||mapping.source===undefined){node.add(code);}else{var source=aRelativePath?util.join(aRelativePath,mapping.source):mapping.source;node.add(new SourceNode(mapping.originalLine,mapping.originalColumn,source,code,mapping.name));}}};/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */SourceNode.prototype.add=function SourceNode_add(aChunk){if(Array.isArray(aChunk)){aChunk.forEach(function(chunk){this.add(chunk);},this);}else if(aChunk[isSourceNode]||typeof aChunk==="string"){if(aChunk){this.children.push(aChunk);}}else{throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+aChunk);}return this;};/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */SourceNode.prototype.prepend=function SourceNode_prepend(aChunk){if(Array.isArray(aChunk)){for(var i=aChunk.length-1;i>=0;i--){this.prepend(aChunk[i]);}}else if(aChunk[isSourceNode]||typeof aChunk==="string"){this.children.unshift(aChunk);}else{throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+aChunk);}return this;};/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */SourceNode.prototype.walk=function SourceNode_walk(aFn){var chunk;for(var i=0,len=this.children.length;i<len;i++){chunk=this.children[i];if(chunk[isSourceNode]){chunk.walk(aFn);}else{if(chunk!==''){aFn(chunk,{source:this.source,line:this.line,column:this.column,name:this.name});}}}};/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */SourceNode.prototype.join=function SourceNode_join(aSep){var newChildren;var i;var len=this.children.length;if(len>0){newChildren=[];for(i=0;i<len-1;i++){newChildren.push(this.children[i]);newChildren.push(aSep);}newChildren.push(this.children[i]);this.children=newChildren;}return this;};/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */SourceNode.prototype.replaceRight=function SourceNode_replaceRight(aPattern,aReplacement){var lastChild=this.children[this.children.length-1];if(lastChild[isSourceNode]){lastChild.replaceRight(aPattern,aReplacement);}else if(typeof lastChild==='string'){this.children[this.children.length-1]=lastChild.replace(aPattern,aReplacement);}else{this.children.push(''.replace(aPattern,aReplacement));}return this;};/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */SourceNode.prototype.setSourceContent=function SourceNode_setSourceContent(aSourceFile,aSourceContent){this.sourceContents[util.toSetString(aSourceFile)]=aSourceContent;};/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */SourceNode.prototype.walkSourceContents=function SourceNode_walkSourceContents(aFn){for(var i=0,len=this.children.length;i<len;i++){if(this.children[i][isSourceNode]){this.children[i].walkSourceContents(aFn);}}var sources=Object.keys(this.sourceContents);for(var i=0,len=sources.length;i<len;i++){aFn(util.fromSetString(sources[i]),this.sourceContents[sources[i]]);}};/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */SourceNode.prototype.toString=function SourceNode_toString(){var str="";this.walk(function(chunk){str+=chunk;});return str;};/**
 * Returns the string representation of this source node along with a source
 * map.
 */SourceNode.prototype.toStringWithSourceMap=function SourceNode_toStringWithSourceMap(aArgs){var generated={code:"",line:1,column:0};var map=new SourceMapGenerator(aArgs);var sourceMappingActive=false;var lastOriginalSource=null;var lastOriginalLine=null;var lastOriginalColumn=null;var lastOriginalName=null;this.walk(function(chunk,original){generated.code+=chunk;if(original.source!==null&&original.line!==null&&original.column!==null){if(lastOriginalSource!==original.source||lastOriginalLine!==original.line||lastOriginalColumn!==original.column||lastOriginalName!==original.name){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name});}lastOriginalSource=original.source;lastOriginalLine=original.line;lastOriginalColumn=original.column;lastOriginalName=original.name;sourceMappingActive=true;}else if(sourceMappingActive){map.addMapping({generated:{line:generated.line,column:generated.column}});lastOriginalSource=null;sourceMappingActive=false;}for(var idx=0,length=chunk.length;idx<length;idx++){if(chunk.charCodeAt(idx)===NEWLINE_CODE){generated.line++;generated.column=0;// Mappings end at eol
if(idx+1===length){lastOriginalSource=null;sourceMappingActive=false;}else if(sourceMappingActive){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name});}}else{generated.column++;}}});this.walkSourceContents(function(sourceFile,sourceContent){map.setSourceContent(sourceFile,sourceContent);});return{code:generated.code,map:map};};exports.SourceNode=SourceNode;},{"./source-map-generator":75,"./util":77}],77:[function(require,module,exports){/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ /**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */function getArg(aArgs,aName,aDefaultValue){if(aName in aArgs){return aArgs[aName];}else if(arguments.length===3){return aDefaultValue;}else{throw new Error('"'+aName+'" is a required argument.');}}exports.getArg=getArg;var urlRegexp=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;var dataUrlRegexp=/^data:.+\,.+$/;function urlParse(aUrl){var match=aUrl.match(urlRegexp);if(!match){return null;}return{scheme:match[1],auth:match[2],host:match[3],port:match[4],path:match[5]};}exports.urlParse=urlParse;function urlGenerate(aParsedUrl){var url='';if(aParsedUrl.scheme){url+=aParsedUrl.scheme+':';}url+='//';if(aParsedUrl.auth){url+=aParsedUrl.auth+'@';}if(aParsedUrl.host){url+=aParsedUrl.host;}if(aParsedUrl.port){url+=":"+aParsedUrl.port;}if(aParsedUrl.path){url+=aParsedUrl.path;}return url;}exports.urlGenerate=urlGenerate;/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */function normalize(aPath){var path=aPath;var url=urlParse(aPath);if(url){if(!url.path){return aPath;}path=url.path;}var isAbsolute=exports.isAbsolute(path);var parts=path.split(/\/+/);for(var part,up=0,i=parts.length-1;i>=0;i--){part=parts[i];if(part==='.'){parts.splice(i,1);}else if(part==='..'){up++;}else if(up>0){if(part===''){// The first part is blank if the path is absolute. Trying to go
// above the root is a no-op. Therefore we can remove all '..' parts
// directly after the root.
parts.splice(i+1,up);up=0;}else{parts.splice(i,2);up--;}}}path=parts.join('/');if(path===''){path=isAbsolute?'/':'.';}if(url){url.path=path;return urlGenerate(url);}return path;}exports.normalize=normalize;/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */function join(aRoot,aPath){if(aRoot===""){aRoot=".";}if(aPath===""){aPath=".";}var aPathUrl=urlParse(aPath);var aRootUrl=urlParse(aRoot);if(aRootUrl){aRoot=aRootUrl.path||'/';}// `join(foo, '//www.example.org')`
if(aPathUrl&&!aPathUrl.scheme){if(aRootUrl){aPathUrl.scheme=aRootUrl.scheme;}return urlGenerate(aPathUrl);}if(aPathUrl||aPath.match(dataUrlRegexp)){return aPath;}// `join('http://', 'www.example.com')`
if(aRootUrl&&!aRootUrl.host&&!aRootUrl.path){aRootUrl.host=aPath;return urlGenerate(aRootUrl);}var joined=aPath.charAt(0)==='/'?aPath:normalize(aRoot.replace(/\/+$/,'')+'/'+aPath);if(aRootUrl){aRootUrl.path=joined;return urlGenerate(aRootUrl);}return joined;}exports.join=join;exports.isAbsolute=function(aPath){return aPath.charAt(0)==='/'||urlRegexp.test(aPath);};/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */function relative(aRoot,aPath){if(aRoot===""){aRoot=".";}aRoot=aRoot.replace(/\/$/,'');// It is possible for the path to be above the root. In this case, simply
// checking whether the root is a prefix of the path won't work. Instead, we
// need to remove components from the root one by one, until either we find
// a prefix that fits, or we run out of components to remove.
var level=0;while(aPath.indexOf(aRoot+'/')!==0){var index=aRoot.lastIndexOf("/");if(index<0){return aPath;}// If the only part of the root that is left is the scheme (i.e. http://,
// file:///, etc.), one or more slashes (/), or simply nothing at all, we
// have exhausted all components, so the path is not relative to the root.
aRoot=aRoot.slice(0,index);if(aRoot.match(/^([^\/]+:\/)?\/*$/)){return aPath;}++level;}// Make sure we add a "../" for each component we removed from the root.
return Array(level+1).join("../")+aPath.substr(aRoot.length+1);}exports.relative=relative;var supportsNullProto=function(){var obj=Object.create(null);return!('__proto__'in obj);}();function identity(s){return s;}/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */function toSetString(aStr){if(isProtoString(aStr)){return'$'+aStr;}return aStr;}exports.toSetString=supportsNullProto?identity:toSetString;function fromSetString(aStr){if(isProtoString(aStr)){return aStr.slice(1);}return aStr;}exports.fromSetString=supportsNullProto?identity:fromSetString;function isProtoString(s){if(!s){return false;}var length=s.length;if(length<9/* "__proto__".length */){return false;}if(s.charCodeAt(length-1)!==95/* '_' */||s.charCodeAt(length-2)!==95/* '_' */||s.charCodeAt(length-3)!==111/* 'o' */||s.charCodeAt(length-4)!==116/* 't' */||s.charCodeAt(length-5)!==111/* 'o' */||s.charCodeAt(length-6)!==114/* 'r' */||s.charCodeAt(length-7)!==112/* 'p' */||s.charCodeAt(length-8)!==95/* '_' */||s.charCodeAt(length-9)!==95/* '_' */){return false;}for(var i=length-10;i>=0;i--){if(s.charCodeAt(i)!==36/* '$' */){return false;}}return true;}/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */function compareByOriginalPositions(mappingA,mappingB,onlyCompareOriginal){var cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0||onlyCompareOriginal){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0){return cmp;}cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByOriginalPositions=compareByOriginalPositions;/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */function compareByGeneratedPositionsDeflated(mappingA,mappingB,onlyCompareGenerated){var cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0||onlyCompareGenerated){return cmp;}cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByGeneratedPositionsDeflated=compareByGeneratedPositionsDeflated;function strcmp(aStr1,aStr2){if(aStr1===aStr2){return 0;}if(aStr1===null){return 1;// aStr2 !== null
}if(aStr2===null){return-1;// aStr1 !== null
}if(aStr1>aStr2){return 1;}return-1;}/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */function compareByGeneratedPositionsInflated(mappingA,mappingB){var cmp=mappingA.generatedLine-mappingB.generatedLine;if(cmp!==0){return cmp;}cmp=mappingA.generatedColumn-mappingB.generatedColumn;if(cmp!==0){return cmp;}cmp=strcmp(mappingA.source,mappingB.source);if(cmp!==0){return cmp;}cmp=mappingA.originalLine-mappingB.originalLine;if(cmp!==0){return cmp;}cmp=mappingA.originalColumn-mappingB.originalColumn;if(cmp!==0){return cmp;}return strcmp(mappingA.name,mappingB.name);}exports.compareByGeneratedPositionsInflated=compareByGeneratedPositionsInflated;/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */function parseSourceMapInput(str){return JSON.parse(str.replace(/^\)]}'[^\n]*\n/,''));}exports.parseSourceMapInput=parseSourceMapInput;/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */function computeSourceURL(sourceRoot,sourceURL,sourceMapURL){sourceURL=sourceURL||'';if(sourceRoot){// This follows what Chrome does.
if(sourceRoot[sourceRoot.length-1]!=='/'&&sourceURL[0]!=='/'){sourceRoot+='/';}// The spec says:
//   Line 4: An optional source root, useful for relocating source
//   files on a server or removing repeated values in the
//   “sources” entry.  This value is prepended to the individual
//   entries in the “source” field.
sourceURL=sourceRoot+sourceURL;}// Historically, SourceMapConsumer did not take the sourceMapURL as
// a parameter.  This mode is still somewhat supported, which is why
// this code block is conditional.  However, it's preferable to pass
// the source map URL to SourceMapConsumer, so that this function
// can implement the source URL resolution algorithm as outlined in
// the spec.  This block is basically the equivalent of:
//    new URL(sourceURL, sourceMapURL).toString()
// ... except it avoids using URL, which wasn't available in the
// older releases of node still supported by this library.
//
// The spec says:
//   If the sources are not absolute URLs after prepending of the
//   “sourceRoot”, the sources are resolved relative to the
//   SourceMap (like resolving script src in a html document).
if(sourceMapURL){var parsed=urlParse(sourceMapURL);if(!parsed){throw new Error("sourceMapURL could not be parsed");}if(parsed.path){// Strip the last path component, but keep the "/".
var index=parsed.path.lastIndexOf('/');if(index>=0){parsed.path=parsed.path.substring(0,index+1);}}sourceURL=join(urlGenerate(parsed),sourceURL);}return normalize(sourceURL);}exports.computeSourceURL=computeSourceURL;},{}],78:[function(require,module,exports){/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */exports.SourceMapGenerator=require('./lib/source-map-generator').SourceMapGenerator;exports.SourceMapConsumer=require('./lib/source-map-consumer').SourceMapConsumer;exports.SourceNode=require('./lib/source-node').SourceNode;},{"./lib/source-map-consumer":74,"./lib/source-map-generator":75,"./lib/source-node":76}],79:[function(require,module,exports){'use strict';var integerRegex=/^\d+$/;function deepUnique(array){return array.sort().filter(function(element,index){return JSON.stringify(element)!==JSON.stringify(array[index-1]);});}exports.parse=function(string){return deepUnique(string.split(',').map(function(part){var result={};part.trim().split(/\s+/).forEach(function(element,index){if(index===0){result.url=element;return;}var value=element.slice(0,element.length-1);var postfix=element[element.length-1];var integerValue=parseInt(value,10);var floatValue=parseFloat(value);if(postfix==='w'&&integerRegex.test(value)){result.width=integerValue;}else if(postfix==='h'&&integerRegex.test(value)){result.height=integerValue;}else if(postfix==='x'&&!Number.isNaN(floatValue)){result.density=floatValue;}else{throw new Error("Invalid srcset descriptor: ".concat(element));}});return result;}));};exports.stringify=function(array){return _toConsumableArray(new Set(array.map(function(element){if(!element.url){throw new Error('URL is required');}var result=[element.url];if(element.width){result.push("".concat(element.width,"w"));}if(element.height){result.push("".concat(element.height,"h"));}if(element.density){result.push("".concat(element.density,"x"));}return result.join(' ');}))).join(', ');};},{}],80:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';var punycode=require('punycode');var util=require('./util');exports.parse=urlParse;exports.resolve=urlResolve;exports.resolveObject=urlResolveObject;exports.format=urlFormat;exports.Url=Url;function Url(){this.protocol=null;this.slashes=null;this.auth=null;this.host=null;this.port=null;this.hostname=null;this.hash=null;this.search=null;this.query=null;this.pathname=null;this.path=null;this.href=null;}// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,// Special case for a simple path URL
simplePathPattern=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims=['<','>','"','`',' ','\r','\n','\t'],// RFC 2396: characters not allowed for various reasons.
unwise=['{','}','|','\\','^','`'].concat(delims),// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape=['\''].concat(unwise),// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars=['%','/','?',';','#'].concat(autoEscape),hostEndingChars=['/','?','#'],hostnameMaxLen=255,hostnamePartPattern=/^[+a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol={'javascript':true,'javascript:':true},// protocols that never have a hostname.
hostlessProtocol={'javascript':true,'javascript:':true},// protocols that always contain a // bit.
slashedProtocol={'http':true,'https':true,'ftp':true,'gopher':true,'file':true,'http:':true,'https:':true,'ftp:':true,'gopher:':true,'file:':true},querystring=require('querystring');function urlParse(url,parseQueryString,slashesDenoteHost){if(url&&util.isObject(url)&&url instanceof Url)return url;var u=new Url();u.parse(url,parseQueryString,slashesDenoteHost);return u;}Url.prototype.parse=function(url,parseQueryString,slashesDenoteHost){if(!util.isString(url)){throw new TypeError("Parameter 'url' must be a string, not "+_typeof(url));}// Copy chrome, IE, opera backslash-handling behavior.
// Back slashes before the query string get converted to forward slashes
// See: https://code.google.com/p/chromium/issues/detail?id=25916
var queryIndex=url.indexOf('?'),splitter=queryIndex!==-1&&queryIndex<url.indexOf('#')?'?':'#',uSplit=url.split(splitter),slashRegex=/\\/g;uSplit[0]=uSplit[0].replace(slashRegex,'/');url=uSplit.join(splitter);var rest=url;// trim before proceeding.
// This is to support parse stuff like "  http://foo.com  \n"
rest=rest.trim();if(!slashesDenoteHost&&url.split('#').length===1){// Try fast path regexp
var simplePath=simplePathPattern.exec(rest);if(simplePath){this.path=rest;this.href=rest;this.pathname=simplePath[1];if(simplePath[2]){this.search=simplePath[2];if(parseQueryString){this.query=querystring.parse(this.search.substr(1));}else{this.query=this.search.substr(1);}}else if(parseQueryString){this.search='';this.query={};}return this;}}var proto=protocolPattern.exec(rest);if(proto){proto=proto[0];var lowerProto=proto.toLowerCase();this.protocol=lowerProto;rest=rest.substr(proto.length);}// figure out if it's got a host
// user@server is *always* interpreted as a hostname, and url
// resolution will treat //foo/bar as host=foo,path=bar because that's
// how the browser resolves relative URLs.
if(slashesDenoteHost||proto||rest.match(/^\/\/[^@\/]+@[^@\/]+/)){var slashes=rest.substr(0,2)==='//';if(slashes&&!(proto&&hostlessProtocol[proto])){rest=rest.substr(2);this.slashes=true;}}if(!hostlessProtocol[proto]&&(slashes||proto&&!slashedProtocol[proto])){// there's a hostname.
// the first instance of /, ?, ;, or # ends the host.
//
// If there is an @ in the hostname, then non-host chars *are* allowed
// to the left of the last @ sign, unless some host-ending character
// comes *before* the @-sign.
// URLs are obnoxious.
//
// ex:
// http://a@b@c/ => user:a@b host:c
// http://a@b?@c => user:a host:c path:/?@c
// v0.12 TODO(isaacs): This is not quite how Chrome does things.
// Review our test case against browsers more comprehensively.
// find the first instance of any hostEndingChars
var hostEnd=-1;for(var i=0;i<hostEndingChars.length;i++){var hec=rest.indexOf(hostEndingChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd))hostEnd=hec;}// at this point, either we have an explicit point where the
// auth portion cannot go past, or the last @ char is the decider.
var auth,atSign;if(hostEnd===-1){// atSign can be anywhere.
atSign=rest.lastIndexOf('@');}else{// atSign must be in auth portion.
// http://a@b/c@d => host:b auth:a path:/c@d
atSign=rest.lastIndexOf('@',hostEnd);}// Now we have a portion which is definitely the auth.
// Pull that off.
if(atSign!==-1){auth=rest.slice(0,atSign);rest=rest.slice(atSign+1);this.auth=decodeURIComponent(auth);}// the host is the remaining to the left of the first non-host char
hostEnd=-1;for(var i=0;i<nonHostChars.length;i++){var hec=rest.indexOf(nonHostChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd))hostEnd=hec;}// if we still have not hit it, then the entire thing is a host.
if(hostEnd===-1)hostEnd=rest.length;this.host=rest.slice(0,hostEnd);rest=rest.slice(hostEnd);// pull out port.
this.parseHost();// we've indicated that there is a hostname,
// so even if it's empty, it has to be present.
this.hostname=this.hostname||'';// if hostname begins with [ and ends with ]
// assume that it's an IPv6 address.
var ipv6Hostname=this.hostname[0]==='['&&this.hostname[this.hostname.length-1]===']';// validate a little.
if(!ipv6Hostname){var hostparts=this.hostname.split(/\./);for(var i=0,l=hostparts.length;i<l;i++){var part=hostparts[i];if(!part)continue;if(!part.match(hostnamePartPattern)){var newpart='';for(var j=0,k=part.length;j<k;j++){if(part.charCodeAt(j)>127){// we replace non-ASCII char with a temporary placeholder
// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
newpart+='x';}else{newpart+=part[j];}}// we test again with ASCII char only
if(!newpart.match(hostnamePartPattern)){var validParts=hostparts.slice(0,i);var notHost=hostparts.slice(i+1);var bit=part.match(hostnamePartStart);if(bit){validParts.push(bit[1]);notHost.unshift(bit[2]);}if(notHost.length){rest='/'+notHost.join('.')+rest;}this.hostname=validParts.join('.');break;}}}}if(this.hostname.length>hostnameMaxLen){this.hostname='';}else{// hostnames are always lower case.
this.hostname=this.hostname.toLowerCase();}if(!ipv6Hostname){// IDNA Support: Returns a punycoded representation of "domain".
// It only converts parts of the domain name that
// have non-ASCII characters, i.e. it doesn't matter if
// you call it with a domain that already is ASCII-only.
this.hostname=punycode.toASCII(this.hostname);}var p=this.port?':'+this.port:'';var h=this.hostname||'';this.host=h+p;this.href+=this.host;// strip [ and ] from the hostname
// the host field still retains them, though
if(ipv6Hostname){this.hostname=this.hostname.substr(1,this.hostname.length-2);if(rest[0]!=='/'){rest='/'+rest;}}}// now rest is set to the post-host stuff.
// chop off any delim chars.
if(!unsafeProtocol[lowerProto]){// First, make 100% sure that any "autoEscape" chars get
// escaped, even if encodeURIComponent doesn't think they
// need to be.
for(var i=0,l=autoEscape.length;i<l;i++){var ae=autoEscape[i];if(rest.indexOf(ae)===-1)continue;var esc=encodeURIComponent(ae);if(esc===ae){esc=escape(ae);}rest=rest.split(ae).join(esc);}}// chop off from the tail first.
var hash=rest.indexOf('#');if(hash!==-1){// got a fragment string.
this.hash=rest.substr(hash);rest=rest.slice(0,hash);}var qm=rest.indexOf('?');if(qm!==-1){this.search=rest.substr(qm);this.query=rest.substr(qm+1);if(parseQueryString){this.query=querystring.parse(this.query);}rest=rest.slice(0,qm);}else if(parseQueryString){// no query string, but parseQueryString still requested
this.search='';this.query={};}if(rest)this.pathname=rest;if(slashedProtocol[lowerProto]&&this.hostname&&!this.pathname){this.pathname='/';}//to support http.request
if(this.pathname||this.search){var p=this.pathname||'';var s=this.search||'';this.path=p+s;}// finally, reconstruct the href based on what has been validated.
this.href=this.format();return this;};// format a parsed object into a url string
function urlFormat(obj){// ensure it's an object, and not a string url.
// If it's an obj, this is a no-op.
// this way, you can call url_format() on strings
// to clean up potentially wonky urls.
if(util.isString(obj))obj=urlParse(obj);if(!(obj instanceof Url))return Url.prototype.format.call(obj);return obj.format();}Url.prototype.format=function(){var auth=this.auth||'';if(auth){auth=encodeURIComponent(auth);auth=auth.replace(/%3A/i,':');auth+='@';}var protocol=this.protocol||'',pathname=this.pathname||'',hash=this.hash||'',host=false,query='';if(this.host){host=auth+this.host;}else if(this.hostname){host=auth+(this.hostname.indexOf(':')===-1?this.hostname:'['+this.hostname+']');if(this.port){host+=':'+this.port;}}if(this.query&&util.isObject(this.query)&&Object.keys(this.query).length){query=querystring.stringify(this.query);}var search=this.search||query&&'?'+query||'';if(protocol&&protocol.substr(-1)!==':')protocol+=':';// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
// unless they had them to begin with.
if(this.slashes||(!protocol||slashedProtocol[protocol])&&host!==false){host='//'+(host||'');if(pathname&&pathname.charAt(0)!=='/')pathname='/'+pathname;}else if(!host){host='';}if(hash&&hash.charAt(0)!=='#')hash='#'+hash;if(search&&search.charAt(0)!=='?')search='?'+search;pathname=pathname.replace(/[?#]/g,function(match){return encodeURIComponent(match);});search=search.replace('#','%23');return protocol+host+pathname+search+hash;};function urlResolve(source,relative){return urlParse(source,false,true).resolve(relative);}Url.prototype.resolve=function(relative){return this.resolveObject(urlParse(relative,false,true)).format();};function urlResolveObject(source,relative){if(!source)return relative;return urlParse(source,false,true).resolveObject(relative);}Url.prototype.resolveObject=function(relative){if(util.isString(relative)){var rel=new Url();rel.parse(relative,false,true);relative=rel;}var result=new Url();var tkeys=Object.keys(this);for(var tk=0;tk<tkeys.length;tk++){var tkey=tkeys[tk];result[tkey]=this[tkey];}// hash is always overridden, no matter what.
// even href="" will remove it.
result.hash=relative.hash;// if the relative url is empty, then there's nothing left to do here.
if(relative.href===''){result.href=result.format();return result;}// hrefs like //foo/bar always cut to the protocol.
if(relative.slashes&&!relative.protocol){// take everything except the protocol from relative
var rkeys=Object.keys(relative);for(var rk=0;rk<rkeys.length;rk++){var rkey=rkeys[rk];if(rkey!=='protocol')result[rkey]=relative[rkey];}//urlParse appends trailing / to urls like http://www.example.com
if(slashedProtocol[result.protocol]&&result.hostname&&!result.pathname){result.path=result.pathname='/';}result.href=result.format();return result;}if(relative.protocol&&relative.protocol!==result.protocol){// if it's a known url protocol, then changing
// the protocol does weird things
// first, if it's not file:, then we MUST have a host,
// and if there was a path
// to begin with, then we MUST have a path.
// if it is file:, then the host is dropped,
// because that's known to be hostless.
// anything else is assumed to be absolute.
if(!slashedProtocol[relative.protocol]){var keys=Object.keys(relative);for(var v=0;v<keys.length;v++){var k=keys[v];result[k]=relative[k];}result.href=result.format();return result;}result.protocol=relative.protocol;if(!relative.host&&!hostlessProtocol[relative.protocol]){var relPath=(relative.pathname||'').split('/');while(relPath.length&&!(relative.host=relPath.shift())){;}if(!relative.host)relative.host='';if(!relative.hostname)relative.hostname='';if(relPath[0]!=='')relPath.unshift('');if(relPath.length<2)relPath.unshift('');result.pathname=relPath.join('/');}else{result.pathname=relative.pathname;}result.search=relative.search;result.query=relative.query;result.host=relative.host||'';result.auth=relative.auth;result.hostname=relative.hostname||relative.host;result.port=relative.port;// to support http.request
if(result.pathname||result.search){var p=result.pathname||'';var s=result.search||'';result.path=p+s;}result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;}var isSourceAbs=result.pathname&&result.pathname.charAt(0)==='/',isRelAbs=relative.host||relative.pathname&&relative.pathname.charAt(0)==='/',mustEndAbs=isRelAbs||isSourceAbs||result.host&&relative.pathname,removeAllDots=mustEndAbs,srcPath=result.pathname&&result.pathname.split('/')||[],relPath=relative.pathname&&relative.pathname.split('/')||[],psychotic=result.protocol&&!slashedProtocol[result.protocol];// if the url is a non-slashed url, then relative
// links like ../.. should be able
// to crawl up to the hostname, as well.  This is strange.
// result.protocol has already been set by now.
// Later on, put the first path part into the host field.
if(psychotic){result.hostname='';result.port=null;if(result.host){if(srcPath[0]==='')srcPath[0]=result.host;else srcPath.unshift(result.host);}result.host='';if(relative.protocol){relative.hostname=null;relative.port=null;if(relative.host){if(relPath[0]==='')relPath[0]=relative.host;else relPath.unshift(relative.host);}relative.host=null;}mustEndAbs=mustEndAbs&&(relPath[0]===''||srcPath[0]==='');}if(isRelAbs){// it's absolute.
result.host=relative.host||relative.host===''?relative.host:result.host;result.hostname=relative.hostname||relative.hostname===''?relative.hostname:result.hostname;result.search=relative.search;result.query=relative.query;srcPath=relPath;// fall through to the dot-handling below.
}else if(relPath.length){// it's relative
// throw away the existing file, and take the new path instead.
if(!srcPath)srcPath=[];srcPath.pop();srcPath=srcPath.concat(relPath);result.search=relative.search;result.query=relative.query;}else if(!util.isNullOrUndefined(relative.search)){// just pull out the search.
// like href='?foo'.
// Put this after the other two cases because it simplifies the booleans
if(psychotic){result.hostname=result.host=srcPath.shift();//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
var authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.host=result.hostname=authInHost.shift();}}result.search=relative.search;result.query=relative.query;//to support http.request
if(!util.isNull(result.pathname)||!util.isNull(result.search)){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.href=result.format();return result;}if(!srcPath.length){// no path at all.  easy.
// we've already handled the other stuff above.
result.pathname=null;//to support http.request
if(result.search){result.path='/'+result.search;}else{result.path=null;}result.href=result.format();return result;}// if a url ENDs in . or .., then it must get a trailing slash.
// however, if it ends in anything else non-slashy,
// then it must NOT get a trailing slash.
var last=srcPath.slice(-1)[0];var hasTrailingSlash=(result.host||relative.host||srcPath.length>1)&&(last==='.'||last==='..')||last==='';// strip single dots, resolve double dots to parent dir
// if the path tries to go above the root, `up` ends up > 0
var up=0;for(var i=srcPath.length;i>=0;i--){last=srcPath[i];if(last==='.'){srcPath.splice(i,1);}else if(last==='..'){srcPath.splice(i,1);up++;}else if(up){srcPath.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s
if(!mustEndAbs&&!removeAllDots){for(;up--;up){srcPath.unshift('..');}}if(mustEndAbs&&srcPath[0]!==''&&(!srcPath[0]||srcPath[0].charAt(0)!=='/')){srcPath.unshift('');}if(hasTrailingSlash&&srcPath.join('/').substr(-1)!=='/'){srcPath.push('');}var isAbsolute=srcPath[0]===''||srcPath[0]&&srcPath[0].charAt(0)==='/';// put the host back
if(psychotic){result.hostname=result.host=isAbsolute?'':srcPath.length?srcPath.shift():'';//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
var authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.host=result.hostname=authInHost.shift();}}mustEndAbs=mustEndAbs||result.host&&srcPath.length;if(mustEndAbs&&!isAbsolute){srcPath.unshift('');}if(!srcPath.length){result.pathname=null;result.path=null;}else{result.pathname=srcPath.join('/');}//to support request.http
if(!util.isNull(result.pathname)||!util.isNull(result.search)){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.auth=relative.auth||result.auth;result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;};Url.prototype.parseHost=function(){var host=this.host;var port=portPattern.exec(host);if(port){port=port[0];if(port!==':'){this.port=port.substr(1);}host=host.substr(0,host.length-port.length);}if(host)this.hostname=host;};},{"./util":81,"punycode":64,"querystring":67}],81:[function(require,module,exports){'use strict';module.exports={isString:function isString(arg){return typeof arg==='string';},isObject:function isObject(arg){return _typeof(arg)==='object'&&arg!==null;},isNull:function isNull(arg){return arg===null;},isNullOrUndefined:function isNullOrUndefined(arg){return arg==null;}};},{}],82:[function(require,module,exports){module.exports=extend;var hasOwnProperty=Object.prototype.hasOwnProperty;function extend(){var target={};for(var i=0;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;}},{}],83:[function(require,module,exports){/* eslint-disable no-useless-escape */var htmlparser=require('htmlparser2');var extend=require('xtend');var quoteRegexp=require('lodash.escaperegexp');var cloneDeep=require('lodash.clonedeep');var mergeWith=require('lodash.mergewith');var isString=require('lodash.isstring');var isPlainObject=require('lodash.isplainobject');var srcset=require('srcset');var postcss=require('postcss');var url=require('url');function each(obj,cb){if(obj){Object.keys(obj).forEach(function(key){cb(obj[key],key);});}}// Avoid false positives with .__proto__, .hasOwnProperty, etc.
function has(obj,key){return{}.hasOwnProperty.call(obj,key);}// Returns those elements of `a` for which `cb(a)` returns truthy
function filter(a,cb){var n=[];each(a,function(v){if(cb(v)){n.push(v);}});return n;}function isEmptyObject(obj){for(var key in obj){if(has(obj,key)){return false;}}return true;}module.exports=sanitizeHtml;// A valid attribute name.
// We use a tolerant definition based on the set of strings defined by
// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state
// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .
// The characters accepted are ones which can be appended to the attribute
// name buffer without triggering a parse error:
//   * unexpected-equals-sign-before-attribute-name
//   * unexpected-null-character
//   * unexpected-character-in-attribute-name
// We exclude the empty string because it's impossible to get to the after
// attribute name state with an empty attribute name buffer.
var VALID_HTML_ATTRIBUTE_NAME=/^[^\0\t\n\f\r /<=>]+$/;// Ignore the _recursing flag; it's there for recursive
// invocation as a guard against this exploit:
// https://github.com/fb55/htmlparser2/issues/105
function sanitizeHtml(html,options,_recursing){var result='';// Used for hot swapping the result variable with an empty string in order to "capture" the text written to it.
var tempResult='';function Frame(tag,attribs){var that=this;this.tag=tag;this.attribs=attribs||{};this.tagPosition=result.length;this.text='';// Node inner text
this.updateParentNodeText=function(){if(stack.length){var parentFrame=stack[stack.length-1];parentFrame.text+=that.text;}};}if(!options){options=sanitizeHtml.defaults;options.parser=htmlParserDefaults;}else{options=extend(sanitizeHtml.defaults,options);if(options.parser){options.parser=extend(htmlParserDefaults,options.parser);}else{options.parser=htmlParserDefaults;}}// Tags that contain something other than HTML, or where discarding
// the text when the tag is disallowed makes sense for other reasons.
// If we are not allowing these tags, we should drop their content too.
// For other tags you would drop the tag but keep its content.
var nonTextTagsArray=options.nonTextTags||['script','style','textarea'];var allowedAttributesMap;var allowedAttributesGlobMap;if(options.allowedAttributes){allowedAttributesMap={};allowedAttributesGlobMap={};each(options.allowedAttributes,function(attributes,tag){allowedAttributesMap[tag]=[];var globRegex=[];attributes.forEach(function(obj){if(isString(obj)&&obj.indexOf('*')>=0){globRegex.push(quoteRegexp(obj).replace(/\\\*/g,'.*'));}else{allowedAttributesMap[tag].push(obj);}});allowedAttributesGlobMap[tag]=new RegExp('^('+globRegex.join('|')+')$');});}var allowedClassesMap={};each(options.allowedClasses,function(classes,tag){// Implicitly allows the class attribute
if(allowedAttributesMap){if(!has(allowedAttributesMap,tag)){allowedAttributesMap[tag]=[];}allowedAttributesMap[tag].push('class');}allowedClassesMap[tag]=classes;});var transformTagsMap={};var transformTagsAll;each(options.transformTags,function(transform,tag){var transFun;if(typeof transform==='function'){transFun=transform;}else if(typeof transform==="string"){transFun=sanitizeHtml.simpleTransform(transform);}if(tag==='*'){transformTagsAll=transFun;}else{transformTagsMap[tag]=transFun;}});var depth=0;var stack=[];var skipMap={};var transformMap={};var skipText=false;var skipTextDepth=0;var parser=new htmlparser.Parser({onopentag:function onopentag(name,attribs){if(skipText){skipTextDepth++;return;}var frame=new Frame(name,attribs);stack.push(frame);var skip=false;var hasText=!!frame.text;var transformedTag;if(has(transformTagsMap,name)){transformedTag=transformTagsMap[name](name,attribs);frame.attribs=attribs=transformedTag.attribs;if(transformedTag.text!==undefined){frame.innerText=transformedTag.text;}if(name!==transformedTag.tagName){frame.name=name=transformedTag.tagName;transformMap[depth]=transformedTag.tagName;}}if(transformTagsAll){transformedTag=transformTagsAll(name,attribs);frame.attribs=attribs=transformedTag.attribs;if(name!==transformedTag.tagName){frame.name=name=transformedTag.tagName;transformMap[depth]=transformedTag.tagName;}}if(options.allowedTags&&options.allowedTags.indexOf(name)===-1||options.disallowedTagsMode==='recursiveEscape'&&!isEmptyObject(skipMap)){skip=true;skipMap[depth]=true;if(options.disallowedTagsMode==='discard'){if(nonTextTagsArray.indexOf(name)!==-1){skipText=true;skipTextDepth=1;}}skipMap[depth]=true;}depth++;if(skip){if(options.disallowedTagsMode==='discard'){// We want the contents but not this tag
return;}tempResult=result;result='';}result+='<'+name;if(!allowedAttributesMap||has(allowedAttributesMap,name)||allowedAttributesMap['*']){each(attribs,function(value,a){if(!VALID_HTML_ATTRIBUTE_NAME.test(a)){// This prevents part of an attribute name in the output from being
// interpreted as the end of an attribute, or end of a tag.
delete frame.attribs[a];return;}var parsed;// check allowedAttributesMap for the element and attribute and modify the value
// as necessary if there are specific values defined.
var passedAllowedAttributesMapCheck=false;if(!allowedAttributesMap||has(allowedAttributesMap,name)&&allowedAttributesMap[name].indexOf(a)!==-1||allowedAttributesMap['*']&&allowedAttributesMap['*'].indexOf(a)!==-1||has(allowedAttributesGlobMap,name)&&allowedAttributesGlobMap[name].test(a)||allowedAttributesGlobMap['*']&&allowedAttributesGlobMap['*'].test(a)){passedAllowedAttributesMapCheck=true;}else if(allowedAttributesMap&&allowedAttributesMap[name]){var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator10=allowedAttributesMap[name][Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator10.next()).done);_iteratorNormalCompletion=true){var o=_step.value;if(isPlainObject(o)&&o.name&&o.name===a){passedAllowedAttributesMapCheck=true;var newValue='';if(o.multiple===true){// verify the values that are allowed
var splitStrArray=value.split(' ');var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator11=splitStrArray[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator11.next()).done);_iteratorNormalCompletion2=true){var s=_step2.value;if(o.values.indexOf(s)!==-1){if(newValue===''){newValue=s;}else{newValue+=' '+s;}}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator11["return"]!=null){_iterator11["return"]();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}}else if(o.values.indexOf(value)>=0){// verified an allowed value matches the entire attribute value
newValue=value;}value=newValue;}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator10["return"]!=null){_iterator10["return"]();}}finally{if(_didIteratorError){throw _iteratorError;}}}}if(passedAllowedAttributesMapCheck){if(options.allowedSchemesAppliedToAttributes.indexOf(a)!==-1){if(naughtyHref(name,value)){delete frame.attribs[a];return;}}if(name==='iframe'&&a==='src'){var allowed=true;try{// naughtyHref is in charge of whether protocol relative URLs
// are cool. We should just accept them
parsed=url.parse(value,false,true);var isRelativeUrl=parsed&&parsed.host===null&&parsed.protocol===null;if(isRelativeUrl){// default value of allowIframeRelativeUrls is true unless allowIframeHostnames specified
allowed=has(options,"allowIframeRelativeUrls")?options.allowIframeRelativeUrls:!options.allowedIframeHostnames;}else if(options.allowedIframeHostnames){allowed=options.allowedIframeHostnames.find(function(hostname){return hostname===parsed.hostname;});}}catch(e){// Unparseable iframe src
allowed=false;}if(!allowed){delete frame.attribs[a];return;}}if(a==='srcset'){try{parsed=srcset.parse(value);each(parsed,function(value){if(naughtyHref('srcset',value.url)){value.evil=true;}});parsed=filter(parsed,function(v){return!v.evil;});if(!parsed.length){delete frame.attribs[a];return;}else{value=srcset.stringify(filter(parsed,function(v){return!v.evil;}));frame.attribs[a]=value;}}catch(e){// Unparseable srcset
delete frame.attribs[a];return;}}if(a==='class'){value=filterClasses(value,allowedClassesMap[name]);if(!value.length){delete frame.attribs[a];return;}}if(a==='style'){try{var abstractSyntaxTree=postcss.parse(name+" {"+value+"}");var filteredAST=filterCss(abstractSyntaxTree,options.allowedStyles);value=stringifyStyleAttributes(filteredAST);if(value.length===0){delete frame.attribs[a];return;}}catch(e){delete frame.attribs[a];return;}}result+=' '+a;if(value&&value.length){result+='="'+escapeHtml(value,true)+'"';}}else{delete frame.attribs[a];}});}if(options.selfClosing.indexOf(name)!==-1){result+=" />";}else{result+=">";if(frame.innerText&&!hasText&&!options.textFilter){result+=frame.innerText;}}if(skip){result=tempResult+escapeHtml(result);tempResult='';}},ontext:function ontext(text){if(skipText){return;}var lastFrame=stack[stack.length-1];var tag;if(lastFrame){tag=lastFrame.tag;// If inner text was set by transform function then let's use it
text=lastFrame.innerText!==undefined?lastFrame.innerText:text;}if(options.disallowedTagsMode==='discard'&&(tag==='script'||tag==='style')){// htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing
// script tags is, by definition, game over for XSS protection, so if that's
// your concern, don't allow them. The same is essentially true for style tags
// which have their own collection of XSS vectors.
result+=text;}else{var escaped=escapeHtml(text,false);if(options.textFilter){result+=options.textFilter(escaped,tag);}else{result+=escaped;}}if(stack.length){var frame=stack[stack.length-1];frame.text+=text;}},onclosetag:function onclosetag(name){if(skipText){skipTextDepth--;if(!skipTextDepth){skipText=false;}else{return;}}var frame=stack.pop();if(!frame){// Do not crash on bad markup
return;}skipText=false;depth--;var skip=skipMap[depth];if(skip){delete skipMap[depth];if(options.disallowedTagsMode==='discard'){frame.updateParentNodeText();return;}tempResult=result;result='';}if(transformMap[depth]){name=transformMap[depth];delete transformMap[depth];}if(options.exclusiveFilter&&options.exclusiveFilter(frame)){result=result.substr(0,frame.tagPosition);return;}frame.updateParentNodeText();if(options.selfClosing.indexOf(name)!==-1){// Already output />
return;}result+="</"+name+">";if(skip){result=tempResult+escapeHtml(result);tempResult='';}}},options.parser);parser.write(html);parser.end();return result;function escapeHtml(s,quote){if(typeof s!=='string'){s=s+'';}if(options.parser.decodeEntities){s=s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/\>/g,'&gt;');if(quote){s=s.replace(/\"/g,'&quot;');}}// TODO: this is inadequate because it will pass `&0;`. This approach
// will not work, each & must be considered with regard to whether it
// is followed by a 100% syntactically valid entity or not, and escaped
// if it is not. If this bothers you, don't set parser.decodeEntities
// to false. (The default is true.)
s=s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g,'&amp;')// Match ampersands not part of existing HTML entity
.replace(/</g,'&lt;').replace(/\>/g,'&gt;');if(quote){s=s.replace(/\"/g,'&quot;');}return s;}function naughtyHref(name,href){// Browsers ignore character codes of 32 (space) and below in a surprising
// number of situations. Start reading here:
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab
// eslint-disable-next-line no-control-regex
href=href.replace(/[\x00-\x20]+/g,'');// Clobber any comments in URLs, which the browser might
// interpret inside an XML data island, allowing
// a javascript: URL to be snuck through
href=href.replace(/<\!\-\-.*?\-\-\>/g,'');// Case insensitive so we don't get faked out by JAVASCRIPT #1
var matches=href.match(/^([a-zA-Z]+)\:/);if(!matches){// Protocol-relative URL starting with any combination of '/' and '\'
if(href.match(/^[\/\\]{2}/)){return!options.allowProtocolRelative;}// No scheme
return false;}var scheme=matches[1].toLowerCase();if(has(options.allowedSchemesByTag,name)){return options.allowedSchemesByTag[name].indexOf(scheme)===-1;}return!options.allowedSchemes||options.allowedSchemes.indexOf(scheme)===-1;}/**
   * Filters user input css properties by whitelisted regex attributes.
   *
   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.
   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.
   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).
   * @return {object}                    - Abstract Syntax Tree with filtered style attributes.
   */function filterCss(abstractSyntaxTree,allowedStyles){if(!allowedStyles){return abstractSyntaxTree;}var filteredAST=cloneDeep(abstractSyntaxTree);var astRules=abstractSyntaxTree.nodes[0];var selectedRule;// Merge global and tag-specific styles into new AST.
if(allowedStyles[astRules.selector]&&allowedStyles['*']){selectedRule=mergeWith(cloneDeep(allowedStyles[astRules.selector]),allowedStyles['*'],function(objValue,srcValue){if(Array.isArray(objValue)){return objValue.concat(srcValue);}});}else{selectedRule=allowedStyles[astRules.selector]||allowedStyles['*'];}if(selectedRule){filteredAST.nodes[0].nodes=astRules.nodes.reduce(filterDeclarations(selectedRule),[]);}return filteredAST;}/**
   * Extracts the style attribues from an AbstractSyntaxTree and formats those
   * values in the inline style attribute format.
   *
   * @param  {AbstractSyntaxTree} filteredAST
   * @return {string}             - Example: "color:yellow;text-align:center;font-family:helvetica;"
   */function stringifyStyleAttributes(filteredAST){return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes,attributeObject){extractedAttributes.push(attributeObject.prop+':'+attributeObject.value);return extractedAttributes;},[]).join(';');}/**
    * Filters the existing attributes for the given property. Discards any attributes
    * which don't match the whitelist.
    *
    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }
    * @param  {array} allowedDeclarationsList   - List of declarations which pass whitelisting.
    * @param  {object} attributeObject          - Object representing the current css property.
    * @property {string} attributeObject.type   - Typically 'declaration'.
    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.
    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.
    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects
    */function filterDeclarations(selectedRule){return function(allowedDeclarationsList,attributeObject){// If this property is whitelisted...
if(selectedRule.hasOwnProperty(attributeObject.prop)){var matchesRegex=selectedRule[attributeObject.prop].some(function(regularExpression){return regularExpression.test(attributeObject.value);});if(matchesRegex){allowedDeclarationsList.push(attributeObject);}}return allowedDeclarationsList;};}function filterClasses(classes,allowed){if(!allowed){// The class attribute is allowed without filtering on this tag
return classes;}classes=classes.split(/\s+/);return classes.filter(function(clss){return allowed.indexOf(clss)!==-1;}).join(' ');}}// Defaults are accessible to you so that you can use them as a starting point
// programmatically if you wish
var htmlParserDefaults={decodeEntities:true};sanitizeHtml.defaults={allowedTags:['h3','h4','h5','h6','blockquote','p','a','ul','ol','nl','li','b','i','strong','em','strike','code','hr','br','div','table','thead','caption','tbody','tr','th','td','pre','iframe'],disallowedTagsMode:'discard',allowedAttributes:{a:['href','name','target'],// We don't currently allow img itself by default, but this
// would make sense if we did. You could add srcset here,
// and if you do the URL is checked for safety
img:['src']},// Lots of these won't come up by default because we don't allow them
selfClosing:['img','br','hr','area','base','basefont','input','link','meta'],// URL schemes we permit
allowedSchemes:['http','https','ftp','mailto'],allowedSchemesByTag:{},allowedSchemesAppliedToAttributes:['href','src','cite'],allowProtocolRelative:true};sanitizeHtml.simpleTransform=function(newTagName,newAttribs,merge){merge=merge===undefined?true:merge;newAttribs=newAttribs||{};return function(tagName,attribs){var attrib;if(merge){for(attrib in newAttribs){attribs[attrib]=newAttribs[attrib];}}else{attribs=newAttribs;}return{tagName:newTagName,attribs:attribs};};};},{"htmlparser2":31,"lodash.clonedeep":33,"lodash.escaperegexp":34,"lodash.isplainobject":35,"lodash.isstring":36,"lodash.mergewith":37,"postcss":51,"srcset":79,"url":80,"xtend":82}]},{},[83])(83);});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./ui/js/blocks/src/blocks/components/BlockPreview.js":
/*!************************************************************!*\
  !*** ./ui/js/blocks/src/blocks/components/BlockPreview.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var sanitize_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sanitize-html */ "./node_modules/sanitize-html/dist/sanitize-html.js");
/* harmony import */ var sanitize_html__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sanitize_html__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _wordpress_autop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wordpress/autop */ "@wordpress/autop");
/* harmony import */ var _wordpress_autop__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_wordpress_autop__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _wordpress_date__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wordpress/date */ "@wordpress/date");
/* harmony import */ var _wordpress_date__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_wordpress_date__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _utils_renderTemplate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/renderTemplate */ "./ui/js/blocks/src/utils/renderTemplate.js");
/* harmony import */ var _config_html__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../config/html */ "./ui/js/blocks/src/config/html.js");


var _this = undefined,
    _jsxFileName = "/Users/zrothauser/Local Sites/fields/app/public/wp-content/plugins/pods/ui/js/blocks/src/blocks/components/BlockPreview.js";

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Renders an individual field to be used in a template.
 *
 * @param {Object} field Field data.
 * @param {Object} attributes All block attributes.
 */

var renderField = function renderField(field, attributes) {
  var name = field.name,
      fieldOptions = field.fieldOptions,
      type = field.type;
  var fieldValue = attributes[name];

  if ('undefined' === typeof fieldValue) {
    return null;
  }

  switch (type) {
    case 'TextControl':
      {
        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--textcontrol",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 48,
            columnNumber: 5
          }
        }, sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(fieldValue, _config_html__WEBPACK_IMPORTED_MODULE_6__["plainText"]));
      }

    case 'TextareaControl':
      {
        var shouldAutoP = fieldOptions.auto_p;
        var sanitizedText = sanitize_html__WEBPACK_IMPORTED_MODULE_0___default()(fieldValue, _config_html__WEBPACK_IMPORTED_MODULE_6__["plainText"]);
        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--textareacontrol",
          dangerouslySetInnerHTML: {
            __html: shouldAutoP ? Object(_wordpress_autop__WEBPACK_IMPORTED_MODULE_2__["autop"])(sanitizedText) : sanitizedText
          },
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 61,
            columnNumber: 5
          }
        });
      }

    case 'RichText':
      {
        return /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_3__["RichText"].Content, {
          key: name,
          tagName: "p",
          value: fieldValue,
          className: "field--richtext",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 72,
            columnNumber: 5
          }
        });
      }

    case 'CheckboxControl':
      {
        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--checkbox",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 82,
            columnNumber: 5
          }
        }, fieldValue ? Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_1__["__"])('Yes') : Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_1__["__"])('No'));
      }

    case 'CheckboxGroup':
      {
        var options = fieldOptions.options;
        var values = Array.isArray(fieldValue) ? fieldValue.filter(function (value) {
          return !!value.checked;
        }) : [];
        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--checkbox-group",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 97,
            columnNumber: 5
          }
        }, values.length ? values.map(function (value, index) {
          var matchingOption = options.find(function (option) {
            return value.value === option.value;
          });
          return /*#__PURE__*/React.createElement("span", {
            className: "field--checkbox-group__item",
            key: value.value,
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 103,
              columnNumber: 9
            }
          }, matchingOption.label, index < values.length - 1 ? ', ' : '');
        }) : 'N/A');
      }

    case 'RadioControl':
      {
        var _options = fieldOptions.options;

        var matchingOption = _options.find(function (option) {
          return fieldValue === option.value;
        });

        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--radio-control",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 122,
            columnNumber: 5
          }
        }, !!matchingOption ? matchingOption.label : 'N/A');
      }

    case 'SelectControl':
      {
        // Could be either a Select with "multiple" values or not.
        if (!Array.isArray(fieldValue)) {
          return /*#__PURE__*/React.createElement("div", {
            key: name,
            className: "field--select-control",
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 131,
              columnNumber: 6
            }
          }, fieldValue.label || 'N/A');
        } else {
          var _values = fieldValue;
          return /*#__PURE__*/React.createElement("div", {
            key: name,
            className: "field--select-control field--multiple-select-control",
            __self: _this,
            __source: {
              fileName: _jsxFileName,
              lineNumber: 139,
              columnNumber: 6
            }
          }, _values.length ? _values.map(function (value, index) {
            return /*#__PURE__*/React.createElement("span", {
              className: "field--select-group__item",
              key: value,
              __self: _this,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 143,
                columnNumber: 10
              }
            }, value.label, index < _values.length - 1 ? ', ' : '');
          }) : 'N/A');
        }
      }

    case 'DateTimePicker':
      {
        var dateFormat = Object(_wordpress_date__WEBPACK_IMPORTED_MODULE_4__["__experimentalGetSettings"])().formats.datetime;

        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--date-time",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 161,
            columnNumber: 5
          }
        }, /*#__PURE__*/React.createElement("time", {
          dateTime: Object(_wordpress_date__WEBPACK_IMPORTED_MODULE_4__["format"])('c', fieldValue),
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 162,
            columnNumber: 6
          }
        }, Object(_wordpress_date__WEBPACK_IMPORTED_MODULE_4__["dateI18n"])(dateFormat, fieldValue)));
      }

    case 'NumberControl':
      {
        var locale = Object(_wordpress_date__WEBPACK_IMPORTED_MODULE_4__["__experimentalGetSettings"])().l10n.locale;

        locale = locale.replace('_', '-');
        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--number",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 176,
            columnNumber: 5
          }
        }, !!fieldValue && fieldValue.toLocaleString(locale));
      }

    case 'MediaUpload':
      {
        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--media-upload",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 183,
            columnNumber: 5
          }
        }, fieldValue && fieldValue.url || 'N/A');
      }

    case 'ColorPicker':
      {
        return /*#__PURE__*/React.createElement("div", {
          key: name,
          className: "field--color",
          style: {
            color: fieldValue
          },
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 190,
            columnNumber: 5
          }
        }, fieldValue);
      }

    default:
      return null;
  }
};

var BlockPreview = function BlockPreview(_ref) {
  var template = _ref.template,
      _ref$fields = _ref.fields,
      fields = _ref$fields === void 0 ? [] : _ref$fields,
      _ref$attributes = _ref.attributes,
      attributes = _ref$attributes === void 0 ? {} : _ref$attributes;
  return /*#__PURE__*/React.createElement(React.Fragment, null, Object(_utils_renderTemplate__WEBPACK_IMPORTED_MODULE_5__["default"])(template, fields, attributes, renderField));
};

/* harmony default export */ __webpack_exports__["default"] = (BlockPreview);

/***/ }),

/***/ "./ui/js/blocks/src/blocks/components/FieldInspectorControls.js":
/*!**********************************************************************!*\
  !*** ./ui/js/blocks/src/blocks/components/FieldInspectorControls.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wordpress_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/components */ "@wordpress/components");
/* harmony import */ var _wordpress_components__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_components__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _RenderedField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RenderedField */ "./ui/js/blocks/src/blocks/components/RenderedField.js");


var _this = undefined,
    _jsxFileName = "/Users/zrothauser/Local Sites/fields/app/public/wp-content/plugins/pods/ui/js/blocks/src/blocks/components/FieldInspectorControls.js";

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Renders the fields that live in the Inspector on the sidebar.
 */

var FieldInspectorControls = function FieldInspectorControls(_ref) {
  var _ref$fields = _ref.fields,
      fields = _ref$fields === void 0 ? [] : _ref$fields,
      attributes = _ref.attributes,
      setAttributes = _ref.setAttributes;

  if (!fields.length) {
    return null;
  }

  return /*#__PURE__*/React.createElement(React.Fragment, null, fields.map(function (field) {
    var name = field.name,
        _field$fieldOptions = field.fieldOptions,
        label = _field$fieldOptions.label,
        heading = _field$fieldOptions.heading;
    return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_0__["PanelBody"], {
      title: heading || label,
      key: name,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 38,
        columnNumber: 6
      }
    }, /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_0__["PanelRow"], {
      className: "pods-inspector-row",
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 42,
        columnNumber: 7
      }
    }, /*#__PURE__*/React.createElement(_RenderedField__WEBPACK_IMPORTED_MODULE_1__["default"], {
      field: field,
      attributes: attributes,
      setAttributes: setAttributes,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 8
      }
    })));
  }));
};

/* harmony default export */ __webpack_exports__["default"] = (FieldInspectorControls);

/***/ }),

/***/ "./ui/js/blocks/src/blocks/components/RenderedField.js":
/*!*************************************************************!*\
  !*** ./ui/js/blocks/src/blocks/components/RenderedField.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-select */ "./node_modules/react-select/dist/react-select.browser.esm.js");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _wordpress_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wordpress/components */ "@wordpress/components");
/* harmony import */ var _wordpress_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wordpress/compose */ "@wordpress/compose");
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_wordpress_compose__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _components_CheckboxGroup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/CheckboxGroup */ "./ui/js/blocks/src/components/CheckboxGroup/index.js");
/* harmony import */ var _components_NumberControl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/NumberControl */ "./ui/js/blocks/src/components/NumberControl/index.js");


var _this = undefined,
    _jsxFileName = "/Users/zrothauser/Local Sites/fields/app/public/wp-content/plugins/pods/ui/js/blocks/src/blocks/components/RenderedField.js";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */





/**
 * Internal dependencies
 */



/**
 * Creates the handler for the 'onChange' prop for a field.
 *
 * @param {string} name Name of the field.
 * @param {Function} setAttributes The setAttributes function for a block.
 * @param {string} type The type of attribute ('string', 'array', 'number').
 *
 * @return {Function} Function update attributes to attach to an `onChange` prop.
 */

var createChangeHandler = function createChangeHandler(name, setAttributes, type) {
  return function (newValue) {
    setAttributes(_defineProperty({}, name, 'NumberControl' === type ? parseInt(newValue, 10) : newValue));
  };
};
/**
 * Renders an individual field to be used in a template.
 */


var RenderedField = function RenderedField(_ref) {
  var field = _ref.field,
      attributes = _ref.attributes,
      setAttributes = _ref.setAttributes;
  var name = field.name,
      type = field.type,
      _field$fieldOptions = field.fieldOptions,
      fieldOptions = _field$fieldOptions === void 0 ? {} : _field$fieldOptions;
  var fieldValue = attributes[name];
  var changeHandler = createChangeHandler(name, setAttributes, type);

  switch (type) {
    case 'TextControl':
      {
        var _fieldOptions$type = fieldOptions.type,
            _type = _fieldOptions$type === void 0 ? 'text' : _fieldOptions$type,
            help = fieldOptions.help,
            label = fieldOptions.label;

        return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["TextControl"], {
          key: name,
          label: label,
          value: fieldValue,
          type: _type,
          help: help,
          onChange: changeHandler,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 78,
            columnNumber: 5
          }
        });
      }

    case 'TextareaControl':
      {
        var _help = fieldOptions.help,
            _label = fieldOptions.label;
        return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["TextareaControl"], {
          key: name,
          label: _label,
          value: fieldValue,
          help: _help,
          rows: "4",
          onChange: changeHandler,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 95,
            columnNumber: 5
          }
        });
      }

    case 'RichText':
      {
        var _fieldOptions$tagName = fieldOptions.tagName,
            tagName = _fieldOptions$tagName === void 0 ? 'p' : _fieldOptions$tagName;
        return /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_2__["RichText"], {
          key: name,
          tagName: tagName,
          value: fieldValue,
          onChange: changeHandler,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 109,
            columnNumber: 5
          }
        });
      }

    case 'CheckboxControl':
      {
        var _label2 = fieldOptions.label,
            _help2 = fieldOptions.help;
        return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["CheckboxControl"], {
          key: name,
          label: _label2,
          help: _help2,
          checked: fieldValue,
          onChange: changeHandler,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 124,
            columnNumber: 5
          }
        });
      }

    case 'CheckboxGroup':
      {
        var _help3 = fieldOptions.help,
            options = fieldOptions.options;
        return /*#__PURE__*/React.createElement(_components_CheckboxGroup__WEBPACK_IMPORTED_MODULE_5__["default"], {
          key: name,
          help: _help3,
          options: options,
          values: fieldValue,
          onChange: changeHandler,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 140,
            columnNumber: 5
          }
        });
      }

    case 'RadioControl':
      {
        var _help4 = fieldOptions.help,
            _options = fieldOptions.options;
        return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["RadioControl"], {
          key: name,
          help: _help4,
          options: _options,
          selected: fieldValue,
          onChange: changeHandler,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 156,
            columnNumber: 5
          }
        });
      }

    case 'SelectControl':
      {
        var _options2 = fieldOptions.options,
            multiple = fieldOptions.multiple,
            _label3 = fieldOptions.label;
        var instanceId = Object(_wordpress_compose__WEBPACK_IMPORTED_MODULE_4__["useInstanceId"])(react_select__WEBPACK_IMPORTED_MODULE_0__["default"]);
        var id = "inspector-select-control-".concat(instanceId);
        return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["BaseControl"], {
          label: _label3,
          id: id,
          key: name,
          className: "full-width-base-control",
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 176,
            columnNumber: 5
          }
        }, /*#__PURE__*/React.createElement(react_select__WEBPACK_IMPORTED_MODULE_0__["default"], {
          id: id,
          name: name,
          options: _options2,
          value: fieldValue,
          isMulti: multiple,
          onChange: changeHandler,
          styles: {
            container: function container(provided) {
              return _objectSpread(_objectSpread({}, provided), {}, {
                width: '100%'
              });
            }
          },
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 182,
            columnNumber: 6
          }
        }));
      }

    case 'DateTimePicker':
      {
        var is12Hour = fieldOptions.is12Hour,
            _label4 = fieldOptions.label;
        return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["BaseControl"], {
          label: _label4,
          key: name,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 206,
            columnNumber: 5
          }
        }, /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["DateTimePicker"], {
          currentDate: fieldValue,
          onChange: changeHandler,
          is12Hour: is12Hour,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 210,
            columnNumber: 6
          }
        }));
      }

    case 'NumberControl':
      {
        var isShiftStepEnabled = fieldOptions.isShiftStepEnabled,
            shiftStep = fieldOptions.shiftStep,
            _label5 = fieldOptions.label,
            _fieldOptions$max = fieldOptions.max,
            max = _fieldOptions$max === void 0 ? Infinity : _fieldOptions$max,
            _fieldOptions$min = fieldOptions.min,
            min = _fieldOptions$min === void 0 ? -Infinity : _fieldOptions$min,
            _fieldOptions$step = fieldOptions.step,
            step = _fieldOptions$step === void 0 ? 1 : _fieldOptions$step;

        var _instanceId = Object(_wordpress_compose__WEBPACK_IMPORTED_MODULE_4__["useInstanceId"])(_components_NumberControl__WEBPACK_IMPORTED_MODULE_6__["default"]);

        var _id = "inspector-number-control-".concat(_instanceId);

        return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["BaseControl"], {
          label: _label5,
          id: _id,
          key: name,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 232,
            columnNumber: 5
          }
        }, /*#__PURE__*/React.createElement(_components_NumberControl__WEBPACK_IMPORTED_MODULE_6__["default"], {
          id: _id,
          onChange: changeHandler,
          isShiftStepEnabled: isShiftStepEnabled,
          shiftStep: shiftStep,
          max: max,
          min: min,
          step: step,
          value: fieldValue || '',
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 237,
            columnNumber: 6
          }
        }));
      }

    case 'MediaUpload':
      {
        var ALLOWED_MEDIA_TYPES = ['image'];
        return /*#__PURE__*/React.createElement("div", {
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 254,
            columnNumber: 5
          }
        }, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_2__["MediaUploadCheck"], {
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 255,
            columnNumber: 6
          }
        }, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_2__["MediaUpload"], {
          onSelect: function onSelect(media) {
            changeHandler({
              id: media.id,
              url: media.url,
              title: media.title
            });
          },
          allowedTypes: ALLOWED_MEDIA_TYPES,
          value: fieldValue,
          render: function render(_ref2) {
            var open = _ref2.open;
            return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["Button"], {
              onClick: open,
              isPrimary: true,
              __self: _this,
              __source: {
                fileName: _jsxFileName,
                lineNumber: 261,
                columnNumber: 9
              }
            }, Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_1__["__"])('Upload'));
          },
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 256,
            columnNumber: 7
          }
        })), !!fieldValue && /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["Button"], {
          onClick: function onClick() {
            return changeHandler(null);
          },
          isSecondary: true,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 268,
            columnNumber: 7
          }
        }, Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_1__["__"])('Remove Upload')), fieldValue && !!fieldValue.title && /*#__PURE__*/React.createElement("div", {
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 276,
            columnNumber: 7
          }
        }, fieldValue.title));
      }

    case 'ColorPicker':
      {
        return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_3__["ColorPicker"], {
          color: fieldValue,
          onChangeComplete: function onChangeComplete(value) {
            return changeHandler(value.hex);
          },
          disableAlpha: true,
          __self: _this,
          __source: {
            fileName: _jsxFileName,
            lineNumber: 285,
            columnNumber: 5
          }
        });
      }

    default:
      return null;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (RenderedField);

/***/ }),

/***/ "./ui/js/blocks/src/blocks/createAttributesFromFields.js":
/*!***************************************************************!*\
  !*** ./ui/js/blocks/src/blocks/createAttributesFromFields.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Returns an "attributes" object, as expected by registerBlockType(),
 * based on the field data.
 *
 * @param {Array} fields Array of field data, each containing a `name`
 *                       and array of `attributeOptions`.
 *
 * @returns {Object} Attributes object to pass to registerBlockType().
 */
var createAttributesFromFields = function createAttributesFromFields(fields) {
  return fields.reduce(function (attributes, currentField) {
    if (!currentField.name) {
      return attributes;
    }

    var name = currentField.name,
        attributeOptions = currentField.attributeOptions;
    return _objectSpread(_objectSpread({}, attributes), {}, _defineProperty({}, name, _objectSpread(_objectSpread({}, attributeOptions), {}, {
      // Default to setting the attribute type to "string"
      // if one wasn't provided.
      type: attributeOptions.type || 'string'
    })));
  }, {});
};

/* harmony default export */ __webpack_exports__["default"] = (createAttributesFromFields);

/***/ }),

/***/ "./ui/js/blocks/src/blocks/createBlockEditComponent.js":
/*!*************************************************************!*\
  !*** ./ui/js/blocks/src/blocks/createBlockEditComponent.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_FieldInspectorControls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/FieldInspectorControls */ "./ui/js/blocks/src/blocks/components/FieldInspectorControls.js");
/* harmony import */ var _components_BlockPreview__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/BlockPreview */ "./ui/js/blocks/src/blocks/components/BlockPreview.js");


var _this = undefined,
    _jsxFileName = "/Users/zrothauser/Local Sites/fields/app/public/wp-content/plugins/pods/ui/js/blocks/src/blocks/createBlockEditComponent.js";

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



/**
 * Creates the 'edit' component for a given block specification.
 *
 * @param {Object} block Block specification (TBD).
 */

var createBlockEditComponent = function createBlockEditComponent(block) {
  return function (props) {
    var _block$fields = block.fields,
        fields = _block$fields === void 0 ? [] : _block$fields,
        template = block.template;
    var className = props.className,
        _props$attributes = props.attributes,
        attributes = _props$attributes === void 0 ? {} : _props$attributes,
        setAttributes = props.setAttributes;
    return /*#__PURE__*/React.createElement("div", {
      className: className,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 31,
        columnNumber: 3
      }
    }, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_1__["InspectorControls"], {
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 4
      }
    }, /*#__PURE__*/React.createElement(_components_FieldInspectorControls__WEBPACK_IMPORTED_MODULE_2__["default"], {
      fields: fields,
      attributes: attributes,
      setAttributes: setAttributes,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 33,
        columnNumber: 5
      }
    })), /*#__PURE__*/React.createElement(_components_BlockPreview__WEBPACK_IMPORTED_MODULE_3__["default"], {
      template: template,
      fields: fields,
      attributes: attributes,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 4
      }
    }));
  };
};

/* harmony default export */ __webpack_exports__["default"] = (createBlockEditComponent);

/***/ }),

/***/ "./ui/js/blocks/src/blocks/index.js":
/*!******************************************!*\
  !*** ./ui/js/blocks/src/blocks/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/blocks */ "@wordpress/blocks");
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _createBlockEditComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createBlockEditComponent */ "./ui/js/blocks/src/blocks/createBlockEditComponent.js");
/* harmony import */ var _createAttributesFromFields__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createAttributesFromFields */ "./ui/js/blocks/src/blocks/createAttributesFromFields.js");


/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



/**
 * Registers a block from the provided data.
 */

var createBlock = function createBlock(block) {
  var blockName = block.blockName,
      fields = block.fields,
      category = block.category,
      description = block.description,
      icon = block.icon,
      keywords = block.keywords,
      supports = block.supports,
      title = block.title;
  var EditComponent = Object(_createBlockEditComponent__WEBPACK_IMPORTED_MODULE_1__["default"])(block);
  Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_0__["registerBlockType"])(blockName, {
    attributes: Object(_createAttributesFromFields__WEBPACK_IMPORTED_MODULE_2__["default"])(fields),
    category: category,
    description: description,
    edit: EditComponent,
    icon: icon,
    keywords: keywords,
    save: function save() {
      return null;
    },
    supports: supports,
    title: title
  });
};

/* harmony default export */ __webpack_exports__["default"] = (createBlock);

/***/ }),

/***/ "./ui/js/blocks/src/components/CheckboxGroup/index.js":
/*!************************************************************!*\
  !*** ./ui/js/blocks/src/components/CheckboxGroup/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _wordpress_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wordpress/components */ "@wordpress/components");
/* harmony import */ var _wordpress_components__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_wordpress_components__WEBPACK_IMPORTED_MODULE_2__);


var _this = undefined,
    _jsxFileName = "/Users/zrothauser/Local Sites/fields/app/public/wp-content/plugins/pods/ui/js/blocks/src/components/CheckboxGroup/index.js";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */



var CheckboxGroup = function CheckboxGroup(_ref) {
  var id = _ref.id,
      className = _ref.className,
      heading = _ref.heading,
      help = _ref.help,
      options = _ref.options,
      values = _ref.values,
      onChange = _ref.onChange;

  // Update the CheckboxGroup's value whenever an individual checkbox has
  // been changed.
  var handleCheckboxControlChange = function handleCheckboxControlChange(value, checked) {
    var updatedValues = _toConsumableArray(values);

    var updatedIndex = updatedValues.findIndex(function (field) {
      return field.value === value;
    });

    if (-1 !== updatedIndex) {
      updatedValues[updatedIndex].checked = checked;
    } else {
      updatedValues.push({
        value: value,
        checked: checked
      });
    }

    onChange(updatedValues);
  };

  return /*#__PURE__*/React.createElement("fieldset", {
    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('components-block-fields-checkbox-group', className),
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 3
    }
  }, heading && /*#__PURE__*/React.createElement("legend", {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 44,
      columnNumber: 17
    }
  }, heading), options.map(function (option) {
    var matchingValue = values.find(function (value) {
      return value.value === option.value;
    }) || false;
    return /*#__PURE__*/React.createElement(_wordpress_components__WEBPACK_IMPORTED_MODULE_2__["CheckboxControl"], {
      key: option.value,
      label: option.label,
      checked: matchingValue.checked || false,
      onChange: function onChange(newChecked) {
        return handleCheckboxControlChange(option.value, newChecked);
      },
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 50,
        columnNumber: 6
      }
    });
  }), !!help && /*#__PURE__*/React.createElement("p", {
    id: id + '__help',
    className: "components-block-fields-checkbox-group__help",
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 60,
      columnNumber: 5
    }
  }, help));
};

CheckboxGroup.propTypes = {
  id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  className: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  heading: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  help: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  options: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({
    label: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
    value: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired
  })),
  values: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({
    value: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,
    checked: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool
  })),
  onChange: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func.isRequired
};
CheckboxGroup.defaultProps = {
  id: '',
  className: null,
  heading: null,
  help: null,
  options: [],
  values: []
};
/* harmony default export */ __webpack_exports__["default"] = (CheckboxGroup);

/***/ }),

/***/ "./ui/js/blocks/src/components/NumberControl/index.js":
/*!************************************************************!*\
  !*** ./ui/js/blocks/src/components/NumberControl/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NumberControl; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "lodash");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _wordpress_keycodes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wordpress/keycodes */ "@wordpress/keycodes");
/* harmony import */ var _wordpress_keycodes__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_wordpress_keycodes__WEBPACK_IMPORTED_MODULE_2__);


var _jsxFileName = "/Users/zrothauser/Local Sites/fields/app/public/wp-content/plugins/pods/ui/js/blocks/src/components/NumberControl/index.js";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */


function NumberControl(_ref) {
  var className = _ref.className,
      _ref$isShiftStepEnabl = _ref.isShiftStepEnabled,
      isShiftStepEnabled = _ref$isShiftStepEnabl === void 0 ? true : _ref$isShiftStepEnabl,
      _ref$max = _ref.max,
      max = _ref$max === void 0 ? Infinity : _ref$max,
      _ref$min = _ref.min,
      min = _ref$min === void 0 ? -Infinity : _ref$min,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? lodash__WEBPACK_IMPORTED_MODULE_0__["noop"] : _ref$onChange,
      _ref$onKeyDown = _ref.onKeyDown,
      onKeyDown = _ref$onKeyDown === void 0 ? lodash__WEBPACK_IMPORTED_MODULE_0__["noop"] : _ref$onKeyDown,
      _ref$shiftStep = _ref.shiftStep,
      shiftStep = _ref$shiftStep === void 0 ? 10 : _ref$shiftStep,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? 1 : _ref$step,
      props = _objectWithoutProperties(_ref, ["className", "isShiftStepEnabled", "max", "min", "onChange", "onKeyDown", "shiftStep", "step"]);

  var baseValue = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["clamp"])(0, min, max);

  var handleOnKeyDown = function handleOnKeyDown(event) {
    onKeyDown(event);
    var value = event.target.value;
    var isEmpty = value === '';
    var enableShift = event.shiftKey && isShiftStepEnabled;
    var incrementalValue = enableShift ? parseFloat(shiftStep) : parseFloat(step);
    var nextValue = isEmpty ? baseValue : value; // Convert to a number to use math

    nextValue = parseFloat(nextValue);

    switch (event.keyCode) {
      case _wordpress_keycodes__WEBPACK_IMPORTED_MODULE_2__["UP"]:
        event.preventDefault();
        nextValue = nextValue + incrementalValue;
        nextValue = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["clamp"])(nextValue, min, max);
        onChange(nextValue.toString(), {
          event: event
        });
        break;

      case _wordpress_keycodes__WEBPACK_IMPORTED_MODULE_2__["DOWN"]:
        event.preventDefault();
        nextValue = nextValue - incrementalValue;
        nextValue = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["clamp"])(nextValue, min, max);
        onChange(nextValue.toString(), {
          event: event
        });
        break;
    }
  };

  var handleOnChange = function handleOnChange(event) {
    onChange(event.target.value, {
      event: event
    });
  };

  var classes = classnames__WEBPACK_IMPORTED_MODULE_1___default()('component-number-control', className);
  return /*#__PURE__*/React.createElement("input", _extends({
    inputMode: "numeric"
  }, props, {
    className: classes,
    type: "number",
    onChange: handleOnChange,
    onKeyDown: handleOnKeyDown,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 3
    }
  }));
}

/***/ }),

/***/ "./ui/js/blocks/src/config/html.js":
/*!*****************************************!*\
  !*** ./ui/js/blocks/src/config/html.js ***!
  \*****************************************/
/*! exports provided: richText, plainText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "richText", function() { return richText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plainText", function() { return plainText; });


var richText = {
  allowedTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'cite', 'hr', 'br', 'div', 'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre', 'img', 'figure', 'figcaption', 'iframe', 'section'],
  allowedAttributes: {
    '*': ['class', 'id', 'data-*', 'style'],
    iframe: ['*'],
    a: ['href', 'name', 'target'],
    img: ['src', 'srcset', 'sizes', 'alt', 'width', 'height']
  },
  selfClosing: ['img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta'],
  allowedSchemes: ['http', 'https', 'ftp', 'mailto'],
  allowedSchemesByTag: {},
  allowProtocolRelative: true
};
var plainText = {
  allowedTags: [],
  allowedAttributes: {}
};

/***/ }),

/***/ "./ui/js/blocks/src/index.js":
/*!***********************************!*\
  !*** ./ui/js/blocks/src/index.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blocks */ "./ui/js/blocks/src/blocks/index.js");


/**
 * Internal dependencies
 */
 // Register blocks from the config.

window.podsBlocksConfig.blocks.forEach(_blocks__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./ui/js/blocks/src/utils/renderTemplate.js":
/*!**************************************************!*\
  !*** ./ui/js/blocks/src/utils/renderTemplate.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var html_to_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! html-to-react */ "./node_modules/html-to-react/index.js");
/* harmony import */ var html_to_react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(html_to_react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var sanitize_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sanitize-html */ "./node_modules/sanitize-html/dist/sanitize-html.js");
/* harmony import */ var sanitize_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(sanitize_html__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _config_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config/html */ "./ui/js/blocks/src/config/html.js");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * External dependencies
 */



/**
 * Internal dependencies
 */


/**
 * Renders the edit template into an edit component.
 *
 * @todo Is there a more efficient way to do this without
 * rendering React components to a string, then parsing the
 * final string back to a React component? The parser may have
 * callbacks that we can use.
 *
 * @param {string} template Template string.
 * @param {Object} fields Fields used in the Block.
 * @param {Object} attributes Block attributes with values.
 * @param {Function} renderField Function that should return a rendered field.
 * @param {Function} setAttributes setAttributes function for the block (Optional).
 */

var renderTemplate = function renderTemplate() {
  var template = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var renderField = arguments.length > 3 ? arguments[3] : undefined;
  var setAttributes = arguments.length > 4 ? arguments[4] : undefined;
  var htmlWithRenderedFields = sanitize_html__WEBPACK_IMPORTED_MODULE_2___default()(template, _config_html__WEBPACK_IMPORTED_MODULE_3__["richText"]); // Replace all of the placeholders in the format of `{@fieldName}` with the
  // rendered field. To do this, we first need to create the React component for
  // the field, then convert it down into a string. To avoid losing any of the props
  // during this conversion, we're saving any props from the component based on the name.
  // At the end, the whole string will be parsed back into React components.

  var savedProps = [];
  fields.forEach(function (field) {
    // Our renderField may or may not take a setAttributes function as a parameter.
    var fieldComponent = 'function' === typeof setAttributes ? renderField(field, attributes, setAttributes) : renderField(field, attributes);

    if (!!fieldComponent) {
      savedProps[field.name] = _objectSpread({}, fieldComponent.props);
    }

    var renderedField = !!fieldComponent ? Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["renderToString"])(fieldComponent) : '';
    htmlWithRenderedFields = htmlWithRenderedFields.replace(new RegExp("{@".concat(field.name, "}"), 'g'), renderedField);
  }); // Parse the rendered template, setting the props back to their saved values.

  var processNodeDefinitions = new html_to_react__WEBPACK_IMPORTED_MODULE_1__["ProcessNodeDefinitions"]();
  var htmlParser = new html_to_react__WEBPACK_IMPORTED_MODULE_1__["Parser"]();
  var processingInstructions = [{
    shouldProcessNode: function shouldProcessNode() {
      return true;
    },
    processNode: processNodeDefinitions.processDefaultNode
  }];
  var parsedComponents = htmlParser.parseWithInstructions(htmlWithRenderedFields, function () {
    return true;
  }, processingInstructions);
  return parsedComponents;
};

/* harmony default export */ __webpack_exports__["default"] = (renderTemplate);

/***/ }),

/***/ 0:
/*!**********************************!*\
  !*** ./WritableStream (ignored) ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "@wordpress/autop":
/*!****************************************!*\
  !*** external {"this":["wp","autop"]} ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["autop"]; }());

/***/ }),

/***/ "@wordpress/block-editor":
/*!**********************************************!*\
  !*** external {"this":["wp","blockEditor"]} ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["blockEditor"]; }());

/***/ }),

/***/ "@wordpress/blocks":
/*!*****************************************!*\
  !*** external {"this":["wp","blocks"]} ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["blocks"]; }());

/***/ }),

/***/ "@wordpress/components":
/*!*********************************************!*\
  !*** external {"this":["wp","components"]} ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["components"]; }());

/***/ }),

/***/ "@wordpress/compose":
/*!******************************************!*\
  !*** external {"this":["wp","compose"]} ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["compose"]; }());

/***/ }),

/***/ "@wordpress/date":
/*!***************************************!*\
  !*** external {"this":["wp","date"]} ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["date"]; }());

/***/ }),

/***/ "@wordpress/element":
/*!******************************************!*\
  !*** external {"this":["wp","element"]} ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["element"]; }());

/***/ }),

/***/ "@wordpress/i18n":
/*!***************************************!*\
  !*** external {"this":["wp","i18n"]} ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["i18n"]; }());

/***/ }),

/***/ "@wordpress/keycodes":
/*!*******************************************!*\
  !*** external {"this":["wp","keycodes"]} ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = this["wp"]["keycodes"]; }());

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = lodash;

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = React;

/***/ }),

/***/ "react-dom":
/*!***************************!*\
  !*** external "ReactDOM" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ReactDOM;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNMb29zZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vY2FjaGUvZGlzdC9jYWNoZS5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vY29yZS9kaXN0L2NvcmUuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2Nzcy9kaXN0L2Nzcy5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaGFzaC9kaXN0L2hhc2guYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9tZW1vaXplLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9zZXJpYWxpemUvZGlzdC9zZXJpYWxpemUuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3NoZWV0L2Rpc3Qvc2hlZXQuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3N0eWxpcy9kaXN0L3N0eWxpcy5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vdW5pdGxlc3MvZGlzdC91bml0bGVzcy5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vdXRpbHMvZGlzdC91dGlscy5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vd2Vhay1tZW1vaXplL2Rpc3Qvd2Vhay1tZW1vaXplLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20tc2VyaWFsaXplci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tZWxlbWVudHR5cGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb21oYW5kbGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9taGFuZGxlci9saWIvbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL2xlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL21hbmlwdWxhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tdXRpbHMvbGliL3F1ZXJ5aW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb211dGlscy9saWIvdGFndHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbXV0aWxzL2xpYi90cmF2ZXJzYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9kZWNvZGVfY29kZXBvaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG8tcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG8tcmVhY3QvbGliL2NhbWVsLWNhc2UtYXR0cmlidXRlLW5hbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLXRvLXJlYWN0L2xpYi9pcy12YWxpZC1ub2RlLWRlZmluaXRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLXRvLXJlYWN0L2xpYi9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG8tcmVhY3QvbGliL3Byb2Nlc3Mtbm9kZS1kZWZpbml0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC10by1yZWFjdC9saWIvcHJvY2Vzc2luZy1pbnN0cnVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG8tcmVhY3QvbGliL3Nob3VsZC1wcm9jZXNzLW5vZGUtZGVmaW5pdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG8tcmVhY3QvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1scGFyc2VyMi9saWIvQ29sbGVjdGluZ0hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9GZWVkSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbHBhcnNlcjIvbGliL011bHRpcGxleEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9QYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9Ub2tlbml6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWxwYXJzZXIyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmNhbWVsY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVtb2l6ZS1vbmUvZGlzdC9tZW1vaXplLW9uZS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvYWRkSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvY3VycnlOLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fYXJpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY29tcGxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jb25jYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnkxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Mi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnlOLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNQbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fcmVkdWNlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZkJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9feGZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194bWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3h3cmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3JlamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3RvUGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LWF1dG9zaXplL2xpYi9BdXRvc2l6ZUlucHV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1zZWxlY3QvZGlzdC9TZWxlY3QtOWZkYjhjZDAuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNlbGVjdC9kaXN0L2luZGV4LTQzMjJjMGVkLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1zZWxlY3QvZGlzdC9yZWFjdC1zZWxlY3QuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNlbGVjdC9kaXN0L3N0YXRlTWFuYWdlci0wNGY3MzRhMi5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2VsZWN0L2Rpc3QvdXRpbHMtMDZiMGQ1YTQuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Nhbml0aXplLWh0bWwvZGlzdC9zYW5pdGl6ZS1odG1sLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vdWkvanMvYmxvY2tzL3NyYy9ibG9ja3MvY29tcG9uZW50cy9CbG9ja1ByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vdWkvanMvYmxvY2tzL3NyYy9ibG9ja3MvY29tcG9uZW50cy9GaWVsZEluc3BlY3RvckNvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL3VpL2pzL2Jsb2Nrcy9zcmMvYmxvY2tzL2NvbXBvbmVudHMvUmVuZGVyZWRGaWVsZC5qcyIsIndlYnBhY2s6Ly8vLi91aS9qcy9ibG9ja3Mvc3JjL2Jsb2Nrcy9jcmVhdGVBdHRyaWJ1dGVzRnJvbUZpZWxkcy5qcyIsIndlYnBhY2s6Ly8vLi91aS9qcy9ibG9ja3Mvc3JjL2Jsb2Nrcy9jcmVhdGVCbG9ja0VkaXRDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vdWkvanMvYmxvY2tzL3NyYy9ibG9ja3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdWkvanMvYmxvY2tzL3NyYy9jb21wb25lbnRzL0NoZWNrYm94R3JvdXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdWkvanMvYmxvY2tzL3NyYy9jb21wb25lbnRzL051bWJlckNvbnRyb2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdWkvanMvYmxvY2tzL3NyYy9jb25maWcvaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi91aS9qcy9ibG9ja3Mvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3VpL2pzL2Jsb2Nrcy9zcmMvdXRpbHMvcmVuZGVyVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vV3JpdGFibGVTdHJlYW0gKGlnbm9yZWQpIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJ0aGlzXCI6W1wid3BcIixcImF1dG9wXCJdfSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1widGhpc1wiOltcIndwXCIsXCJibG9ja0VkaXRvclwiXX0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcInRoaXNcIjpbXCJ3cFwiLFwiYmxvY2tzXCJdfSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1widGhpc1wiOltcIndwXCIsXCJjb21wb25lbnRzXCJdfSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1widGhpc1wiOltcIndwXCIsXCJjb21wb3NlXCJdfSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1widGhpc1wiOltcIndwXCIsXCJkYXRlXCJdfSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1widGhpc1wiOltcIndwXCIsXCJlbGVtZW50XCJdfSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1widGhpc1wiOltcIndwXCIsXCJpMThuXCJdfSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1widGhpc1wiOltcIndwXCIsXCJrZXljb2Rlc1wiXX0iLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibG9kYXNoXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiUmVhY3RcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJSZWFjdERPTVwiIl0sIm5hbWVzIjpbInJlbmRlckZpZWxkIiwiZmllbGQiLCJhdHRyaWJ1dGVzIiwibmFtZSIsImZpZWxkT3B0aW9ucyIsInR5cGUiLCJmaWVsZFZhbHVlIiwic2FuaXRpemVIdG1sIiwicGxhaW5UZXh0Iiwic2hvdWxkQXV0b1AiLCJhdXRvX3AiLCJzYW5pdGl6ZWRUZXh0IiwiX19odG1sIiwiYXV0b3AiLCJfXyIsIm9wdGlvbnMiLCJ2YWx1ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJ2YWx1ZSIsImNoZWNrZWQiLCJsZW5ndGgiLCJtYXAiLCJpbmRleCIsIm1hdGNoaW5nT3B0aW9uIiwiZmluZCIsIm9wdGlvbiIsImxhYmVsIiwiZGF0ZUZvcm1hdCIsIl9fZXhwZXJpbWVudGFsR2V0U2V0dGluZ3MiLCJmb3JtYXRzIiwiZGF0ZXRpbWUiLCJmb3JtYXREYXRlIiwiZGF0ZUkxOG4iLCJsb2NhbGUiLCJsMTBuIiwicmVwbGFjZSIsInRvTG9jYWxlU3RyaW5nIiwidXJsIiwiY29sb3IiLCJCbG9ja1ByZXZpZXciLCJ0ZW1wbGF0ZSIsImZpZWxkcyIsInJlbmRlclRlbXBsYXRlIiwiRmllbGRJbnNwZWN0b3JDb250cm9scyIsInNldEF0dHJpYnV0ZXMiLCJoZWFkaW5nIiwiY3JlYXRlQ2hhbmdlSGFuZGxlciIsIm5ld1ZhbHVlIiwicGFyc2VJbnQiLCJSZW5kZXJlZEZpZWxkIiwiY2hhbmdlSGFuZGxlciIsImhlbHAiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJpbnN0YW5jZUlkIiwidXNlSW5zdGFuY2VJZCIsIlNlbGVjdCIsImlkIiwiY29udGFpbmVyIiwicHJvdmlkZWQiLCJ3aWR0aCIsImlzMTJIb3VyIiwiaXNTaGlmdFN0ZXBFbmFibGVkIiwic2hpZnRTdGVwIiwibWF4IiwiSW5maW5pdHkiLCJtaW4iLCJzdGVwIiwiTnVtYmVyQ29udHJvbCIsIkFMTE9XRURfTUVESUFfVFlQRVMiLCJtZWRpYSIsInRpdGxlIiwib3BlbiIsImhleCIsImNyZWF0ZUF0dHJpYnV0ZXNGcm9tRmllbGRzIiwicmVkdWNlIiwiY3VycmVudEZpZWxkIiwiYXR0cmlidXRlT3B0aW9ucyIsImNyZWF0ZUJsb2NrRWRpdENvbXBvbmVudCIsImJsb2NrIiwicHJvcHMiLCJjbGFzc05hbWUiLCJjcmVhdGVCbG9jayIsImJsb2NrTmFtZSIsImNhdGVnb3J5IiwiZGVzY3JpcHRpb24iLCJpY29uIiwia2V5d29yZHMiLCJzdXBwb3J0cyIsIkVkaXRDb21wb25lbnQiLCJyZWdpc3RlckJsb2NrVHlwZSIsImVkaXQiLCJzYXZlIiwiQ2hlY2tib3hHcm91cCIsIm9uQ2hhbmdlIiwiaGFuZGxlQ2hlY2tib3hDb250cm9sQ2hhbmdlIiwidXBkYXRlZFZhbHVlcyIsInVwZGF0ZWRJbmRleCIsImZpbmRJbmRleCIsInB1c2giLCJjbGFzc05hbWVzIiwibWF0Y2hpbmdWYWx1ZSIsIm5ld0NoZWNrZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJhcnJheU9mIiwic2hhcGUiLCJpc1JlcXVpcmVkIiwiYm9vbCIsImZ1bmMiLCJkZWZhdWx0UHJvcHMiLCJub29wIiwib25LZXlEb3duIiwiYmFzZVZhbHVlIiwiY2xhbXAiLCJoYW5kbGVPbktleURvd24iLCJldmVudCIsInRhcmdldCIsImlzRW1wdHkiLCJlbmFibGVTaGlmdCIsInNoaWZ0S2V5IiwiaW5jcmVtZW50YWxWYWx1ZSIsInBhcnNlRmxvYXQiLCJuZXh0VmFsdWUiLCJrZXlDb2RlIiwiVVAiLCJwcmV2ZW50RGVmYXVsdCIsInRvU3RyaW5nIiwiRE9XTiIsImhhbmRsZU9uQ2hhbmdlIiwiY2xhc3NlcyIsInJpY2hUZXh0IiwiYWxsb3dlZFRhZ3MiLCJhbGxvd2VkQXR0cmlidXRlcyIsImlmcmFtZSIsImEiLCJpbWciLCJzZWxmQ2xvc2luZyIsImFsbG93ZWRTY2hlbWVzIiwiYWxsb3dlZFNjaGVtZXNCeVRhZyIsImFsbG93UHJvdG9jb2xSZWxhdGl2ZSIsIndpbmRvdyIsInBvZHNCbG9ja3NDb25maWciLCJibG9ja3MiLCJmb3JFYWNoIiwiaHRtbFdpdGhSZW5kZXJlZEZpZWxkcyIsInNhdmVkUHJvcHMiLCJmaWVsZENvbXBvbmVudCIsInJlbmRlcmVkRmllbGQiLCJyZW5kZXJUb1N0cmluZyIsIlJlZ0V4cCIsInByb2Nlc3NOb2RlRGVmaW5pdGlvbnMiLCJQcm9jZXNzTm9kZURlZmluaXRpb25zIiwiaHRtbFBhcnNlciIsIlBhcnNlciIsInByb2Nlc3NpbmdJbnN0cnVjdGlvbnMiLCJzaG91bGRQcm9jZXNzTm9kZSIsInByb2Nlc3NOb2RlIiwicHJvY2Vzc0RlZmF1bHROb2RlIiwicGFyc2VkQ29tcG9uZW50cyIsInBhcnNlV2l0aEluc3RydWN0aW9ucyJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0M7Ozs7Ozs7Ozs7OztBQ05BO0FBQUE7QUFBQTtBQUFBO0FBQTRDO0FBQ1A7QUFDTjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsdURBQU07O0FBRXpCLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGVB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0IseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEy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Q0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDaE1hO0FBQ2IsOENBQThDLGNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDbFhhO0FBQ2I7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCx5Q0FBeUMsbUJBQU8sQ0FBQyxzRkFBK0I7QUFDaEYsc0NBQXNDLG1CQUFPLENBQUMsdUZBQWlDO0FBQy9FLG9DQUFvQyxtQkFBTyxDQUFDLG1GQUErQjtBQUMzRSxpQ0FBaUMsbUJBQU8sQ0FBQyw2RUFBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyw0RkFBNEYsU0FBTTtBQUM3STtBQUNBOztBQUVBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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LENBQUMsMEZBQStCO0FBQzFEOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXdEO0FBQ25CO0FBQ0Q7QUFDSTtBQUM2STtBQUNzWTtBQUMzaEI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsZ0RBQWdELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZSxHQUFHLHdDQUF3Qzs7QUFFM1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtEQUFrRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRywwQ0FBMEM7O0FBRWpVLFdBQVcsTUFBcUMsR0FBRyxTQUdsRDtBQUNEO0FBQ0EsMEJBQTBCLGFBQWEsU0FBUyw4QkFBOEIsV0FBVyxVQUFVLGtCQUFrQixnQkFBZ0IsVUFBVSxtQkFBbUI7QUFDbEssbURBQW1ELGNBQWM7QUFDakU7O0FBRUE7QUFDQSxTQUFTLHlEQUFHO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsdUJBQXVCLGtEQUFrRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRywwQ0FBMEM7O0FBRWpVLDBEQUEwRCwrQkFBK0IsaUJBQWlCLHNDQUFzQyxZQUFZLFlBQVksdUJBQXVCLE9BQU8scUJBQXFCLDBDQUEwQywyQkFBMkIsRUFBRSxlQUFlO0FBQ2pUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMseURBQUc7QUFDWjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSw0REFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLE1BQXFDLEdBQUcsU0FBRSwrQ0FBK0MsY0FBYztBQUM5RyxHQUFHO0FBQ0g7O0FBRUEsK0NBQStDLDBEQUEwRCwyQ0FBMkMsaUNBQWlDOztBQUVyTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsNkRBQVc7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsQ0FBQywrQ0FBUzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsMERBQTBELDJDQUEyQyxpQ0FBaUM7QUFDdkw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRCxtRkFBbUY7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLENBQUMsK0NBQVM7O0FBRVg7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCwwREFBMEQsMkNBQTJDLGlDQUFpQzs7QUFFdkwsYUFBYSxNQUFxQyxHQUFHLFNBR3BEO0FBQ0Q7QUFDQSwwQkFBMEIsT0FBTyxTQUFTLFFBQVEsTUFBTTtBQUN4RCxtREFBbUQsY0FBYztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLHlEQUFHLGNBQWMseURBQUc7QUFDL0I7QUFDQTtBQUNBLEtBQUssR0FBRyx5REFBRztBQUNYO0FBQ0EsS0FBSyxpQ0FBaUMseURBQUc7QUFDekM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDLENBQUMsbURBQWE7O0FBRWYsNERBQTRELCtCQUErQixpQkFBaUIsc0NBQXNDLFlBQVksWUFBWSx1QkFBdUIsT0FBTyxxQkFBcUIsMENBQTBDLDJCQUEyQixFQUFFLGVBQWU7O0FBRW5ULGlEQUFpRCwwREFBMEQsMkNBQTJDLGlDQUFpQzs7QUFFdkw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsNENBQUs7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDLENBQUMsK0NBQVM7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDRDQUFLO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtEQUFrRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRywwQ0FBMEM7QUFDalU7QUFDQSxrQkFBa0IsZ0VBQWlCO0FBQ25DLGFBQWEsZ0VBQVk7QUFDekIsV0FBVyxnRUFBRztBQUNkLHFCQUFxQixnRUFBb0I7QUFDekMsU0FBUyxnRUFBUTtBQUNqQixnQkFBZ0IsZ0VBQWU7QUFDL0IsdUJBQXVCLGdFQUFzQjtBQUM3QyxzQkFBc0IsZ0VBQXFCO0FBQzNDLFNBQVMsZ0VBQVE7QUFDakIsb0JBQW9CLGdFQUFtQjtBQUN2QyxrQkFBa0IsZ0VBQWlCO0FBQ25DLFFBQVEsZ0VBQU87QUFDZixZQUFZLGdFQUFXO0FBQ3ZCLGNBQWMsZ0VBQWE7QUFDM0IsY0FBYyxnRUFBYTtBQUMzQixtQkFBbUIsZ0VBQWtCO0FBQ3JDLG9CQUFvQixnRUFBbUI7QUFDdkMsb0JBQW9CLGdFQUFtQjtBQUN2QyxVQUFVLGdFQUFTO0FBQ25CLGVBQWUsZ0VBQWM7QUFDN0IsZUFBZSxnRUFBSztBQUNwQixrQkFBa0IsZ0VBQWlCO0FBQ25DLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixVQUFVOzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLGlCQUFpQjs7QUFFakIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RCwrQkFBK0IsaUJBQWlCLHNDQUFzQyxZQUFZLFlBQVksdUJBQXVCLE9BQU8scUJBQXFCLDBDQUEwQywyQkFBMkIsRUFBRSxlQUFlOztBQUVuVCx1QkFBdUIsa0RBQWtELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZSxHQUFHLDBDQUEwQzs7QUFFalUsaURBQWlELDBEQUEwRCwyQ0FBMkMsaUNBQWlDOztBQUV2TCx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7QUFDcEs7QUFDQTtBQUNBLHFCQUFxQix3RUFBYztBQUNuQyxzQkFBc0Isd0VBQWM7QUFDcEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3RUFBYztBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix3RUFBaUI7QUFDMUM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELHdFQUFpQjtBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSw0QkFBNEIsMkRBQVUsd0JBQXdCLGdFQUFhOztBQUUzRTs7QUFFQTs7QUFFQSx1QkFBdUIsd0VBQVU7O0FBRWpDLDZCQUE2QiwyREFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdFQUFhLHFDQUFxQyx3RUFBYSwrQ0FBK0Msd0VBQWE7QUFDeEksS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0MsK0NBQStDOztBQUUvQztBQUNBLHdCQUF3Qix3RUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsTUFBTSx3RUFBYztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxnRUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTzs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTzs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsNENBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyw0Q0FBSyx5Q0FBeUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQUssd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw0Q0FBSyx5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQUssNENBQTRDO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQUssOENBQThDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBSyxnREFBZ0Q7QUFDaEU7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBSywrQ0FBK0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNENBQUssb0NBQW9DO0FBQ3REO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsNENBQUssbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGVBQWUsNENBQUs7QUFDcEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsZUFBZSw0Q0FBSztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBSyxlQUFlLGdFQUFVLGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRDQUFLLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyxHQUFHLDRDQUFLO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFLDRDQUFLO0FBQ2Q7QUFDQSxPQUFPLEVBQUUsNENBQUssc0NBQXNDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLEVBQUU7QUFDUDtBQUNBOztBQUVBLDBEQUEwRCw0Q0FBSyx3Q0FBd0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlLDRDQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsNENBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUyxJQUFJLDRDQUFLO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZSw0Q0FBSztBQUNwQjtBQUNBLEtBQUs7QUFDTDs7QUFFQSxhQUFhLDRDQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDRDQUFLO0FBQ2hCO0FBQ0EsS0FBSyxFQUFFLDRDQUFLO0FBQ1o7QUFDQSxLQUFLLHlDQUF5Qyw0Q0FBSztBQUNuRDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNENBQUssNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLDRCQUE0Qiw0Q0FBSyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLDRDQUFLLDRDQUE0QztBQUN6RDtBQUNBLEtBQUsseURBQXlELDRDQUFLLGlEQUFpRDtBQUNwSDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUMsQ0FBQywrQ0FBUzs7QUFFWDs7QUFFa0c7Ozs7Ozs7Ozs7Ozs7QUM3cUZsRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtDO0FBQ3lCO0FBQ2xCO0FBQ047QUFDd0g7QUFDM0g7QUFDaUI7O0FBRWpELHFCQUFxQixnREFBZ0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlLEdBQUcsd0NBQXdDOztBQUUzVCwrQ0FBK0MsMERBQTBELDJDQUEyQyxpQ0FBaUM7QUFDckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdFQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3RUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVUsd0VBQWdCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVUsd0VBQWdCO0FBQzFCLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxRQUFRLHdFQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVSx3RUFBZ0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHdFQUFnQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLCtDQUFTO0FBQ1g7QUFDQSxzQkFBc0IsaURBQVM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx3RUFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixzQkFBc0IseURBQUc7QUFDekI7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLDhEQUFZO0FBQ2xDOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLCtDQUFTO0FBQ1g7QUFDQSxzQkFBc0IsaURBQVM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLEtBQUs7QUFDTDs7O0FBR0Esb0JBQW9CLFdBQVc7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0RBQWtELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZSxHQUFHLDBDQUEwQztBQUNqVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0EsOERBQThELFlBQVksRUFBRSxTQUFTLFlBQVksRUFBRTs7QUFFbkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0RBQW9ELFlBQVksd0JBQXdCLEVBQUUsbUJBQW1CLGdCQUFnQjs7QUFFN0gsdUJBQXVCLGtEQUFrRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRywwQ0FBMEM7O0FBRWpVLDBEQUEwRCwrQkFBK0IsaUJBQWlCLHNDQUFzQyxZQUFZLFlBQVksdUJBQXVCLE9BQU8scUJBQXFCLDBDQUEwQywyQkFBMkIsRUFBRSxlQUFlOztBQUVqVCxZQUFZLE1BQXFDLEdBQUcsU0FHbkQ7QUFDRDtBQUNBLGdDQUFnQyxrQkFBa0IsY0FBYyxvQkFBb0IsZUFBZTtBQUNuRyxtREFBbUQsY0FBYztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyx5REFBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFNBQVMseURBQUc7QUFDWjtBQUNBLEdBQUcsVUFBVSx5REFBRztBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyx5REFBRztBQUNaO0FBQ0EsR0FBRyxVQUFVLHlEQUFHO0FBQ2hCO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBRyxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxlQUFlLHlEQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFHLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLGVBQWUseURBQUc7QUFDckIsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFHLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBLDJCQUEyQiwrREFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUc7QUFDWjtBQUNBO0FBQ0EsSUFBSSw0REFBSTtBQUNSLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSxNQUFxQyxHQUFHLFNBQUUsK0NBQStDLGNBQWM7QUFDOUcsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUcscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsR0FBRyx5REFBRztBQUNUO0FBQ0E7QUFDQSxHQUFHLEdBQUcseURBQUc7QUFDVDtBQUNBO0FBQ0EsR0FBRyxHQUFHLHlEQUFHO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsa0RBQWtELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZSxHQUFHLDBDQUEwQztBQUNqVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQSw0REFBNEQsK0JBQStCLGlCQUFpQixzQ0FBc0MsWUFBWSxZQUFZLHVCQUF1QixPQUFPLHFCQUFxQiwwQ0FBMEMsMkJBQTJCLEVBQUUsZUFBZTs7QUFFblQsdUJBQXVCLGtEQUFrRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRywwQ0FBMEM7QUFDalU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsRUFBRSx5REFBRyx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFdBQVcseURBQUc7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyx5REFBRztBQUNaO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUEsdUJBQXVCLGtEQUFrRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRywwQ0FBMEM7O0FBRWpVLDREQUE0RCwrQkFBK0IsaUJBQWlCLHNDQUFzQyxZQUFZLFlBQVksdUJBQXVCLE9BQU8scUJBQXFCLDBDQUEwQywyQkFBMkIsRUFBRSxlQUFlO0FBQ25UO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHlEQUFHO0FBQ1o7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLEVBQUUseURBQUcsQ0FBQywyREFBYTtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx1QkFBdUIsa0RBQWtELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZSxHQUFHLDBDQUEwQztBQUNqVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBRyxnQ0FBZ0MseURBQUc7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUcsQ0FBQyx3REFBVTtBQUN2QjtBQUNBO0FBQ0EsV0FBVyx5REFBRztBQUNkO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLLEVBQUUseURBQUc7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLLGFBQWEseURBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtEQUFrRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWUsR0FBRywwQ0FBMEM7QUFDalU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQSx1QkFBdUIsa0RBQWtELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZSxHQUFHLDBDQUEwQztBQUNqVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHVCQUF1QixrREFBa0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlLEdBQUcsMENBQTBDO0FBQ2pVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQSx1QkFBdUIsa0RBQWtELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZSxHQUFHLDBDQUEwQztBQUNqVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFcWlCOzs7Ozs7Ozs7Ozs7O0FDaHdDcmlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUM7QUFDSjtBQUNTO0FBQzNCO0FBQ0M7QUFDcUI7QUFDeUI7QUFDSDtBQUMyQztBQUNwRjtBQUNRO0FBQzRDO0FBQ2pDOztBQUV6QywrQ0FBK0MsMERBQTBELDJDQUEyQyxpQ0FBaUM7O0FBRXJMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLCtEQUFXO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBLCtCQUErQiwyREFBVTtBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDRDQUFLLGVBQWUsMkRBQWE7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDLENBQUMsK0NBQVM7O0FBRVgsWUFBWSxnRkFBVyxDQUFDLGlFQUFNOztBQUVmLG9FQUFLLEVBQUM7QUFDSTs7Ozs7Ozs7Ozs7OztBQ25EekI7QUFBQTtBQUFBO0FBQUE7QUFBeUM7O0FBRXpDLHFCQUFxQixnREFBZ0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlLEdBQUcsd0NBQXdDOztBQUUzVCwwREFBMEQsK0JBQStCLGlCQUFpQixzQ0FBc0MsWUFBWSxZQUFZLHVCQUF1QixPQUFPLHFCQUFxQiwwQ0FBMEMsMkJBQTJCLEVBQUUsZUFBZTs7QUFFalQsK0NBQStDLDBEQUEwRCwyQ0FBMkMsaUNBQWlDO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtHQUFrRyxlQUFlO0FBQ2pIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDRDQUFLLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRyxDQUFDLCtDQUFTO0FBQ2I7O0FBRTRCOzs7Ozs7Ozs7Ozs7O0FDaEk1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUEsNEJBQTRCLCtCQUErQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBRUEsTUFBTUMsc0JBQXNCLEdBQUcsQ0FDOUI7QUFDQ0MscUJBQWlCLEVBQUU7QUFBQSxhQUFNLElBQU47QUFBQSxLQURwQjtBQUVDQyxlQUFXLEVBQUVOLHNCQUFzQixDQUFDTztBQUZyQyxHQUQ4QixDQUEvQjtBQU9BLE1BQU1DLGdCQUFnQixHQUFHTixVQUFVLENBQUNPLHFCQUFYLENBQ3hCZixzQkFEd0IsRUFFeEI7QUFBQSxXQUFNLElBQU47QUFBQSxHQUZ3QixFQUd4QlUsc0JBSHdCLENBQXpCO0FBTUEsU0FBT0ksZ0JBQVA7QUFDQSxDQXBERDs7QUFzRGV0SCw2RUFBZixFOzs7Ozs7Ozs7OztBQ2hGQSxlOzs7Ozs7Ozs7OztBQ0FBLGFBQWEsc0NBQXNDLEVBQUUsSTs7Ozs7Ozs7Ozs7QUNBckQsYUFBYSw0Q0FBNEMsRUFBRSxJOzs7Ozs7Ozs7OztBQ0EzRCxhQUFhLHVDQUF1QyxFQUFFLEk7Ozs7Ozs7Ozs7O0FDQXRELGFBQWEsMkNBQTJDLEVBQUUsSTs7Ozs7Ozs7Ozs7QUNBMUQsYUFBYSx3Q0FBd0MsRUFBRSxJOzs7Ozs7Ozs7OztBQ0F2RCxhQUFhLHFDQUFxQyxFQUFFLEk7Ozs7Ozs7Ozs7O0FDQXBELGFBQWEsd0NBQXdDLEVBQUUsSTs7Ozs7Ozs7Ozs7QUNBdkQsYUFBYSxxQ0FBcUMsRUFBRSxJOzs7Ozs7Ozs7OztBQ0FwRCxhQUFhLHlDQUF5QyxFQUFFLEk7Ozs7Ozs7Ozs7O0FDQXhELHdCOzs7Ozs7Ozs7OztBQ0FBLHVCOzs7Ozs7Ozs7OztBQ0FBLDBCIiwiZmlsZSI6ImJsb2Nrcy9idWlsZC9ibG9jay1jcmVhdG9yLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vdWkvanMvYmxvY2tzL3NyYy9pbmRleC5qc1wiKTtcbiIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHNMb29zZTsiLCJpbXBvcnQgeyBTdHlsZVNoZWV0IH0gZnJvbSAnQGVtb3Rpb24vc2hlZXQnO1xuaW1wb3J0IFN0eWxpcyBmcm9tICdAZW1vdGlvbi9zdHlsaXMnO1xuaW1wb3J0ICdAZW1vdGlvbi93ZWFrLW1lbW9pemUnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGh5c3VsdGFuL3N0eWxpcy5qcy90cmVlL21hc3Rlci9wbHVnaW5zL3J1bGUtc2hlZXRcbi8vIGlubGluZWQgdG8gYXZvaWQgdW1kIHdyYXBwZXIgYW5kIHBlZXJEZXAgd2FybmluZ3MvaW5zdGFsbGluZyBzdHlsaXNcbi8vIHNpbmNlIHdlIHVzZSBzdHlsaXMgYWZ0ZXIgY2xvc3VyZSBjb21waWxlclxudmFyIGRlbGltaXRlciA9ICcvKnwqLyc7XG52YXIgbmVlZGxlID0gZGVsaW1pdGVyICsgJ30nO1xuXG5mdW5jdGlvbiB0b1NoZWV0KGJsb2NrKSB7XG4gIGlmIChibG9jaykge1xuICAgIFNoZWV0LmN1cnJlbnQuaW5zZXJ0KGJsb2NrICsgJ30nKTtcbiAgfVxufVxuXG52YXIgU2hlZXQgPSB7XG4gIGN1cnJlbnQ6IG51bGxcbn07XG52YXIgcnVsZVNoZWV0ID0gZnVuY3Rpb24gcnVsZVNoZWV0KGNvbnRleHQsIGNvbnRlbnQsIHNlbGVjdG9ycywgcGFyZW50cywgbGluZSwgY29sdW1uLCBsZW5ndGgsIG5zLCBkZXB0aCwgYXQpIHtcbiAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgLy8gcHJvcGVydHlcbiAgICBjYXNlIDE6XG4gICAgICB7XG4gICAgICAgIHN3aXRjaCAoY29udGVudC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gQGltcG9ydFxuICAgICAgICAgICAgICBTaGVldC5jdXJyZW50Lmluc2VydChjb250ZW50ICsgJzsnKTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGNoYXJjb2RlIGZvciBsXG5cbiAgICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gY2hhcmNvZGUgZm9yIGJcbiAgICAgICAgICAgICAgLy8gdGhpcyBpZ25vcmVzIGxhYmVsXG4gICAgICAgICAgICAgIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMikgPT09IDk4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBzZWxlY3RvclxuXG4gICAgY2FzZSAyOlxuICAgICAge1xuICAgICAgICBpZiAobnMgPT09IDApIHJldHVybiBjb250ZW50ICsgZGVsaW1pdGVyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBhdC1ydWxlXG5cbiAgICBjYXNlIDM6XG4gICAgICB7XG4gICAgICAgIHN3aXRjaCAobnMpIHtcbiAgICAgICAgICAvLyBAZm9udC1mYWNlLCBAcGFnZVxuICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBTaGVldC5jdXJyZW50Lmluc2VydChzZWxlY3RvcnNbMF0gKyBjb250ZW50KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQgKyAoYXQgPT09IDAgPyBkZWxpbWl0ZXIgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgLTI6XG4gICAgICB7XG4gICAgICAgIGNvbnRlbnQuc3BsaXQobmVlZGxlKS5mb3JFYWNoKHRvU2hlZXQpO1xuICAgICAgfVxuICB9XG59O1xuXG52YXIgY3JlYXRlQ2FjaGUgPSBmdW5jdGlvbiBjcmVhdGVDYWNoZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5IHx8ICdjc3MnO1xuICB2YXIgc3R5bGlzT3B0aW9ucztcblxuICBpZiAob3B0aW9ucy5wcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxpc09wdGlvbnMgPSB7XG4gICAgICBwcmVmaXg6IG9wdGlvbnMucHJlZml4XG4gICAgfTtcbiAgfVxuXG4gIHZhciBzdHlsaXMgPSBuZXcgU3R5bGlzKHN0eWxpc09wdGlvbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIGlmICgvW15hLXotXS8udGVzdChrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbW90aW9uIGtleSBtdXN0IG9ubHkgY29udGFpbiBsb3dlciBjYXNlIGFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzIGFuZCAtIGJ1dCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIHBhc3NlZFwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5zZXJ0ZWQgPSB7fTsgLy8gJEZsb3dGaXhNZVxuXG4gIHZhciBjb250YWluZXI7XG5cbiAge1xuICAgIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyIHx8IGRvY3VtZW50LmhlYWQ7XG4gICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlW2RhdGEtZW1vdGlvbi1cIiArIGtleSArIFwiXVwiKTtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGF0dHJpYiA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbW90aW9uLVwiICsga2V5KTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBhdHRyaWIuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpbnNlcnRlZFtpZF0gPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgX2luc2VydDtcblxuICB7XG4gICAgc3R5bGlzLnVzZShvcHRpb25zLnN0eWxpc1BsdWdpbnMpKHJ1bGVTaGVldCk7XG5cbiAgICBfaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0KHNlbGVjdG9yLCBzZXJpYWxpemVkLCBzaGVldCwgc2hvdWxkQ2FjaGUpIHtcbiAgICAgIHZhciBuYW1lID0gc2VyaWFsaXplZC5uYW1lO1xuICAgICAgU2hlZXQuY3VycmVudCA9IHNoZWV0O1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzZXJpYWxpemVkLm1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBtYXAgPSBzZXJpYWxpemVkLm1hcDtcbiAgICAgICAgU2hlZXQuY3VycmVudCA9IHtcbiAgICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgICAgICBzaGVldC5pbnNlcnQocnVsZSArIG1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzdHlsaXMoc2VsZWN0b3IsIHNlcmlhbGl6ZWQuc3R5bGVzKTtcblxuICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgIGNhY2hlLmluc2VydGVkW25hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzViZjczNzFhNGNkN2U2MDA5ZWY2MWQwYVxuICAgIHZhciBjb21tZW50U3RhcnQgPSAvXFwvXFwqL2c7XG4gICAgdmFyIGNvbW1lbnRFbmQgPSAvXFwqXFwvL2c7XG4gICAgc3R5bGlzLnVzZShmdW5jdGlvbiAoY29udGV4dCwgY29udGVudCkge1xuICAgICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgd2hpbGUgKGNvbW1lbnRTdGFydC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgIGNvbW1lbnRFbmQubGFzdEluZGV4ID0gY29tbWVudFN0YXJ0Lmxhc3RJbmRleDtcblxuICAgICAgICAgICAgICBpZiAoY29tbWVudEVuZC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudFN0YXJ0Lmxhc3RJbmRleCA9IGNvbW1lbnRFbmQubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIHN0eWxlcyBoYXZlIGFuIHVudGVybWluYXRlZCBjb21tZW50IChcIi8qXCIgd2l0aG91dCBjb3JyZXNwb25kaW5nIFwiKi9cIikuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbW1lbnRTdGFydC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHN0eWxpcy51c2UoZnVuY3Rpb24gKGNvbnRleHQsIGNvbnRlbnQsIHNlbGVjdG9ycykge1xuICAgICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZsYWcgPSAnZW1vdGlvbi1kaXNhYmxlLXNlcnZlci1yZW5kZXJpbmctdW5zYWZlLXNlbGVjdG9yLXdhcm5pbmctcGxlYXNlLWRvLW5vdC11c2UtdGhpcy10aGUtd2FybmluZy1leGlzdHMtZm9yLWEtcmVhc29uJztcbiAgICAgICAgICAgIHZhciB1bnNhZmVQc2V1ZG9DbGFzc2VzID0gY29udGVudC5tYXRjaCgvKDpmaXJzdHw6bnRofDpudGgtbGFzdCktY2hpbGQvZyk7XG5cbiAgICAgICAgICAgIGlmICh1bnNhZmVQc2V1ZG9DbGFzc2VzICYmIGNhY2hlLmNvbXBhdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB1bnNhZmVQc2V1ZG9DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKHVuc2FmZVBzZXVkb0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlnbm9yZVJlZ0V4cCA9IG5ldyBSZWdFeHAodW5zYWZlUHNldWRvQ2xhc3MgKyBcIi4qXFxcXC9cXFxcKiBcIiArIGZsYWcgKyBcIiBcXFxcKlxcXFwvXCIpO1xuICAgICAgICAgICAgICAgIHZhciBpZ25vcmUgPSBpZ25vcmVSZWdFeHAudGVzdChjb250ZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh1bnNhZmVQc2V1ZG9DbGFzcyAmJiAhaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIHBzZXVkbyBjbGFzcyBcXFwiXCIgKyB1bnNhZmVQc2V1ZG9DbGFzcyArIFwiXFxcIiBpcyBwb3RlbnRpYWxseSB1bnNhZmUgd2hlbiBkb2luZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuIFRyeSBjaGFuZ2luZyBpdCB0byBcXFwiXCIgKyB1bnNhZmVQc2V1ZG9DbGFzcy5zcGxpdCgnLWNoaWxkJylbMF0gKyBcIi1vZi10eXBlXFxcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGNhY2hlID0ge1xuICAgIGtleToga2V5LFxuICAgIHNoZWV0OiBuZXcgU3R5bGVTaGVldCh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgICBzcGVlZHk6IG9wdGlvbnMuc3BlZWR5XG4gICAgfSksXG4gICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgaW5zZXJ0ZWQ6IGluc2VydGVkLFxuICAgIHJlZ2lzdGVyZWQ6IHt9LFxuICAgIGluc2VydDogX2luc2VydFxuICB9O1xuICByZXR1cm4gY2FjaGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDYWNoZTtcbiIsImltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgZm9yd2FyZFJlZiwgY3JlYXRlRWxlbWVudCwgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNyZWF0ZUNhY2hlIGZyb20gJ0BlbW90aW9uL2NhY2hlJztcbmltcG9ydCB7IGdldFJlZ2lzdGVyZWRTdHlsZXMsIGluc2VydFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3V0aWxzJztcbmltcG9ydCB7IHNlcmlhbGl6ZVN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyBTdHlsZVNoZWV0IH0gZnJvbSAnQGVtb3Rpb24vc2hlZXQnO1xuaW1wb3J0IGNzcyBmcm9tICdAZW1vdGlvbi9jc3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuXG52YXIgRW1vdGlvbkNhY2hlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoIC8vIHdlJ3JlIGRvaW5nIHRoaXMgdG8gYXZvaWQgcHJlY29uc3RydWN0J3MgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIGluIHRoaXMgb25lIGNhc2Vcbi8vIGJlY2F1c2UgdGhpcyBtb2R1bGUgaXMgcHJpbWFyaWx5IGludGVuZGVkIGZvciB0aGUgYnJvd3NlciBhbmQgbm9kZVxuLy8gYnV0IGl0J3MgYWxzbyByZXF1aXJlZCBpbiByZWFjdCBuYXRpdmUgYW5kIHNpbWlsYXIgZW52aXJvbm1lbnRzIHNvbWV0aW1lc1xuLy8gYW5kIHdlIGNvdWxkIGhhdmUgYSBzcGVjaWFsIGJ1aWxkIGp1c3QgZm9yIHRoYXRcbi8vIGJ1dCB0aGlzIGlzIG11Y2ggZWFzaWVyIGFuZCB0aGUgbmF0aXZlIHBhY2thZ2VzXG4vLyBtaWdodCB1c2UgYSBkaWZmZXJlbnQgdGhlbWUgY29udGV4dCBpbiB0aGUgZnV0dXJlIGFueXdheVxudHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IGNyZWF0ZUNhY2hlKCkgOiBudWxsKTtcbnZhciBUaGVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbnZhciBDYWNoZVByb3ZpZGVyID0gRW1vdGlvbkNhY2hlQ29udGV4dC5Qcm92aWRlcjtcblxudmFyIHdpdGhFbW90aW9uQ2FjaGUgPSBmdW5jdGlvbiB3aXRoRW1vdGlvbkNhY2hlKGZ1bmMpIHtcbiAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRW1vdGlvbkNhY2hlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICByZXR1cm4gZnVuYyhwcm9wcywgY2FjaGUsIHJlZik7XG4gICAgfSk7XG4gIH07IC8vICRGbG93Rml4TWVcblxuXG4gIHJldHVybiBmb3J3YXJkUmVmKHJlbmRlcik7XG59O1xuXG4vLyB0aHVzIHdlIG9ubHkgbmVlZCB0byByZXBsYWNlIHdoYXQgaXMgYSB2YWxpZCBjaGFyYWN0ZXIgZm9yIEpTLCBidXQgbm90IGZvciBDU1NcblxudmFyIHNhbml0aXplSWRlbnRpZmllciA9IGZ1bmN0aW9uIHNhbml0aXplSWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHJldHVybiBpZGVudGlmaWVyLnJlcGxhY2UoL1xcJC9nLCAnLScpO1xufTtcblxudmFyIHR5cGVQcm9wTmFtZSA9ICdfX0VNT1RJT05fVFlQRV9QTEVBU0VfRE9fTk9UX1VTRV9fJztcbnZhciBsYWJlbFByb3BOYW1lID0gJ19fRU1PVElPTl9MQUJFTF9QTEVBU0VfRE9fTk9UX1VTRV9fJztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2FjaGUsIHByb3BzLCB0aGVtZSwgcmVmKSB7XG4gIHZhciBjc3NQcm9wID0gdGhlbWUgPT09IG51bGwgPyBwcm9wcy5jc3MgOiBwcm9wcy5jc3ModGhlbWUpOyAvLyBzbyB0aGF0IHVzaW5nIGBjc3NgIGZyb20gYGVtb3Rpb25gIGFuZCBwYXNzaW5nIHRoZSByZXN1bHQgdG8gdGhlIGNzcyBwcm9wIHdvcmtzXG4gIC8vIG5vdCBwYXNzaW5nIHRoZSByZWdpc3RlcmVkIGNhY2hlIHRvIHNlcmlhbGl6ZVN0eWxlcyBiZWNhdXNlIGl0IHdvdWxkXG4gIC8vIG1ha2UgY2VydGFpbiBiYWJlbCBvcHRpbWlzYXRpb25zIG5vdCBwb3NzaWJsZVxuXG4gIGlmICh0eXBlb2YgY3NzUHJvcCA9PT0gJ3N0cmluZycgJiYgY2FjaGUucmVnaXN0ZXJlZFtjc3NQcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3NzUHJvcCA9IGNhY2hlLnJlZ2lzdGVyZWRbY3NzUHJvcF07XG4gIH1cblxuICB2YXIgdHlwZSA9IHByb3BzW3R5cGVQcm9wTmFtZV07XG4gIHZhciByZWdpc3RlcmVkU3R5bGVzID0gW2Nzc1Byb3BdO1xuICB2YXIgY2xhc3NOYW1lID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBwcm9wcy5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY2xhc3NOYW1lID0gZ2V0UmVnaXN0ZXJlZFN0eWxlcyhjYWNoZS5yZWdpc3RlcmVkLCByZWdpc3RlcmVkU3R5bGVzLCBwcm9wcy5jbGFzc05hbWUpO1xuICB9IGVsc2UgaWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG4gICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgXCIgXCI7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVN0eWxlcyhyZWdpc3RlcmVkU3R5bGVzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzZXJpYWxpemVkLm5hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHZhciBsYWJlbEZyb21TdGFjayA9IHByb3BzW2xhYmVsUHJvcE5hbWVdO1xuXG4gICAgaWYgKGxhYmVsRnJvbVN0YWNrKSB7XG4gICAgICBzZXJpYWxpemVkID0gc2VyaWFsaXplU3R5bGVzKFtzZXJpYWxpemVkLCAnbGFiZWw6JyArIGxhYmVsRnJvbVN0YWNrICsgJzsnXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJ1bGVzID0gaW5zZXJ0U3R5bGVzKGNhY2hlLCBzZXJpYWxpemVkLCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpO1xuICBjbGFzc05hbWUgKz0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG4gIHZhciBuZXdQcm9wcyA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBrZXkpICYmIGtleSAhPT0gJ2NzcycgJiYga2V5ICE9PSB0eXBlUHJvcE5hbWUgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgfHwga2V5ICE9PSBsYWJlbFByb3BOYW1lKSkge1xuICAgICAgbmV3UHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgfVxuICB9XG5cbiAgbmV3UHJvcHMucmVmID0gcmVmO1xuICBuZXdQcm9wcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gIHZhciBlbGUgPSBjcmVhdGVFbGVtZW50KHR5cGUsIG5ld1Byb3BzKTtcblxuICByZXR1cm4gZWxlO1xufTtcblxudmFyIEVtb3Rpb24gPVxuLyogI19fUFVSRV9fICovXG53aXRoRW1vdGlvbkNhY2hlKGZ1bmN0aW9uIChwcm9wcywgY2FjaGUsIHJlZikge1xuICAvLyB1c2UgQ29udGV4dC5yZWFkIGZvciB0aGUgdGhlbWUgd2hlbiBpdCdzIHN0YWJsZVxuICBpZiAodHlwZW9mIHByb3BzLmNzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFRoZW1lQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgICByZXR1cm4gcmVuZGVyKGNhY2hlLCBwcm9wcywgdGhlbWUsIHJlZik7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyKGNhY2hlLCBwcm9wcywgbnVsbCwgcmVmKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBFbW90aW9uLmRpc3BsYXlOYW1lID0gJ0Vtb3Rpb25Dc3NQcm9wSW50ZXJuYWwnO1xufSAvLyAkRmxvd0ZpeE1lXG5cblxudmFyIGpzeCA9IGZ1bmN0aW9uIGpzeCh0eXBlLCBwcm9wcykge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICBpZiAocHJvcHMgPT0gbnVsbCB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2NzcycpKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgcHJvcHMuY3NzID09PSAnc3RyaW5nJyAmJiAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIGNzcyBkZWNsYXJhdGlvblxuICBwcm9wcy5jc3MuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZ3MgYXJlIG5vdCBhbGxvd2VkIGFzIGNzcyBwcm9wIHZhbHVlcywgcGxlYXNlIHdyYXAgaXQgaW4gYSBjc3MgdGVtcGxhdGUgbGl0ZXJhbCBmcm9tICdAZW1vdGlvbi9jc3MnIGxpa2UgdGhpczogY3NzYFwiICsgcHJvcHMuY3NzICsgXCJgXCIpO1xuICB9XG5cbiAgdmFyIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGNyZWF0ZUVsZW1lbnRBcmdBcnJheSA9IG5ldyBBcnJheShhcmdzTGVuZ3RoKTtcbiAgY3JlYXRlRWxlbWVudEFyZ0FycmF5WzBdID0gRW1vdGlvbjtcbiAgdmFyIG5ld1Byb3BzID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIGtleSkpIHtcbiAgICAgIG5ld1Byb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIG5ld1Byb3BzW3R5cGVQcm9wTmFtZV0gPSB0eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG5cbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgIC8vIGNocm9tZVxuICAgICAgdmFyIG1hdGNoID0gZXJyb3Iuc3RhY2subWF0Y2goL2F0ICg/Ok9iamVjdFxcLnwpanN4LipcXG5cXHMrYXQgKFtBLVpdW0EtWmEteiRdKykgLyk7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgLy8gc2FmYXJpIGFuZCBmaXJlZm94XG4gICAgICAgIG1hdGNoID0gZXJyb3Iuc3RhY2subWF0Y2goLy4qXFxuKFtBLVpdW0EtWmEteiRdKylALyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBuZXdQcm9wc1tsYWJlbFByb3BOYW1lXSA9IHNhbml0aXplSWRlbnRpZmllcihtYXRjaFsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRWxlbWVudEFyZ0FycmF5WzFdID0gbmV3UHJvcHM7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIHtcbiAgICBjcmVhdGVFbGVtZW50QXJnQXJyYXlbaV0gPSBhcmdzW2ldO1xuICB9IC8vICRGbG93Rml4TWVcblxuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KG51bGwsIGNyZWF0ZUVsZW1lbnRBcmdBcnJheSk7XG59O1xuXG52YXIgd2FybmVkQWJvdXRDc3NQcm9wRm9yR2xvYmFsID0gZmFsc2U7XG52YXIgR2xvYmFsID1cbi8qICNfX1BVUkVfXyAqL1xud2l0aEVtb3Rpb25DYWNoZShmdW5jdGlvbiAocHJvcHMsIGNhY2hlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF3YXJuZWRBYm91dENzc1Byb3BGb3JHbG9iYWwgJiYgKCAvLyBjaGVjayBmb3IgY2xhc3NOYW1lIGFzIHdlbGwgc2luY2UgdGhlIHVzZXIgaXNcbiAgLy8gcHJvYmFibHkgdXNpbmcgdGhlIGN1c3RvbSBjcmVhdGVFbGVtZW50IHdoaWNoXG4gIC8vIG1lYW5zIGl0IHdpbGwgYmUgdHVybmVkIGludG8gYSBjbGFzc05hbWUgcHJvcFxuICAvLyAkRmxvd0ZpeE1lIEkgZG9uJ3QgcmVhbGx5IHdhbnQgdG8gYWRkIGl0IHRvIHRoZSB0eXBlIHNpbmNlIGl0IHNob3VsZG4ndCBiZSB1c2VkXG4gIHByb3BzLmNsYXNzTmFtZSB8fCBwcm9wcy5jc3MpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBjc3MgcHJvcCBvbiBHbG9iYWwsIGRpZCB5b3UgbWVhbiB0byB1c2UgdGhlIHN0eWxlcyBwcm9wIGluc3RlYWQ/XCIpO1xuICAgIHdhcm5lZEFib3V0Q3NzUHJvcEZvckdsb2JhbCA9IHRydWU7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gcHJvcHMuc3R5bGVzO1xuXG4gIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVGhlbWVDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0gc2VyaWFsaXplU3R5bGVzKFtzdHlsZXModGhlbWUpXSk7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChJbm5lckdsb2JhbCwge1xuICAgICAgICBzZXJpYWxpemVkOiBzZXJpYWxpemVkLFxuICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVTdHlsZXMoW3N0eWxlc10pO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChJbm5lckdsb2JhbCwge1xuICAgIHNlcmlhbGl6ZWQ6IHNlcmlhbGl6ZWQsXG4gICAgY2FjaGU6IGNhY2hlXG4gIH0pO1xufSk7XG5cbi8vIG1haW50YWluIHBsYWNlIG92ZXIgcmVyZW5kZXJzLlxuLy8gaW5pdGlhbCByZW5kZXIgZnJvbSBicm93c2VyLCBpbnNlcnRCZWZvcmUgY29udGV4dC5zaGVldC50YWdzWzBdIG9yIGlmIGEgc3R5bGUgaGFzbid0IGJlZW4gaW5zZXJ0ZWQgdGhlcmUgeWV0LCBhcHBlbmRDaGlsZFxuLy8gaW5pdGlhbCBjbGllbnQtc2lkZSByZW5kZXIgZnJvbSBTU1IsIHVzZSBwbGFjZSBvZiBoeWRyYXRpbmcgdGFnXG52YXIgSW5uZXJHbG9iYWwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5uZXJHbG9iYWwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIElubmVyR2xvYmFsKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCwgdXBkYXRlcikgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbm5lckdsb2JhbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zaGVldCA9IG5ldyBTdHlsZVNoZWV0KHtcbiAgICAgIGtleTogdGhpcy5wcm9wcy5jYWNoZS5rZXkgKyBcIi1nbG9iYWxcIixcbiAgICAgIG5vbmNlOiB0aGlzLnByb3BzLmNhY2hlLnNoZWV0Lm5vbmNlLFxuICAgICAgY29udGFpbmVyOiB0aGlzLnByb3BzLmNhY2hlLnNoZWV0LmNvbnRhaW5lclxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVtkYXRhLWVtb3Rpb24tXCIgKyB0aGlzLnByb3BzLmNhY2hlLmtleSArIFwiPVxcXCJcIiArIHRoaXMucHJvcHMuc2VyaWFsaXplZC5uYW1lICsgXCJcXFwiXVwiKTtcblxuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNoZWV0LnRhZ3MucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5jYWNoZS5zaGVldC50YWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5zaGVldC5iZWZvcmUgPSB0aGlzLnByb3BzLmNhY2hlLnNoZWV0LnRhZ3NbMF07XG4gICAgfVxuXG4gICAgdGhpcy5pbnNlcnRTdHlsZXMoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmIChwcmV2UHJvcHMuc2VyaWFsaXplZC5uYW1lICE9PSB0aGlzLnByb3BzLnNlcmlhbGl6ZWQubmFtZSkge1xuICAgICAgdGhpcy5pbnNlcnRTdHlsZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmluc2VydFN0eWxlcyA9IGZ1bmN0aW9uIGluc2VydFN0eWxlcyQxKCkge1xuICAgIGlmICh0aGlzLnByb3BzLnNlcmlhbGl6ZWQubmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBpbnNlcnQga2V5ZnJhbWVzXG4gICAgICBpbnNlcnRTdHlsZXModGhpcy5wcm9wcy5jYWNoZSwgdGhpcy5wcm9wcy5zZXJpYWxpemVkLm5leHQsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNoZWV0LnRhZ3MubGVuZ3RoKSB7XG4gICAgICAvLyBpZiB0aGlzIGRvZXNuJ3QgZXhpc3QgdGhlbiBpdCB3aWxsIGJlIG51bGwgc28gdGhlIHN0eWxlIGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZFxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnNoZWV0LnRhZ3NbdGhpcy5zaGVldC50YWdzLmxlbmd0aCAtIDFdLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIHRoaXMuc2hlZXQuYmVmb3JlID0gZWxlbWVudDtcbiAgICAgIHRoaXMuc2hlZXQuZmx1c2goKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLmNhY2hlLmluc2VydChcIlwiLCB0aGlzLnByb3BzLnNlcmlhbGl6ZWQsIHRoaXMuc2hlZXQsIGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnNoZWV0LmZsdXNoKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBJbm5lckdsb2JhbDtcbn0oQ29tcG9uZW50KTtcblxudmFyIGtleWZyYW1lcyA9IGZ1bmN0aW9uIGtleWZyYW1lcygpIHtcbiAgdmFyIGluc2VydGFibGUgPSBjc3MuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB2YXIgbmFtZSA9IFwiYW5pbWF0aW9uLVwiICsgaW5zZXJ0YWJsZS5uYW1lOyAvLyAkRmxvd0ZpeE1lXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHN0eWxlczogXCJAa2V5ZnJhbWVzIFwiICsgbmFtZSArIFwie1wiICsgaW5zZXJ0YWJsZS5zdHlsZXMgKyBcIn1cIixcbiAgICBhbmltOiAxLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIl9FTU9fXCIgKyB0aGlzLm5hbWUgKyBcIl9cIiArIHRoaXMuc3R5bGVzICsgXCJfRU1PX1wiO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBjbGFzc25hbWVzID0gZnVuY3Rpb24gY2xhc3NuYW1lcyhhcmdzKSB7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgY2xzID0gJyc7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgIGlmIChhcmcgPT0gbnVsbCkgY29udGludWU7XG4gICAgdmFyIHRvQWRkID0gdm9pZCAwO1xuXG4gICAgc3dpdGNoICh0eXBlb2YgYXJnKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0b0FkZCA9IGNsYXNzbmFtZXMoYXJnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9BZGQgPSAnJztcblxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ1trXSAmJiBrKSB7XG4gICAgICAgICAgICAgICAgdG9BZGQgJiYgKHRvQWRkICs9ICcgJyk7XG4gICAgICAgICAgICAgICAgdG9BZGQgKz0gaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0b0FkZCA9IGFyZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b0FkZCkge1xuICAgICAgY2xzICYmIChjbHMgKz0gJyAnKTtcbiAgICAgIGNscyArPSB0b0FkZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xzO1xufTtcblxuZnVuY3Rpb24gbWVyZ2UocmVnaXN0ZXJlZCwgY3NzLCBjbGFzc05hbWUpIHtcbiAgdmFyIHJlZ2lzdGVyZWRTdHlsZXMgPSBbXTtcbiAgdmFyIHJhd0NsYXNzTmFtZSA9IGdldFJlZ2lzdGVyZWRTdHlsZXMocmVnaXN0ZXJlZCwgcmVnaXN0ZXJlZFN0eWxlcywgY2xhc3NOYW1lKTtcblxuICBpZiAocmVnaXN0ZXJlZFN0eWxlcy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIHJldHVybiByYXdDbGFzc05hbWUgKyBjc3MocmVnaXN0ZXJlZFN0eWxlcyk7XG59XG5cbnZhciBDbGFzc05hbWVzID0gd2l0aEVtb3Rpb25DYWNoZShmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVGhlbWVDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICB2YXIgaGFzUmVuZGVyZWQgPSBmYWxzZTtcblxuICAgIHZhciBjc3MgPSBmdW5jdGlvbiBjc3MoKSB7XG4gICAgICBpZiAoaGFzUmVuZGVyZWQgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NzcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyByZW5kZXInKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpYWxpemVkID0gc2VyaWFsaXplU3R5bGVzKGFyZ3MsIGNvbnRleHQucmVnaXN0ZXJlZCk7XG5cbiAgICAgIHtcbiAgICAgICAgaW5zZXJ0U3R5bGVzKGNvbnRleHQsIHNlcmlhbGl6ZWQsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG4gICAgfTtcblxuICAgIHZhciBjeCA9IGZ1bmN0aW9uIGN4KCkge1xuICAgICAgaWYgKGhhc1JlbmRlcmVkICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjeCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyByZW5kZXInKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlKGNvbnRleHQucmVnaXN0ZXJlZCwgY3NzLCBjbGFzc25hbWVzKGFyZ3MpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICBjc3M6IGNzcyxcbiAgICAgIGN4OiBjeCxcbiAgICAgIHRoZW1lOiB0aGVtZVxuICAgIH07XG4gICAgdmFyIGVsZSA9IHByb3BzLmNoaWxkcmVuKGNvbnRlbnQpO1xuICAgIGhhc1JlbmRlcmVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBlbGU7XG4gIH0pO1xufSk7XG5cbmV4cG9ydCB7IENhY2hlUHJvdmlkZXIsIENsYXNzTmFtZXMsIEdsb2JhbCwgVGhlbWVDb250ZXh0LCBqc3gsIGtleWZyYW1lcywgd2l0aEVtb3Rpb25DYWNoZSB9O1xuIiwiaW1wb3J0IHsgc2VyaWFsaXplU3R5bGVzIH0gZnJvbSAnQGVtb3Rpb24vc2VyaWFsaXplJztcblxuZnVuY3Rpb24gY3NzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZVN0eWxlcyhhcmdzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3NzO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvbXVybXVyaGFzaC1qc1xuLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FhcHBsZWJ5L3NtaGFzaGVyL2Jsb2IvNjFhMDUzMGYyODI3N2YyZTg1MGJmYzM5NjAwY2U2MWQwMmI1MThkZS9zcmMvTXVybXVySGFzaDIuY3BwI0wzNy1MODZcbmZ1bmN0aW9uIG11cm11cjIoc3RyKSB7XG4gIC8vICdtJyBhbmQgJ3InIGFyZSBtaXhpbmcgY29uc3RhbnRzIGdlbmVyYXRlZCBvZmZsaW5lLlxuICAvLyBUaGV5J3JlIG5vdCByZWFsbHkgJ21hZ2ljJywgdGhleSBqdXN0IGhhcHBlbiB0byB3b3JrIHdlbGwuXG4gIC8vIGNvbnN0IG0gPSAweDViZDFlOTk1O1xuICAvLyBjb25zdCByID0gMjQ7XG4gIC8vIEluaXRpYWxpemUgdGhlIGhhc2hcbiAgdmFyIGggPSAwOyAvLyBNaXggNCBieXRlcyBhdCBhIHRpbWUgaW50byB0aGUgaGFzaFxuXG4gIHZhciBrLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAoOyBsZW4gPj0gNDsgKytpLCBsZW4gLT0gNCkge1xuICAgIGsgPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDggfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDE2IHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAyNDtcbiAgICBrID1cbiAgICAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoayA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KTtcbiAgICBrIF49XG4gICAgLyogayA+Pj4gcjogKi9cbiAgICBrID4+PiAyNDtcbiAgICBoID1cbiAgICAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoayA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KSBeXG4gICAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAgIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIH0gLy8gSGFuZGxlIHRoZSBsYXN0IGZldyBieXRlcyBvZiB0aGUgaW5wdXQgYXJyYXlcblxuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAzOlxuICAgICAgaCBePSAoc3RyLmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG5cbiAgICBjYXNlIDI6XG4gICAgICBoIF49IChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4O1xuXG4gICAgY2FzZSAxOlxuICAgICAgaCBePSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgICBoID1cbiAgICAgIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgICAgIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIH0gLy8gRG8gYSBmZXcgZmluYWwgbWl4ZXMgb2YgdGhlIGhhc2ggdG8gZW5zdXJlIHRoZSBsYXN0IGZld1xuICAvLyBieXRlcyBhcmUgd2VsbC1pbmNvcnBvcmF0ZWQuXG5cblxuICBoIF49IGggPj4+IDEzO1xuICBoID1cbiAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChoID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICByZXR1cm4gKChoIF4gaCA+Pj4gMTUpID4+PiAwKS50b1N0cmluZygzNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG11cm11cjI7XG4iLCJmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChjYWNoZVthcmddID09PSB1bmRlZmluZWQpIGNhY2hlW2FyZ10gPSBmbihhcmcpO1xuICAgIHJldHVybiBjYWNoZVthcmddO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IGhhc2hTdHJpbmcgZnJvbSAnQGVtb3Rpb24vaGFzaCc7XG5pbXBvcnQgdW5pdGxlc3MgZnJvbSAnQGVtb3Rpb24vdW5pdGxlc3MnO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnQGVtb3Rpb24vbWVtb2l6ZSc7XG5cbnZhciBJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiA9IFwiWW91IGhhdmUgaWxsZWdhbCBlc2NhcGUgc2VxdWVuY2UgaW4geW91ciB0ZW1wbGF0ZSBsaXRlcmFsLCBtb3N0IGxpa2VseSBpbnNpZGUgY29udGVudCdzIHByb3BlcnR5IHZhbHVlLlxcbkJlY2F1c2UgeW91IHdyaXRlIHlvdXIgQ1NTIGluc2lkZSBhIEphdmFTY3JpcHQgc3RyaW5nIHlvdSBhY3R1YWxseSBoYXZlIHRvIGRvIGRvdWJsZSBlc2NhcGluZywgc28gZm9yIGV4YW1wbGUgXFxcImNvbnRlbnQ6ICdcXFxcMDBkNyc7XFxcIiBzaG91bGQgYmVjb21lIFxcXCJjb250ZW50OiAnXFxcXFxcXFwwMGQ3JztcXFwiLlxcbllvdSBjYW4gcmVhZCBtb3JlIGFib3V0IHRoaXMgaGVyZTpcXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9UZW1wbGF0ZV9saXRlcmFscyNFUzIwMThfcmV2aXNpb25fb2ZfaWxsZWdhbF9lc2NhcGVfc2VxdWVuY2VzXCI7XG52YXIgVU5ERUZJTkVEX0FTX09CSkVDVF9LRVlfRVJST1IgPSBcIllvdSBoYXZlIHBhc3NlZCBpbiBmYWxzeSB2YWx1ZSBhcyBzdHlsZSBvYmplY3QncyBrZXkgKGNhbiBoYXBwZW4gd2hlbiBpbiBleGFtcGxlIHlvdSBwYXNzIHVuZXhwb3J0ZWQgY29tcG9uZW50IGFzIGNvbXB1dGVkIGtleSkuXCI7XG52YXIgaHlwaGVuYXRlUmVnZXggPSAvW0EtWl18Xm1zL2c7XG52YXIgYW5pbWF0aW9uUmVnZXggPSAvX0VNT18oW15fXSs/KV8oW15dKj8pX0VNT18vZztcblxudmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBmdW5jdGlvbiBpc0N1c3RvbVByb3BlcnR5KHByb3BlcnR5KSB7XG4gIHJldHVybiBwcm9wZXJ0eS5jaGFyQ29kZUF0KDEpID09PSA0NTtcbn07XG5cbnZhciBpc1Byb2Nlc3NhYmxlVmFsdWUgPSBmdW5jdGlvbiBpc1Byb2Nlc3NhYmxlVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbic7XG59O1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemUoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaXNDdXN0b21Qcm9wZXJ0eShzdHlsZU5hbWUpID8gc3R5bGVOYW1lIDogc3R5bGVOYW1lLnJlcGxhY2UoaHlwaGVuYXRlUmVnZXgsICctJCYnKS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbnZhciBwcm9jZXNzU3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NTdHlsZVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlICdhbmltYXRpb24nOlxuICAgIGNhc2UgJ2FuaW1hdGlvbk5hbWUnOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKGFuaW1hdGlvblJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIHAxLCBwMikge1xuICAgICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgICBuYW1lOiBwMSxcbiAgICAgICAgICAgICAgc3R5bGVzOiBwMixcbiAgICAgICAgICAgICAgbmV4dDogY3Vyc29yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHAxO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBpZiAodW5pdGxlc3Nba2V5XSAhPT0gMSAmJiAhaXNDdXN0b21Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGNvbnRlbnRWYWx1ZVBhdHRlcm4gPSAvKGF0dHJ8Y2FsY3xjb3VudGVycz98dXJsKVxcKC87XG4gIHZhciBjb250ZW50VmFsdWVzID0gWydub3JtYWwnLCAnbm9uZScsICdjb3VudGVyJywgJ29wZW4tcXVvdGUnLCAnY2xvc2UtcXVvdGUnLCAnbm8tb3Blbi1xdW90ZScsICduby1jbG9zZS1xdW90ZScsICdpbml0aWFsJywgJ2luaGVyaXQnLCAndW5zZXQnXTtcbiAgdmFyIG9sZFByb2Nlc3NTdHlsZVZhbHVlID0gcHJvY2Vzc1N0eWxlVmFsdWU7XG4gIHZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG4gIHZhciBoeXBoZW5hdGVkQ2FjaGUgPSB7fTtcblxuICBwcm9jZXNzU3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIHByb2Nlc3NTdHlsZVZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IGNvbnRlbnRWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xICYmICFjb250ZW50VmFsdWVQYXR0ZXJuLnRlc3QodmFsdWUpICYmICh2YWx1ZS5jaGFyQXQoMCkgIT09IHZhbHVlLmNoYXJBdCh2YWx1ZS5sZW5ndGggLSAxKSB8fCB2YWx1ZS5jaGFyQXQoMCkgIT09ICdcIicgJiYgdmFsdWUuY2hhckF0KDApICE9PSBcIidcIikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBzZWVtIHRvIGJlIHVzaW5nIGEgdmFsdWUgZm9yICdjb250ZW50JyB3aXRob3V0IHF1b3RlcywgdHJ5IHJlcGxhY2luZyBpdCB3aXRoIGBjb250ZW50OiAnXFxcIlwiICsgdmFsdWUgKyBcIlxcXCInYFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvY2Vzc2VkID0gb2xkUHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAocHJvY2Vzc2VkICE9PSAnJyAmJiAhaXNDdXN0b21Qcm9wZXJ0eShrZXkpICYmIGtleS5pbmRleE9mKCctJykgIT09IC0xICYmIGh5cGhlbmF0ZWRDYWNoZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGh5cGhlbmF0ZWRDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVc2luZyBrZWJhYi1jYXNlIGZvciBjc3MgcHJvcGVydGllcyBpbiBvYmplY3RzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiBcIiArIGtleS5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKHN0ciwgX2NoYXIpIHtcbiAgICAgICAgcmV0dXJuIF9jaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KSArIFwiP1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICB9O1xufVxuXG52YXIgc2hvdWxkV2FybkFib3V0SW50ZXJwb2xhdGluZ0NsYXNzTmFtZUZyb21Dc3MgPSB0cnVlO1xuXG5mdW5jdGlvbiBoYW5kbGVJbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBpbnRlcnBvbGF0aW9uLCBjb3VsZEJlU2VsZWN0b3JJbnRlcnBvbGF0aW9uKSB7XG4gIGlmIChpbnRlcnBvbGF0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoaW50ZXJwb2xhdGlvbi5fX2Vtb3Rpb25fc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbnRlcnBvbGF0aW9uLnRvU3RyaW5nKCkgPT09ICdOT19DT01QT05FTlRfU0VMRUNUT1InKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBzZWxlY3RvcnMgY2FuIG9ubHkgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGJhYmVsLXBsdWdpbi1lbW90aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgaW50ZXJwb2xhdGlvbikge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbi5hbmltID09PSAxKSB7XG4gICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgbmFtZTogaW50ZXJwb2xhdGlvbi5uYW1lLFxuICAgICAgICAgICAgc3R5bGVzOiBpbnRlcnBvbGF0aW9uLnN0eWxlcyxcbiAgICAgICAgICAgIG5leHQ6IGN1cnNvclxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRpb24ubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uLnN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnRlcnBvbGF0aW9uLm5leHQ7XG5cbiAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIG1vc3QgZWZmaWNpZW50IHRoaW5nIGV2ZXIgYnV0IHRoaXMgaXMgYSBwcmV0dHkgcmFyZSBjYXNlXG4gICAgICAgICAgICAvLyBhbmQgdGhlcmUgd2lsbCBiZSB2ZXJ5IGZldyBpdGVyYXRpb25zIG9mIHRoaXMgZ2VuZXJhbGx5XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuZXh0Lm5hbWUsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBuZXh0LnN0eWxlcyxcbiAgICAgICAgICAgICAgICBuZXh0OiBjdXJzb3JcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3R5bGVzID0gaW50ZXJwb2xhdGlvbi5zdHlsZXMgKyBcIjtcIjtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24ubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSBpbnRlcnBvbGF0aW9uLm1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0Zyb21PYmplY3QobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGludGVycG9sYXRpb24pO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICBpZiAobWVyZ2VkUHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwcmV2aW91c0N1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gaW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcyk7XG4gICAgICAgICAgY3Vyc29yID0gcHJldmlvdXNDdXJzb3I7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHJlc3VsdCwgY291bGRCZVNlbGVjdG9ySW50ZXJwb2xhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Z1bmN0aW9ucyB0aGF0IGFyZSBpbnRlcnBvbGF0ZWQgaW4gY3NzIGNhbGxzIHdpbGwgYmUgc3RyaW5naWZpZWQuXFxuJyArICdJZiB5b3Ugd2FudCB0byBoYXZlIGEgY3NzIGNhbGwgYmFzZWQgb24gcHJvcHMsIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNzcyBjYWxsIGxpa2UgdGhpc1xcbicgKyAnbGV0IGR5bmFtaWNTdHlsZSA9IChwcm9wcykgPT4gY3NzYGNvbG9yOiAke3Byb3BzLmNvbG9yfWBcXG4nICsgJ0l0IGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgd2l0aCBwcm9wcyBvciBpbnRlcnBvbGF0ZWQgaW4gYSBzdHlsZWQgY2FsbCBsaWtlIHRoaXNcXG4nICsgXCJsZXQgU29tZUNvbXBvbmVudCA9IHN0eWxlZCgnZGl2JylgJHtkeW5hbWljU3R5bGV9YFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gW107XG4gICAgICAgIHZhciByZXBsYWNlZCA9IGludGVycG9sYXRpb24ucmVwbGFjZShhbmltYXRpb25SZWdleCwgZnVuY3Rpb24gKG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgICAgICB2YXIgZmFrZVZhck5hbWUgPSBcImFuaW1hdGlvblwiICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKFwiY29uc3QgXCIgKyBmYWtlVmFyTmFtZSArIFwiID0ga2V5ZnJhbWVzYFwiICsgcDIucmVwbGFjZSgvXkBrZXlmcmFtZXMgYW5pbWF0aW9uLVxcdysvLCAnJykgKyBcImBcIik7XG4gICAgICAgICAgcmV0dXJuIFwiJHtcIiArIGZha2VWYXJOYW1lICsgXCJ9XCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2BrZXlmcmFtZXNgIG91dHB1dCBnb3QgaW50ZXJwb2xhdGVkIGludG8gcGxhaW4gc3RyaW5nLCBwbGVhc2Ugd3JhcCBpdCB3aXRoIGBjc3NgLlxcblxcbicgKyAnSW5zdGVhZCBvZiBkb2luZyB0aGlzOlxcblxcbicgKyBbXS5jb25jYXQobWF0Y2hlZCwgW1wiYFwiICsgcmVwbGFjZWQgKyBcImBcIl0pLmpvaW4oJ1xcbicpICsgJ1xcblxcbllvdSBzaG91bGQgd3JhcCBpdCB3aXRoIGBjc3NgIGxpa2UgdGhpczpcXG5cXG4nICsgKFwiY3NzYFwiICsgcmVwbGFjZWQgKyBcImBcIikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9IC8vIGZpbmFsaXplIHN0cmluZyB2YWx1ZXMgKHJlZ3VsYXIgc3RyaW5ncyBhbmQgZnVuY3Rpb25zIGludGVycG9sYXRlZCBpbnRvIGNzcyBjYWxscylcblxuXG4gIGlmIChyZWdpc3RlcmVkID09IG51bGwpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHZhciBjYWNoZWQgPSByZWdpc3RlcmVkW2ludGVycG9sYXRpb25dO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvdWxkQmVTZWxlY3RvckludGVycG9sYXRpb24gJiYgc2hvdWxkV2FybkFib3V0SW50ZXJwb2xhdGluZ0NsYXNzTmFtZUZyb21Dc3MgJiYgY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLmVycm9yKCdJbnRlcnBvbGF0aW5nIGEgY2xhc3NOYW1lIGZyb20gY3NzYGAgaXMgbm90IHJlY29tbWVuZGVkIGFuZCB3aWxsIGNhdXNlIHByb2JsZW1zIHdpdGggY29tcG9zaXRpb24uXFxuJyArICdJbnRlcnBvbGF0aW5nIGEgY2xhc3NOYW1lIGZyb20gY3NzYGAgd2lsbCBiZSBjb21wbGV0ZWx5IHVuc3VwcG9ydGVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24gb2YgRW1vdGlvbicpO1xuICAgIHNob3VsZFdhcm5BYm91dEludGVycG9sYXRpbmdDbGFzc05hbWVGcm9tQ3NzID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY2FjaGVkICE9PSB1bmRlZmluZWQgJiYgIWNvdWxkQmVTZWxlY3RvckludGVycG9sYXRpb24gPyBjYWNoZWQgOiBpbnRlcnBvbGF0aW9uO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdGcm9tT2JqZWN0KG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBvYmopIHtcbiAgdmFyIHN0cmluZyA9ICcnO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgc3RyaW5nICs9IGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIG9ialtpXSwgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW19rZXldO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZCAhPSBudWxsICYmIHJlZ2lzdGVyZWRbdmFsdWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJpbmcgKz0gX2tleSArIFwie1wiICsgcmVnaXN0ZXJlZFt2YWx1ZV0gKyBcIn1cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb2Nlc3NhYmxlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHByb2Nlc3NTdHlsZU5hbWUoX2tleSkgKyBcIjpcIiArIHByb2Nlc3NTdHlsZVZhbHVlKF9rZXksIHZhbHVlKSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX2tleSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHNlbGVjdG9ycyBjYW4gb25seSBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYmFiZWwtcGx1Z2luLWVtb3Rpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlWzBdID09PSAnc3RyaW5nJyAmJiAocmVnaXN0ZXJlZCA9PSBudWxsIHx8IHJlZ2lzdGVyZWRbdmFsdWVbMF1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHZhbHVlLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2FibGVWYWx1ZSh2YWx1ZVtfaV0pKSB7XG4gICAgICAgICAgICAgIHN0cmluZyArPSBwcm9jZXNzU3R5bGVOYW1lKF9rZXkpICsgXCI6XCIgKyBwcm9jZXNzU3R5bGVWYWx1ZShfa2V5LCB2YWx1ZVtfaV0pICsgXCI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZWQgPSBoYW5kbGVJbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCB2YWx1ZSwgZmFsc2UpO1xuXG4gICAgICAgICAgc3dpdGNoIChfa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnYW5pbWF0aW9uTmFtZSc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZShfa2V5KSArIFwiOlwiICsgaW50ZXJwb2xhdGVkICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF9rZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFVOREVGSU5FRF9BU19PQkpFQ1RfS0VZX0VSUk9SKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gX2tleSArIFwie1wiICsgaW50ZXJwb2xhdGVkICsgXCJ9XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgbGFiZWxQYXR0ZXJuID0gL2xhYmVsOlxccyooW15cXHM7XFxue10rKVxccyo7L2c7XG52YXIgc291cmNlTWFwUGF0dGVybjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc291cmNlTWFwUGF0dGVybiA9IC9cXC9cXCojXFxzc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtcXFMrXFxzK1xcKlxcLy87XG59IC8vIHRoaXMgaXMgdGhlIGN1cnNvciBmb3Iga2V5ZnJhbWVzXG4vLyBrZXlmcmFtZXMgYXJlIHN0b3JlZCBvbiB0aGUgU2VyaWFsaXplZFN0eWxlcyBvYmplY3QgYXMgYSBsaW5rZWQgbGlzdFxuXG5cbnZhciBjdXJzb3I7XG52YXIgc2VyaWFsaXplU3R5bGVzID0gZnVuY3Rpb24gc2VyaWFsaXplU3R5bGVzKGFyZ3MsIHJlZ2lzdGVyZWQsIG1lcmdlZFByb3BzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgYXJnc1swXSAhPT0gbnVsbCAmJiBhcmdzWzBdLnN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIH1cblxuICB2YXIgc3RyaW5nTW9kZSA9IHRydWU7XG4gIHZhciBzdHlsZXMgPSAnJztcbiAgY3Vyc29yID0gdW5kZWZpbmVkO1xuICB2YXIgc3RyaW5ncyA9IGFyZ3NbMF07XG5cbiAgaWYgKHN0cmluZ3MgPT0gbnVsbCB8fCBzdHJpbmdzLnJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaW5nTW9kZSA9IGZhbHNlO1xuICAgIHN0eWxlcyArPSBoYW5kbGVJbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBzdHJpbmdzLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RyaW5nc1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SKTtcbiAgICB9XG5cbiAgICBzdHlsZXMgKz0gc3RyaW5nc1swXTtcbiAgfSAvLyB3ZSBzdGFydCBhdCAxIHNpbmNlIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgZmlyc3QgYXJnXG5cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdHlsZXMgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgYXJnc1tpXSwgc3R5bGVzLmNoYXJDb2RlQXQoc3R5bGVzLmxlbmd0aCAtIDEpID09PSA0Nik7XG5cbiAgICBpZiAoc3RyaW5nTW9kZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RyaW5nc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXMgKz0gc3RyaW5nc1tpXTtcbiAgICB9XG4gIH1cblxuICB2YXIgc291cmNlTWFwO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgc3R5bGVzID0gc3R5bGVzLnJlcGxhY2Uoc291cmNlTWFwUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICBzb3VyY2VNYXAgPSBtYXRjaDtcbiAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgfSAvLyB1c2luZyBhIGdsb2JhbCByZWdleCB3aXRoIC5leGVjIGlzIHN0YXRlZnVsIHNvIGxhc3RJbmRleCBoYXMgdG8gYmUgcmVzZXQgZWFjaCB0aW1lXG5cblxuICBsYWJlbFBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgdmFyIGlkZW50aWZpZXJOYW1lID0gJyc7XG4gIHZhciBtYXRjaDsgLy8gaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81YjgwOWMyY2YyOTQ5ODAwYTBmNjFmYjVcblxuICB3aGlsZSAoKG1hdGNoID0gbGFiZWxQYXR0ZXJuLmV4ZWMoc3R5bGVzKSkgIT09IG51bGwpIHtcbiAgICBpZGVudGlmaWVyTmFtZSArPSAnLScgKyAvLyAkRmxvd0ZpeE1lIHdlIGtub3cgaXQncyBub3QgbnVsbFxuICAgIG1hdGNoWzFdO1xuICB9XG5cbiAgdmFyIG5hbWUgPSBoYXNoU3RyaW5nKHN0eWxlcykgKyBpZGVudGlmaWVyTmFtZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWUgU2VyaWFsaXplZFN0eWxlcyB0eXBlIGRvZXNuJ3QgaGF2ZSB0b1N0cmluZyBwcm9wZXJ0eSAoYW5kIHdlIGRvbid0IHdhbnQgdG8gYWRkIGl0KVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICBtYXA6IHNvdXJjZU1hcCxcbiAgICAgIG5leHQ6IGN1cnNvcixcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiWW91IGhhdmUgdHJpZWQgdG8gc3RyaW5naWZ5IG9iamVjdCByZXR1cm5lZCBmcm9tIGBjc3NgIGZ1bmN0aW9uLiBJdCBpc24ndCBzdXBwb3NlZCB0byBiZSB1c2VkIGRpcmVjdGx5IChlLmcuIGFzIHZhbHVlIG9mIHRoZSBgY2xhc3NOYW1lYCBwcm9wKSwgYnV0IHJhdGhlciBoYW5kZWQgdG8gZW1vdGlvbiBzbyBpdCBjYW4gaGFuZGxlIGl0IChlLmcuIGFzIHZhbHVlIG9mIGBjc3NgIHByb3ApLlwiO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgbmV4dDogY3Vyc29yXG4gIH07XG59O1xuXG5leHBvcnQgeyBzZXJpYWxpemVTdHlsZXMgfTtcbiIsIi8qXG5cbkJhc2VkIG9mZiBnbGFtb3IncyBTdHlsZVNoZWV0LCB0aGFua3MgU3VuaWwg4p2k77iPXG5cbmhpZ2ggcGVyZm9ybWFuY2UgU3R5bGVTaGVldCBmb3IgY3NzLWluLWpzIHN5c3RlbXNcblxuLSB1c2VzIG11bHRpcGxlIHN0eWxlIHRhZ3MgYmVoaW5kIHRoZSBzY2VuZXMgZm9yIG1pbGxpb25zIG9mIHJ1bGVzXG4tIHVzZXMgYGluc2VydFJ1bGVgIGZvciBhcHBlbmRpbmcgaW4gcHJvZHVjdGlvbiBmb3IgKm11Y2gqIGZhc3RlciBwZXJmb3JtYW5jZVxuXG4vLyB1c2FnZVxuXG5pbXBvcnQgeyBTdHlsZVNoZWV0IH0gZnJvbSAnQGVtb3Rpb24vc2hlZXQnXG5cbmxldCBzdHlsZVNoZWV0ID0gbmV3IFN0eWxlU2hlZXQoeyBrZXk6ICcnLCBjb250YWluZXI6IGRvY3VtZW50LmhlYWQgfSlcblxuc3R5bGVTaGVldC5pbnNlcnQoJyNib3ggeyBib3JkZXI6IDFweCBzb2xpZCByZWQ7IH0nKVxuLSBhcHBlbmRzIGEgY3NzIHJ1bGUgaW50byB0aGUgc3R5bGVzaGVldFxuXG5zdHlsZVNoZWV0LmZsdXNoKClcbi0gZW1wdGllcyB0aGUgc3R5bGVzaGVldCBvZiBhbGwgaXRzIGNvbnRlbnRzXG5cbiovXG4vLyAkRmxvd0ZpeE1lXG5mdW5jdGlvbiBzaGVldEZvclRhZyh0YWcpIHtcbiAgaWYgKHRhZy5zaGVldCkge1xuICAgIC8vICRGbG93Rml4TWVcbiAgICByZXR1cm4gdGFnLnNoZWV0O1xuICB9IC8vIHRoaXMgd2VpcmRuZXNzIGJyb3VnaHQgdG8geW91IGJ5IGZpcmVmb3hcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkb2N1bWVudC5zdHlsZVNoZWV0c1tpXS5vd25lck5vZGUgPT09IHRhZykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1lbW90aW9uJywgb3B0aW9ucy5rZXkpO1xuXG4gIGlmIChvcHRpb25zLm5vbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0YWcuc2V0QXR0cmlidXRlKCdub25jZScsIG9wdGlvbnMubm9uY2UpO1xuICB9XG5cbiAgdGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKSk7XG4gIHJldHVybiB0YWc7XG59XG5cbnZhciBTdHlsZVNoZWV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVTaGVldChvcHRpb25zKSB7XG4gICAgdGhpcy5pc1NwZWVkeSA9IG9wdGlvbnMuc3BlZWR5ID09PSB1bmRlZmluZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nIDogb3B0aW9ucy5zcGVlZHk7XG4gICAgdGhpcy50YWdzID0gW107XG4gICAgdGhpcy5jdHIgPSAwO1xuICAgIHRoaXMubm9uY2UgPSBvcHRpb25zLm5vbmNlOyAvLyBrZXkgaXMgdGhlIHZhbHVlIG9mIHRoZSBkYXRhLWVtb3Rpb24gYXR0cmlidXRlLCBpdCdzIHVzZWQgdG8gaWRlbnRpZnkgZGlmZmVyZW50IHNoZWV0c1xuXG4gICAgdGhpcy5rZXkgPSBvcHRpb25zLmtleTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuYmVmb3JlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAvLyB0aGUgbWF4IGxlbmd0aCBpcyBob3cgbWFueSBydWxlcyB3ZSBoYXZlIHBlciBzdHlsZSB0YWcsIGl0J3MgNjUwMDAgaW4gc3BlZWR5IG1vZGVcbiAgICAvLyBpdCdzIDEgaW4gZGV2IGJlY2F1c2Ugd2UgaW5zZXJ0IHNvdXJjZSBtYXBzIHRoYXQgbWFwIGEgc2luZ2xlIHJ1bGUgdG8gYSBsb2NhdGlvblxuICAgIC8vIGFuZCB5b3UgY2FuIG9ubHkgaGF2ZSBvbmUgc291cmNlIG1hcCBwZXIgc3R5bGUgdGFnXG4gICAgaWYgKHRoaXMuY3RyICUgKHRoaXMuaXNTcGVlZHkgPyA2NTAwMCA6IDEpID09PSAwKSB7XG4gICAgICB2YXIgX3RhZyA9IGNyZWF0ZVN0eWxlRWxlbWVudCh0aGlzKTtcblxuICAgICAgdmFyIGJlZm9yZTtcblxuICAgICAgaWYgKHRoaXMudGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYmVmb3JlID0gdGhpcy5iZWZvcmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZWZvcmUgPSB0aGlzLnRhZ3NbdGhpcy50YWdzLmxlbmd0aCAtIDFdLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRhaW5lci5pbnNlcnRCZWZvcmUoX3RhZywgYmVmb3JlKTtcbiAgICAgIHRoaXMudGFncy5wdXNoKF90YWcpO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSB0aGlzLnRhZ3NbdGhpcy50YWdzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHRoaXMuaXNTcGVlZHkpIHtcbiAgICAgIHZhciBzaGVldCA9IHNoZWV0Rm9yVGFnKHRhZyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSByZWFsbHkgaG90IHBhdGhcbiAgICAgICAgLy8gd2UgY2hlY2sgdGhlIHNlY29uZCBjaGFyYWN0ZXIgZmlyc3QgYmVjYXVzZSBoYXZpbmcgXCJpXCJcbiAgICAgICAgLy8gYXMgdGhlIHNlY29uZCBjaGFyYWN0ZXIgd2lsbCBoYXBwZW4gbGVzcyBvZnRlbiB0aGFuXG4gICAgICAgIC8vIGhhdmluZyBcIkBcIiBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgICAgIHZhciBpc0ltcG9ydFJ1bGUgPSBydWxlLmNoYXJDb2RlQXQoMSkgPT09IDEwNSAmJiBydWxlLmNoYXJDb2RlQXQoMCkgPT09IDY0OyAvLyB0aGlzIGlzIHRoZSB1bHRyYWZhc3QgdmVyc2lvbiwgd29ya3MgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIHRoZSBiaWcgZHJhd2JhY2sgaXMgdGhhdCB0aGUgY3NzIHdvbid0IGJlIGVkaXRhYmxlIGluIGRldnRvb2xzXG5cbiAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCAvLyB3ZSBuZWVkIHRvIGluc2VydCBAaW1wb3J0IHJ1bGVzIGJlZm9yZSBhbnl0aGluZyBlbHNlXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIGFuIGVycm9yXG4gICAgICAgIC8vIHRlY2huaWNhbGx5IHRoaXMgbWVhbnMgdGhhdCB0aGUgQGltcG9ydCBydWxlcyB3aWxsXG4gICAgICAgIC8vIF91c3VhbGx5Xyhub3QgYWx3YXlzIHNpbmNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHN0eWxlIHRhZ3MpXG4gICAgICAgIC8vIGJlIHRoZSBmaXJzdCBvbmVzIGluIHByb2QgYW5kIGdlbmVyYWxseSBsYXRlciBpbiBkZXZcbiAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgcmVhbGx5IG1hdHRlciBpbiB0aGUgcmVhbCB3b3JsZCB0aG91Z2hcbiAgICAgICAgLy8gQGltcG9ydCBpcyBnZW5lcmFsbHkgb25seSB1c2VkIGZvciBmb250IGZhY2VzIGZyb20gZ29vZ2xlIGZvbnRzIGFuZCBldGMuXG4gICAgICAgIC8vIHNvIHdoaWxlIHRoaXMgY291bGQgYmUgdGVjaG5pY2FsbHkgY29ycmVjdCB0aGVuIGl0IHdvdWxkIGJlIHNsb3dlciBhbmQgbGFyZ2VyXG4gICAgICAgIC8vIGZvciBhIHRpbnkgYml0IG9mIGNvcnJlY3RuZXNzIHRoYXQgd29uJ3QgbWF0dGVyIGluIHRoZSByZWFsIHdvcmxkXG4gICAgICAgIGlzSW1wb3J0UnVsZSA/IDAgOiBzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZXJlIHdhcyBhIHByb2JsZW0gaW5zZXJ0aW5nIHRoZSBmb2xsb3dpbmcgcnVsZTogXFxcIlwiICsgcnVsZSArIFwiXFxcIlwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocnVsZSkpO1xuICAgIH1cblxuICAgIHRoaXMuY3RyKys7XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHRoaXMudGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgIHJldHVybiB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgIH0pO1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMuY3RyID0gMDtcbiAgfTtcblxuICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcblxuZXhwb3J0IHsgU3R5bGVTaGVldCB9O1xuIiwiZnVuY3Rpb24gc3R5bGlzX21pbiAoVykge1xuICBmdW5jdGlvbiBNKGQsIGMsIGUsIGgsIGEpIHtcbiAgICBmb3IgKHZhciBtID0gMCwgYiA9IDAsIHYgPSAwLCBuID0gMCwgcSwgZywgeCA9IDAsIEsgPSAwLCBrLCB1ID0gayA9IHEgPSAwLCBsID0gMCwgciA9IDAsIEkgPSAwLCB0ID0gMCwgQiA9IGUubGVuZ3RoLCBKID0gQiAtIDEsIHksIGYgPSAnJywgcCA9ICcnLCBGID0gJycsIEcgPSAnJywgQzsgbCA8IEI7KSB7XG4gICAgICBnID0gZS5jaGFyQ29kZUF0KGwpO1xuICAgICAgbCA9PT0gSiAmJiAwICE9PSBiICsgbiArIHYgKyBtICYmICgwICE9PSBiICYmIChnID0gNDcgPT09IGIgPyAxMCA6IDQ3KSwgbiA9IHYgPSBtID0gMCwgQisrLCBKKyspO1xuXG4gICAgICBpZiAoMCA9PT0gYiArIG4gKyB2ICsgbSkge1xuICAgICAgICBpZiAobCA9PT0gSiAmJiAoMCA8IHIgJiYgKGYgPSBmLnJlcGxhY2UoTiwgJycpKSwgMCA8IGYudHJpbSgpLmxlbmd0aCkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBmICs9IGUuY2hhckF0KGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGcgPSA1OTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgZiA9IGYudHJpbSgpO1xuICAgICAgICAgICAgcSA9IGYuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGsgPSAxO1xuXG4gICAgICAgICAgICBmb3IgKHQgPSArK2w7IGwgPCBCOykge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGcgPSBlLmNoYXJDb2RlQXQobCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGcgPSBlLmNoYXJDb2RlQXQobCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh1ID0gbCArIDE7IHUgPCBKOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlLmNoYXJDb2RlQXQodSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDQyID09PSBnICYmIDQyID09PSBlLmNoYXJDb2RlQXQodSAtIDEpICYmIGwgKyAyICE9PSB1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDQ3ID09PSBnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgOTE6XG4gICAgICAgICAgICAgICAgICBnKys7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgZysrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgICAgZm9yICg7IGwrKyA8IEogJiYgZS5jaGFyQ29kZUF0KGwpICE9PSBnOykge1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoMCA9PT0gaykgYnJlYWs7XG4gICAgICAgICAgICAgIGwrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgayA9IGUuc3Vic3RyaW5nKHQsIGwpO1xuICAgICAgICAgICAgMCA9PT0gcSAmJiAocSA9IChmID0gZi5yZXBsYWNlKGNhLCAnJykudHJpbSgpKS5jaGFyQ29kZUF0KDApKTtcblxuICAgICAgICAgICAgc3dpdGNoIChxKSB7XG4gICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgMCA8IHIgJiYgKGYgPSBmLnJlcGxhY2UoTiwgJycpKTtcbiAgICAgICAgICAgICAgICBnID0gZi5jaGFyQ29kZUF0KDEpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICByID0gYztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHIgPSBPO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGsgPSBNKGMsIHIsIGssIGcsIGEgKyAxKTtcbiAgICAgICAgICAgICAgICB0ID0gay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgMCA8IEEgJiYgKHIgPSBYKE8sIGYsIEkpLCBDID0gSCgzLCBrLCByLCBjLCBELCB6LCB0LCBnLCBhLCBoKSwgZiA9IHIuam9pbignJyksIHZvaWQgMCAhPT0gQyAmJiAwID09PSAodCA9IChrID0gQy50cmltKCkpLmxlbmd0aCkgJiYgKGcgPSAwLCBrID0gJycpKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA8IHQpIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLnJlcGxhY2UoZGEsIGVhKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgJ3snICsgayArICd9JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgICAgICBmID0gZi5yZXBsYWNlKGZhLCAnJDEgJDInKTtcbiAgICAgICAgICAgICAgICAgICAgayA9IGYgKyAneycgKyBrICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBrID0gMSA9PT0gdyB8fCAyID09PSB3ICYmIEwoJ0AnICsgaywgMykgPyAnQC13ZWJraXQtJyArIGsgKyAnQCcgKyBrIDogJ0AnICsgaztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgaywgMTEyID09PSBoICYmIChrID0gKHAgKz0gaywgJycpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgayA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgayA9IE0oYywgWChjLCBmLCBJKSwgaywgaCwgYSArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBGICs9IGs7XG4gICAgICAgICAgICBrID0gSSA9IHIgPSB1ID0gcSA9IDA7XG4gICAgICAgICAgICBmID0gJyc7XG4gICAgICAgICAgICBnID0gZS5jaGFyQ29kZUF0KCsrbCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICBmID0gKDAgPCByID8gZi5yZXBsYWNlKE4sICcnKSA6IGYpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICgxIDwgKHQgPSBmLmxlbmd0aCkpIHN3aXRjaCAoMCA9PT0gdSAmJiAocSA9IGYuY2hhckNvZGVBdCgwKSwgNDUgPT09IHEgfHwgOTYgPCBxICYmIDEyMyA+IHEpICYmICh0ID0gKGYgPSBmLnJlcGxhY2UoJyAnLCAnOicpKS5sZW5ndGgpLCAwIDwgQSAmJiB2b2lkIDAgIT09IChDID0gSCgxLCBmLCBjLCBkLCBELCB6LCBwLmxlbmd0aCwgaCwgYSwgaCkpICYmIDAgPT09ICh0ID0gKGYgPSBDLnRyaW0oKSkubGVuZ3RoKSAmJiAoZiA9ICdcXHgwMFxceDAwJyksIHEgPSBmLmNoYXJDb2RlQXQoMCksIGcgPSBmLmNoYXJDb2RlQXQoMSksIHEpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgICAgaWYgKDEwNSA9PT0gZyB8fCA5OSA9PT0gZykge1xuICAgICAgICAgICAgICAgICAgRyArPSBmICsgZS5jaGFyQXQobCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICA1OCAhPT0gZi5jaGFyQ29kZUF0KHQgLSAxKSAmJiAocCArPSBQKGYsIHEsIGcsIGYuY2hhckNvZGVBdCgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSSA9IHIgPSB1ID0gcSA9IDA7XG4gICAgICAgICAgICBmID0gJyc7XG4gICAgICAgICAgICBnID0gZS5jaGFyQ29kZUF0KCsrbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgNDcgPT09IGIgPyBiID0gMCA6IDAgPT09IDEgKyBxICYmIDEwNyAhPT0gaCAmJiAwIDwgZi5sZW5ndGggJiYgKHIgPSAxLCBmICs9ICdcXHgwMCcpO1xuICAgICAgICAgIDAgPCBBICogWSAmJiBIKDAsIGYsIGMsIGQsIEQsIHosIHAubGVuZ3RoLCBoLCBhLCBoKTtcbiAgICAgICAgICB6ID0gMTtcbiAgICAgICAgICBEKys7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgaWYgKDAgPT09IGIgKyBuICsgdiArIG0pIHtcbiAgICAgICAgICAgIHorKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHorKztcbiAgICAgICAgICB5ID0gZS5jaGFyQXQobCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIGlmICgwID09PSBuICsgbSArIGIpIHN3aXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgIHkgPSAnJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIDMyICE9PSBnICYmICh5ID0gJyAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB5ID0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXGYnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgeSA9ICdcXFxcdic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgKHIgPSBJID0gMSwgeSA9ICdcXGYnICsgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IG4gKyBiICsgbSArIEUgJiYgMCA8IHUpIHN3aXRjaCAobCAtIHUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAxMTIgPT09IHggJiYgNTggPT09IGUuY2hhckNvZGVBdChsIC0gMykgJiYgKEUgPSB4KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIDExMSA9PT0gSyAmJiAoRSA9IEspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgKHUgPSBsKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgIDAgPT09IGIgKyB2ICsgbiArIG0gJiYgKHIgPSAxLCB5ICs9ICdcXHInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAwID09PSBiICYmIChuID0gbiA9PT0gZyA/IDAgOiAwID09PSBuID8gZyA6IG4pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyB2ICYmIG0rKztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTM6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgdiAmJiBtLS07XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIG0gJiYgdi0tO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IG4gKyBiICsgbSkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBxKSBzd2l0Y2ggKDIgKiB4ICsgMyAqIEspIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTMzOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHYrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAwID09PSBiICsgdiArIG4gKyBtICsgdSArIGsgJiYgKGsgPSAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICBpZiAoISgwIDwgbiArIG0gKyB2KSkgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgc3dpdGNoICgyICogZyArIDMgKiBlLmNoYXJDb2RlQXQobCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM1OlxuICAgICAgICAgICAgICAgICAgICAgIGIgPSA0NztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICAgICAgICAgICAgICB0ID0gbCwgYiA9IDQyO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICA0NyA9PT0gZyAmJiA0MiA9PT0geCAmJiB0ICsgMiAhPT0gbCAmJiAoMzMgPT09IGUuY2hhckNvZGVBdCh0ICsgMikgJiYgKHAgKz0gZS5zdWJzdHJpbmcodCwgbCArIDEpKSwgeSA9ICcnLCBiID0gMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAwID09PSBiICYmIChmICs9IHkpO1xuICAgICAgfVxuXG4gICAgICBLID0geDtcbiAgICAgIHggPSBnO1xuICAgICAgbCsrO1xuICAgIH1cblxuICAgIHQgPSBwLmxlbmd0aDtcblxuICAgIGlmICgwIDwgdCkge1xuICAgICAgciA9IGM7XG4gICAgICBpZiAoMCA8IEEgJiYgKEMgPSBIKDIsIHAsIHIsIGQsIEQsIHosIHQsIGgsIGEsIGgpLCB2b2lkIDAgIT09IEMgJiYgMCA9PT0gKHAgPSBDKS5sZW5ndGgpKSByZXR1cm4gRyArIHAgKyBGO1xuICAgICAgcCA9IHIuam9pbignLCcpICsgJ3snICsgcCArICd9JztcblxuICAgICAgaWYgKDAgIT09IHcgKiBFKSB7XG4gICAgICAgIDIgIT09IHcgfHwgTChwLCAyKSB8fCAoRSA9IDApO1xuXG4gICAgICAgIHN3aXRjaCAoRSkge1xuICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgcCA9IHAucmVwbGFjZShoYSwgJzotbW96LSQxJykgKyBwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICAgIHAgPSBwLnJlcGxhY2UoUSwgJzo6LXdlYmtpdC1pbnB1dC0kMScpICsgcC5yZXBsYWNlKFEsICc6Oi1tb3otJDEnKSArIHAucmVwbGFjZShRLCAnOi1tcy1pbnB1dC0kMScpICsgcDtcbiAgICAgICAgfVxuXG4gICAgICAgIEUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBHICsgcCArIEY7XG4gIH1cblxuICBmdW5jdGlvbiBYKGQsIGMsIGUpIHtcbiAgICB2YXIgaCA9IGMudHJpbSgpLnNwbGl0KGlhKTtcbiAgICBjID0gaDtcbiAgICB2YXIgYSA9IGgubGVuZ3RoLFxuICAgICAgICBtID0gZC5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKG0pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICAgIGZvciAoZCA9IDAgPT09IG0gPyAnJyA6IGRbMF0gKyAnICc7IGIgPCBhOyArK2IpIHtcbiAgICAgICAgICBjW2JdID0gWihkLCBjW2JdLCBlKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHYgPSBiID0gMDtcblxuICAgICAgICBmb3IgKGMgPSBbXTsgYiA8IGE7ICsrYikge1xuICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbTsgKytuKSB7XG4gICAgICAgICAgICBjW3YrK10gPSBaKGRbbl0gKyAnICcsIGhbYl0sIGUpLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gWihkLCBjLCBlKSB7XG4gICAgdmFyIGggPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgMzMgPiBoICYmIChoID0gKGMgPSBjLnRyaW0oKSkuY2hhckNvZGVBdCgwKSk7XG5cbiAgICBzd2l0Y2ggKGgpIHtcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHJldHVybiBjLnJlcGxhY2UoRiwgJyQxJyArIGQudHJpbSgpKTtcblxuICAgICAgY2FzZSA1ODpcbiAgICAgICAgcmV0dXJuIGQudHJpbSgpICsgYy5yZXBsYWNlKEYsICckMScgKyBkLnRyaW0oKSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICgwIDwgMSAqIGUgJiYgMCA8IGMuaW5kZXhPZignXFxmJykpIHJldHVybiBjLnJlcGxhY2UoRiwgKDU4ID09PSBkLmNoYXJDb2RlQXQoMCkgPyAnJyA6ICckMScpICsgZC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBkICsgYztcbiAgfVxuXG4gIGZ1bmN0aW9uIFAoZCwgYywgZSwgaCkge1xuICAgIHZhciBhID0gZCArICc7JyxcbiAgICAgICAgbSA9IDIgKiBjICsgMyAqIGUgKyA0ICogaDtcblxuICAgIGlmICg5NDQgPT09IG0pIHtcbiAgICAgIGQgPSBhLmluZGV4T2YoJzonLCA5KSArIDE7XG4gICAgICB2YXIgYiA9IGEuc3Vic3RyaW5nKGQsIGEubGVuZ3RoIC0gMSkudHJpbSgpO1xuICAgICAgYiA9IGEuc3Vic3RyaW5nKDAsIGQpLnRyaW0oKSArIGIgKyAnOyc7XG4gICAgICByZXR1cm4gMSA9PT0gdyB8fCAyID09PSB3ICYmIEwoYiwgMSkgPyAnLXdlYmtpdC0nICsgYiArIGIgOiBiO1xuICAgIH1cblxuICAgIGlmICgwID09PSB3IHx8IDIgPT09IHcgJiYgIUwoYSwgMSkpIHJldHVybiBhO1xuXG4gICAgc3dpdGNoIChtKSB7XG4gICAgICBjYXNlIDEwMTU6XG4gICAgICAgIHJldHVybiA5NyA9PT0gYS5jaGFyQ29kZUF0KDEwKSA/ICctd2Via2l0LScgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgOTUxOlxuICAgICAgICByZXR1cm4gMTE2ID09PSBhLmNoYXJDb2RlQXQoMykgPyAnLXdlYmtpdC0nICsgYSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDk2MzpcbiAgICAgICAgcmV0dXJuIDExMCA9PT0gYS5jaGFyQ29kZUF0KDUpID8gJy13ZWJraXQtJyArIGEgKyBhIDogYTtcblxuICAgICAgY2FzZSAxMDA5OlxuICAgICAgICBpZiAoMTAwICE9PSBhLmNoYXJDb2RlQXQoNCkpIGJyZWFrO1xuXG4gICAgICBjYXNlIDk2OTpcbiAgICAgIGNhc2UgOTQyOlxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDk3ODpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tb3otJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDEwMTk6XG4gICAgICBjYXNlIDk4MzpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tb3otJyArIGEgKyAnLW1zLScgKyBhICsgYTtcblxuICAgICAgY2FzZSA4ODM6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDgpKSByZXR1cm4gJy13ZWJraXQtJyArIGEgKyBhO1xuICAgICAgICBpZiAoMCA8IGEuaW5kZXhPZignaW1hZ2Utc2V0KCcsIDExKSkgcmV0dXJuIGEucmVwbGFjZShqYSwgJyQxLXdlYmtpdC0kMicpICsgYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTMyOlxuICAgICAgICBpZiAoNDUgPT09IGEuY2hhckNvZGVBdCg0KSkgc3dpdGNoIChhLmNoYXJDb2RlQXQoNSkpIHtcbiAgICAgICAgICBjYXNlIDEwMzpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC1ib3gtJyArIGEucmVwbGFjZSgnLWdyb3cnLCAnJykgKyAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnZ3JvdycsICdwb3NpdGl2ZScpICsgYTtcblxuICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYS5yZXBsYWNlKCdzaHJpbmsnLCAnbmVnYXRpdmUnKSArIGE7XG5cbiAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYS5yZXBsYWNlKCdiYXNpcycsICdwcmVmZXJyZWQtc2l6ZScpICsgYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBhICsgYTtcblxuICAgICAgY2FzZSA5NjQ6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgMTAyMzpcbiAgICAgICAgaWYgKDk5ICE9PSBhLmNoYXJDb2RlQXQoOCkpIGJyZWFrO1xuICAgICAgICBiID0gYS5zdWJzdHJpbmcoYS5pbmRleE9mKCc6JywgMTUpKS5yZXBsYWNlKCdmbGV4LScsICcnKS5yZXBsYWNlKCdzcGFjZS1iZXR3ZWVuJywgJ2p1c3RpZnknKTtcbiAgICAgICAgcmV0dXJuICctd2Via2l0LWJveC1wYWNrJyArIGIgKyAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC1wYWNrJyArIGIgKyBhO1xuXG4gICAgICBjYXNlIDEwMDU6XG4gICAgICAgIHJldHVybiBrYS50ZXN0KGEpID8gYS5yZXBsYWNlKGFhLCAnOi13ZWJraXQtJykgKyBhLnJlcGxhY2UoYWEsICc6LW1vei0nKSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDFlMzpcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKDEzKS50cmltKCk7XG4gICAgICAgIGMgPSBiLmluZGV4T2YoJy0nKSArIDE7XG5cbiAgICAgICAgc3dpdGNoIChiLmNoYXJDb2RlQXQoMCkgKyBiLmNoYXJDb2RlQXQoYykpIHtcbiAgICAgICAgICBjYXNlIDIyNjpcbiAgICAgICAgICAgIGIgPSBhLnJlcGxhY2UoRywgJ3RiJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjMyOlxuICAgICAgICAgICAgYiA9IGEucmVwbGFjZShHLCAndGItcmwnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICdscicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBiICsgYTtcblxuICAgICAgY2FzZSAxMDE3OlxuICAgICAgICBpZiAoLTEgPT09IGEuaW5kZXhPZignc3RpY2t5JywgOSkpIGJyZWFrO1xuXG4gICAgICBjYXNlIDk3NTpcbiAgICAgICAgYyA9IChhID0gZCkubGVuZ3RoIC0gMTA7XG4gICAgICAgIGIgPSAoMzMgPT09IGEuY2hhckNvZGVBdChjKSA/IGEuc3Vic3RyaW5nKDAsIGMpIDogYSkuc3Vic3RyaW5nKGQuaW5kZXhPZignOicsIDcpICsgMSkudHJpbSgpO1xuXG4gICAgICAgIHN3aXRjaCAobSA9IGIuY2hhckNvZGVBdCgwKSArIChiLmNoYXJDb2RlQXQoNykgfCAwKSkge1xuICAgICAgICAgIGNhc2UgMjAzOlxuICAgICAgICAgICAgaWYgKDExMSA+IGIuY2hhckNvZGVBdCg4KSkgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIGEgPSBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgJzsnICsgYTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMDc6XG4gICAgICAgICAgY2FzZSAxMDI6XG4gICAgICAgICAgICBhID0gYS5yZXBsYWNlKGIsICctd2Via2l0LScgKyAoMTAyIDwgbSA/ICdpbmxpbmUtJyA6ICcnKSArICdib3gnKSArICc7JyArIGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgYikgKyAnOycgKyBhLnJlcGxhY2UoYiwgJy1tcy0nICsgYiArICdib3gnKSArICc7JyArIGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSArICc7JztcblxuICAgICAgY2FzZSA5Mzg6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDUpKSBzd2l0Y2ggKGEuY2hhckNvZGVBdCg2KSkge1xuICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgICAgcmV0dXJuIGIgPSBhLnJlcGxhY2UoJy1pdGVtcycsICcnKSwgJy13ZWJraXQtJyArIGEgKyAnLXdlYmtpdC1ib3gtJyArIGIgKyAnLW1zLWZsZXgtJyArIGIgKyBhO1xuXG4gICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtaXRlbS0nICsgYS5yZXBsYWNlKGJhLCAnJykgKyBhO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC1saW5lLXBhY2snICsgYS5yZXBsYWNlKCdhbGlnbi1jb250ZW50JywgJycpLnJlcGxhY2UoYmEsICcnKSArIGE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTczOlxuICAgICAgY2FzZSA5ODk6XG4gICAgICAgIGlmICg0NSAhPT0gYS5jaGFyQ29kZUF0KDMpIHx8IDEyMiA9PT0gYS5jaGFyQ29kZUF0KDQpKSBicmVhaztcblxuICAgICAgY2FzZSA5MzE6XG4gICAgICBjYXNlIDk1MzpcbiAgICAgICAgaWYgKCEwID09PSBsYS50ZXN0KGQpKSByZXR1cm4gMTE1ID09PSAoYiA9IGQuc3Vic3RyaW5nKGQuaW5kZXhPZignOicpICsgMSkpLmNoYXJDb2RlQXQoMCkgPyBQKGQucmVwbGFjZSgnc3RyZXRjaCcsICdmaWxsLWF2YWlsYWJsZScpLCBjLCBlLCBoKS5yZXBsYWNlKCc6ZmlsbC1hdmFpbGFibGUnLCAnOnN0cmV0Y2gnKSA6IGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgYikgKyBhLnJlcGxhY2UoYiwgJy1tb3otJyArIGIucmVwbGFjZSgnZmlsbC0nLCAnJykpICsgYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTYyOlxuICAgICAgICBpZiAoYSA9ICctd2Via2l0LScgKyBhICsgKDEwMiA9PT0gYS5jaGFyQ29kZUF0KDUpID8gJy1tcy0nICsgYSA6ICcnKSArIGEsIDIxMSA9PT0gZSArIGggJiYgMTA1ID09PSBhLmNoYXJDb2RlQXQoMTMpICYmIDAgPCBhLmluZGV4T2YoJ3RyYW5zZm9ybScsIDEwKSkgcmV0dXJuIGEuc3Vic3RyaW5nKDAsIGEuaW5kZXhPZignOycsIDI3KSArIDEpLnJlcGxhY2UobWEsICckMS13ZWJraXQtJDInKSArIGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBMKGQsIGMpIHtcbiAgICB2YXIgZSA9IGQuaW5kZXhPZigxID09PSBjID8gJzonIDogJ3snKSxcbiAgICAgICAgaCA9IGQuc3Vic3RyaW5nKDAsIDMgIT09IGMgPyBlIDogMTApO1xuICAgIGUgPSBkLnN1YnN0cmluZyhlICsgMSwgZC5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gUigyICE9PSBjID8gaCA6IGgucmVwbGFjZShuYSwgJyQxJyksIGUsIGMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWEoZCwgYykge1xuICAgIHZhciBlID0gUChjLCBjLmNoYXJDb2RlQXQoMCksIGMuY2hhckNvZGVBdCgxKSwgYy5jaGFyQ29kZUF0KDIpKTtcbiAgICByZXR1cm4gZSAhPT0gYyArICc7JyA/IGUucmVwbGFjZShvYSwgJyBvciAoJDEpJykuc3Vic3RyaW5nKDQpIDogJygnICsgYyArICcpJztcbiAgfVxuXG4gIGZ1bmN0aW9uIEgoZCwgYywgZSwgaCwgYSwgbSwgYiwgdiwgbiwgcSkge1xuICAgIGZvciAodmFyIGcgPSAwLCB4ID0gYywgdzsgZyA8IEE7ICsrZykge1xuICAgICAgc3dpdGNoICh3ID0gU1tnXS5jYWxsKEIsIGQsIHgsIGUsIGgsIGEsIG0sIGIsIHYsIG4sIHEpKSB7XG4gICAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICBjYXNlICExOlxuICAgICAgICBjYXNlICEwOlxuICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB4ID0gdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCAhPT0gYykgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBUKGQpIHtcbiAgICBzd2l0Y2ggKGQpIHtcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgICBBID0gUy5sZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkKSBTW0ErK10gPSBkO2Vsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgZCkgZm9yICh2YXIgYyA9IDAsIGUgPSBkLmxlbmd0aDsgYyA8IGU7ICsrYykge1xuICAgICAgICAgIFQoZFtjXSk7XG4gICAgICAgIH0gZWxzZSBZID0gISFkIHwgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFUoZCkge1xuICAgIGQgPSBkLnByZWZpeDtcbiAgICB2b2lkIDAgIT09IGQgJiYgKFIgPSBudWxsLCBkID8gJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGQgPyB3ID0gMSA6ICh3ID0gMiwgUiA9IGQpIDogdyA9IDApO1xuICAgIHJldHVybiBVO1xuICB9XG5cbiAgZnVuY3Rpb24gQihkLCBjKSB7XG4gICAgdmFyIGUgPSBkO1xuICAgIDMzID4gZS5jaGFyQ29kZUF0KDApICYmIChlID0gZS50cmltKCkpO1xuICAgIFYgPSBlO1xuICAgIGUgPSBbVl07XG5cbiAgICBpZiAoMCA8IEEpIHtcbiAgICAgIHZhciBoID0gSCgtMSwgYywgZSwgZSwgRCwgeiwgMCwgMCwgMCwgMCk7XG4gICAgICB2b2lkIDAgIT09IGggJiYgJ3N0cmluZycgPT09IHR5cGVvZiBoICYmIChjID0gaCk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBNKE8sIGUsIGMsIDAsIDApO1xuICAgIDAgPCBBICYmIChoID0gSCgtMiwgYSwgZSwgZSwgRCwgeiwgYS5sZW5ndGgsIDAsIDAsIDApLCB2b2lkIDAgIT09IGggJiYgKGEgPSBoKSk7XG4gICAgViA9ICcnO1xuICAgIEUgPSAwO1xuICAgIHogPSBEID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHZhciBjYSA9IC9eXFwwKy9nLFxuICAgICAgTiA9IC9bXFwwXFxyXFxmXS9nLFxuICAgICAgYWEgPSAvOiAqL2csXG4gICAgICBrYSA9IC96b298Z3JhLyxcbiAgICAgIG1hID0gLyhbLDogXSkodHJhbnNmb3JtKS9nLFxuICAgICAgaWEgPSAvLFxccis/L2csXG4gICAgICBGID0gLyhbXFx0XFxyXFxuIF0pKlxcZj8mL2csXG4gICAgICBmYSA9IC9AKGtcXHcrKVxccyooXFxTKilcXHMqLyxcbiAgICAgIFEgPSAvOjoocGxhY2UpL2csXG4gICAgICBoYSA9IC86KHJlYWQtb25seSkvZyxcbiAgICAgIEcgPSAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sXG4gICAgICBkYSA9IC9cXChcXHMqKC4qKVxccypcXCkvZyxcbiAgICAgIG9hID0gLyhbXFxzXFxTXSo/KTsvZyxcbiAgICAgIGJhID0gLy1zZWxmfGZsZXgtL2csXG4gICAgICBuYSA9IC9bXl0qPyg6W3JwXVtlbF1hW1xcdy1dKylbXl0qLyxcbiAgICAgIGxhID0gL3N0cmV0Y2h8OlxccypcXHcrXFwtKD86Y29udGV8YXZhaWwpLyxcbiAgICAgIGphID0gLyhbXi1dKShpbWFnZS1zZXRcXCgpLyxcbiAgICAgIHogPSAxLFxuICAgICAgRCA9IDEsXG4gICAgICBFID0gMCxcbiAgICAgIHcgPSAxLFxuICAgICAgTyA9IFtdLFxuICAgICAgUyA9IFtdLFxuICAgICAgQSA9IDAsXG4gICAgICBSID0gbnVsbCxcbiAgICAgIFkgPSAwLFxuICAgICAgViA9ICcnO1xuICBCLnVzZSA9IFQ7XG4gIEIuc2V0ID0gVTtcbiAgdm9pZCAwICE9PSBXICYmIFUoVyk7XG4gIHJldHVybiBCO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsaXNfbWluO1xuIiwidmFyIHVuaXRsZXNzS2V5cyA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IDEsXG4gIGJvcmRlckltYWdlT3V0c2V0OiAxLFxuICBib3JkZXJJbWFnZVNsaWNlOiAxLFxuICBib3JkZXJJbWFnZVdpZHRoOiAxLFxuICBib3hGbGV4OiAxLFxuICBib3hGbGV4R3JvdXA6IDEsXG4gIGJveE9yZGluYWxHcm91cDogMSxcbiAgY29sdW1uQ291bnQ6IDEsXG4gIGNvbHVtbnM6IDEsXG4gIGZsZXg6IDEsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4UG9zaXRpdmU6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIGZsZXhOZWdhdGl2ZTogMSxcbiAgZmxleE9yZGVyOiAxLFxuICBncmlkUm93OiAxLFxuICBncmlkUm93RW5kOiAxLFxuICBncmlkUm93U3BhbjogMSxcbiAgZ3JpZFJvd1N0YXJ0OiAxLFxuICBncmlkQ29sdW1uOiAxLFxuICBncmlkQ29sdW1uRW5kOiAxLFxuICBncmlkQ29sdW1uU3BhbjogMSxcbiAgZ3JpZENvbHVtblN0YXJ0OiAxLFxuICBtc0dyaWRSb3c6IDEsXG4gIG1zR3JpZFJvd1NwYW46IDEsXG4gIG1zR3JpZENvbHVtbjogMSxcbiAgbXNHcmlkQ29sdW1uU3BhbjogMSxcbiAgZm9udFdlaWdodDogMSxcbiAgbGluZUhlaWdodDogMSxcbiAgb3BhY2l0eTogMSxcbiAgb3JkZXI6IDEsXG4gIG9ycGhhbnM6IDEsXG4gIHRhYlNpemU6IDEsXG4gIHdpZG93czogMSxcbiAgekluZGV4OiAxLFxuICB6b29tOiAxLFxuICBXZWJraXRMaW5lQ2xhbXA6IDEsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIGZsb29kT3BhY2l0eTogMSxcbiAgc3RvcE9wYWNpdHk6IDEsXG4gIHN0cm9rZURhc2hhcnJheTogMSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogMSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMSxcbiAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVuaXRsZXNzS2V5cztcbiIsInZhciBpc0Jyb3dzZXIgPSBcIm9iamVjdFwiICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRTdHlsZXMocmVnaXN0ZXJlZCwgcmVnaXN0ZXJlZFN0eWxlcywgY2xhc3NOYW1lcykge1xuICB2YXIgcmF3Q2xhc3NOYW1lID0gJyc7XG4gIGNsYXNzTmFtZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICBpZiAocmVnaXN0ZXJlZFtjbGFzc05hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlZ2lzdGVyZWRTdHlsZXMucHVzaChyZWdpc3RlcmVkW2NsYXNzTmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXdDbGFzc05hbWUgKz0gY2xhc3NOYW1lICsgXCIgXCI7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJhd0NsYXNzTmFtZTtcbn1cbnZhciBpbnNlcnRTdHlsZXMgPSBmdW5jdGlvbiBpbnNlcnRTdHlsZXMoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKSB7XG4gIHZhciBjbGFzc05hbWUgPSBjYWNoZS5rZXkgKyBcIi1cIiArIHNlcmlhbGl6ZWQubmFtZTtcblxuICBpZiAoIC8vIHdlIG9ubHkgbmVlZCB0byBhZGQgdGhlIHN0eWxlcyB0byB0aGUgcmVnaXN0ZXJlZCBjYWNoZSBpZiB0aGVcbiAgLy8gY2xhc3MgbmFtZSBjb3VsZCBiZSB1c2VkIGZ1cnRoZXIgZG93blxuICAvLyB0aGUgdHJlZSBidXQgaWYgaXQncyBhIHN0cmluZyB0YWcsIHdlIGtub3cgaXQgd29uJ3RcbiAgLy8gc28gd2UgZG9uJ3QgaGF2ZSB0byBhZGQgaXQgdG8gcmVnaXN0ZXJlZCBjYWNoZS5cbiAgLy8gdGhpcyBpbXByb3ZlcyBtZW1vcnkgdXNhZ2Ugc2luY2Ugd2UgY2FuIGF2b2lkIHN0b3JpbmcgdGhlIHdob2xlIHN0eWxlIHN0cmluZ1xuICAoaXNTdHJpbmdUYWcgPT09IGZhbHNlIHx8IC8vIHdlIG5lZWQgdG8gYWx3YXlzIHN0b3JlIGl0IGlmIHdlJ3JlIGluIGNvbXBhdCBtb2RlIGFuZFxuICAvLyBpbiBub2RlIHNpbmNlIGVtb3Rpb24tc2VydmVyIHJlbGllcyBvbiB3aGV0aGVyIGEgc3R5bGUgaXMgaW5cbiAgLy8gdGhlIHJlZ2lzdGVyZWQgY2FjaGUgdG8ga25vdyB3aGV0aGVyIGEgc3R5bGUgaXMgZ2xvYmFsIG9yIG5vdFxuICAvLyBhbHNvLCBub3RlIHRoYXQgdGhpcyBjaGVjayB3aWxsIGJlIGRlYWQgY29kZSBlbGltaW5hdGVkIGluIHRoZSBicm93c2VyXG4gIGlzQnJvd3NlciA9PT0gZmFsc2UgJiYgY2FjaGUuY29tcGF0ICE9PSB1bmRlZmluZWQpICYmIGNhY2hlLnJlZ2lzdGVyZWRbY2xhc3NOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGUucmVnaXN0ZXJlZFtjbGFzc05hbWVdID0gc2VyaWFsaXplZC5zdHlsZXM7XG4gIH1cblxuICBpZiAoY2FjaGUuaW5zZXJ0ZWRbc2VyaWFsaXplZC5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBzZXJpYWxpemVkO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIG1heWJlU3R5bGVzID0gY2FjaGUuaW5zZXJ0KFwiLlwiICsgY2xhc3NOYW1lLCBjdXJyZW50LCBjYWNoZS5zaGVldCwgdHJ1ZSk7XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCAhPT0gdW5kZWZpbmVkKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ2V0UmVnaXN0ZXJlZFN0eWxlcywgaW5zZXJ0U3R5bGVzIH07XG4iLCJ2YXIgd2Vha01lbW9pemUgPSBmdW5jdGlvbiB3ZWFrTWVtb2l6ZShmdW5jKSB7XG4gIC8vICRGbG93Rml4TWUgZmxvdyBkb2Vzbid0IGluY2x1ZGUgYWxsIG5vbi1wcmltaXRpdmUgdHlwZXMgYXMgYWxsb3dlZCBmb3Igd2Vha21hcHNcbiAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGUuaGFzKGFyZykpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoYXJnKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gZnVuYyhhcmcpO1xuICAgIGNhY2hlLnNldChhcmcsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHdlYWtNZW1vaXplO1xuIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiLypcbiAgTW9kdWxlIGRlcGVuZGVuY2llc1xuKi9cbnZhciBFbGVtZW50VHlwZSA9IHJlcXVpcmUoJ2RvbWVsZW1lbnR0eXBlJyk7XG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCdlbnRpdGllcycpO1xuXG4vKiBtaXhlZC1jYXNlIFNWRyBhbmQgTWF0aE1MIHRhZ3MgJiBhdHRyaWJ1dGVzXG4gICByZWNvZ25pemVkIGJ5IHRoZSBIVE1MIHBhcnNlciwgc2VlXG4gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcGFyc2luZy1tYWluLWluZm9yZWlnblxuKi9cbnZhciBmb3JlaWduTmFtZXMgPSByZXF1aXJlKCcuL2ZvcmVpZ25OYW1lcy5qc29uJyk7XG5mb3JlaWduTmFtZXMuZWxlbWVudE5hbWVzLl9fcHJvdG9fXyA9IG51bGw7IC8qIHVzZSBhcyBhIHNpbXBsZSBkaWN0aW9uYXJ5ICovXG5mb3JlaWduTmFtZXMuYXR0cmlidXRlTmFtZXMuX19wcm90b19fID0gbnVsbDtcblxudmFyIHVuZW5jb2RlZEVsZW1lbnRzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIHN0eWxlOiB0cnVlLFxuICBzY3JpcHQ6IHRydWUsXG4gIHhtcDogdHJ1ZSxcbiAgaWZyYW1lOiB0cnVlLFxuICBub2VtYmVkOiB0cnVlLFxuICBub2ZyYW1lczogdHJ1ZSxcbiAgcGxhaW50ZXh0OiB0cnVlLFxuICBub3NjcmlwdDogdHJ1ZVxufTtcblxuLypcbiAgRm9ybWF0IGF0dHJpYnV0ZXNcbiovXG5mdW5jdGlvbiBmb3JtYXRBdHRycyhhdHRyaWJ1dGVzLCBvcHRzKSB7XG4gIGlmICghYXR0cmlidXRlcykgcmV0dXJuO1xuXG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIHZhbHVlO1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgYXR0cmlidXRlc1xuICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgIHZhbHVlID0gYXR0cmlidXRlc1trZXldO1xuICAgIGlmIChvdXRwdXQpIHtcbiAgICAgIG91dHB1dCArPSAnICc7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMueG1sTW9kZSA9PT0gJ2ZvcmVpZ24nKSB7XG4gICAgICAvKiBmaXggdXAgbWl4ZWQtY2FzZSBhdHRyaWJ1dGUgbmFtZXMgKi9cbiAgICAgIGtleSA9IGZvcmVpZ25OYW1lcy5hdHRyaWJ1dGVOYW1lc1trZXldIHx8IGtleTtcbiAgICB9XG4gICAgb3V0cHV0ICs9IGtleTtcbiAgICBpZiAoKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSAnJykgfHwgb3B0cy54bWxNb2RlKSB7XG4gICAgICBvdXRwdXQgKz1cbiAgICAgICAgJz1cIicgK1xuICAgICAgICAob3B0cy5kZWNvZGVFbnRpdGllc1xuICAgICAgICAgID8gZW50aXRpZXMuZW5jb2RlWE1MKHZhbHVlKVxuICAgICAgICAgIDogdmFsdWUucmVwbGFjZSgvXFxcIi9nLCAnJnF1b3Q7JykpICtcbiAgICAgICAgJ1wiJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICBTZWxmLWVuY2xvc2luZyB0YWdzIChzdG9sZW4gZnJvbSBub2RlLWh0bWxwYXJzZXIpXG4qL1xudmFyIHNpbmdsZVRhZyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBiYXNlZm9udDogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgY29tbWFuZDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGZyYW1lOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAgaXNpbmRleDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG52YXIgcmVuZGVyID0gKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9tLCBvcHRzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkb20pICYmICFkb20uY2hlZXJpbykgZG9tID0gW2RvbV07XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGVtID0gZG9tW2ldO1xuXG4gICAgaWYgKGVsZW0udHlwZSA9PT0gJ3Jvb3QnKSBvdXRwdXQgKz0gcmVuZGVyKGVsZW0uY2hpbGRyZW4sIG9wdHMpO1xuICAgIGVsc2UgaWYgKEVsZW1lbnRUeXBlLmlzVGFnKGVsZW0pKSBvdXRwdXQgKz0gcmVuZGVyVGFnKGVsZW0sIG9wdHMpO1xuICAgIGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gRWxlbWVudFR5cGUuRGlyZWN0aXZlKVxuICAgICAgb3V0cHV0ICs9IHJlbmRlckRpcmVjdGl2ZShlbGVtKTtcbiAgICBlbHNlIGlmIChlbGVtLnR5cGUgPT09IEVsZW1lbnRUeXBlLkNvbW1lbnQpIG91dHB1dCArPSByZW5kZXJDb21tZW50KGVsZW0pO1xuICAgIGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gRWxlbWVudFR5cGUuQ0RBVEEpIG91dHB1dCArPSByZW5kZXJDZGF0YShlbGVtKTtcbiAgICBlbHNlIG91dHB1dCArPSByZW5kZXJUZXh0KGVsZW0sIG9wdHMpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn0pO1xuXG52YXIgZm9yZWlnbk1vZGVJbnRlZ3JhdGlvblBvaW50cyA9IFtcbiAgJ21pJyxcbiAgJ21vJyxcbiAgJ21uJyxcbiAgJ21zJyxcbiAgJ210ZXh0JyxcbiAgJ2Fubm90YXRpb24teG1sJyxcbiAgJ2ZvcmVpZ25PYmplY3QnLFxuICAnZGVzYycsXG4gICd0aXRsZSdcbl07XG5cbmZ1bmN0aW9uIHJlbmRlclRhZyhlbGVtLCBvcHRzKSB7XG4gIC8vIEhhbmRsZSBTVkcgLyBNYXRoTUwgaW4gSFRNTFxuICBpZiAob3B0cy54bWxNb2RlID09PSAnZm9yZWlnbicpIHtcbiAgICAvKiBmaXggdXAgbWl4ZWQtY2FzZSBlbGVtZW50IG5hbWVzICovXG4gICAgZWxlbS5uYW1lID0gZm9yZWlnbk5hbWVzLmVsZW1lbnROYW1lc1tlbGVtLm5hbWVdIHx8IGVsZW0ubmFtZTtcbiAgICAvKiBleGl0IGZvcmVpZ24gbW9kZSBhdCBpbnRlZ3JhdGlvbiBwb2ludHMgKi9cbiAgICBpZiAoXG4gICAgICBlbGVtLnBhcmVudCAmJlxuICAgICAgZm9yZWlnbk1vZGVJbnRlZ3JhdGlvblBvaW50cy5pbmRleE9mKGVsZW0ucGFyZW50Lm5hbWUpID49IDBcbiAgICApXG4gICAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywgeyB4bWxNb2RlOiBmYWxzZSB9KTtcbiAgfVxuICBpZiAoIW9wdHMueG1sTW9kZSAmJiBbJ3N2ZycsICdtYXRoJ10uaW5kZXhPZihlbGVtLm5hbWUpID49IDApIHtcbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywgeyB4bWxNb2RlOiAnZm9yZWlnbicgfSk7XG4gIH1cblxuICB2YXIgdGFnID0gJzwnICsgZWxlbS5uYW1lO1xuICB2YXIgYXR0cmlicyA9IGZvcm1hdEF0dHJzKGVsZW0uYXR0cmlicywgb3B0cyk7XG5cbiAgaWYgKGF0dHJpYnMpIHtcbiAgICB0YWcgKz0gJyAnICsgYXR0cmlicztcbiAgfVxuXG4gIGlmIChvcHRzLnhtbE1vZGUgJiYgKCFlbGVtLmNoaWxkcmVuIHx8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkge1xuICAgIHRhZyArPSAnLz4nO1xuICB9IGVsc2Uge1xuICAgIHRhZyArPSAnPic7XG4gICAgaWYgKGVsZW0uY2hpbGRyZW4pIHtcbiAgICAgIHRhZyArPSByZW5kZXIoZWxlbS5jaGlsZHJlbiwgb3B0cyk7XG4gICAgfVxuXG4gICAgaWYgKCFzaW5nbGVUYWdbZWxlbS5uYW1lXSB8fCBvcHRzLnhtbE1vZGUpIHtcbiAgICAgIHRhZyArPSAnPC8nICsgZWxlbS5uYW1lICsgJz4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWc7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRpcmVjdGl2ZShlbGVtKSB7XG4gIHJldHVybiAnPCcgKyBlbGVtLmRhdGEgKyAnPic7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRleHQoZWxlbSwgb3B0cykge1xuICB2YXIgZGF0YSA9IGVsZW0uZGF0YSB8fCAnJztcblxuICAvLyBpZiBlbnRpdGllcyB3ZXJlbid0IGRlY29kZWQsIG5vIG5lZWQgdG8gZW5jb2RlIHRoZW0gYmFja1xuICBpZiAoXG4gICAgb3B0cy5kZWNvZGVFbnRpdGllcyAmJlxuICAgICEoZWxlbS5wYXJlbnQgJiYgZWxlbS5wYXJlbnQubmFtZSBpbiB1bmVuY29kZWRFbGVtZW50cylcbiAgKSB7XG4gICAgZGF0YSA9IGVudGl0aWVzLmVuY29kZVhNTChkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDZGF0YShlbGVtKSB7XG4gIHJldHVybiAnPCFbQ0RBVEFbJyArIGVsZW0uY2hpbGRyZW5bMF0uZGF0YSArICddXT4nO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb21tZW50KGVsZW0pIHtcbiAgcmV0dXJuICc8IS0tJyArIGVsZW0uZGF0YSArICctLT4nO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhIHRhZyBvciBub3QuXG4gKlxuICogQHBhcmFtIGVsZW0gRWxlbWVudCB0byB0ZXN0XG4gKi9cbmZ1bmN0aW9uIGlzVGFnKGVsZW0pIHtcbiAgICByZXR1cm4gKGVsZW0udHlwZSA9PT0gXCJ0YWdcIiAvKiBUYWcgKi8gfHxcbiAgICAgICAgZWxlbS50eXBlID09PSBcInNjcmlwdFwiIC8qIFNjcmlwdCAqLyB8fFxuICAgICAgICBlbGVtLnR5cGUgPT09IFwic3R5bGVcIiAvKiBTdHlsZSAqLyk7XG59XG5leHBvcnRzLmlzVGFnID0gaXNUYWc7XG4vLyBFeHBvcnRzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuZXhwb3J0cy5UZXh0ID0gXCJ0ZXh0XCIgLyogVGV4dCAqLzsgLy9UZXh0XG5leHBvcnRzLkRpcmVjdGl2ZSA9IFwiZGlyZWN0aXZlXCIgLyogRGlyZWN0aXZlICovOyAvLzw/IC4uLiA/PlxuZXhwb3J0cy5Db21tZW50ID0gXCJjb21tZW50XCIgLyogQ29tbWVudCAqLzsgLy88IS0tIC4uLiAtLT5cbmV4cG9ydHMuU2NyaXB0ID0gXCJzY3JpcHRcIiAvKiBTY3JpcHQgKi87IC8vPHNjcmlwdD4gdGFnc1xuZXhwb3J0cy5TdHlsZSA9IFwic3R5bGVcIiAvKiBTdHlsZSAqLzsgLy88c3R5bGU+IHRhZ3NcbmV4cG9ydHMuVGFnID0gXCJ0YWdcIiAvKiBUYWcgKi87IC8vQW55IHRhZ1xuZXhwb3J0cy5DREFUQSA9IFwiY2RhdGFcIiAvKiBDREFUQSAqLzsgLy88IVtDREFUQVsgLi4uIF1dPlxuZXhwb3J0cy5Eb2N0eXBlID0gXCJkb2N0eXBlXCIgLyogRG9jdHlwZSAqLztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5vZGVfMSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG5leHBvcnRzLk5vZGUgPSBub2RlXzEuTm9kZTtcbmV4cG9ydHMuRWxlbWVudCA9IG5vZGVfMS5FbGVtZW50O1xuZXhwb3J0cy5EYXRhTm9kZSA9IG5vZGVfMS5EYXRhTm9kZTtcbmV4cG9ydHMuTm9kZVdpdGhDaGlsZHJlbiA9IG5vZGVfMS5Ob2RlV2l0aENoaWxkcmVuO1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMrL2c7XG4vLyBEZWZhdWx0IG9wdGlvbnNcbnZhciBkZWZhdWx0T3B0cyA9IHtcbiAgICBub3JtYWxpemVXaGl0ZXNwYWNlOiBmYWxzZSxcbiAgICB3aXRoU3RhcnRJbmRpY2VzOiBmYWxzZSxcbiAgICB3aXRoRW5kSW5kaWNlczogZmFsc2Vcbn07XG52YXIgRG9tSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBhIG5ldyBEb21IYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxlZCBvbmNlIHBhcnNpbmcgaGFzIGNvbXBsZXRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBTZXR0aW5ncyBmb3IgdGhlIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIGVsZW1lbnRDQiBDYWxsYmFjayB3aGVuZXZlciBhIHRhZyBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRG9tSGFuZGxlcihjYWxsYmFjaywgb3B0aW9ucywgZWxlbWVudENCKSB7XG4gICAgICAgIC8qKiBUaGUgY29uc3RydWN0ZWQgRE9NICovXG4gICAgICAgIHRoaXMuZG9tID0gW107XG4gICAgICAgIC8qKiBJbmRpY2F0ZWQgd2hldGhlciBwYXJzaW5nIGhhcyBiZWVuIGNvbXBsZXRlZC4gKi9cbiAgICAgICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgICAgICAvKiogU3RhY2sgb2Ygb3BlbiB0YWdzLiAqL1xuICAgICAgICB0aGlzLl90YWdTdGFjayA9IFtdO1xuICAgICAgICAvKiogQSBkYXRhIG5vZGUgdGhhdCBpcyBzdGlsbCBiZWluZyB3cml0dGVuIHRvLiAqL1xuICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHBhcnNlciBpbnN0YW5jZS4gVXNlZCBmb3IgbG9jYXRpb24gaW5mb3JtYXRpb24uICovXG4gICAgICAgIHRoaXMuX3BhcnNlciA9IG51bGw7XG4gICAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gc2tpcCBhcmd1bWVudHMsIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWxlbWVudENCID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRPcHRzO1xuICAgICAgICB0aGlzLl9lbGVtZW50Q0IgPSBlbGVtZW50Q0IgfHwgbnVsbDtcbiAgICB9XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25wYXJzZXJpbml0ID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBwYXJzZXI7XG4gICAgfTtcbiAgICAvLyBSZXNldHMgdGhlIGhhbmRsZXIgYmFjayB0byBzdGFydGluZyBzdGF0ZVxuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9ucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZG9tID0gW107XG4gICAgICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGFnU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSB0aGlzLl9wYXJzZXIgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8vIFNpZ25hbHMgdGhlIGhhbmRsZXIgdGhhdCBwYXJzaW5nIGlzIGRvbmVcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZUNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLmhhbmRsZUNhbGxiYWNrKGVycm9yKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY2xvc2V0YWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgLy8gSWYodGhpcy5fdGFnU3RhY2sucG9wKCkubmFtZSAhPT0gbmFtZSkgdGhpcy5oYW5kbGVDYWxsYmFjayhFcnJvcihcIlRhZ25hbWUgZGlkbid0IG1hdGNoIVwiKSk7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5fdGFnU3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghZWxlbSB8fCAhdGhpcy5fcGFyc2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMud2l0aEVuZEluZGljZXMpIHtcbiAgICAgICAgICAgIGVsZW0uZW5kSW5kZXggPSB0aGlzLl9wYXJzZXIuZW5kSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRDQilcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRDQihlbGVtKTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9ub3BlbnRhZyA9IGZ1bmN0aW9uIChuYW1lLCBhdHRyaWJzKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gbmV3IG5vZGVfMS5FbGVtZW50KG5hbWUsIGF0dHJpYnMpO1xuICAgICAgICB0aGlzLmFkZE5vZGUoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3RhZ1N0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5vbnRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbm9ybWFsaXplID0gdGhpcy5fb3B0aW9ucy5ub3JtYWxpemVXaGl0ZXNwYWNlO1xuICAgICAgICB2YXIgX2xhc3ROb2RlID0gdGhpcy5fbGFzdE5vZGU7XG4gICAgICAgIGlmIChfbGFzdE5vZGUgJiYgX2xhc3ROb2RlLnR5cGUgPT09IFwidGV4dFwiIC8qIFRleHQgKi8pIHtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBfbGFzdE5vZGUuZGF0YSA9IChfbGFzdE5vZGUuZGF0YSArIGRhdGEpLnJlcGxhY2UocmVXaGl0ZXNwYWNlLCBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfbGFzdE5vZGUuZGF0YSArPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UocmVXaGl0ZXNwYWNlLCBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBub2RlXzEuRGF0YU5vZGUoXCJ0ZXh0XCIgLyogVGV4dCAqLywgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmFkZE5vZGUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0Tm9kZSAmJiB0aGlzLl9sYXN0Tm9kZS50eXBlID09PSBcImNvbW1lbnRcIiAvKiBDb21tZW50ICovKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Tm9kZS5kYXRhICs9IGRhdGE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgbm9kZV8xLkRhdGFOb2RlKFwiY29tbWVudFwiIC8qIENvbW1lbnQgKi8sIGRhdGEpO1xuICAgICAgICB0aGlzLmFkZE5vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbm9kZTtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBudWxsO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUub25jZGF0YXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dCA9IG5ldyBub2RlXzEuRGF0YU5vZGUoXCJ0ZXh0XCIgLyogVGV4dCAqLywgXCJcIik7XG4gICAgICAgIHZhciBub2RlID0gbmV3IG5vZGVfMS5Ob2RlV2l0aENoaWxkcmVuKFwiY2RhdGFcIiAvKiBDREFUQSAqLywgW3RleHRdKTtcbiAgICAgICAgdGhpcy5hZGROb2RlKG5vZGUpO1xuICAgICAgICB0ZXh0LnBhcmVudCA9IG5vZGU7XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gdGV4dDtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9uY2RhdGFlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xhc3ROb2RlID0gbnVsbDtcbiAgICB9O1xuICAgIERvbUhhbmRsZXIucHJvdG90eXBlLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgbm9kZV8xLlByb2Nlc3NpbmdJbnN0cnVjdGlvbihuYW1lLCBkYXRhKTtcbiAgICAgICAgdGhpcy5hZGROb2RlKG5vZGUpO1xuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFjayhlcnJvciwgdGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9tSGFuZGxlci5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl90YWdTdGFja1t0aGlzLl90YWdTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHNpYmxpbmdzID0gcGFyZW50ID8gcGFyZW50LmNoaWxkcmVuIDogdGhpcy5kb207XG4gICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBzaWJsaW5nc1tzaWJsaW5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMud2l0aFN0YXJ0SW5kaWNlcykge1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhcnRJbmRleCA9IHRoaXMuX3BhcnNlci5zdGFydEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMud2l0aEVuZEluZGljZXMpIHtcbiAgICAgICAgICAgICAgICBub2RlLmVuZEluZGV4ID0gdGhpcy5fcGFyc2VyLmVuZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgIG5vZGUucHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHByZXZpb3VzU2libGluZy5uZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0Tm9kZSA9IG51bGw7XG4gICAgfTtcbiAgICBEb21IYW5kbGVyLnByb3RvdHlwZS5hZGREYXRhTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYWRkTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSBub2RlO1xuICAgIH07XG4gICAgcmV0dXJuIERvbUhhbmRsZXI7XG59KCkpO1xuZXhwb3J0cy5Eb21IYW5kbGVyID0gRG9tSGFuZGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IERvbUhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5vZGVUeXBlcyA9IG5ldyBNYXAoW1xuICAgIFtcInRhZ1wiIC8qIFRhZyAqLywgMV0sXG4gICAgW1wic2NyaXB0XCIgLyogU2NyaXB0ICovLCAxXSxcbiAgICBbXCJzdHlsZVwiIC8qIFN0eWxlICovLCAxXSxcbiAgICBbXCJkaXJlY3RpdmVcIiAvKiBEaXJlY3RpdmUgKi8sIDFdLFxuICAgIFtcInRleHRcIiAvKiBUZXh0ICovLCAzXSxcbiAgICBbXCJjZGF0YVwiIC8qIENEQVRBICovLCA0XSxcbiAgICBbXCJjb21tZW50XCIgLyogQ29tbWVudCAqLywgOF1cbl0pO1xuLy8gVGhpcyBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHRoZSBwcm90b3R5cGUgZm9yIE5vZGVzIHdoZW4gY3JlYXRpbmcgYVxuLy8gRE9NLUxldmVsLTEtY29tcGxpYW50IHN0cnVjdHVyZS5cbnZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9kZSh0eXBlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKiBQYXJlbnQgb2YgdGhlIG5vZGUgKi9cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAvKiogUHJldmlvdXMgc2libGluZyAqL1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICAvKiogTmV4dCBzaWJsaW5nICovXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIG5vZGUuIFJlcXVpcmVzIGB3aXRoU3RhcnRJbmRpY2VzYCBvbiB0aGUgaGFuZGxlciB0byBiZSBgdHJ1ZS4gKi9cbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBlbmQgaW5kZXggb2YgdGhlIG5vZGUuIFJlcXVpcmVzIGB3aXRoRW5kSW5kaWNlc2Agb24gdGhlIGhhbmRsZXIgdG8gYmUgYHRydWUuICovXG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIFwibm9kZVR5cGVcIiwge1xuICAgICAgICAvLyBSZWFkLW9ubHkgYWxpYXNlc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlVHlwZXMuZ2V0KHRoaXMudHlwZSkgfHwgMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCBcInBhcmVudE5vZGVcIiwge1xuICAgICAgICAvLyBSZWFkLXdyaXRlIGFsaWFzZXMgZm9yIHByb3BlcnRpZXNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCBcInByZXZpb3VzU2libGluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldiB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIFwibmV4dFNpYmxpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbnZhciBEYXRhTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0YU5vZGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBjb250ZW50IG9mIHRoZSBkYXRhIG5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhTm9kZSh0eXBlLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwibm9kZVZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRGF0YU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRGF0YU5vZGUgPSBEYXRhTm9kZTtcbnZhciBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcImRpcmVjdGl2ZVwiIC8qIERpcmVjdGl2ZSAqLywgZGF0YSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFByb2Nlc3NpbmdJbnN0cnVjdGlvbjtcbn0oRGF0YU5vZGUpKTtcbmV4cG9ydHMuUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xudmFyIE5vZGVXaXRoQ2hpbGRyZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vZGVXaXRoQ2hpbGRyZW4sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBUeXBlIG9mIHRoZSBub2RlLlxuICAgICAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiBvZiB0aGUgbm9kZS4gT25seSBjZXJ0YWluIG5vZGUgdHlwZXMgY2FuIGhhdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9kZVdpdGhDaGlsZHJlbih0eXBlLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlV2l0aENoaWxkcmVuLnByb3RvdHlwZSwgXCJmaXJzdENoaWxkXCIsIHtcbiAgICAgICAgLy8gQWxpYXNlc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdIHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb2RlV2l0aENoaWxkcmVuLnByb3RvdHlwZSwgXCJsYXN0Q2hpbGRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGVXaXRoQ2hpbGRyZW4ucHJvdG90eXBlLCBcImNoaWxkTm9kZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTm9kZVdpdGhDaGlsZHJlbjtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Ob2RlV2l0aENoaWxkcmVuID0gTm9kZVdpdGhDaGlsZHJlbjtcbnZhciBFbGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdGFnLCBlZy4gYGRpdmAsIGBzcGFuYFxuICAgICAqIEBwYXJhbSBhdHRyaWJzIE9iamVjdCBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lcyB0byBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWxlbWVudChuYW1lLCBhdHRyaWJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUgPT09IFwic2NyaXB0XCJcbiAgICAgICAgICAgID8gXCJzY3JpcHRcIiAvKiBTY3JpcHQgKi9cbiAgICAgICAgICAgIDogbmFtZSA9PT0gXCJzdHlsZVwiXG4gICAgICAgICAgICAgICAgPyBcInN0eWxlXCIgLyogU3R5bGUgKi9cbiAgICAgICAgICAgICAgICA6IFwidGFnXCIgLyogVGFnICovLCBbXSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmF0dHJpYnMgPSBhdHRyaWJzO1xuICAgICAgICBfdGhpcy5hdHRyaWJzID0gYXR0cmlicztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudC5wcm90b3R5cGUsIFwidGFnTmFtZVwiLCB7XG4gICAgICAgIC8vIERPTSBMZXZlbCAxIGFsaWFzZXNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRWxlbWVudDtcbn0oTm9kZVdpdGhDaGlsZHJlbikpO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRhZ3R5cGVzXzEgPSByZXF1aXJlKFwiLi90YWd0eXBlc1wiKTtcbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygbm9kZXMsIHJlbW92ZSBhbnkgbWVtYmVyIHRoYXQgaXMgY29udGFpbmVkIGJ5IGFub3RoZXIuXG4gKlxuICogQHBhcmFtIG5vZGVzIOKAlCBOb2RlcyB0byBmaWx0ZXIuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVN1YnNldHMobm9kZXMpIHtcbiAgICB2YXIgaWR4ID0gbm9kZXMubGVuZ3RoO1xuICAgIC8vIENoZWNrIGlmIGVhY2ggbm9kZSAob3Igb25lIG9mIGl0cyBhbmNlc3RvcnMpIGlzIGFscmVhZHkgY29udGFpbmVkIGluIHRoZVxuICAgIC8vIGFycmF5LlxuICAgIHdoaWxlICgtLWlkeCA+PSAwKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaWR4XTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlIGlmIGl0IGlzIG5vdCB1bmlxdWUuXG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0aHJvdWdoIHRoZSBhcnJheSBmcm9tIHRoZSBlbmQsIHNvIHdlIG9ubHlcbiAgICAgICAgLy8gaGF2ZSB0byBjaGVjayBub2RlcyB0aGF0IHByZWNlZWQgdGhlIG5vZGUgdW5kZXIgY29uc2lkZXJhdGlvbiBpbiB0aGUgYXJyYXkuXG4gICAgICAgIGlmIChpZHggPiAwICYmIG5vZGVzLmxhc3RJbmRleE9mKG5vZGUsIGlkeCAtIDEpID49IDApIHtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgYW5jZXN0b3IgPSBub2RlLnBhcmVudDsgYW5jZXN0b3I7IGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihhbmNlc3RvcikgPiAtMSkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmV4cG9ydHMucmVtb3ZlU3Vic2V0cyA9IHJlbW92ZVN1YnNldHM7XG4vKioqXG4gKiBDb21wYXJlIHRoZSBwb3NpdGlvbiBvZiBvbmUgbm9kZSBhZ2FpbnN0IGFub3RoZXIgbm9kZSBpbiBhbnkgb3RoZXIgZG9jdW1lbnQuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGEgYml0bWFzayB3aXRoIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICpcbiAqIGRvY3VtZW50IG9yZGVyOlxuICogPiBUaGVyZSBpcyBhbiBvcmRlcmluZywgZG9jdW1lbnQgb3JkZXIsIGRlZmluZWQgb24gYWxsIHRoZSBub2RlcyBpbiB0aGVcbiAqID4gZG9jdW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGVcbiAqID4gWE1MIHJlcHJlc2VudGF0aW9uIG9mIGVhY2ggbm9kZSBvY2N1cnMgaW4gdGhlIFhNTCByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAqID4gZG9jdW1lbnQgYWZ0ZXIgZXhwYW5zaW9uIG9mIGdlbmVyYWwgZW50aXRpZXMuIFRodXMsIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gKiA+IG5vZGUgd2lsbCBiZSB0aGUgZmlyc3Qgbm9kZS4gRWxlbWVudCBub2RlcyBvY2N1ciBiZWZvcmUgdGhlaXIgY2hpbGRyZW4uXG4gKiA+IFRodXMsIGRvY3VtZW50IG9yZGVyIG9yZGVycyBlbGVtZW50IG5vZGVzIGluIG9yZGVyIG9mIHRoZSBvY2N1cnJlbmNlIG9mXG4gKiA+IHRoZWlyIHN0YXJ0LXRhZyBpbiB0aGUgWE1MIChhZnRlciBleHBhbnNpb24gb2YgZW50aXRpZXMpLiBUaGUgYXR0cmlidXRlXG4gKiA+IG5vZGVzIG9mIGFuIGVsZW1lbnQgb2NjdXIgYWZ0ZXIgdGhlIGVsZW1lbnQgYW5kIGJlZm9yZSBpdHMgY2hpbGRyZW4uIFRoZVxuICogPiByZWxhdGl2ZSBvcmRlciBvZiBhdHRyaWJ1dGUgbm9kZXMgaXMgaW1wbGVtZW50YXRpb24tZGVwZW5kZW50Li9cbiAqXG4gKiBTb3VyY2U6XG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2dsb3NzYXJ5Lmh0bWwjZHQtZG9jdW1lbnQtb3JkZXJcbiAqIEBhcmd1bWVudCBub2RhQSBUaGUgZmlyc3Qgbm9kZSB0byB1c2UgaW4gdGhlIGNvbXBhcmlzb25cbiAqIEBhcmd1bWVudCBub2RlQiBUaGUgc2Vjb25kIG5vZGUgdG8gdXNlIGluIHRoZSBjb21wYXJpc29uXG4gKlxuICogQHJldHVybiBBIGJpdG1hc2sgZGVzY3JpYmluZyB0aGUgaW5wdXQgbm9kZXMnIHJlbGF0aXZlIHBvc2l0aW9uLlxuICpcbiAqICAgICAgICBTZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ub2RlLWNvbXBhcmVkb2N1bWVudHBvc2l0aW9uIGZvclxuICogICAgICAgIGEgZGVzY3JpcHRpb24gb2YgdGhlc2UgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlQSwgbm9kZUIpIHtcbiAgICB2YXIgYVBhcmVudHMgPSBbXTtcbiAgICB2YXIgYlBhcmVudHMgPSBbXTtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9IHRhZ3R5cGVzXzEuaGFzQ2hpbGRyZW4obm9kZUEpID8gbm9kZUEgOiBub2RlQS5wYXJlbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgYVBhcmVudHMudW5zaGlmdChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICBjdXJyZW50ID0gdGFndHlwZXNfMS5oYXNDaGlsZHJlbihub2RlQikgPyBub2RlQiA6IG5vZGVCLnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBiUGFyZW50cy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciBpZHggPSAwO1xuICAgIHdoaWxlIChhUGFyZW50c1tpZHhdID09PSBiUGFyZW50c1tpZHhdKSB7XG4gICAgICAgIGlkeCsrO1xuICAgIH1cbiAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxIC8qIERJU0NPTk5FQ1RFRCAqLztcbiAgICB9XG4gICAgdmFyIHNoYXJlZFBhcmVudCA9IGFQYXJlbnRzW2lkeCAtIDFdO1xuICAgIHZhciBzaWJsaW5ncyA9IHNoYXJlZFBhcmVudC5jaGlsZHJlbjtcbiAgICB2YXIgYVNpYmxpbmcgPSBhUGFyZW50c1tpZHhdO1xuICAgIHZhciBiU2libGluZyA9IGJQYXJlbnRzW2lkeF07XG4gICAgaWYgKHNpYmxpbmdzLmluZGV4T2YoYVNpYmxpbmcpID4gc2libGluZ3MuaW5kZXhPZihiU2libGluZykpIHtcbiAgICAgICAgaWYgKHNoYXJlZFBhcmVudCA9PT0gbm9kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiA0IC8qIEZPTExPV0lORyAqLyB8IDE2IC8qIENPTlRBSU5FRF9CWSAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gNCAvKiBGT0xMT1dJTkcgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2hhcmVkUGFyZW50ID09PSBub2RlQSkge1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogUFJFQ0VESU5HICovIHwgOCAvKiBDT05UQUlOUyAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMiAvKiBQUkVDRURJTkcgKi87XG4gICAgfVxufVxuZXhwb3J0cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA9IGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuLyoqKlxuICogU29ydCBhbiBhcnJheSBvZiBub2RlcyBiYXNlZCBvbiB0aGVpciByZWxhdGl2ZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQgYW5kXG4gKiByZW1vdmUgYW55IGR1cGxpY2F0ZSBub2Rlcy4gSWYgdGhlIGFycmF5IGNvbnRhaW5zIG5vZGVzIHRoYXQgZG8gbm90IGJlbG9uZ1xuICogdG8gdGhlIHNhbWUgZG9jdW1lbnQsIHNvcnQgb3JkZXIgaXMgdW5zcGVjaWZpZWQuXG4gKlxuICogQGFyZ3VtZW50IG5vZGVzIEFycmF5IG9mIERPTSBub2Rlc1xuICogQHJldHVybnMgY29sbGVjdGlvbiBvZiB1bmlxdWUgbm9kZXMsIHNvcnRlZCBpbiBkb2N1bWVudCBvcmRlclxuICovXG5mdW5jdGlvbiB1bmlxdWVTb3J0KG5vZGVzKSB7XG4gICAgbm9kZXMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUsIGksIGFycikgeyByZXR1cm4gIWFyci5pbmNsdWRlcyhub2RlLCBpICsgMSk7IH0pO1xuICAgIG5vZGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSwgYik7XG4gICAgICAgIGlmIChyZWxhdGl2ZSAmIDIgLyogUFJFQ0VESU5HICovKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVsYXRpdmUgJiA0IC8qIEZPTExPV0lORyAqLykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZXhwb3J0cy51bmlxdWVTb3J0ID0gdW5pcXVlU29ydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmF2ZXJzYWxcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbWFuaXB1bGF0aW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3F1ZXJ5aW5nXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2xlZ2FjeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oZWxwZXJzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHF1ZXJ5aW5nXzEgPSByZXF1aXJlKFwiLi9xdWVyeWluZ1wiKTtcbnZhciB0YWd0eXBlc18xID0gcmVxdWlyZShcIi4vdGFndHlwZXNcIik7XG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInRleHRcIiAvKiBUZXh0ICovO1xufVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZSAqL1xudmFyIENoZWNrcyA9IHtcbiAgICB0YWdfbmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGFndHlwZXNfMS5pc1RhZyhlbGVtKSAmJiBuYW1lKGVsZW0ubmFtZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWd0eXBlc18xLmlzVGFnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0YWd0eXBlc18xLmlzVGFnKGVsZW0pICYmIGVsZW0ubmFtZSA9PT0gbmFtZTsgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGFnX3R5cGU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHR5cGUoZWxlbS50eXBlKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbS50eXBlID09PSB0eXBlOyB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0YWdfY29udGFpbnM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGlzVGV4dE5vZGUoZWxlbSkgJiYgZGF0YShlbGVtLmRhdGEpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBpc1RleHROb2RlKGVsZW0pICYmIGVsZW0uZGF0YSA9PT0gZGF0YTsgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jYW1lbGNhc2UgKi9cbmZ1bmN0aW9uIGdldEF0dHJpYkNoZWNrKGF0dHJpYiwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB0YWd0eXBlc18xLmlzVGFnKGVsZW0pICYmIHZhbHVlKGVsZW0uYXR0cmlic1thdHRyaWJdKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGFndHlwZXNfMS5pc1RhZyhlbGVtKSAmJiBlbGVtLmF0dHJpYnNbYXR0cmliXSA9PT0gdmFsdWU7IH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tYmluZUZ1bmNzKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGEoZWxlbSkgfHwgYihlbGVtKTsgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVUZXN0KG9wdGlvbnMpIHtcbiAgICB2YXIgZnVuY3MgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGtleSBpbiBDaGVja3MgPyBDaGVja3Nba2V5XSh2YWx1ZSkgOiBnZXRBdHRyaWJDaGVjayhrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3MubGVuZ3RoID09PSAwID8gbnVsbCA6IGZ1bmNzLnJlZHVjZShjb21iaW5lRnVuY3MpO1xufVxuZnVuY3Rpb24gdGVzdEVsZW1lbnQob3B0aW9ucywgZWxlbWVudCkge1xuICAgIHZhciB0ZXN0ID0gY29tcGlsZVRlc3Qob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRlc3QgPyB0ZXN0KGVsZW1lbnQpIDogdHJ1ZTtcbn1cbmV4cG9ydHMudGVzdEVsZW1lbnQgPSB0ZXN0RWxlbWVudDtcbmZ1bmN0aW9uIGdldEVsZW1lbnRzKG9wdGlvbnMsIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIHZhciB0ZXN0ID0gY29tcGlsZVRlc3Qob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRlc3QgPyBxdWVyeWluZ18xLmZpbHRlcih0ZXN0LCBlbGVtZW50LCByZWN1cnNlLCBsaW1pdCkgOiBbXTtcbn1cbmV4cG9ydHMuZ2V0RWxlbWVudHMgPSBnZXRFbGVtZW50cztcbmZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKGlkLCBlbGVtZW50LCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50KSlcbiAgICAgICAgZWxlbWVudCA9IFtlbGVtZW50XTtcbiAgICByZXR1cm4gcXVlcnlpbmdfMS5maW5kT25lKGdldEF0dHJpYkNoZWNrKFwiaWRcIiwgaWQpLCBlbGVtZW50LCByZWN1cnNlKTtcbn1cbmV4cG9ydHMuZ2V0RWxlbWVudEJ5SWQgPSBnZXRFbGVtZW50QnlJZDtcbmZ1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUsIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIHJldHVybiBxdWVyeWluZ18xLmZpbHRlcihDaGVja3MudGFnX25hbWUobmFtZSksIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KTtcbn1cbmV4cG9ydHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBnZXRFbGVtZW50c0J5VGFnTmFtZTtcbmZ1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdUeXBlKHR5cGUsIGVsZW1lbnQsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIGlmIChsaW1pdCA9PT0gdm9pZCAwKSB7IGxpbWl0ID0gSW5maW5pdHk7IH1cbiAgICByZXR1cm4gcXVlcnlpbmdfMS5maWx0ZXIoQ2hlY2tzLnRhZ190eXBlKHR5cGUpLCBlbGVtZW50LCByZWN1cnNlLCBsaW1pdCk7XG59XG5leHBvcnRzLmdldEVsZW1lbnRzQnlUYWdUeXBlID0gZ2V0RWxlbWVudHNCeVRhZ1R5cGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIGRvbVxuICpcbiAqIEBhcmd1bWVudCBlbGVtIFRoZSBlbGVtZW50IHRvIGJlIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtKSB7XG4gICAgaWYgKGVsZW0ucHJldilcbiAgICAgICAgZWxlbS5wcmV2Lm5leHQgPSBlbGVtLm5leHQ7XG4gICAgaWYgKGVsZW0ubmV4dClcbiAgICAgICAgZWxlbS5uZXh0LnByZXYgPSBlbGVtLnByZXY7XG4gICAgaWYgKGVsZW0ucGFyZW50KSB7XG4gICAgICAgIHZhciBjaGlsZHMgPSBlbGVtLnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoZWxlbSksIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMucmVtb3ZlRWxlbWVudCA9IHJlbW92ZUVsZW1lbnQ7XG4vKioqXG4gKiBSZXBsYWNlIGFuIGVsZW1lbnQgaW4gdGhlIGRvbVxuICpcbiAqIEBhcmd1bWVudCBlbGVtIFRoZSBlbGVtZW50IHRvIGJlIHJlcGxhY2VkXG4gKiBAYXJndW1lbnQgcmVwbGFjZW1lbnQgVGhlIGVsZW1lbnQgdG8gYmUgYWRkZWRcbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUVsZW1lbnQoZWxlbSwgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgcHJldiA9IChyZXBsYWNlbWVudC5wcmV2ID0gZWxlbS5wcmV2KTtcbiAgICBpZiAocHJldikge1xuICAgICAgICBwcmV2Lm5leHQgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgdmFyIG5leHQgPSAocmVwbGFjZW1lbnQubmV4dCA9IGVsZW0ubmV4dCk7XG4gICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dC5wcmV2ID0gcmVwbGFjZW1lbnQ7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSAocmVwbGFjZW1lbnQucGFyZW50ID0gZWxlbS5wYXJlbnQpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkcyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY2hpbGRzW2NoaWxkcy5sYXN0SW5kZXhPZihlbGVtKV0gPSByZXBsYWNlbWVudDtcbiAgICB9XG59XG5leHBvcnRzLnJlcGxhY2VFbGVtZW50ID0gcmVwbGFjZUVsZW1lbnQ7XG4vKioqXG4gKiBBcHBlbmQgYSBjaGlsZCB0byBhbiBlbGVtZW50XG4gKlxuICogQGFyZ3VtZW50IGVsZW0gVGhlIGVsZW1lbnQgdG8gYXBwZW5kIHRvXG4gKiBAYXJndW1lbnQgY2hpbGQgVGhlIGVsZW1lbnQgdG8gYmUgYWRkZWQgYXMgYSBjaGlsZFxuICovXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChlbGVtLCBjaGlsZCkge1xuICAgIGNoaWxkLnBhcmVudCA9IGVsZW07XG4gICAgaWYgKGVsZW0uY2hpbGRyZW4ucHVzaChjaGlsZCkgIT09IDEpIHtcbiAgICAgICAgdmFyIHNpYmxpbmcgPSBlbGVtLmNoaWxkcmVuW2VsZW0uY2hpbGRyZW4ubGVuZ3RoIC0gMl07XG4gICAgICAgIHNpYmxpbmcubmV4dCA9IGNoaWxkO1xuICAgICAgICBjaGlsZC5wcmV2ID0gc2libGluZztcbiAgICAgICAgY2hpbGQubmV4dCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5hcHBlbmRDaGlsZCA9IGFwcGVuZENoaWxkO1xuLyoqKlxuICogQXBwZW5kIGFuIGVsZW1lbnQgYWZ0ZXIgYW5vdGhlclxuICpcbiAqIEBhcmd1bWVudCBlbGVtIFRoZSBlbGVtZW50IHRvIGFwcGVuZCB0b1xuICogQGFyZ3VtZW50IG5leHQgVGhlIGVsZW1lbnQgYmUgYWRkZWRcbiAqL1xuZnVuY3Rpb24gYXBwZW5kKGVsZW0sIG5leHQpIHtcbiAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnQsIGN1cnJOZXh0ID0gZWxlbS5uZXh0O1xuICAgIG5leHQubmV4dCA9IGN1cnJOZXh0O1xuICAgIG5leHQucHJldiA9IGVsZW07XG4gICAgZWxlbS5uZXh0ID0gbmV4dDtcbiAgICBuZXh0LnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAoY3Vyck5leHQpIHtcbiAgICAgICAgY3Vyck5leHQucHJldiA9IG5leHQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHMgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICBjaGlsZHMuc3BsaWNlKGNoaWxkcy5sYXN0SW5kZXhPZihjdXJyTmV4dCksIDAsIG5leHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChuZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLmFwcGVuZCA9IGFwcGVuZDtcbi8qKipcbiAqIFByZXBlbmQgYW4gZWxlbWVudCBiZWZvcmUgYW5vdGhlclxuICpcbiAqIEBhcmd1bWVudCBlbGVtIFRoZSBlbGVtZW50IHRvIGFwcGVuZCB0b1xuICogQGFyZ3VtZW50IHByZXYgVGhlIGVsZW1lbnQgYmUgYWRkZWRcbiAqL1xuZnVuY3Rpb24gcHJlcGVuZChlbGVtLCBwcmV2KSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkcyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoZWxlbSksIDAsIHByZXYpO1xuICAgIH1cbiAgICBpZiAoZWxlbS5wcmV2KSB7XG4gICAgICAgIGVsZW0ucHJldi5uZXh0ID0gcHJldjtcbiAgICB9XG4gICAgcHJldi5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcHJldi5wcmV2ID0gZWxlbS5wcmV2O1xuICAgIHByZXYubmV4dCA9IGVsZW07XG4gICAgZWxlbS5wcmV2ID0gcHJldjtcbn1cbmV4cG9ydHMucHJlcGVuZCA9IHByZXBlbmQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0YWd0eXBlc18xID0gcmVxdWlyZShcIi4vdGFndHlwZXNcIik7XG5mdW5jdGlvbiBmaWx0ZXIodGVzdCwgZWxlbWVudCwgcmVjdXJzZSwgbGltaXQpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSB0cnVlOyB9XG4gICAgaWYgKGxpbWl0ID09PSB2b2lkIDApIHsgbGltaXQgPSBJbmZpbml0eTsgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50KSlcbiAgICAgICAgZWxlbWVudCA9IFtlbGVtZW50XTtcbiAgICByZXR1cm4gZmluZCh0ZXN0LCBlbGVtZW50LCByZWN1cnNlLCBsaW1pdCk7XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmZ1bmN0aW9uIGZpbmQodGVzdCwgZWxlbXMsIHJlY3Vyc2UsIGxpbWl0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW0gPSBlbGVtc1tpXTtcbiAgICAgICAgaWYgKHRlc3QoZWxlbSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgaWYgKC0tbGltaXQgPD0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzZSAmJiB0YWd0eXBlc18xLmhhc0NoaWxkcmVuKGVsZW0pICYmIGVsZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZmluZCh0ZXN0LCBlbGVtLmNoaWxkcmVuLCByZWN1cnNlLCBsaW1pdCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIGxpbWl0IC09IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuZnVuY3Rpb24gZmluZE9uZUNoaWxkKHRlc3QsIGVsZW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGVzdChlbGVtc1tpXSkpXG4gICAgICAgICAgICByZXR1cm4gZWxlbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5maW5kT25lQ2hpbGQgPSBmaW5kT25lQ2hpbGQ7XG5mdW5jdGlvbiBmaW5kT25lKHRlc3QsIGVsZW1zLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gdHJ1ZTsgfVxuICAgIHZhciBlbGVtID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aCAmJiAhZWxlbTsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VkID0gZWxlbXNbaV07XG4gICAgICAgIGlmICghdGFndHlwZXNfMS5pc1RhZyhjaGVja2VkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGVzdChjaGVja2VkKSkge1xuICAgICAgICAgICAgZWxlbSA9IGNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVjdXJzZSAmJiBjaGVja2VkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsZW0gPSBmaW5kT25lKHRlc3QsIGNoZWNrZWQuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtO1xufVxuZXhwb3J0cy5maW5kT25lID0gZmluZE9uZTtcbmZ1bmN0aW9uIGV4aXN0c09uZSh0ZXN0LCBlbGVtcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZWQgPSBlbGVtc1tpXTtcbiAgICAgICAgaWYgKHRhZ3R5cGVzXzEuaXNUYWcoY2hlY2tlZCkgJiZcbiAgICAgICAgICAgICh0ZXN0KGNoZWNrZWQpIHx8XG4gICAgICAgICAgICAgICAgKGNoZWNrZWQuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBleGlzdHNPbmUodGVzdCwgY2hlY2tlZC5jaGlsZHJlbikpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5leGlzdHNPbmUgPSBleGlzdHNPbmU7XG5mdW5jdGlvbiBmaW5kQWxsKHRlc3QsIHJvb3RFbGVtcykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc3RhY2sgPSByb290RWxlbXMuc2xpY2UoKTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbGVtID0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgaWYgKCFlbGVtIHx8ICF0YWd0eXBlc18xLmlzVGFnKGVsZW0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChlbGVtLmNoaWxkcmVuICYmIGVsZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhY2sudW5zaGlmdC5hcHBseShzdGFjaywgZWxlbS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlc3QoZWxlbSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZmluZEFsbCA9IGZpbmRBbGw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0YWd0eXBlc18xID0gcmVxdWlyZShcIi4vdGFndHlwZXNcIik7XG52YXIgZG9tX3NlcmlhbGl6ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9tLXNlcmlhbGl6ZXJcIikpO1xuZXhwb3J0cy5nZXRPdXRlckhUTUwgPSBkb21fc2VyaWFsaXplcl8xLmRlZmF1bHQ7XG5mdW5jdGlvbiBnZXRJbm5lckhUTUwobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0YWd0eXBlc18xLmhhc0NoaWxkcmVuKG5vZGUpXG4gICAgICAgID8gbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGV4cG9ydHMuZ2V0T3V0ZXJIVE1MKG5vZGUsIG9wdGlvbnMpOyB9KS5qb2luKFwiXCIpXG4gICAgICAgIDogXCJcIjtcbn1cbmV4cG9ydHMuZ2V0SW5uZXJIVE1MID0gZ2V0SW5uZXJIVE1MO1xuZnVuY3Rpb24gZ2V0VGV4dChub2RlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLm1hcChnZXRUZXh0KS5qb2luKFwiXCIpO1xuICAgIGlmICh0YWd0eXBlc18xLmlzVGFnKG5vZGUpKVxuICAgICAgICByZXR1cm4gbm9kZS5uYW1lID09PSBcImJyXCIgPyBcIlxcblwiIDogZ2V0VGV4dChub2RlLmNoaWxkcmVuKTtcbiAgICBpZiAodGFndHlwZXNfMS5pc0NEQVRBKG5vZGUpKVxuICAgICAgICByZXR1cm4gZ2V0VGV4dChub2RlLmNoaWxkcmVuKTtcbiAgICBpZiAodGFndHlwZXNfMS5pc1RleHQobm9kZSkpXG4gICAgICAgIHJldHVybiBub2RlLmRhdGE7XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnRzLmdldFRleHQgPSBnZXRUZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9tZWxlbWVudHR5cGVfMSA9IHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKTtcbmZ1bmN0aW9uIGlzVGFnKG5vZGUpIHtcbiAgICByZXR1cm4gZG9tZWxlbWVudHR5cGVfMS5pc1RhZyhub2RlKTtcbn1cbmV4cG9ydHMuaXNUYWcgPSBpc1RhZztcbmZ1bmN0aW9uIGlzQ0RBVEEobm9kZSkge1xuICAgIHJldHVybiBcImNkYXRhXCIgLyogQ0RBVEEgKi8gPT09IG5vZGUudHlwZTtcbn1cbmV4cG9ydHMuaXNDREFUQSA9IGlzQ0RBVEE7XG5mdW5jdGlvbiBpc1RleHQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwidGV4dFwiIC8qIFRleHQgKi87XG59XG5leHBvcnRzLmlzVGV4dCA9IGlzVGV4dDtcbmZ1bmN0aW9uIGlzQ29tbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjb21tZW50XCIgLyogQ29tbWVudCAqLztcbn1cbmV4cG9ydHMuaXNDb21tZW50ID0gaXNDb21tZW50O1xuZnVuY3Rpb24gaGFzQ2hpbGRyZW4obm9kZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgXCJjaGlsZHJlblwiKTtcbn1cbmV4cG9ydHMuaGFzQ2hpbGRyZW4gPSBoYXNDaGlsZHJlbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZWxlbSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZWxlbS5jaGlsZHJlbiB8fCBudWxsO1xufVxuZXhwb3J0cy5nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuO1xuZnVuY3Rpb24gZ2V0UGFyZW50KGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS5wYXJlbnQgfHwgbnVsbDtcbn1cbmV4cG9ydHMuZ2V0UGFyZW50ID0gZ2V0UGFyZW50O1xuZnVuY3Rpb24gZ2V0U2libGluZ3MoZWxlbSkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQoZWxlbSk7XG4gICAgcmV0dXJuIHBhcmVudCA/IGdldENoaWxkcmVuKHBhcmVudCkgOiBbZWxlbV07XG59XG5leHBvcnRzLmdldFNpYmxpbmdzID0gZ2V0U2libGluZ3M7XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLCBuYW1lKSB7XG4gICAgcmV0dXJuIGVsZW0uYXR0cmlicyAmJiBlbGVtLmF0dHJpYnNbbmFtZV07XG59XG5leHBvcnRzLmdldEF0dHJpYnV0ZVZhbHVlID0gZ2V0QXR0cmlidXRlVmFsdWU7XG5mdW5jdGlvbiBoYXNBdHRyaWIoZWxlbSwgbmFtZSkge1xuICAgIHJldHVybiAhIWdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sIG5hbWUpO1xufVxuZXhwb3J0cy5oYXNBdHRyaWIgPSBoYXNBdHRyaWI7XG4vKioqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIHByb3BlcnR5IG9mIGFuIGVsZW1lbnRcbiAqXG4gKiBAYXJndW1lbnQgZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIG5hbWUgZm9yXG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLm5hbWU7XG59XG5leHBvcnRzLmdldE5hbWUgPSBnZXROYW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW50aXRpZXNfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hcHMvZW50aXRpZXMuanNvblwiKSk7XG52YXIgbGVnYWN5X2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2xlZ2FjeS5qc29uXCIpKTtcbnZhciB4bWxfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hcHMveG1sLmpzb25cIikpO1xudmFyIGRlY29kZV9jb2RlcG9pbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9kZWNvZGVfY29kZXBvaW50XCIpKTtcbmV4cG9ydHMuZGVjb2RlWE1MID0gZ2V0U3RyaWN0RGVjb2Rlcih4bWxfanNvbl8xLmRlZmF1bHQpO1xuZXhwb3J0cy5kZWNvZGVIVE1MU3RyaWN0ID0gZ2V0U3RyaWN0RGVjb2RlcihlbnRpdGllc19qc29uXzEuZGVmYXVsdCk7XG5mdW5jdGlvbiBnZXRTdHJpY3REZWNvZGVyKG1hcCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobWFwKS5qb2luKFwifFwiKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKG1hcCk7XG4gICAga2V5cyArPSBcInwjW3hYXVtcXFxcZGEtZkEtRl0rfCNcXFxcZCtcIjtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cyArIFwiKTtcIiwgXCJnXCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLCByZXBsYWNlKTsgfTtcbn1cbnZhciBzb3J0ZXIgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEgPCBiID8gMSA6IC0xKTsgfTtcbmV4cG9ydHMuZGVjb2RlSFRNTCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlZ2FjeSA9IE9iamVjdC5rZXlzKGxlZ2FjeV9qc29uXzEuZGVmYXVsdCkuc29ydChzb3J0ZXIpO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZW50aXRpZXNfanNvbl8xLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZWdhY3lbal0gPT09IGtleXNbaV0pIHtcbiAgICAgICAgICAgIGtleXNbaV0gKz0gXCI7P1wiO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5c1tpXSArPSBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cy5qb2luKFwifFwiKSArIFwifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsIFwiZ1wiKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKGVudGl0aWVzX2pzb25fMS5kZWZhdWx0KTtcbiAgICBmdW5jdGlvbiByZXBsYWNlcihzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5zdWJzdHIoLTEpICE9PSBcIjtcIilcbiAgICAgICAgICAgIHN0ciArPSBcIjtcIjtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2Uoc3RyKTtcbiAgICB9XG4gICAgLy9UT0RPIGNvbnNpZGVyIGNyZWF0aW5nIGEgbWVyZ2VkIG1hcFxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLCByZXBsYWNlcik7XG4gICAgfTtcbn0pKCk7XG5mdW5jdGlvbiBnZXRSZXBsYWNlcihtYXApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMSkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmNoYXJBdCgyKSA9PT0gXCJYXCIgfHwgc3RyLmNoYXJBdCgyKSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VJbnQoc3RyLnN1YnN0cigzKSwgMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVfY29kZXBvaW50XzEuZGVmYXVsdChwYXJzZUludChzdHIuc3Vic3RyKDIpLCAxMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBbc3RyLnNsaWNlKDEsIC0xKV07XG4gICAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlY29kZV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy9kZWNvZGUuanNvblwiKSk7XG4vLyBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL2hlL2Jsb2IvbWFzdGVyL3NyYy9oZS5qcyNMOTQtTDExOVxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuICAgIGlmICgoY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkZmZmKSB8fCBjb2RlUG9pbnQgPiAweDEwZmZmZikge1xuICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgaW4gZGVjb2RlX2pzb25fMS5kZWZhdWx0KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29kZVBvaW50ID0gZGVjb2RlX2pzb25fMS5kZWZhdWx0W2NvZGVQb2ludF07XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgIGlmIChjb2RlUG9pbnQgPiAweGZmZmYpIHtcbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+PiAxMCkgJiAweDNmZikgfCAweGQ4MDApO1xuICAgICAgICBjb2RlUG9pbnQgPSAweGRjMDAgfCAoY29kZVBvaW50ICYgMHgzZmYpO1xuICAgIH1cbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWNvZGVDb2RlUG9pbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB4bWxfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hcHMveG1sLmpzb25cIikpO1xudmFyIGludmVyc2VYTUwgPSBnZXRJbnZlcnNlT2JqKHhtbF9qc29uXzEuZGVmYXVsdCk7XG52YXIgeG1sUmVwbGFjZXIgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZVhNTCk7XG5leHBvcnRzLmVuY29kZVhNTCA9IGdldEludmVyc2UoaW52ZXJzZVhNTCwgeG1sUmVwbGFjZXIpO1xudmFyIGVudGl0aWVzX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2VudGl0aWVzLmpzb25cIikpO1xudmFyIGludmVyc2VIVE1MID0gZ2V0SW52ZXJzZU9iaihlbnRpdGllc19qc29uXzEuZGVmYXVsdCk7XG52YXIgaHRtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VIVE1MKTtcbmV4cG9ydHMuZW5jb2RlSFRNTCA9IGdldEludmVyc2UoaW52ZXJzZUhUTUwsIGh0bWxSZXBsYWNlcik7XG5mdW5jdGlvbiBnZXRJbnZlcnNlT2JqKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoaW52ZXJzZSwgbmFtZSkge1xuICAgICAgICBpbnZlcnNlW29ialtuYW1lXV0gPSBcIiZcIiArIG5hbWUgKyBcIjtcIjtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2UpIHtcbiAgICB2YXIgc2luZ2xlID0gW107XG4gICAgdmFyIG11bHRpcGxlID0gW107XG4gICAgT2JqZWN0LmtleXMoaW52ZXJzZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gay5sZW5ndGggPT09IDFcbiAgICAgICAgICAgID8gLy8gQWRkIHZhbHVlIHRvIHNpbmdsZSBhcnJheVxuICAgICAgICAgICAgICAgIHNpbmdsZS5wdXNoKFwiXFxcXFwiICsgaylcbiAgICAgICAgICAgIDogLy8gQWRkIHZhbHVlIHRvIG11bHRpcGxlIGFycmF5XG4gICAgICAgICAgICAgICAgbXVsdGlwbGUucHVzaChrKTtcbiAgICB9KTtcbiAgICAvL1RPRE8gYWRkIHJhbmdlc1xuICAgIG11bHRpcGxlLnVuc2hpZnQoXCJbXCIgKyBzaW5nbGUuam9pbihcIlwiKSArIFwiXVwiKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChtdWx0aXBsZS5qb2luKFwifFwiKSwgXCJnXCIpO1xufVxudmFyIHJlTm9uQVNDSUkgPSAvW15cXDAtXFx4N0ZdL2c7XG52YXIgcmVBc3RyYWxTeW1ib2xzID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZztcbmZ1bmN0aW9uIHNpbmdsZUNoYXJSZXBsYWNlcihjKSB7XG4gICAgcmV0dXJuIFwiJiN4XCIgKyBjXG4gICAgICAgIC5jaGFyQ29kZUF0KDApXG4gICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgLnRvVXBwZXJDYXNlKCkgKyBcIjtcIjtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGFzdHJhbFJlcGxhY2VyKGMsIF8pIHtcbiAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgIHZhciBoaWdoID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBsb3cgPSBjLmNoYXJDb2RlQXQoMSk7XG4gICAgdmFyIGNvZGVQb2ludCA9IChoaWdoIC0gMHhkODAwKSAqIDB4NDAwICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICByZXR1cm4gXCImI3hcIiArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiO1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52ZXJzZShpbnZlcnNlLCByZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpbnZlcnNlW25hbWVdOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UocmVBc3RyYWxTeW1ib2xzLCBhc3RyYWxSZXBsYWNlcilcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlTm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG4gICAgfTtcbn1cbnZhciByZVhtbENoYXJzID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO1xuZnVuY3Rpb24gZXNjYXBlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YVxuICAgICAgICAucmVwbGFjZShyZVhtbENoYXJzLCBzaW5nbGVDaGFyUmVwbGFjZXIpXG4gICAgICAgIC5yZXBsYWNlKHJlQXN0cmFsU3ltYm9scywgYXN0cmFsUmVwbGFjZXIpXG4gICAgICAgIC5yZXBsYWNlKHJlTm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlY29kZV8xID0gcmVxdWlyZShcIi4vZGVjb2RlXCIpO1xudmFyIGVuY29kZV8xID0gcmVxdWlyZShcIi4vZW5jb2RlXCIpO1xuZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUwpKGRhdGEpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBkZWNvZGVTdHJpY3QoZGF0YSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlXzEuZGVjb2RlWE1MIDogZGVjb2RlXzEuZGVjb2RlSFRNTFN0cmljdCkoZGF0YSk7XG59XG5leHBvcnRzLmRlY29kZVN0cmljdCA9IGRlY29kZVN0cmljdDtcbmZ1bmN0aW9uIGVuY29kZShkYXRhLCBsZXZlbCkge1xuICAgIHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBlbmNvZGVfMS5lbmNvZGVYTUwgOiBlbmNvZGVfMS5lbmNvZGVIVE1MKShkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xudmFyIGVuY29kZV8yID0gcmVxdWlyZShcIi4vZW5jb2RlXCIpO1xuZXhwb3J0cy5lbmNvZGVYTUwgPSBlbmNvZGVfMi5lbmNvZGVYTUw7XG5leHBvcnRzLmVuY29kZUhUTUwgPSBlbmNvZGVfMi5lbmNvZGVIVE1MO1xuZXhwb3J0cy5lc2NhcGUgPSBlbmNvZGVfMi5lc2NhcGU7XG4vLyBMZWdhY3kgYWxpYXNlc1xuZXhwb3J0cy5lbmNvZGVIVE1MNCA9IGVuY29kZV8yLmVuY29kZUhUTUw7XG5leHBvcnRzLmVuY29kZUhUTUw1ID0gZW5jb2RlXzIuZW5jb2RlSFRNTDtcbnZhciBkZWNvZGVfMiA9IHJlcXVpcmUoXCIuL2RlY29kZVwiKTtcbmV4cG9ydHMuZGVjb2RlWE1MID0gZGVjb2RlXzIuZGVjb2RlWE1MO1xuZXhwb3J0cy5kZWNvZGVIVE1MID0gZGVjb2RlXzIuZGVjb2RlSFRNTDtcbmV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7XG4vLyBMZWdhY3kgYWxpYXNlc1xuZXhwb3J0cy5kZWNvZGVIVE1MNCA9IGRlY29kZV8yLmRlY29kZUhUTUw7XG5leHBvcnRzLmRlY29kZUhUTUw1ID0gZGVjb2RlXzIuZGVjb2RlSFRNTDtcbmV4cG9ydHMuZGVjb2RlSFRNTDRTdHJpY3QgPSBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0O1xuZXhwb3J0cy5kZWNvZGVIVE1MNVN0cmljdCA9IGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7XG5leHBvcnRzLmRlY29kZVhNTFN0cmljdCA9IGRlY29kZV8yLmRlY29kZVhNTDtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9saWIvcGFyc2VyJyk7XG52YXIgcHJvY2Vzc2luZ0luc3RydWN0aW9ucyA9IHJlcXVpcmUoJy4vbGliL3Byb2Nlc3NpbmctaW5zdHJ1Y3Rpb25zJyk7XG52YXIgaXNWYWxpZE5vZGVEZWZpbml0aW9ucyA9IHJlcXVpcmUoJy4vbGliL2lzLXZhbGlkLW5vZGUtZGVmaW5pdGlvbnMnKTtcbnZhciBwcm9jZXNzTm9kZURlZmluaXRpb25zID0gcmVxdWlyZSgnLi9saWIvcHJvY2Vzcy1ub2RlLWRlZmluaXRpb25zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQYXJzZXI6IHBhcnNlcixcbiAgUHJvY2Vzc2luZ0luc3RydWN0aW9uczogcHJvY2Vzc2luZ0luc3RydWN0aW9ucyxcbiAgSXNWYWxpZE5vZGVEZWZpbml0aW9uczogaXNWYWxpZE5vZGVEZWZpbml0aW9ucyxcbiAgUHJvY2Vzc05vZGVEZWZpbml0aW9uczogcHJvY2Vzc05vZGVEZWZpbml0aW9ucyxcbn07XG4iLCIvLyBUaGVzZSBhcmUgYWxsIHNvdXJjZWQgZnJvbSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RhZ3MtYW5kLWF0dHJpYnV0ZXMuaHRtbCAtXG4vLyBhbGwgYXR0cmlidXRlcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleSBoYXZlIGEgZGlmZmVyZW50IGNhc2UgdG8gdGhlaXIgSFRNTCBlcXVpdmFsZW50cyBhcmVcbi8vIGxpc3RlZCB0byByZWR1Y2UgdGhlIGNoYW5jZSBvZiBodW1hbiBlcnJvciBhbmQgbWFrZSBpdCBlYXNpZXIgdG8ganVzdCBjb3B5LXBhc3RlIHRoZSBuZXcgbGlzdCBpZlxuLy8gaXQgY2hhbmdlcy5cbid1c2Ugc3RyaWN0JztcbnZhciBIVE1MX0FUVFJJQlVURVMgPSBbXG4gICdhY2NlcHQnLCAnYWNjZXB0Q2hhcnNldCcsICdhY2Nlc3NLZXknLCAnYWN0aW9uJywgJ2FsbG93RnVsbFNjcmVlbicsICdhbGxvd1RyYW5zcGFyZW5jeScsXG4gICdhbHQnLCAnYXN5bmMnLCAnYXV0b0NvbXBsZXRlJywgJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjYXB0dXJlJywgJ2NlbGxQYWRkaW5nJyxcbiAgJ2NlbGxTcGFjaW5nJywgJ2NoYWxsZW5nZScsICdjaGFyU2V0JywgJ2NoZWNrZWQnLCAnY2l0ZScsICdjbGFzc0lEJywgJ2NsYXNzTmFtZScsXG4gICdjb2xTcGFuJywgJ2NvbHMnLCAnY29udGVudCcsICdjb250ZW50RWRpdGFibGUnLCAnY29udGV4dE1lbnUnLCAnY29udHJvbHMnLCAnY29vcmRzJyxcbiAgJ2Nyb3NzT3JpZ2luJywgJ2RhdGEnLCAnZGF0ZVRpbWUnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXInLCAnZGlzYWJsZWQnLCAnZG93bmxvYWQnLFxuICAnZHJhZ2dhYmxlJywgJ2VuY1R5cGUnLCAnZm9ybScsICdmb3JtQWN0aW9uJywgJ2Zvcm1FbmNUeXBlJywgJ2Zvcm1NZXRob2QnLCAnZm9ybU5vVmFsaWRhdGUnLFxuICAnZm9ybVRhcmdldCcsICdmcmFtZUJvcmRlcicsICdoZWFkZXJzJywgJ2hlaWdodCcsICdoaWRkZW4nLCAnaGlnaCcsICdocmVmJywgJ2hyZWZMYW5nJyxcbiAgJ2h0bWxGb3InLCAnaHR0cEVxdWl2JywgJ2ljb24nLCAnaWQnLCAnaW5wdXRNb2RlJywgJ2ludGVncml0eScsICdpcycsICdrZXlQYXJhbXMnLCAna2V5VHlwZScsXG4gICdraW5kJywgJ2xhYmVsJywgJ2xhbmcnLCAnbGlzdCcsICdsb29wJywgJ2xvdycsICdtYW5pZmVzdCcsICdtYXJnaW5IZWlnaHQnLCAnbWFyZ2luV2lkdGgnLFxuICAnbWF4JywgJ21heExlbmd0aCcsICdtZWRpYScsICdtZWRpYUdyb3VwJywgJ21ldGhvZCcsICdtaW4nLCAnbWluTGVuZ3RoJywgJ211bHRpcGxlJywgJ211dGVkJyxcbiAgJ25hbWUnLCAnbm9WYWxpZGF0ZScsICdub25jZScsICdvcGVuJywgJ29wdGltdW0nLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdwb3N0ZXInLFxuICAncHJlbG9hZCcsICdwcm9maWxlJywgJ3JhZGlvR3JvdXAnLCAncmVhZE9ubHknLCAncmVsJywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3JvbGUnLFxuICAncm93U3BhbicsICdyb3dzJywgJ3NhbmRib3gnLCAnc2NvcGUnLCAnc2NvcGVkJywgJ3Njcm9sbGluZycsICdzZWFtbGVzcycsICdzZWxlY3RlZCcsXG4gICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3NwYW4nLCAnc3BlbGxDaGVjaycsICdzcmMnLCAnc3JjRG9jJywgJ3NyY0xhbmcnLCAnc3JjU2V0JywgJ3N0YXJ0JyxcbiAgJ3N0ZXAnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJJbmRleCcsICd0YXJnZXQnLCAndGl0bGUnLCAndHlwZScsICd1c2VNYXAnLCAndmFsdWUnLCAnd2lkdGgnLFxuICAnd21vZGUnLCAnd3JhcCcsICdvbkNsaWNrJyxcbl07XG5cbnZhciBOT05fU1RBTkRBUkRfQVRUUklCVVRFUyA9IFtcbiAgJ2F1dG9DYXBpdGFsaXplJywgJ2F1dG9Db3JyZWN0JywgJ2NvbG9yJywgJ2l0ZW1Qcm9wJywgJ2l0ZW1TY29wZScsICdpdGVtVHlwZScsICdpdGVtUmVmJyxcbiAgJ2l0ZW1JRCcsICdzZWN1cml0eScsICd1bnNlbGVjdGFibGUnLCAncmVzdWx0cycsICdhdXRvU2F2ZScsXG5dO1xuXG52YXIgU1ZHX0FUVFJJQlVURVMgPSBbXG4gICdhY2NlbnRIZWlnaHQnLCAnYWNjdW11bGF0ZScsICdhZGRpdGl2ZScsICdhbGlnbm1lbnRCYXNlbGluZScsICdhbGxvd1Jlb3JkZXInLCAnYWxwaGFiZXRpYycsXG4gICdhbXBsaXR1ZGUnLCAnYXJhYmljRm9ybScsICdhc2NlbnQnLCAnYXR0cmlidXRlTmFtZScsICdhdHRyaWJ1dGVUeXBlJywgJ2F1dG9SZXZlcnNlJywgJ2F6aW11dGgnLFxuICAnYmFzZUZyZXF1ZW5jeScsICdiYXNlUHJvZmlsZScsICdiYXNlbGluZVNoaWZ0JywgJ2Jib3gnLCAnYmVnaW4nLCAnYmlhcycsICdieScsICdjYWxjTW9kZScsXG4gICdjYXBIZWlnaHQnLCAnY2xpcCcsICdjbGlwUGF0aCcsICdjbGlwUGF0aFVuaXRzJywgJ2NsaXBSdWxlJywgJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJywgJ2NvbG9yUHJvZmlsZScsICdjb2xvclJlbmRlcmluZycsICdjb250ZW50U2NyaXB0VHlwZScsXG4gICdjb250ZW50U3R5bGVUeXBlJywgJ2N1cnNvcicsICdjeCcsICdjeScsICdkJywgJ2RlY2VsZXJhdGUnLCAnZGVzY2VudCcsICdkaWZmdXNlQ29uc3RhbnQnLFxuICAnZGlyZWN0aW9uJywgJ2Rpc3BsYXknLCAnZGl2aXNvcicsICdkb21pbmFudEJhc2VsaW5lJywgJ2R1cicsICdkeCcsICdkeScsICdlZGdlTW9kZScsXG4gICdlbGV2YXRpb24nLCAnZW5hYmxlQmFja2dyb3VuZCcsICdlbmQnLCAnZXhwb25lbnQnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmaWxsJyxcbiAgJ2ZpbGxPcGFjaXR5JywgJ2ZpbGxSdWxlJywgJ2ZpbHRlcicsICdmaWx0ZXJSZXMnLCAnZmlsdGVyVW5pdHMnLCAnZmxvb2RDb2xvcicsICdmbG9vZE9wYWNpdHknLFxuICAnZm9jdXNhYmxlJywgJ2ZvbnRGYW1pbHknLCAnZm9udFNpemUnLCAnZm9udFNpemVBZGp1c3QnLCAnZm9udFN0cmV0Y2gnLCAnZm9udFN0eWxlJyxcbiAgJ2ZvbnRWYXJpYW50JywgJ2ZvbnRXZWlnaHQnLCAnZm9ybWF0JywgJ2Zyb20nLCAnZngnLCAnZnknLCAnZzEnLCAnZzInLCAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJywgJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsICdnbHlwaFJlZicsXG4gICdncmFkaWVudFRyYW5zZm9ybScsICdncmFkaWVudFVuaXRzJywgJ2hhbmdpbmcnLCAnaG9yaXpBZHZYJywgJ2hvcml6T3JpZ2luWCcsICdpZGVvZ3JhcGhpYycsXG4gICdpbWFnZVJlbmRlcmluZycsICdpbicsICdpbjInLCAnaW50ZXJjZXB0JywgJ2snLCAnazEnLCAnazInLCAnazMnLCAnazQnLCAna2VybmVsTWF0cml4JyxcbiAgJ2tlcm5lbFVuaXRMZW5ndGgnLCAna2VybmluZycsICdrZXlQb2ludHMnLCAna2V5U3BsaW5lcycsICdrZXlUaW1lcycsICdsZW5ndGhBZGp1c3QnLFxuICAnbGV0dGVyU3BhY2luZycsICdsaWdodGluZ0NvbG9yJywgJ2xpbWl0aW5nQ29uZUFuZ2xlJywgJ2xvY2FsJywgJ21hcmtlckVuZCcsICdtYXJrZXJIZWlnaHQnLFxuICAnbWFya2VyTWlkJywgJ21hcmtlclN0YXJ0JywgJ21hcmtlclVuaXRzJywgJ21hcmtlcldpZHRoJywgJ21hc2snLCAnbWFza0NvbnRlbnRVbml0cycsXG4gICdtYXNrVW5pdHMnLCAnbWF0aGVtYXRpY2FsJywgJ21vZGUnLCAnbnVtT2N0YXZlcycsICdvZmZzZXQnLCAnb3BhY2l0eScsICdvcGVyYXRvcicsICdvcmRlcicsXG4gICdvcmllbnQnLCAnb3JpZW50YXRpb24nLCAnb3JpZ2luJywgJ292ZXJmbG93JywgJ292ZXJsaW5lUG9zaXRpb24nLCAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAncGFpbnRPcmRlcicsICdwYW5vc2UxJywgJ3BhdGhMZW5ndGgnLCAncGF0dGVybkNvbnRlbnRVbml0cycsICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgJ3BhdHRlcm5Vbml0cycsICdwb2ludGVyRXZlbnRzJywgJ3BvaW50cycsICdwb2ludHNBdFgnLCAncG9pbnRzQXRZJywgJ3BvaW50c0F0WicsXG4gICdwcmVzZXJ2ZUFscGhhJywgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAncHJpbWl0aXZlVW5pdHMnLCAncicsICdyYWRpdXMnLCAncmVmWCcsICdyZWZZJyxcbiAgJ3JlbmRlcmluZ0ludGVudCcsICdyZXBlYXRDb3VudCcsICdyZXBlYXREdXInLCAncmVxdWlyZWRFeHRlbnNpb25zJywgJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3J4JywgJ3J5JywgJ3NjYWxlJywgJ3NlZWQnLCAnc2hhcGVSZW5kZXJpbmcnLCAnc2xvcGUnLFxuICAnc3BhY2luZycsICdzcGVjdWxhckNvbnN0YW50JywgJ3NwZWN1bGFyRXhwb25lbnQnLCAnc3BlZWQnLCAnc3ByZWFkTWV0aG9kJywgJ3N0YXJ0T2Zmc2V0JyxcbiAgJ3N0ZERldmlhdGlvbicsICdzdGVtaCcsICdzdGVtdicsICdzdGl0Y2hUaWxlcycsICdzdG9wQ29sb3InLCAnc3RvcE9wYWNpdHknLFxuICAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLCAnc3RyaW5nJywgJ3N0cm9rZScsICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlRGFzaG9mZnNldCcsICdzdHJva2VMaW5lY2FwJywgJ3N0cm9rZUxpbmVqb2luJywgJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2VXaWR0aCcsICdzdXJmYWNlU2NhbGUnLCAnc3lzdGVtTGFuZ3VhZ2UnLCAndGFibGVWYWx1ZXMnLCAndGFyZ2V0WCcsICd0YXJnZXRZJyxcbiAgJ3RleHRBbmNob3InLCAndGV4dERlY29yYXRpb24nLCAndGV4dExlbmd0aCcsICd0ZXh0UmVuZGVyaW5nJywgJ3RvJywgJ3RyYW5zZm9ybScsICd1MScsXG4gICd1MicsICd1bmRlcmxpbmVQb3NpdGlvbicsICd1bmRlcmxpbmVUaGlja25lc3MnLCAndW5pY29kZScsICd1bmljb2RlQmlkaScsICd1bmljb2RlUmFuZ2UnLFxuICAndW5pdHNQZXJFbScsICd2QWxwaGFiZXRpYycsICd2SGFuZ2luZycsICd2SWRlb2dyYXBoaWMnLCAndk1hdGhlbWF0aWNhbCcsICd2YWx1ZXMnLFxuICAndmVjdG9yRWZmZWN0JywgJ3ZlcnNpb24nLCAndmVydEFkdlknLCAndmVydE9yaWdpblgnLCAndmVydE9yaWdpblknLCAndmlld0JveCcsXG4gICd2aWV3VGFyZ2V0JywgJ3Zpc2liaWxpdHknLCAnd2lkdGhzJywgJ3dvcmRTcGFjaW5nJywgJ3dyaXRpbmdNb2RlJywgJ3gnLCAneDEnLCAneDInLFxuICAneENoYW5uZWxTZWxlY3RvcicsICd4SGVpZ2h0JywgJ3hsaW5rQWN0dWF0ZScsICd4bGlua0FyY3JvbGUnLCAneGxpbmtIcmVmJywgJ3hsaW5rUm9sZScsXG4gICd4bGlua1Nob3cnLCAneGxpbmtUaXRsZScsICd4bGlua1R5cGUnLCAneG1sbnMnLCAneG1sbnNYbGluaycsICd4bWxCYXNlJywgJ3htbExhbmcnLFxuICAneG1sU3BhY2UnLCAneScsICd5MScsICd5MicsICd5Q2hhbm5lbFNlbGVjdG9yJywgJ3onLCAnem9vbUFuZFBhbicsXG5dO1xuXG52YXIgY2FtZWxDYXNlTWFwID0gSFRNTF9BVFRSSUJVVEVTXG4gIC5jb25jYXQoTk9OX1NUQU5EQVJEX0FUVFJJQlVURVMpXG4gIC5jb25jYXQoU1ZHX0FUVFJJQlVURVMpXG4gIC5yZWR1Y2UoZnVuY3Rpb24gKHNvRmFyLCBhdHRyKSB7XG4gICAgdmFyIGxvd2VyID0gYXR0ci50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlciAhPT0gYXR0cikge1xuICAgICAgc29GYXJbbG93ZXJdID0gYXR0cjtcbiAgICB9XG4gICAgcmV0dXJuIHNvRmFyO1xuICB9LCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxDYXNlTWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuZnVuY3Rpb24gYWx3YXlzVmFsaWQoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWx3YXlzVmFsaWQ6IGFsd2F5c1ZhbGlkLFxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgncmFtZGEvc3JjL2ZvckVhY2gnKTtcbnZhciBmaW5kID0gcmVxdWlyZSgncmFtZGEvc3JjL2ZpbmQnKTtcbnZhciByZWplY3QgPSByZXF1aXJlKCdyYW1kYS9zcmMvcmVqZWN0Jyk7XG52YXIgYWRkSW5kZXggPSByZXF1aXJlKCdyYW1kYS9zcmMvYWRkSW5kZXgnKTtcbnZhciBtYXAgPSByZXF1aXJlKCdyYW1kYS9zcmMvbWFwJyk7XG52YXIgSHRtbFBhcnNlciA9IHJlcXVpcmUoJ2h0bWxwYXJzZXIyJykuUGFyc2VyO1xudmFyIERvbUhhbmRsZXIgPSByZXF1aXJlKCdkb21oYW5kbGVyJykuRG9tSGFuZGxlcjtcbnZhciBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zID0gcmVxdWlyZSgnLi9wcm9jZXNzaW5nLWluc3RydWN0aW9ucycpO1xudmFyIElzVmFsaWROb2RlRGVmaW5pdGlvbnMgPSByZXF1aXJlKCcuL2lzLXZhbGlkLW5vZGUtZGVmaW5pdGlvbnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSHRtbDJSZWFjdFBhcnNlcihvcHRpb25zKSB7XG4gIGZ1bmN0aW9uIHBhcnNlSHRtbFRvVHJlZShodG1sKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5kZWNvZGVFbnRpdGllcyA9IHRydWU7XG4gICAgdmFyIGhhbmRsZXIgPSBuZXcgRG9tSGFuZGxlcigpO1xuICAgIHZhciBwYXJzZXIgPSBuZXcgSHRtbFBhcnNlcihoYW5kbGVyLCBvcHRpb25zKTtcbiAgICBwYXJzZXIucGFyc2VDb21wbGV0ZShodG1sKTtcbiAgICByZXR1cm4gaGFuZGxlci5kb20uZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlICE9PSAnZGlyZWN0aXZlJztcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiB0cmF2ZXJzZURvbShub2RlLCBpc1ZhbGlkTm9kZSwgcHJvY2Vzc2luZ0luc3RydWN0aW9ucywgcHJlcHJvY2Vzc2luZ0luc3RydWN0aW9ucyxcbiAgICBpbmRleCkge1xuICAgIGlmIChpc1ZhbGlkTm9kZShub2RlKSkge1xuICAgICAgZm9yRWFjaChmdW5jdGlvbiAocHJlcHJvY2Vzc2luZ0luc3RydWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24uc2hvdWxkUHJlcHJvY2Vzc05vZGUobm9kZSkpIHtcbiAgICAgICAgICBwcmVwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJlcHJvY2Vzc05vZGUobm9kZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LCBwcmVwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zIHx8IFtdKTtcblxuICAgICAgdmFyIHByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IGZpbmQoZnVuY3Rpb24gKHByb2Nlc3NpbmdJbnN0cnVjdGlvbikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2luZ0luc3RydWN0aW9uLnNob3VsZFByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgfSwgcHJvY2Vzc2luZ0luc3RydWN0aW9ucyB8fCBbXSk7XG4gICAgICBpZiAocHJvY2Vzc2luZ0luc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcmVqZWN0KGZ1bmN0aW9uICh4KSB7cmV0dXJuIHggPT0gbnVsbCB8fCB4ID09PSBmYWxzZTt9LFxuICAgICAgICAgIGFkZEluZGV4KG1hcCkoZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VEb20oY2hpbGQsIGlzVmFsaWROb2RlLCBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zLFxuICAgICAgICAgICAgICBwcmVwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zLCBpKTtcbiAgICAgICAgICB9LCBub2RlLmNoaWxkcmVuIHx8IFtdKSk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3NpbmdJbnN0cnVjdGlvbi5yZXBsYWNlQ2hpbGRyZW4pIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMuY3JlYXRlRWxlbWVudChub2RlLCBpbmRleCwgbm9kZS5kYXRhLCBbXG4gICAgICAgICAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJvY2Vzc05vZGUobm9kZSwgY2hpbGRyZW4sIGluZGV4KSxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzc2luZ0luc3RydWN0aW9uLnByb2Nlc3NOb2RlKG5vZGUsIGNoaWxkcmVuLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZVdpdGhJbnN0cnVjdGlvbnMoaHRtbCwgaXNWYWxpZE5vZGUsIHByb2Nlc3NpbmdJbnN0cnVjdGlvbnMsXG4gICAgICBwcmVwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zKSB7XG4gICAgdmFyIGRvbVRyZWUgPSBwYXJzZUh0bWxUb1RyZWUoaHRtbCk7XG4gICAgdmFyIGxpc3QgPSBkb21UcmVlLm1hcChmdW5jdGlvbiAoZG9tVHJlZUl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gdHJhdmVyc2VEb20oZG9tVHJlZUl0ZW0sIGlzVmFsaWROb2RlLCBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zLFxuICAgICAgICBwcmVwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zLCBpbmRleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpc3QubGVuZ3RoIDw9IDEgPyBsaXN0WzBdIDogbGlzdDtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZShodG1sKSB7XG4gICAgdmFyIHByb2Nlc3NpbmdJbnN0cnVjdGlvbnMgPSBuZXcgUHJvY2Vzc2luZ0luc3RydWN0aW9ucygpO1xuICAgIHJldHVybiBwYXJzZVdpdGhJbnN0cnVjdGlvbnMoaHRtbCxcbiAgICAgIElzVmFsaWROb2RlRGVmaW5pdGlvbnMuYWx3YXlzVmFsaWQsXG4gICAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zLmRlZmF1bHRQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBwYXJzZVdpdGhJbnN0cnVjdGlvbnM6IHBhcnNlV2l0aEluc3RydWN0aW9ucyxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDJSZWFjdFBhcnNlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzE1LjAtc3RhYmxlL3NyYy9yZW5kZXJlcnMvZG9tL3NoYXJlZC9SZWFjdERPTUNvbXBvbmVudC5qcyNMNDU3XG52YXIgdm9pZEVsZW1lbnRUYWdzID0gW1xuICAnYXJlYScsICdiYXNlJywgJ2JyJywgJ2NvbCcsICdlbWJlZCcsICdocicsICdpbWcnLCAnaW5wdXQnLCAna2V5Z2VuJywgJ2xpbmsnLCAnbWV0YScsICdwYXJhbScsXG4gICdzb3VyY2UnLCAndHJhY2snLCAnd2JyJywgJ21lbnVpdGVtJywgJ3RleHRhcmVhJyxcbl07XG5cbmZ1bmN0aW9uIFByb2Nlc3NOb2RlRGVmaW5pdGlvbnMoKSB7XG4gIGZ1bmN0aW9uIHByb2Nlc3NEZWZhdWx0Tm9kZShub2RlLCBjaGlsZHJlbiwgaW5kZXgpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHJldHVybiBub2RlLmRhdGE7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdjb21tZW50Jykge1xuICAgICAgLy8gRklYTUU6IFRoZSBmb2xsb3dpbmcgZG9lc24ndCB3b3JrIGFzIHRoZSBnZW5lcmF0ZWQgSFRNTCByZXN1bHRzIGluXG4gICAgICAvLyBcIiZsdDshLS0gIFRoaXMgaXMgYSBjb21tZW50ICAtLSZndDtcIlxuICAgICAgLy8gcmV0dXJuICc8IS0tICcgKyBub2RlLmRhdGEgKyAnIC0tPic7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHZvaWRFbGVtZW50VGFncy5pbmRleE9mKG5vZGUubmFtZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIHV0aWxzLmNyZWF0ZUVsZW1lbnQobm9kZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXRpbHMuY3JlYXRlRWxlbWVudChub2RlLCBpbmRleCwgbm9kZS5kYXRhLCBjaGlsZHJlbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzRGVmYXVsdE5vZGU6IHByb2Nlc3NEZWZhdWx0Tm9kZSxcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9jZXNzTm9kZURlZmluaXRpb25zO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFNob3VsZFByb2Nlc3NOb2RlRGVmaW5pdGlvbnMgPSByZXF1aXJlKCcuL3Nob3VsZC1wcm9jZXNzLW5vZGUtZGVmaW5pdGlvbnMnKTtcbnZhciBQcm9jZXNzTm9kZURlZmluaXRpb25zID0gcmVxdWlyZSgnLi9wcm9jZXNzLW5vZGUtZGVmaW5pdGlvbnMnKTtcblxuZnVuY3Rpb24gUHJvY2Vzc2luZ0luc3RydWN0aW9ucygpIHtcbiAgdmFyIHByb2Nlc3NOb2RlRGVmaW5pdGlvbnMgPSBuZXcgUHJvY2Vzc05vZGVEZWZpbml0aW9ucygpO1xuXG4gIHJldHVybiB7XG4gICAgZGVmYXVsdFByb2Nlc3NpbmdJbnN0cnVjdGlvbnM6IFt7XG4gICAgICBzaG91bGRQcm9jZXNzTm9kZTogU2hvdWxkUHJvY2Vzc05vZGVEZWZpbml0aW9ucy5zaG91bGRQcm9jZXNzRXZlcnlOb2RlLFxuICAgICAgcHJvY2Vzc05vZGU6IHByb2Nlc3NOb2RlRGVmaW5pdGlvbnMucHJvY2Vzc0RlZmF1bHROb2RlLFxuICAgIH0sXSxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvY2Vzc2luZ0luc3RydWN0aW9ucztcbiIsIid1c2Ugc3RyaWN0JztcbmZ1bmN0aW9uIHNob3VsZFByb2Nlc3NFdmVyeU5vZGUobm9kZSkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNob3VsZFByb2Nlc3NFdmVyeU5vZGU6IHNob3VsZFByb2Nlc3NFdmVyeU5vZGUsXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2xvZGFzaC5jYW1lbGNhc2UnKTtcbnZhciB0b1BhaXJzID0gcmVxdWlyZSgncmFtZGEvc3JjL3RvUGFpcnMnKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCdyYW1kYS9zcmMvcmVkdWNlJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNhbWVsQ2FzZUF0dHJNYXAgPSByZXF1aXJlKCcuL2NhbWVsLWNhc2UtYXR0cmlidXRlLW5hbWVzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlSnNvbkZyb21TdHJpbmcoc3R5bGVTdHJpbmcpIHtcbiAgc3R5bGVTdHJpbmcgPSBzdHlsZVN0cmluZyB8fCAnJztcbiAgdmFyIHN0eWxlcyA9IHN0eWxlU3RyaW5nLnNwbGl0KC87KD8hYmFzZTY0KS8pO1xuICB2YXIgc2luZ2xlU3R5bGUsIGtleSwgdmFsdWUsIGpzb25TdHlsZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICBzaW5nbGVTdHlsZSA9IHN0eWxlc1tpXS5zcGxpdCgnOicpO1xuICAgIGlmIChzaW5nbGVTdHlsZS5sZW5ndGggPiAyKSB7XG4gICAgICBzaW5nbGVTdHlsZVsxXSA9IHNpbmdsZVN0eWxlLnNsaWNlKDEpLmpvaW4oJzonKTtcbiAgICB9XG5cbiAgICBrZXkgPSBzaW5nbGVTdHlsZVswXTtcbiAgICB2YWx1ZSA9IHNpbmdsZVN0eWxlWzFdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKXtcbiAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgIH1cblxuICAgIGlmIChrZXkgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsICYmIGtleS5sZW5ndGggPiAwICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGpzb25TdHlsZXNbY2FtZWxDYXNlKGtleSldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBqc29uU3R5bGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KG5vZGUsIGluZGV4LCBkYXRhLCBjaGlsZHJlbikge1xuICB2YXIgZWxlbWVudFByb3BzID0ge1xuICAgIGtleTogaW5kZXgsXG4gIH07XG4gIGlmIChub2RlLmF0dHJpYnMpIHtcbiAgICBlbGVtZW50UHJvcHMgPSByZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCBrZXlBbmRWYWx1ZSkge1xuICAgICAgdmFyIGtleSA9IGtleUFuZFZhbHVlWzBdO1xuICAgICAgdmFyIHZhbHVlID0ga2V5QW5kVmFsdWVbMV07XG4gICAgICBrZXkgPSBjYW1lbENhc2VBdHRyTWFwW2tleS5yZXBsYWNlKC9bLTpdLywgJycpXSB8fCBrZXk7XG4gICAgICBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgIHZhbHVlID0gY3JlYXRlU3R5bGVKc29uRnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICBrZXkgPSAnY2xhc3NOYW1lJztcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZm9yJykge1xuICAgICAgICBrZXkgPSAnaHRtbEZvcic7XG4gICAgICB9XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlIHx8IGtleTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgZWxlbWVudFByb3BzLCB0b1BhaXJzKG5vZGUuYXR0cmlicykpO1xuICB9XG5cbiAgY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgdmFyIGFsbENoaWxkcmVuID0gZGF0YSAhPSBudWxsID8gW2RhdGEsXS5jb25jYXQoY2hpbGRyZW4pIDogY2hpbGRyZW47XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50LmFwcGx5KFxuICAgIG51bGwsIFtub2RlLm5hbWUsIGVsZW1lbnRQcm9wcyxdLmNvbmNhdChhbGxDaGlsZHJlbilcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNdWx0aXBsZXhIYW5kbGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTXVsdGlwbGV4SGFuZGxlclwiKSk7XG52YXIgQ29sbGVjdGluZ0hhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbGxlY3RpbmdIYW5kbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbGxlY3RpbmdIYW5kbGVyKGNicykge1xuICAgICAgICBpZiAoY2JzID09PSB2b2lkIDApIHsgY2JzID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5ldmVudHMucHVzaChbbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChfdGhpcy5fY2JzW25hbWVdKVxuICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLl9jYnMpW25hbWVdLmFwcGx5KF9hLCBhcmdzKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NicyA9IGNicztcbiAgICAgICAgX3RoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29sbGVjdGluZ0hhbmRsZXIucHJvdG90eXBlLm9ucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9jYnMub25yZXNldClcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbnJlc2V0KCk7XG4gICAgfTtcbiAgICBDb2xsZWN0aW5nSGFuZGxlci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5fY2JzLm9ucmVzZXQpXG4gICAgICAgICAgICB0aGlzLl9jYnMub25yZXNldCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLmV2ZW50c1tpXSwgbmFtZV8xID0gX2JbMF0sIGFyZ3MgPSBfYi5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2JzW25hbWVfMV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIChfYSA9IHRoaXMuX2NicylbbmFtZV8xXS5hcHBseShfYSwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb2xsZWN0aW5nSGFuZGxlcjtcbn0oTXVsdGlwbGV4SGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuQ29sbGVjdGluZ0hhbmRsZXIgPSBDb2xsZWN0aW5nSGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9taGFuZGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpKTtcbnZhciBEb21VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZG9tdXRpbHNcIikpO1xudmFyIFBhcnNlcl8xID0gcmVxdWlyZShcIi4vUGFyc2VyXCIpO1xuLy9UT0RPOiBDb25zdW1lIGRhdGEgYXMgaXQgaXMgY29taW5nIGluXG52YXIgRmVlZEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZlZWRIYW5kbGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGZWVkSGFuZGxlcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGxiYWNrLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZlZWRIYW5kbGVyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZlZWQgPSB7fTtcbiAgICAgICAgdmFyIGZlZWRSb290ID0gZ2V0T25lRWxlbWVudChpc1ZhbGlkRmVlZCwgdGhpcy5kb20pO1xuICAgICAgICBpZiAoZmVlZFJvb3QpIHtcbiAgICAgICAgICAgIGlmIChmZWVkUm9vdC5uYW1lID09PSBcImZlZWRcIikge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHMgPSBmZWVkUm9vdC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBmZWVkLnR5cGUgPSBcImF0b21cIjtcbiAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwiaWRcIiwgXCJpZFwiLCBjaGlsZHMpO1xuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJ0aXRsZVwiLCBcInRpdGxlXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBnZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGdldE9uZUVsZW1lbnQoXCJsaW5rXCIsIGNoaWxkcykpO1xuICAgICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZWQubGluayA9IGhyZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJkZXNjcmlwdGlvblwiLCBcInN1YnRpdGxlXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSBmZXRjaChcInVwZGF0ZWRcIiwgY2hpbGRzKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBmZWVkLnVwZGF0ZWQgPSBuZXcgRGF0ZSh1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImF1dGhvclwiLCBcImVtYWlsXCIsIGNoaWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZmVlZC5pdGVtcyA9IGdldEVsZW1lbnRzKFwiZW50cnlcIiwgY2hpbGRzKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGl0ZW0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwiaWRcIiwgXCJpZFwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gZ2V0QXR0cmlidXRlKFwiaHJlZlwiLCBnZXRPbmVFbGVtZW50KFwibGlua1wiLCBjaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkubGluayA9IGhyZWY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gZmV0Y2goXCJzdW1tYXJ5XCIsIGNoaWxkcmVuKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2goXCJjb250ZW50XCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwdWJEYXRlID0gZmV0Y2goXCJ1cGRhdGVkXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1YkRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnB1YkRhdGUgPSBuZXcgRGF0ZShwdWJEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRzID0gZ2V0T25lRWxlbWVudChcImNoYW5uZWxcIiwgZmVlZFJvb3QuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBmZWVkLnR5cGUgPSBmZWVkUm9vdC5uYW1lLnN1YnN0cigwLCAzKTtcbiAgICAgICAgICAgICAgICBmZWVkLmlkID0gXCJcIjtcbiAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGZlZWQsIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHMpO1xuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJsaW5rXCIsIFwibGlua1wiLCBjaGlsZHMpO1xuICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZmVlZCwgXCJkZXNjcmlwdGlvblwiLCBcImRlc2NyaXB0aW9uXCIsIGNoaWxkcyk7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSBmZXRjaChcImxhc3RCdWlsZERhdGVcIiwgY2hpbGRzKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBmZWVkLnVwZGF0ZWQgPSBuZXcgRGF0ZSh1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkQ29uZGl0aW9uYWxseShmZWVkLCBcImF1dGhvclwiLCBcIm1hbmFnaW5nRWRpdG9yXCIsIGNoaWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZmVlZC5pdGVtcyA9IGdldEVsZW1lbnRzKFwiaXRlbVwiLCBmZWVkUm9vdC5jaGlsZHJlbikubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBpdGVtLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGVudHJ5LCBcImlkXCIsIFwiZ3VpZFwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwidGl0bGVcIiwgXCJ0aXRsZVwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbmRpdGlvbmFsbHkoZW50cnksIFwibGlua1wiLCBcImxpbmtcIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBhZGRDb25kaXRpb25hbGx5KGVudHJ5LCBcImRlc2NyaXB0aW9uXCIsIFwiZGVzY3JpcHRpb25cIiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHViRGF0ZSA9IGZldGNoKFwicHViRGF0ZVwiLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdWJEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkucHViRGF0ZSA9IG5ldyBEYXRlKHB1YkRhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZWVkID0gZmVlZDtcbiAgICAgICAgdGhpcy5oYW5kbGVDYWxsYmFjayhmZWVkUm9vdCA/IG51bGwgOiBFcnJvcihcImNvdWxkbid0IGZpbmQgcm9vdCBvZiBmZWVkXCIpKTtcbiAgICB9O1xuICAgIHJldHVybiBGZWVkSGFuZGxlcjtcbn0oZG9taGFuZGxlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuRmVlZEhhbmRsZXIgPSBGZWVkSGFuZGxlcjtcbmZ1bmN0aW9uIGdldEVsZW1lbnRzKHdoYXQsIHdoZXJlKSB7XG4gICAgcmV0dXJuIERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHdoYXQsIHdoZXJlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdldE9uZUVsZW1lbnQod2hhdCwgd2hlcmUpIHtcbiAgICByZXR1cm4gRG9tVXRpbHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUod2hhdCwgd2hlcmUsIHRydWUsIDEpWzBdO1xufVxuZnVuY3Rpb24gZmV0Y2god2hhdCwgd2hlcmUsIHJlY3Vyc2UpIHtcbiAgICBpZiAocmVjdXJzZSA9PT0gdm9pZCAwKSB7IHJlY3Vyc2UgPSBmYWxzZTsgfVxuICAgIHJldHVybiBEb21VdGlscy5nZXRUZXh0KERvbVV0aWxzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHdoYXQsIHdoZXJlLCByZWN1cnNlLCAxKSkudHJpbSgpO1xufVxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5hbWUsIGVsZW0pIHtcbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhdHRyaWJzID0gZWxlbS5hdHRyaWJzO1xuICAgIHJldHVybiBhdHRyaWJzW25hbWVdO1xufVxuZnVuY3Rpb24gYWRkQ29uZGl0aW9uYWxseShvYmosIHByb3AsIHdoYXQsIHdoZXJlLCByZWN1cnNlKSB7XG4gICAgaWYgKHJlY3Vyc2UgPT09IHZvaWQgMCkgeyByZWN1cnNlID0gZmFsc2U7IH1cbiAgICB2YXIgdG1wID0gZmV0Y2god2hhdCwgd2hlcmUsIHJlY3Vyc2UpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodG1wKVxuICAgICAgICBvYmpbcHJvcF0gPSB0bXA7XG59XG5mdW5jdGlvbiBpc1ZhbGlkRmVlZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gXCJyc3NcIiB8fCB2YWx1ZSA9PT0gXCJmZWVkXCIgfHwgdmFsdWUgPT09IFwicmRmOlJERlwiO1xufVxudmFyIGRlZmF1bHRPcHRpb25zID0geyB4bWxNb2RlOiB0cnVlIH07XG4vKipcbiAqIFBhcnNlIGEgZmVlZC5cbiAqXG4gKiBAcGFyYW0gZmVlZCBUaGUgZmVlZCB0aGF0IHNob3VsZCBiZSBwYXJzZWQsIGFzIGEgc3RyaW5nLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWxseSwgb3B0aW9ucyBmb3IgcGFyc2luZy4gV2hlbiB1c2luZyB0aGlzIG9wdGlvbiwgeW91IHByb2JhYmx5IHdhbnQgdG8gc2V0IGB4bWxNb2RlYCB0byBgdHJ1ZWAuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmVlZChmZWVkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7IH1cbiAgICB2YXIgaGFuZGxlciA9IG5ldyBGZWVkSGFuZGxlcihvcHRpb25zKTtcbiAgICBuZXcgUGFyc2VyXzEuUGFyc2VyKGhhbmRsZXIsIG9wdGlvbnMpLmVuZChmZWVkKTtcbiAgICByZXR1cm4gaGFuZGxlci5mZWVkO1xufVxuZXhwb3J0cy5wYXJzZUZlZWQgPSBwYXJzZUZlZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQ2FsbHMgYSBzcGVjaWZpYyBoYW5kbGVyIGZ1bmN0aW9uIGZvciBhbGwgZXZlbnRzIHRoYXQgYXJlIGVuY291bnRlcmVkLlxuICpcbiAqIEBwYXJhbSBmdW5jIOKAlCBUaGUgZnVuY3Rpb24gdG8gbXVsdGlwbGV4IGFsbCBldmVudHMgdG8uXG4gKi9cbnZhciBNdWx0aXBsZXhIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpcGxleEhhbmRsZXIoZnVuYykge1xuICAgICAgICB0aGlzLl9mdW5jID0gZnVuYztcbiAgICB9XG4gICAgLyogRm9ybWF0OiBldmVudG5hbWU6IG51bWJlciBvZiBhcmd1bWVudHMgKi9cbiAgICBNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mdW5jKFwib25hdHRyaWJ1dGVcIiwgbmFtZSwgdmFsdWUpO1xuICAgIH07XG4gICAgTXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25jZGF0YXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mdW5jKFwib25jZGF0YXN0YXJ0XCIpO1xuICAgIH07XG4gICAgTXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25jZGF0YWVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZnVuYyhcIm9uY2RhdGFlbmRcIik7XG4gICAgfTtcbiAgICBNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbnRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB0aGlzLl9mdW5jKFwib250ZXh0XCIsIHRleHQpO1xuICAgIH07XG4gICAgTXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZnVuYyhcIm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uXCIsIG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuICAgIE11bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICAgIHRoaXMuX2Z1bmMoXCJvbmNvbW1lbnRcIiwgY29tbWVudCk7XG4gICAgfTtcbiAgICBNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmNvbW1lbnRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2Z1bmMoXCJvbmNvbW1lbnRlbmRcIik7XG4gICAgfTtcbiAgICBNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmNsb3NldGFnID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fZnVuYyhcIm9uY2xvc2V0YWdcIiwgbmFtZSk7XG4gICAgfTtcbiAgICBNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbm9wZW50YWcgPSBmdW5jdGlvbiAobmFtZSwgYXR0cmlicykge1xuICAgICAgICB0aGlzLl9mdW5jKFwib25vcGVudGFnXCIsIG5hbWUsIGF0dHJpYnMpO1xuICAgIH07XG4gICAgTXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25vcGVudGFnbmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMuX2Z1bmMoXCJvbm9wZW50YWduYW1lXCIsIG5hbWUpO1xuICAgIH07XG4gICAgTXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLl9mdW5jKFwib25lcnJvclwiLCBlcnJvcik7XG4gICAgfTtcbiAgICBNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZnVuYyhcIm9uZW5kXCIpO1xuICAgIH07XG4gICAgTXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25wYXJzZXJpbml0ID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICB0aGlzLl9mdW5jKFwib25wYXJzZXJpbml0XCIsIHBhcnNlcik7XG4gICAgfTtcbiAgICBNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mdW5jKFwib25yZXNldFwiKTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aXBsZXhIYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpcGxleEhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRva2VuaXplcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Rva2VuaXplclwiKSk7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIGZvcm1UYWdzID0gbmV3IFNldChbXG4gICAgXCJpbnB1dFwiLFxuICAgIFwib3B0aW9uXCIsXG4gICAgXCJvcHRncm91cFwiLFxuICAgIFwic2VsZWN0XCIsXG4gICAgXCJidXR0b25cIixcbiAgICBcImRhdGFsaXN0XCIsXG4gICAgXCJ0ZXh0YXJlYVwiXG5dKTtcbnZhciBwVGFnID0gbmV3IFNldChbXCJwXCJdKTtcbnZhciBvcGVuSW1wbGllc0Nsb3NlID0ge1xuICAgIHRyOiBuZXcgU2V0KFtcInRyXCIsIFwidGhcIiwgXCJ0ZFwiXSksXG4gICAgdGg6IG5ldyBTZXQoW1widGhcIl0pLFxuICAgIHRkOiBuZXcgU2V0KFtcInRoZWFkXCIsIFwidGhcIiwgXCJ0ZFwiXSksXG4gICAgYm9keTogbmV3IFNldChbXCJoZWFkXCIsIFwibGlua1wiLCBcInNjcmlwdFwiXSksXG4gICAgbGk6IG5ldyBTZXQoW1wibGlcIl0pLFxuICAgIHA6IHBUYWcsXG4gICAgaDE6IHBUYWcsXG4gICAgaDI6IHBUYWcsXG4gICAgaDM6IHBUYWcsXG4gICAgaDQ6IHBUYWcsXG4gICAgaDU6IHBUYWcsXG4gICAgaDY6IHBUYWcsXG4gICAgc2VsZWN0OiBmb3JtVGFncyxcbiAgICBpbnB1dDogZm9ybVRhZ3MsXG4gICAgb3V0cHV0OiBmb3JtVGFncyxcbiAgICBidXR0b246IGZvcm1UYWdzLFxuICAgIGRhdGFsaXN0OiBmb3JtVGFncyxcbiAgICB0ZXh0YXJlYTogZm9ybVRhZ3MsXG4gICAgb3B0aW9uOiBuZXcgU2V0KFtcIm9wdGlvblwiXSksXG4gICAgb3B0Z3JvdXA6IG5ldyBTZXQoW1wib3B0Z3JvdXBcIiwgXCJvcHRpb25cIl0pLFxuICAgIGRkOiBuZXcgU2V0KFtcImR0XCIsIFwiZGRcIl0pLFxuICAgIGR0OiBuZXcgU2V0KFtcImR0XCIsIFwiZGRcIl0pLFxuICAgIGFkZHJlc3M6IHBUYWcsXG4gICAgYXJ0aWNsZTogcFRhZyxcbiAgICBhc2lkZTogcFRhZyxcbiAgICBibG9ja3F1b3RlOiBwVGFnLFxuICAgIGRldGFpbHM6IHBUYWcsXG4gICAgZGl2OiBwVGFnLFxuICAgIGRsOiBwVGFnLFxuICAgIGZpZWxkc2V0OiBwVGFnLFxuICAgIGZpZ2NhcHRpb246IHBUYWcsXG4gICAgZmlndXJlOiBwVGFnLFxuICAgIGZvb3RlcjogcFRhZyxcbiAgICBmb3JtOiBwVGFnLFxuICAgIGhlYWRlcjogcFRhZyxcbiAgICBocjogcFRhZyxcbiAgICBtYWluOiBwVGFnLFxuICAgIG5hdjogcFRhZyxcbiAgICBvbDogcFRhZyxcbiAgICBwcmU6IHBUYWcsXG4gICAgc2VjdGlvbjogcFRhZyxcbiAgICB0YWJsZTogcFRhZyxcbiAgICB1bDogcFRhZyxcbiAgICBydDogbmV3IFNldChbXCJydFwiLCBcInJwXCJdKSxcbiAgICBycDogbmV3IFNldChbXCJydFwiLCBcInJwXCJdKSxcbiAgICB0Ym9keTogbmV3IFNldChbXCJ0aGVhZFwiLCBcInRib2R5XCJdKSxcbiAgICB0Zm9vdDogbmV3IFNldChbXCJ0aGVhZFwiLCBcInRib2R5XCJdKVxufTtcbnZhciB2b2lkRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICBcImFyZWFcIixcbiAgICBcImJhc2VcIixcbiAgICBcImJhc2Vmb250XCIsXG4gICAgXCJiclwiLFxuICAgIFwiY29sXCIsXG4gICAgXCJjb21tYW5kXCIsXG4gICAgXCJlbWJlZFwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcImhyXCIsXG4gICAgXCJpbWdcIixcbiAgICBcImlucHV0XCIsXG4gICAgXCJpc2luZGV4XCIsXG4gICAgXCJrZXlnZW5cIixcbiAgICBcImxpbmtcIixcbiAgICBcIm1ldGFcIixcbiAgICBcInBhcmFtXCIsXG4gICAgXCJzb3VyY2VcIixcbiAgICBcInRyYWNrXCIsXG4gICAgXCJ3YnJcIlxuXSk7XG52YXIgZm9yZWlnbkNvbnRleHRFbGVtZW50cyA9IG5ldyBTZXQoW1wibWF0aFwiLCBcInN2Z1wiXSk7XG52YXIgaHRtbEludGVncmF0aW9uRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICBcIm1pXCIsXG4gICAgXCJtb1wiLFxuICAgIFwibW5cIixcbiAgICBcIm1zXCIsXG4gICAgXCJtdGV4dFwiLFxuICAgIFwiYW5ub3RhdGlvbi14bWxcIixcbiAgICBcImZvcmVpZ25PYmplY3RcIixcbiAgICBcImRlc2NcIixcbiAgICBcInRpdGxlXCJcbl0pO1xudmFyIHJlTmFtZUVuZCA9IC9cXHN8XFwvLztcbnZhciBQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJzZXIoY2JzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90YWduYW1lID0gXCJcIjtcbiAgICAgICAgX3RoaXMuX2F0dHJpYm5hbWUgPSBcIlwiO1xuICAgICAgICBfdGhpcy5fYXR0cmlidmFsdWUgPSBcIlwiO1xuICAgICAgICBfdGhpcy5fYXR0cmlicyA9IG51bGw7XG4gICAgICAgIF90aGlzLl9zdGFjayA9IFtdO1xuICAgICAgICBfdGhpcy5fZm9yZWlnbkNvbnRleHQgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIF90aGlzLmVuZEluZGV4ID0gbnVsbDtcbiAgICAgICAgLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgX3RoaXMucGFyc2VDaHVuayA9IFBhcnNlci5wcm90b3R5cGUud3JpdGU7XG4gICAgICAgIF90aGlzLmRvbmUgPSBQYXJzZXIucHJvdG90eXBlLmVuZDtcbiAgICAgICAgX3RoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBfdGhpcy5fY2JzID0gY2JzIHx8IHt9O1xuICAgICAgICBfdGhpcy5fdGFnbmFtZSA9IFwiXCI7XG4gICAgICAgIF90aGlzLl9hdHRyaWJuYW1lID0gXCJcIjtcbiAgICAgICAgX3RoaXMuX2F0dHJpYnZhbHVlID0gXCJcIjtcbiAgICAgICAgX3RoaXMuX2F0dHJpYnMgPSBudWxsO1xuICAgICAgICBfdGhpcy5fc3RhY2sgPSBbXTtcbiAgICAgICAgX3RoaXMuX2ZvcmVpZ25Db250ZXh0ID0gW107XG4gICAgICAgIF90aGlzLnN0YXJ0SW5kZXggPSAwO1xuICAgICAgICBfdGhpcy5lbmRJbmRleCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9sb3dlckNhc2VUYWdOYW1lcyA9XG4gICAgICAgICAgICBcImxvd2VyQ2FzZVRhZ3NcIiBpbiBfdGhpcy5fb3B0aW9uc1xuICAgICAgICAgICAgICAgID8gISFfdGhpcy5fb3B0aW9ucy5sb3dlckNhc2VUYWdzXG4gICAgICAgICAgICAgICAgOiAhX3RoaXMuX29wdGlvbnMueG1sTW9kZTtcbiAgICAgICAgX3RoaXMuX2xvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzID1cbiAgICAgICAgICAgIFwibG93ZXJDYXNlQXR0cmlidXRlTmFtZXNcIiBpbiBfdGhpcy5fb3B0aW9uc1xuICAgICAgICAgICAgICAgID8gISFfdGhpcy5fb3B0aW9ucy5sb3dlckNhc2VBdHRyaWJ1dGVOYW1lc1xuICAgICAgICAgICAgICAgIDogIV90aGlzLl9vcHRpb25zLnhtbE1vZGU7XG4gICAgICAgIF90aGlzLl90b2tlbml6ZXIgPSBuZXcgKF90aGlzLl9vcHRpb25zLlRva2VuaXplciB8fCBUb2tlbml6ZXJfMS5kZWZhdWx0KShfdGhpcy5fb3B0aW9ucywgX3RoaXMpO1xuICAgICAgICBpZiAoX3RoaXMuX2Nicy5vbnBhcnNlcmluaXQpXG4gICAgICAgICAgICBfdGhpcy5fY2JzLm9ucGFyc2VyaW5pdChfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGFyc2VyLnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoaW5pdGlhbE9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5lbmRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rva2VuaXplci5fc2VjdGlvblN0YXJ0IDw9IGluaXRpYWxPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gdGhpcy5fdG9rZW5pemVyLl9zZWN0aW9uU3RhcnQgLSBpbml0aWFsT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHRoaXMuZW5kSW5kZXggKyAxO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gdGhpcy5fdG9rZW5pemVyLmdldEFic29sdXRlSW5kZXgoKTtcbiAgICB9O1xuICAgIC8vVG9rZW5pemVyIGV2ZW50IGhhbmRsZXJzXG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigxKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmVuZEluZGV4LS07XG4gICAgICAgIGlmICh0aGlzLl9jYnMub250ZXh0KVxuICAgICAgICAgICAgdGhpcy5fY2JzLm9udGV4dChkYXRhKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25vcGVudGFnbmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWduYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLnhtbE1vZGUgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcGVuSW1wbGllc0Nsb3NlLCBuYW1lKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgZWwgPSB2b2lkIDA7IFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgb3BlbkltcGxpZXNDbG9zZVtuYW1lXS5oYXMoKGVsID0gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV0pKTsgdGhpcy5vbmNsb3NldGFnKGVsKSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMueG1sTW9kZSB8fCAhdm9pZEVsZW1lbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhY2sucHVzaChuYW1lKTtcbiAgICAgICAgICAgIGlmIChmb3JlaWduQ29udGV4dEVsZW1lbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvcmVpZ25Db250ZXh0LnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChodG1sSW50ZWdyYXRpb25FbGVtZW50cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JlaWduQ29udGV4dC5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2JzLm9ub3BlbnRhZ25hbWUpXG4gICAgICAgICAgICB0aGlzLl9jYnMub25vcGVudGFnbmFtZShuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nicy5vbm9wZW50YWcpXG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJzID0ge307XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9ub3BlbnRhZ2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2JzLm9ub3BlbnRhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nicy5vbm9wZW50YWcodGhpcy5fdGFnbmFtZSwgdGhpcy5fYXR0cmlicyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMueG1sTW9kZSAmJlxuICAgICAgICAgICAgdGhpcy5fY2JzLm9uY2xvc2V0YWcgJiZcbiAgICAgICAgICAgIHZvaWRFbGVtZW50cy5oYXModGhpcy5fdGFnbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbmNsb3NldGFnKHRoaXMuX3RhZ25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhZ25hbWUgPSBcIlwiO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmNsb3NldGFnID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7XG4gICAgICAgIGlmICh0aGlzLl9sb3dlckNhc2VUYWdOYW1lcykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yZWlnbkNvbnRleHRFbGVtZW50cy5oYXMobmFtZSkgfHxcbiAgICAgICAgICAgIGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fZm9yZWlnbkNvbnRleHQucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrLmxlbmd0aCAmJlxuICAgICAgICAgICAgKHRoaXMuX29wdGlvbnMueG1sTW9kZSB8fCAhdm9pZEVsZW1lbnRzLmhhcyhuYW1lKSkpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLl9zdGFjay5sYXN0SW5kZXhPZihuYW1lKTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nicy5vbmNsb3NldGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuX3N0YWNrLmxlbmd0aCAtIHBvcztcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYnMub25jbG9zZXRhZyh0aGlzLl9zdGFjay5wb3AoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gXCJwXCIgJiYgIXRoaXMuX29wdGlvbnMueG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25vcGVudGFnbmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZUN1cnJlbnRUYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fb3B0aW9ucy54bWxNb2RlICYmIChuYW1lID09PSBcImJyXCIgfHwgbmFtZSA9PT0gXCJwXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm9ub3BlbnRhZ25hbWUobmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUN1cnJlbnRUYWcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnNlbGZjbG9zaW5ndGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy54bWxNb2RlIHx8XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLnJlY29nbml6ZVNlbGZDbG9zaW5nIHx8XG4gICAgICAgICAgICB0aGlzLl9mb3JlaWduQ29udGV4dFt0aGlzLl9mb3JlaWduQ29udGV4dC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VDdXJyZW50VGFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ub3BlbnRhZ2VuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLl9jbG9zZUN1cnJlbnRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5fdGFnbmFtZTtcbiAgICAgICAgdGhpcy5vbm9wZW50YWdlbmQoKTtcbiAgICAgICAgLy9zZWxmLWNsb3NpbmcgdGFncyB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgIC8vKGNoZWFwZXIgY2hlY2sgdGhhbiBpbiBvbmNsb3NldGFnKVxuICAgICAgICBpZiAodGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYnMub25jbG9zZXRhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nicy5vbmNsb3NldGFnKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25hdHRyaWJuYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dHJpYm5hbWUgPSBuYW1lO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmRhdGEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidmFsdWUgKz0gdmFsdWU7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm9uYXR0cmliZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2JzLm9uYXR0cmlidXRlKVxuICAgICAgICAgICAgdGhpcy5fY2JzLm9uYXR0cmlidXRlKHRoaXMuX2F0dHJpYm5hbWUsIHRoaXMuX2F0dHJpYnZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnMgJiZcbiAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fYXR0cmlicywgdGhpcy5fYXR0cmlibmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnNbdGhpcy5fYXR0cmlibmFtZV0gPSB0aGlzLl9hdHRyaWJ2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRyaWJuYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5fYXR0cmlidmFsdWUgPSBcIlwiO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5fZ2V0SW5zdHJ1Y3Rpb25OYW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpZHggPSB2YWx1ZS5zZWFyY2gocmVOYW1lRW5kKTtcbiAgICAgICAgdmFyIG5hbWUgPSBpZHggPCAwID8gdmFsdWUgOiB2YWx1ZS5zdWJzdHIoMCwgaWR4KTtcbiAgICAgICAgaWYgKHRoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbmRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLl9nZXRJbnN0cnVjdGlvbk5hbWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKFwiIVwiICsgbmFtZV8xLCBcIiFcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8yID0gdGhpcy5fZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihcIj9cIiArIG5hbWVfMiwgXCI/XCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25jb21tZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKDQpO1xuICAgICAgICBpZiAodGhpcy5fY2JzLm9uY29tbWVudClcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbmNvbW1lbnQodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fY2JzLm9uY29tbWVudGVuZClcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbmNvbW1lbnRlbmQoKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25jZGF0YSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigxKTtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMueG1sTW9kZSB8fCB0aGlzLl9vcHRpb25zLnJlY29nbml6ZUNEQVRBKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2JzLm9uY2RhdGFzdGFydClcbiAgICAgICAgICAgICAgICB0aGlzLl9jYnMub25jZGF0YXN0YXJ0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2JzLm9udGV4dClcbiAgICAgICAgICAgICAgICB0aGlzLl9jYnMub250ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYnMub25jZGF0YWVuZClcbiAgICAgICAgICAgICAgICB0aGlzLl9jYnMub25jZGF0YWVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbmNvbW1lbnQoXCJbQ0RBVEFbXCIgKyB2YWx1ZSArIFwiXV1cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nicy5vbmVycm9yKVxuICAgICAgICAgICAgdGhpcy5fY2JzLm9uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYnMub25jbG9zZXRhZykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3N0YWNrLmxlbmd0aDsgaSA+IDA7IHRoaXMuX2Nicy5vbmNsb3NldGFnKHRoaXMuX3N0YWNrWy0taV0pKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2JzLm9uZW5kKVxuICAgICAgICAgICAgdGhpcy5fY2JzLm9uZW5kKCk7XG4gICAgfTtcbiAgICAvL1Jlc2V0cyB0aGUgcGFyc2VyIHRvIGEgYmxhbmsgc3RhdGUsIHJlYWR5IHRvIHBhcnNlIGEgbmV3IEhUTUwgZG9jdW1lbnRcbiAgICBQYXJzZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2JzLm9ucmVzZXQpXG4gICAgICAgICAgICB0aGlzLl9jYnMub25yZXNldCgpO1xuICAgICAgICB0aGlzLl90b2tlbml6ZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fdGFnbmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuX2F0dHJpYm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLl9hdHRyaWJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX2Nicy5vbnBhcnNlcmluaXQpXG4gICAgICAgICAgICB0aGlzLl9jYnMub25wYXJzZXJpbml0KHRoaXMpO1xuICAgIH07XG4gICAgLy9QYXJzZXMgYSBjb21wbGV0ZSBIVE1MIGRvY3VtZW50IGFuZCBwdXNoZXMgaXQgdG8gdGhlIGhhbmRsZXJcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxldGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZW5kKGRhdGEpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLl90b2tlbml6ZXIud3JpdGUoY2h1bmspO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5fdG9rZW5pemVyLmVuZChjaHVuayk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90b2tlbml6ZXIucGF1c2UoKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90b2tlbml6ZXIucmVzdW1lKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVjb2RlX2NvZGVwb2ludF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvZGVjb2RlX2NvZGVwb2ludFwiKSk7XG52YXIgZW50aXRpZXNfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uXCIpKTtcbnZhciBsZWdhY3lfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvbWFwcy9sZWdhY3kuanNvblwiKSk7XG52YXIgeG1sX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZW50aXRpZXMvbGliL21hcHMveG1sLmpzb25cIikpO1xuZnVuY3Rpb24gd2hpdGVzcGFjZShjKSB7XG4gICAgcmV0dXJuIGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcZlwiIHx8IGMgPT09IFwiXFxyXCI7XG59XG5mdW5jdGlvbiBpZkVsc2VTdGF0ZSh1cHBlciwgU1VDQ0VTUywgRkFJTFVSRSkge1xuICAgIHZhciBsb3dlciA9IHVwcGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHVwcGVyID09PSBsb3dlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGMpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBsb3dlcikge1xuICAgICAgICAgICAgICAgIHQuX3N0YXRlID0gU1VDQ0VTUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQuX3N0YXRlID0gRkFJTFVSRTtcbiAgICAgICAgICAgICAgICB0Ll9pbmRleC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBjKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gbG93ZXIgfHwgYyA9PT0gdXBwZXIpIHtcbiAgICAgICAgICAgICAgICB0Ll9zdGF0ZSA9IFNVQ0NFU1M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0Ll9zdGF0ZSA9IEZBSUxVUkU7XG4gICAgICAgICAgICAgICAgdC5faW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKHVwcGVyLCBORVhUX1NUQVRFKSB7XG4gICAgdmFyIGxvd2VyID0gdXBwZXIudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGMpIHtcbiAgICAgICAgaWYgKGMgPT09IGxvd2VyIHx8IGMgPT09IHVwcGVyKSB7XG4gICAgICAgICAgICB0Ll9zdGF0ZSA9IE5FWFRfU1RBVEU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0Ll9zdGF0ZSA9IDMgLyogSW5UYWdOYW1lICovO1xuICAgICAgICAgICAgdC5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBzdGF0ZUJlZm9yZUNkYXRhMSA9IGlmRWxzZVN0YXRlKFwiQ1wiLCAyMyAvKiBCZWZvcmVDZGF0YTIgKi8sIDE2IC8qIEluRGVjbGFyYXRpb24gKi8pO1xudmFyIHN0YXRlQmVmb3JlQ2RhdGEyID0gaWZFbHNlU3RhdGUoXCJEXCIsIDI0IC8qIEJlZm9yZUNkYXRhMyAqLywgMTYgLyogSW5EZWNsYXJhdGlvbiAqLyk7XG52YXIgc3RhdGVCZWZvcmVDZGF0YTMgPSBpZkVsc2VTdGF0ZShcIkFcIiwgMjUgLyogQmVmb3JlQ2RhdGE0ICovLCAxNiAvKiBJbkRlY2xhcmF0aW9uICovKTtcbnZhciBzdGF0ZUJlZm9yZUNkYXRhNCA9IGlmRWxzZVN0YXRlKFwiVFwiLCAyNiAvKiBCZWZvcmVDZGF0YTUgKi8sIDE2IC8qIEluRGVjbGFyYXRpb24gKi8pO1xudmFyIHN0YXRlQmVmb3JlQ2RhdGE1ID0gaWZFbHNlU3RhdGUoXCJBXCIsIDI3IC8qIEJlZm9yZUNkYXRhNiAqLywgMTYgLyogSW5EZWNsYXJhdGlvbiAqLyk7XG52YXIgc3RhdGVCZWZvcmVTY3JpcHQxID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlJcIiwgMzQgLyogQmVmb3JlU2NyaXB0MiAqLyk7XG52YXIgc3RhdGVCZWZvcmVTY3JpcHQyID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIklcIiwgMzUgLyogQmVmb3JlU2NyaXB0MyAqLyk7XG52YXIgc3RhdGVCZWZvcmVTY3JpcHQzID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlBcIiwgMzYgLyogQmVmb3JlU2NyaXB0NCAqLyk7XG52YXIgc3RhdGVCZWZvcmVTY3JpcHQ0ID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIlRcIiwgMzcgLyogQmVmb3JlU2NyaXB0NSAqLyk7XG52YXIgc3RhdGVBZnRlclNjcmlwdDEgPSBpZkVsc2VTdGF0ZShcIlJcIiwgMzkgLyogQWZ0ZXJTY3JpcHQyICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQWZ0ZXJTY3JpcHQyID0gaWZFbHNlU3RhdGUoXCJJXCIsIDQwIC8qIEFmdGVyU2NyaXB0MyAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUFmdGVyU2NyaXB0MyA9IGlmRWxzZVN0YXRlKFwiUFwiLCA0MSAvKiBBZnRlclNjcmlwdDQgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVBZnRlclNjcmlwdDQgPSBpZkVsc2VTdGF0ZShcIlRcIiwgNDIgLyogQWZ0ZXJTY3JpcHQ1ICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQmVmb3JlU3R5bGUxID0gY29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIllcIiwgNDQgLyogQmVmb3JlU3R5bGUyICovKTtcbnZhciBzdGF0ZUJlZm9yZVN0eWxlMiA9IGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJMXCIsIDQ1IC8qIEJlZm9yZVN0eWxlMyAqLyk7XG52YXIgc3RhdGVCZWZvcmVTdHlsZTMgPSBjb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiRVwiLCA0NiAvKiBCZWZvcmVTdHlsZTQgKi8pO1xudmFyIHN0YXRlQWZ0ZXJTdHlsZTEgPSBpZkVsc2VTdGF0ZShcIllcIiwgNDggLyogQWZ0ZXJTdHlsZTIgKi8sIDEgLyogVGV4dCAqLyk7XG52YXIgc3RhdGVBZnRlclN0eWxlMiA9IGlmRWxzZVN0YXRlKFwiTFwiLCA0OSAvKiBBZnRlclN0eWxlMyAqLywgMSAvKiBUZXh0ICovKTtcbnZhciBzdGF0ZUFmdGVyU3R5bGUzID0gaWZFbHNlU3RhdGUoXCJFXCIsIDUwIC8qIEFmdGVyU3R5bGU0ICovLCAxIC8qIFRleHQgKi8pO1xudmFyIHN0YXRlQmVmb3JlRW50aXR5ID0gaWZFbHNlU3RhdGUoXCIjXCIsIDUyIC8qIEJlZm9yZU51bWVyaWNFbnRpdHkgKi8sIDUzIC8qIEluTmFtZWRFbnRpdHkgKi8pO1xudmFyIHN0YXRlQmVmb3JlTnVtZXJpY0VudGl0eSA9IGlmRWxzZVN0YXRlKFwiWFwiLCA1NSAvKiBJbkhleEVudGl0eSAqLywgNTQgLyogSW5OdW1lcmljRW50aXR5ICovKTtcbnZhciBUb2tlbml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW5pemVyKG9wdGlvbnMsIGNicykge1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgdGhlIHRva2VuaXplciBpcyBpbi4gKi9cbiAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgIC8qKiBUaGUgcmVhZCBidWZmZXIuICovXG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IFwiXCI7XG4gICAgICAgIC8qKiBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzZWN0aW9uIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHJlYWQuICovXG4gICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IDA7XG4gICAgICAgIC8qKiBUaGUgaW5kZXggd2l0aGluIHRoZSBidWZmZXIgdGhhdCB3ZSBhcmUgY3VycmVudGx5IGxvb2tpbmcgYXQuICovXG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYnVmZmVyIG9jY2FzaW9uYWxseS5cbiAgICAgICAgICogYF9idWZmZXJPZmZzZXRgIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlbW92ZWQsIHRvIG1ha2Ugc3VyZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBhY2N1cmF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2J1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBTb21lIGJlaGF2aW9yLCBlZy4gd2hlbiBkZWNvZGluZyBlbnRpdGllcywgaXMgZG9uZSB3aGlsZSB3ZSBhcmUgaW4gYW5vdGhlciBzdGF0ZS4gVGhpcyBrZWVwcyB0cmFjayBvZiB0aGUgb3RoZXIgc3RhdGUgdHlwZS4gKi9cbiAgICAgICAgdGhpcy5fYmFzZVN0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAvKiogRm9yIHNwZWNpYWwgcGFyc2luZyBiZWhhdmlvciBpbnNpZGUgb2Ygc2NyaXB0IGFuZCBzdHlsZSB0YWdzLiAqL1xuICAgICAgICB0aGlzLl9zcGVjaWFsID0gMSAvKiBOb25lICovO1xuICAgICAgICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRva2VuaXplciBoYXMgYmVlbiBwYXVzZWQuICovXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRva2VuaXplciBoYXMgZmluaXNoZWQgcnVubmluZyAvIGAuZW5kYCBoYXMgYmVlbiBjYWxsZWQuICovXG4gICAgICAgIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NicyA9IGNicztcbiAgICAgICAgdGhpcy5feG1sTW9kZSA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy54bWxNb2RlKTtcbiAgICAgICAgdGhpcy5fZGVjb2RlRW50aXRpZXMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuZGVjb2RlRW50aXRpZXMpO1xuICAgIH1cbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gXCJcIjtcbiAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9iYXNlU3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgIHRoaXMuX3NwZWNpYWwgPSAxIC8qIE5vbmUgKi87XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVUZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPiB0aGlzLl9zZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYnMub250ZXh0KHRoaXMuX2dldFNlY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDIgLyogQmVmb3JlVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RlY29kZUVudGl0aWVzICYmXG4gICAgICAgICAgICB0aGlzLl9zcGVjaWFsID09PSAxIC8qIE5vbmUgKi8gJiZcbiAgICAgICAgICAgIGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPiB0aGlzLl9zZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYnMub250ZXh0KHRoaXMuX2dldFNlY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iYXNlU3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDUxIC8qIEJlZm9yZUVudGl0eSAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVRhZ05hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNSAvKiBCZWZvcmVDbG9zaW5nVGFnTmFtZSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBcIjxcIikge1xuICAgICAgICAgICAgdGhpcy5fY2JzLm9udGV4dCh0aGlzLl9nZXRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI+XCIgfHxcbiAgICAgICAgICAgIHRoaXMuX3NwZWNpYWwgIT09IDEgLyogTm9uZSAqLyB8fFxuICAgICAgICAgICAgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTUgLyogQmVmb3JlRGVjbGFyYXRpb24gKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTcgLyogSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9XG4gICAgICAgICAgICAgICAgIXRoaXMuX3htbE1vZGUgJiYgKGMgPT09IFwic1wiIHx8IGMgPT09IFwiU1wiKVxuICAgICAgICAgICAgICAgICAgICA/IDMxIC8qIEJlZm9yZVNwZWNpYWwgKi9cbiAgICAgICAgICAgICAgICAgICAgOiAzIC8qIEluVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluVGFnTmFtZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIi9cIiB8fCBjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0VG9rZW4oXCJvbm9wZW50YWduYW1lXCIpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zcGVjaWFsICE9PSAxIC8qIE5vbmUgKi8pIHtcbiAgICAgICAgICAgIGlmIChjID09PSBcInNcIiB8fCBjID09PSBcIlNcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMzIgLyogQmVmb3JlU3BlY2lhbEVuZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDYgLyogSW5DbG9zaW5nVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQ2xvc2luZ1RhZ05hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdFRva2VuKFwib25jbG9zZXRhZ1wiKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNyAvKiBBZnRlckNsb3NpbmdUYWdOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy9za2lwIGV2ZXJ5dGhpbmcgdW50aWwgXCI+XCJcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jYnMub25vcGVudGFnZW5kKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA0IC8qIEluU2VsZkNsb3NpbmdUYWcgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gOSAvKiBJbkF0dHJpYnV0ZU5hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJblNlbGZDbG9zaW5nVGFnID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jYnMub25zZWxmY2xvc2luZ3RhZygpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gOCAvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI9XCIgfHwgYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fY2JzLm9uYXR0cmlibmFtZSh0aGlzLl9nZXRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEwIC8qIEFmdGVyQXR0cmlidXRlTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDExIC8qIEJlZm9yZUF0dHJpYnV0ZVZhbHVlICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFwiL1wiIHx8IGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jYnMub25hdHRyaWJlbmQoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gOCAvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fY2JzLm9uYXR0cmliZW5kKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDkgLyogSW5BdHRyaWJ1dGVOYW1lICovO1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxMiAvKiBJbkF0dHJpYnV0ZVZhbHVlRHEgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTMgLyogSW5BdHRyaWJ1dGVWYWx1ZVNxICovO1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDE0IC8qIEluQXR0cmlidXRlVmFsdWVOcSAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgdGhpcy5faW5kZXgtLTsgLy9yZWNvbnN1bWUgdG9rZW5cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZGVjb2RlRW50aXRpZXMgJiYgYyA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA1MSAvKiBCZWZvcmVFbnRpdHkgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG4gICAgICAgICAgICB0aGlzLl9jYnMub25hdHRyaWJlbmQoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gOCAvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RlY29kZUVudGl0aWVzICYmIGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG4gICAgICAgICAgICB0aGlzLl9iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNTEgLyogQmVmb3JlRW50aXR5ICovO1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2UoYykgfHwgYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RlY29kZUVudGl0aWVzICYmIGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7XG4gICAgICAgICAgICB0aGlzLl9iYXNlU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNTEgLyogQmVmb3JlRW50aXR5ICovO1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9XG4gICAgICAgICAgICBjID09PSBcIltcIlxuICAgICAgICAgICAgICAgID8gMjIgLyogQmVmb3JlQ2RhdGExICovXG4gICAgICAgICAgICAgICAgOiBjID09PSBcIi1cIlxuICAgICAgICAgICAgICAgICAgICA/IDE4IC8qIEJlZm9yZUNvbW1lbnQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiAxNiAvKiBJbkRlY2xhcmF0aW9uICovO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9jYnMub25kZWNsYXJhdGlvbih0aGlzLl9nZXRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbnByb2Nlc3NpbmdpbnN0cnVjdGlvbih0aGlzLl9nZXRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIi1cIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxOSAvKiBJbkNvbW1lbnQgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDE2IC8qIEluRGVjbGFyYXRpb24gKi87XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5Db21tZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiLVwiKVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyMCAvKiBBZnRlckNvbW1lbnQxICovO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNvbW1lbnQxID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDIxIC8qIEFmdGVyQ29tbWVudDIgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDE5IC8qIEluQ29tbWVudCAqLztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNvbW1lbnQyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAvL3JlbW92ZSAyIHRyYWlsaW5nIGNoYXJzXG4gICAgICAgICAgICB0aGlzLl9jYnMub25jb21tZW50KHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcodGhpcy5fc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCAtIDIpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDE5IC8qIEluQ29tbWVudCAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlOiBzdGF5IGluIEFGVEVSX0NPTU1FTlRfMiAoYC0tLT5gKVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDZGF0YTYgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjggLyogSW5DZGF0YSAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMTYgLyogSW5EZWNsYXJhdGlvbiAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5DZGF0YSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIl1cIilcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjkgLyogQWZ0ZXJDZGF0YTEgKi87XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ2RhdGExID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiXVwiKVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAzMCAvKiBBZnRlckNkYXRhMiAqLztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyOCAvKiBJbkNkYXRhICovO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNkYXRhMiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgLy9yZW1vdmUgMiB0cmFpbGluZyBjaGFyc1xuICAgICAgICAgICAgdGhpcy5fY2JzLm9uY2RhdGEodGhpcy5fYnVmZmVyLnN1YnN0cmluZyh0aGlzLl9zZWN0aW9uU3RhcnQsIHRoaXMuX2luZGV4IC0gMikpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gXCJdXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMjggLyogSW5DZGF0YSAqLztcbiAgICAgICAgfVxuICAgICAgICAvL2Vsc2U6IHN0YXkgaW4gQUZURVJfQ0RBVEFfMiAoYF1dXT5gKVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTcGVjaWFsID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiY1wiIHx8IGMgPT09IFwiQ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDMzIC8qIEJlZm9yZVNjcmlwdDEgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gXCJ0XCIgfHwgYyA9PT0gXCJUXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNDMgLyogQmVmb3JlU3R5bGUxICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAzIC8qIEluVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07IC8vY29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTcGVjaWFsRW5kID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NwZWNpYWwgPT09IDIgLyogU2NyaXB0ICovICYmIChjID09PSBcImNcIiB8fCBjID09PSBcIkNcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMzggLyogQWZ0ZXJTY3JpcHQxICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NwZWNpYWwgPT09IDMgLyogU3R5bGUgKi8gJiZcbiAgICAgICAgICAgIChjID09PSBcInRcIiB8fCBjID09PSBcIlRcIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gNDcgLyogQWZ0ZXJTdHlsZTEgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFRleHQgKi87XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVNjcmlwdDUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fc3BlY2lhbCA9IDIgLyogU2NyaXB0ICovO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMyAvKiBJblRhZ05hbWUgKi87XG4gICAgICAgIHRoaXMuX2luZGV4LS07IC8vY29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJTY3JpcHQ1ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPlwiIHx8IHdoaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NwZWNpYWwgPSAxIC8qIE5vbmUgKi87XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDYgLyogSW5DbG9zaW5nVGFnTmFtZSAqLztcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IHRoaXMuX2luZGV4IC0gNjtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07IC8vcmVjb25zdW1lIHRoZSB0b2tlblxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBUZXh0ICovO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTdHlsZTQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gXCIvXCIgfHwgYyA9PT0gXCI+XCIgfHwgd2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgdGhpcy5fc3BlY2lhbCA9IDMgLyogU3R5bGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUgPSAzIC8qIEluVGFnTmFtZSAqLztcbiAgICAgICAgdGhpcy5faW5kZXgtLTsgLy9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlclN0eWxlNCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIj5cIiB8fCB3aGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICB0aGlzLl9zcGVjaWFsID0gMSAvKiBOb25lICovO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSA2IC8qIEluQ2xvc2luZ1RhZ05hbWUgKi87XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCAtIDU7XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tOyAvL3JlY29uc3VtZSB0aGUgdG9rZW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogVGV4dCAqLztcbiAgICB9O1xuICAgIC8vZm9yIGVudGl0aWVzIHRlcm1pbmF0ZWQgd2l0aCBhIHNlbWljb2xvblxuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3BhcnNlTmFtZWRFbnRpdHlTdHJpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vb2Zmc2V0ID0gMVxuICAgICAgICBpZiAodGhpcy5fc2VjdGlvblN0YXJ0ICsgMSA8IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5fYnVmZmVyLnN1YnN0cmluZyh0aGlzLl9zZWN0aW9uU3RhcnQgKyAxLCB0aGlzLl9pbmRleCksIG1hcCA9IHRoaXMuX3htbE1vZGUgPyB4bWxfanNvbl8xLmRlZmF1bHQgOiBlbnRpdGllc19qc29uXzEuZGVmYXVsdDtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBlbnRpdHkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRQYXJ0aWFsKG1hcFtlbnRpdHldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgPSB0aGlzLl9pbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vcGFyc2VzIGxlZ2FjeSBlbnRpdGllcyAod2l0aG91dCB0cmFpbGluZyBzZW1pY29sb24pXG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2VMZWdhY3lFbnRpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuX3NlY3Rpb25TdGFydCArIDE7XG4gICAgICAgIHZhciBsaW1pdCA9IHRoaXMuX2luZGV4IC0gc3RhcnQ7XG4gICAgICAgIGlmIChsaW1pdCA+IDYpXG4gICAgICAgICAgICBsaW1pdCA9IDY7IC8vIFRoZSBtYXggbGVuZ3RoIG9mIGxlZ2FjeSBlbnRpdGllcyBpcyA2XG4gICAgICAgIHdoaWxlIChsaW1pdCA+PSAyKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWluIGxlbmd0aCBvZiBsZWdhY3kgZW50aXRpZXMgaXMgMlxuICAgICAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuX2J1ZmZlci5zdWJzdHIoc3RhcnQsIGxpbWl0KTtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGVnYWN5X2pzb25fMS5kZWZhdWx0LCBlbnRpdHkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRQYXJ0aWFsKGxlZ2FjeV9qc29uXzEuZGVmYXVsdFtlbnRpdHldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQgKz0gbGltaXQgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5OYW1lZEVudGl0eSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSBcIjtcIikge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VOYW1lZEVudGl0eVN0cmljdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlY3Rpb25TdGFydCArIDEgPCB0aGlzLl9pbmRleCAmJiAhdGhpcy5feG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyA8IFwiYVwiIHx8IGMgPiBcInpcIikgJiZcbiAgICAgICAgICAgIChjIDwgXCJBXCIgfHwgYyA+IFwiWlwiKSAmJlxuICAgICAgICAgICAgKGMgPCBcIjBcIiB8fCBjID4gXCI5XCIpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5feG1sTW9kZSB8fCB0aGlzLl9zZWN0aW9uU3RhcnQgKyAxID09PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYmFzZVN0YXRlICE9PSAxIC8qIFRleHQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VOYW1lZEVudGl0eVN0cmljdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4LS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX2RlY29kZU51bWVyaWNFbnRpdHkgPSBmdW5jdGlvbiAob2Zmc2V0LCBiYXNlKSB7XG4gICAgICAgIHZhciBzZWN0aW9uU3RhcnQgPSB0aGlzLl9zZWN0aW9uU3RhcnQgKyBvZmZzZXQ7XG4gICAgICAgIGlmIChzZWN0aW9uU3RhcnQgIT09IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICAvL3BhcnNlIGVudGl0eVxuICAgICAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuX2J1ZmZlci5zdWJzdHJpbmcoc2VjdGlvblN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoZW50aXR5LCBiYXNlKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRQYXJ0aWFsKGRlY29kZV9jb2RlcG9pbnRfMS5kZWZhdWx0KHBhcnNlZCkpO1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvblN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZWN0aW9uU3RhcnQtLTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5OdW1lcmljRW50aXR5ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDIsIDEwKTtcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCBcIjBcIiB8fCBjID4gXCI5XCIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5feG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluSGV4RW50aXR5ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDMsIDE2KTtcbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjIDwgXCJhXCIgfHwgYyA+IFwiZlwiKSAmJlxuICAgICAgICAgICAgKGMgPCBcIkFcIiB8fCBjID4gXCJGXCIpICYmXG4gICAgICAgICAgICAoYyA8IFwiMFwiIHx8IGMgPiBcIjlcIikpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5feG1sTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMywgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbmRleC0tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VjdGlvblN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlck9mZnNldCArPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDEgLyogVGV4dCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWN0aW9uU3RhcnQgIT09IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nicy5vbnRleHQodGhpcy5fYnVmZmVyLnN1YnN0cih0aGlzLl9zZWN0aW9uU3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VjdGlvblN0YXJ0ID09PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIC8vdGhlIHNlY3Rpb24ganVzdCBzdGFydGVkXG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgKz0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgZXZlcnl0aGluZyB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5zdWJzdHIodGhpcy5fc2VjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCAtPSB0aGlzLl9zZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyT2Zmc2V0ICs9IHRoaXMuX3NlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vVE9ETyBtYWtlIGV2ZW50cyBjb25kaXRpb25hbFxuICAgIFRva2VuaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuX2VuZGVkKVxuICAgICAgICAgICAgdGhpcy5fY2JzLm9uZXJyb3IoRXJyb3IoXCIud3JpdGUoKSBhZnRlciBkb25lIVwiKSk7XG4gICAgICAgIHRoaXMuX2J1ZmZlciArPSBjaHVuaztcbiAgICAgICAgdGhpcy5fcGFyc2UoKTtcbiAgICB9O1xuICAgIC8vIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGJ1ZmZlciwgY2FsbGluZyB0aGUgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAvLyBTdGF0ZXMgdGhhdCBhcmUgbW9yZSBsaWtlbHkgdG8gYmUgaGl0IGFyZSBoaWdoZXIgdXAsIGFzIGEgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuXG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9pbmRleCA8IHRoaXMuX2J1ZmZlci5sZW5ndGggJiYgdGhpcy5fcnVubmluZykge1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLl9idWZmZXIuY2hhckF0KHRoaXMuX2luZGV4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMSAvKiBUZXh0ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVUZXh0KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDEyIC8qIEluQXR0cmlidXRlVmFsdWVEcSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA5IC8qIEluQXR0cmlidXRlTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5BdHRyaWJ1dGVOYW1lKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDE5IC8qIEluQ29tbWVudCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5Db21tZW50KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDggLyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzIC8qIEluVGFnTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5UYWdOYW1lKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDYgLyogSW5DbG9zaW5nVGFnTmFtZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5DbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyIC8qIEJlZm9yZVRhZ05hbWUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUJlZm9yZVRhZ05hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTAgLyogQWZ0ZXJBdHRyaWJ1dGVOYW1lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVBZnRlckF0dHJpYnV0ZU5hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTMgLyogSW5BdHRyaWJ1dGVWYWx1ZVNxICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDExIC8qIEJlZm9yZUF0dHJpYnV0ZVZhbHVlICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1IC8qIEJlZm9yZUNsb3NpbmdUYWdOYW1lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVCZWZvcmVDbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA3IC8qIEFmdGVyQ2xvc2luZ1RhZ05hbWUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMzEgLyogQmVmb3JlU3BlY2lhbCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlQmVmb3JlU3BlY2lhbChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyMCAvKiBBZnRlckNvbW1lbnQxICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVBZnRlckNvbW1lbnQxKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDE0IC8qIEluQXR0cmlidXRlVmFsdWVOcSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQgLyogSW5TZWxmQ2xvc2luZ1RhZyAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5TZWxmQ2xvc2luZ1RhZyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAxNiAvKiBJbkRlY2xhcmF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVJbkRlY2xhcmF0aW9uKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDE1IC8qIEJlZm9yZURlY2xhcmF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyMSAvKiBBZnRlckNvbW1lbnQyICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVBZnRlckNvbW1lbnQyKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDE4IC8qIEJlZm9yZUNvbW1lbnQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUJlZm9yZUNvbW1lbnQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMzIgLyogQmVmb3JlU3BlY2lhbEVuZCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlQmVmb3JlU3BlY2lhbEVuZChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzOCAvKiBBZnRlclNjcmlwdDEgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU2NyaXB0MSh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzOSAvKiBBZnRlclNjcmlwdDIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU2NyaXB0Mih0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0MCAvKiBBZnRlclNjcmlwdDMgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU2NyaXB0Myh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzMyAvKiBCZWZvcmVTY3JpcHQxICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVTY3JpcHQxKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDM0IC8qIEJlZm9yZVNjcmlwdDIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVNjcmlwdDIodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMzUgLyogQmVmb3JlU2NyaXB0MyAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlU2NyaXB0Myh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAzNiAvKiBCZWZvcmVTY3JpcHQ0ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVTY3JpcHQ0KHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDM3IC8qIEJlZm9yZVNjcmlwdDUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUJlZm9yZVNjcmlwdDUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDEgLyogQWZ0ZXJTY3JpcHQ0ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVBZnRlclNjcmlwdDQodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDIgLyogQWZ0ZXJTY3JpcHQ1ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVBZnRlclNjcmlwdDUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDMgLyogQmVmb3JlU3R5bGUxICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVTdHlsZTEodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjggLyogSW5DZGF0YSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5DZGF0YShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0NCAvKiBCZWZvcmVTdHlsZTIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVN0eWxlMih0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0NSAvKiBCZWZvcmVTdHlsZTMgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZVN0eWxlMyh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0NiAvKiBCZWZvcmVTdHlsZTQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUJlZm9yZVN0eWxlNChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA0NyAvKiBBZnRlclN0eWxlMSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQWZ0ZXJTdHlsZTEodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNDggLyogQWZ0ZXJTdHlsZTIgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUFmdGVyU3R5bGUyKHRoaXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDQ5IC8qIEFmdGVyU3R5bGUzICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVBZnRlclN0eWxlMyh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1MCAvKiBBZnRlclN0eWxlNCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlQWZ0ZXJTdHlsZTQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTcgLyogSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDUzIC8qIEluTmFtZWRFbnRpdHkgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUluTmFtZWRFbnRpdHkoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjIgLyogQmVmb3JlQ2RhdGExICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVDZGF0YTEodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTEgLyogQmVmb3JlRW50aXR5ICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVFbnRpdHkodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjMgLyogQmVmb3JlQ2RhdGEyICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVDZGF0YTIodGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjQgLyogQmVmb3JlQ2RhdGEzICovKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVCZWZvcmVDZGF0YTModGhpcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMjkgLyogQWZ0ZXJDZGF0YTEgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUFmdGVyQ2RhdGExKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDMwIC8qIEFmdGVyQ2RhdGEyICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVBZnRlckNkYXRhMihjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyNSAvKiBCZWZvcmVDZGF0YTQgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZUNkYXRhNCh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyNiAvKiBCZWZvcmVDZGF0YTUgKi8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUJlZm9yZUNkYXRhNSh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSAyNyAvKiBCZWZvcmVDZGF0YTYgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUJlZm9yZUNkYXRhNihjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1NSAvKiBJbkhleEVudGl0eSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlSW5IZXhFbnRpdHkoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTQgLyogSW5OdW1lcmljRW50aXR5ICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVJbk51bWVyaWNFbnRpdHkoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTIgLyogQmVmb3JlTnVtZXJpY0VudGl0eSAqLykge1xuICAgICAgICAgICAgICAgIHN0YXRlQmVmb3JlTnVtZXJpY0VudGl0eSh0aGlzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwidW5rbm93biBfc3RhdGVcIiksIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLl9idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbmRlZClcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwiLmVuZCgpIGFmdGVyIGRvbmUhXCIpKTtcbiAgICAgICAgaWYgKGNodW5rKVxuICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuayk7XG4gICAgICAgIHRoaXMuX2VuZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpXG4gICAgICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9pZiB0aGVyZSBpcyByZW1haW5pbmcgZGF0YSwgZW1pdCBpdCBpbiBhIHJlYXNvbmFibGUgd2F5XG4gICAgICAgIGlmICh0aGlzLl9zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2JzLm9uZW5kKCk7XG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9oYW5kbGVUcmFpbGluZ0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fYnVmZmVyLnN1YnN0cih0aGlzLl9zZWN0aW9uU3RhcnQpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDI4IC8qIEluQ2RhdGEgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID09PSAyOSAvKiBBZnRlckNkYXRhMSAqLyB8fFxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPT09IDMwIC8qIEFmdGVyQ2RhdGEyICovKSB7XG4gICAgICAgICAgICB0aGlzLl9jYnMub25jZGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gMTkgLyogSW5Db21tZW50ICovIHx8XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gMjAgLyogQWZ0ZXJDb21tZW50MSAqLyB8fFxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPT09IDIxIC8qIEFmdGVyQ29tbWVudDIgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX2Nicy5vbmNvbW1lbnQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IDUzIC8qIEluTmFtZWRFbnRpdHkgKi8gJiYgIXRoaXMuX3htbE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VjdGlvblN0YXJ0IDwgdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSA9PT0gNTQgLyogSW5OdW1lcmljRW50aXR5ICovICYmICF0aGlzLl94bWxNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDIsIDEwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWN0aW9uU3RhcnQgPCB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVRyYWlsaW5nRGF0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSA1NSAvKiBJbkhleEVudGl0eSAqLyAmJiAhdGhpcy5feG1sTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVjb2RlTnVtZXJpY0VudGl0eSgzLCAxNik7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VjdGlvblN0YXJ0IDwgdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gMyAvKiBJblRhZ05hbWUgKi8gJiZcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlICE9PSA4IC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi8gJiZcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlICE9PSAxMSAvKiBCZWZvcmVBdHRyaWJ1dGVWYWx1ZSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgIT09IDEwIC8qIEFmdGVyQXR0cmlidXRlTmFtZSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgIT09IDkgLyogSW5BdHRyaWJ1dGVOYW1lICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gMTMgLyogSW5BdHRyaWJ1dGVWYWx1ZVNxICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gMTIgLyogSW5BdHRyaWJ1dGVWYWx1ZURxICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gMTQgLyogSW5BdHRyaWJ1dGVWYWx1ZU5xICovICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSAhPT0gNiAvKiBJbkNsb3NpbmdUYWdOYW1lICovKSB7XG4gICAgICAgICAgICB0aGlzLl9jYnMub250ZXh0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vZWxzZSwgaWdub3JlIHJlbWFpbmluZyBkYXRhXG4gICAgICAgIC8vVE9ETyBhZGQgYSB3YXkgdG8gcmVtb3ZlIGN1cnJlbnQgdGFnXG4gICAgfTtcbiAgICBUb2tlbml6ZXIucHJvdG90eXBlLmdldEFic29sdXRlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXJPZmZzZXQgKyB0aGlzLl9pbmRleDtcbiAgICB9O1xuICAgIFRva2VuaXplci5wcm90b3R5cGUuX2dldFNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCwgdGhpcy5faW5kZXgpO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fZW1pdFRva2VuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fY2JzW25hbWVdKHRoaXMuX2dldFNlY3Rpb24oKSk7XG4gICAgICAgIHRoaXMuX3NlY3Rpb25TdGFydCA9IC0xO1xuICAgIH07XG4gICAgVG9rZW5pemVyLnByb3RvdHlwZS5fZW1pdFBhcnRpYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Jhc2VTdGF0ZSAhPT0gMSAvKiBUZXh0ICovKSB7XG4gICAgICAgICAgICB0aGlzLl9jYnMub25hdHRyaWJkYXRhKHZhbHVlKTsgLy9UT0RPIGltcGxlbWVudCB0aGUgbmV3IGV2ZW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jYnMub250ZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRva2VuaXplcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbml6ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9QYXJzZXJcIik7XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcl8xLlBhcnNlcjtcbnZhciBkb21oYW5kbGVyXzEgPSByZXF1aXJlKFwiZG9taGFuZGxlclwiKTtcbmV4cG9ydHMuRG9tSGFuZGxlciA9IGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyO1xuZXhwb3J0cy5EZWZhdWx0SGFuZGxlciA9IGRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyO1xuLy8gSGVscGVyIG1ldGhvZHNcbi8qKlxuICogUGFyc2VzIGRhdGEsIHJldHVybnMgdGhlIHJlc3VsdGluZyBET00uXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGJ1aWxkZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRE9NKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgaGFuZGxlciA9IG5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcih2b2lkIDAsIG9wdGlvbnMpO1xuICAgIG5ldyBQYXJzZXJfMS5QYXJzZXIoaGFuZGxlciwgb3B0aW9ucykuZW5kKGRhdGEpO1xuICAgIHJldHVybiBoYW5kbGVyLmRvbTtcbn1cbmV4cG9ydHMucGFyc2VET00gPSBwYXJzZURPTTtcbi8qKlxuICogQ3JlYXRlcyBhIHBhcnNlciBpbnN0YW5jZSwgd2l0aCBhbiBhdHRhY2hlZCBET00gaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0gY2IgQSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgcGFyc2luZyBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciB0aGUgcGFyc2VyIGFuZCBET00gYnVpbGRlci5cbiAqIEBwYXJhbSBlbGVtZW50Q2IgQW4gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBldmVyeSB0aW1lIGEgdGFnIGhhcyBiZWVuIGNvbXBsZXRlZCBpbnNpZGUgb2YgdGhlIERPTS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9tU3RyZWFtKGNiLCBvcHRpb25zLCBlbGVtZW50Q2IpIHtcbiAgICB2YXIgaGFuZGxlciA9IG5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcihjYiwgb3B0aW9ucywgZWxlbWVudENiKTtcbiAgICByZXR1cm4gbmV3IFBhcnNlcl8xLlBhcnNlcihoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlRG9tU3RyZWFtID0gY3JlYXRlRG9tU3RyZWFtO1xudmFyIFRva2VuaXplcl8xID0gcmVxdWlyZShcIi4vVG9rZW5pemVyXCIpO1xuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXJfMS5kZWZhdWx0O1xudmFyIEVsZW1lbnRUeXBlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKSk7XG5leHBvcnRzLkVsZW1lbnRUeXBlID0gRWxlbWVudFR5cGU7XG4vKipcbiAqIExpc3Qgb2YgYWxsIGV2ZW50cyB0aGF0IHRoZSBwYXJzZXIgZW1pdHMuXG4gKlxuICogRm9ybWF0OiBldmVudG5hbWU6IG51bWJlciBvZiBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydHMuRVZFTlRTID0ge1xuICAgIGF0dHJpYnV0ZTogMixcbiAgICBjZGF0YXN0YXJ0OiAwLFxuICAgIGNkYXRhZW5kOiAwLFxuICAgIHRleHQ6IDEsXG4gICAgcHJvY2Vzc2luZ2luc3RydWN0aW9uOiAyLFxuICAgIGNvbW1lbnQ6IDEsXG4gICAgY29tbWVudGVuZDogMCxcbiAgICBjbG9zZXRhZzogMSxcbiAgICBvcGVudGFnOiAyLFxuICAgIG9wZW50YWduYW1lOiAxLFxuICAgIGVycm9yOiAxLFxuICAgIGVuZDogMFxufTtcbi8qXG4gICAgQWxsIG9mIHRoZSBmb2xsb3dpbmcgZXhwb3J0cyBleGlzdCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuXG4gICAgVGhleSBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZCBldmVudHVhbGx5LlxuKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0ZlZWRIYW5kbGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1dyaXRhYmxlU3RyZWFtXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0NvbGxlY3RpbmdIYW5kbGVyXCIpKTtcbnZhciBEb21VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZG9tdXRpbHNcIikpO1xuZXhwb3J0cy5Eb21VdGlscyA9IERvbVV0aWxzO1xudmFyIEZlZWRIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9GZWVkSGFuZGxlclwiKTtcbmV4cG9ydHMuUnNzSGFuZGxlciA9IEZlZWRIYW5kbGVyXzEuRmVlZEhhbmRsZXI7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbnZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG52YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyMycsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGYwJyxcbiAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc0xvd2VyTWlzYyA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc1VwcGVyTWlzYyA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc09wdExvd2VyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdFVwcGVyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG52YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICovXG52YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdExvd2VyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlck1pc2MgKyAnKycgKyByc09wdFVwcGVyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNMb3dlck1pc2MsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyICsgJz8nICsgcnNMb3dlck1pc2MgKyAnKycgKyByc09wdExvd2VyQ29udHIsXG4gIHJzVXBwZXIgKyAnKycgKyByc09wdFVwcGVyQ29udHIsXG4gIHJzRGlnaXRzLFxuICByc0Vtb2ppXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xudmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyLH1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnLFxuICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAnc3MnXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICovXG52YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKlxuICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICovXG52YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAqIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAqIC8vID0+ICdkZWphIHZ1J1xuICovXG5mdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICpcbiAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICogLy8gPT4gJ0ZSRUQnXG4gKi9cbnZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICovXG5mdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbENhc2U7XG4iLCJmdW5jdGlvbiBhcmVJbnB1dHNFcXVhbChuZXdJbnB1dHMsIGxhc3RJbnB1dHMpIHtcbiAgICBpZiAobmV3SW5wdXRzLmxlbmd0aCAhPT0gbGFzdElucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobmV3SW5wdXRzW2ldICE9PSBsYXN0SW5wdXRzW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVPbmUocmVzdWx0Rm4sIGlzRXF1YWwpIHtcbiAgICBpZiAoaXNFcXVhbCA9PT0gdm9pZCAwKSB7IGlzRXF1YWwgPSBhcmVJbnB1dHNFcXVhbDsgfVxuICAgIHZhciBsYXN0VGhpcztcbiAgICB2YXIgbGFzdEFyZ3MgPSBbXTtcbiAgICB2YXIgbGFzdFJlc3VsdDtcbiAgICB2YXIgY2FsbGVkT25jZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgICAgICB2YXIgbmV3QXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbmV3QXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsZWRPbmNlICYmIGxhc3RUaGlzID09PSB0aGlzICYmIGlzRXF1YWwobmV3QXJncywgbGFzdEFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgIGNhbGxlZE9uY2UgPSB0cnVlO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RBcmdzID0gbmV3QXJncztcbiAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBtZW1vaXplZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZU9uZTtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwidmFyIF9jb25jYXQgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29uY2F0Jyk7XG5cbnZhciBfY3VycnkxID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG52YXIgY3VycnlOID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vY3VycnlOJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IGl0ZXJhdGlvbiBmdW5jdGlvbiBmcm9tIGFuIGV4aXN0aW5nIG9uZSBieSBhZGRpbmcgdHdvIG5ld1xuICogcGFyYW1ldGVycyB0byBpdHMgY2FsbGJhY2sgZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4LCBhbmQgdGhlIGVudGlyZSBsaXN0LlxuICpcbiAqIFRoaXMgd291bGQgdHVybiwgZm9yIGluc3RhbmNlLCBbYFIubWFwYF0oI21hcCkgZnVuY3Rpb24gaW50byBvbmUgdGhhdFxuICogbW9yZSBjbG9zZWx5IHJlc2VtYmxlcyBgQXJyYXkucHJvdG90eXBlLm1hcGAuIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrXG4gKiBmb3IgZnVuY3Rpb25zIGluIHdoaWNoIHRoZSBpdGVyYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGZpcnN0XG4gKiBwYXJhbWV0ZXIsIGFuZCB3aGVyZSB0aGUgbGlzdCBpcyB0aGUgbGFzdCBwYXJhbWV0ZXIuIChUaGlzIGxhdHRlciBtaWdodCBiZVxuICogdW5pbXBvcnRhbnQgaWYgdGhlIGxpc3QgcGFyYW1ldGVyIGlzIG5vdCB1c2VkLilcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSAuLi4gLT4gYikgLi4uIC0+IFthXSAtPiAqKSAtPiAoKGEgLi4uLCBJbnQsIFthXSAtPiBiKSAuLi4gLT4gW2FdIC0+ICopXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgcGFzcyBpbmRleCBvciBsaXN0IHRvIGl0cyBjYWxsYmFja1xuICogQHJldHVybiB7RnVuY3Rpb259IEFuIGFsdGVyZWQgbGlzdCBpdGVyYXRpb24gZnVuY3Rpb24gdGhhdCBwYXNzZXMgKGl0ZW0sIGluZGV4LCBsaXN0KSB0byBpdHMgY2FsbGJhY2tcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBtYXBJbmRleGVkID0gUi5hZGRJbmRleChSLm1hcCk7XG4gKiAgICAgIG1hcEluZGV4ZWQoKHZhbCwgaWR4KSA9PiBpZHggKyAnLScgKyB2YWwsIFsnZicsICdvJywgJ28nLCAnYicsICdhJywgJ3InXSk7XG4gKiAgICAgIC8vPT4gWycwLWYnLCAnMS1vJywgJzItbycsICczLWInLCAnNC1hJywgJzUtciddXG4gKi9cblxuXG52YXIgYWRkSW5kZXggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MShmdW5jdGlvbiBhZGRJbmRleChmbikge1xuICByZXR1cm4gY3VycnlOKGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBvcmlnRm4gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxpc3QgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzWzBdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9yaWdGbi5hcHBseSh0aGlzLCBfY29uY2F0KGFyZ3VtZW50cywgW2lkeCwgbGlzdF0pKTtcbiAgICAgIGlkeCArPSAxO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gYWRkSW5kZXg7IiwidmFyIF9hcml0eSA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xuXG52YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBib3VuZCB0byBhIGNvbnRleHQuXG4gKiBOb3RlOiBgUi5iaW5kYCBkb2VzIG5vdCBwcm92aWRlIHRoZSBhZGRpdGlvbmFsIGFyZ3VtZW50LWJpbmRpbmcgY2FwYWJpbGl0aWVzIG9mXG4gKiBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgqIC0+ICopIC0+IHsqfSAtPiAoKiAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJpbmQgdG8gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNPYmogVGhlIGNvbnRleHQgdG8gYmluZCBgZm5gIHRvXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBpbiB0aGUgY29udGV4dCBvZiBgdGhpc09iamAuXG4gKiBAc2VlIFIucGFydGlhbFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGxvZyA9IFIuYmluZChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gKiAgICAgIFIucGlwZShSLmFzc29jKCdhJywgMiksIFIudGFwKGxvZyksIFIuYXNzb2MoJ2EnLCAzKSkoe2E6IDF9KTsgLy89PiB7YTogM31cbiAqICAgICAgLy8gbG9ncyB7YTogMn1cbiAqIEBzeW1iIFIuYmluZChmLCBvKShhLCBiKSA9IGYuY2FsbChvLCBhLCBiKVxuICovXG5cblxudmFyIGJpbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBiaW5kKGZuLCB0aGlzT2JqKSB7XG4gIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNPYmosIGFyZ3VtZW50cyk7XG4gIH0pO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQ7IiwidmFyIF9hcml0eSA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xuXG52YXIgX2N1cnJ5MSA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxudmFyIF9jdXJyeTIgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cbnZhciBfY3VycnlOID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5TicpO1xuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAqIGFyaXR5LiBUaGUgY3VycmllZCBmdW5jdGlvbiBoYXMgdHdvIHVudXN1YWwgY2FwYWJpbGl0aWVzLiBGaXJzdCwgaXRzXG4gKiBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmUgYXQgYSB0aW1lLiBJZiBgZ2AgaXMgYFIuY3VycnlOKDMsIGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBbYFIuX19gXSgjX18pIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gKiByZWdhcmRsZXNzIG9mIHRoZWlyIHBvc2l0aW9ucy4gSWYgYGdgIGlzIGFzIGFib3ZlIGFuZCBgX2AgaXMgW2BSLl9fYF0oI19fKSxcbiAqIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjUuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgZm9yIHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jdXJyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHN1bUFyZ3MgPSAoLi4uYXJncykgPT4gUi5zdW0oYXJncyk7XG4gKlxuICogICAgICBjb25zdCBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5Tig0LCBzdW1BcmdzKTtcbiAqICAgICAgY29uc3QgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgY29uc3QgZyA9IGYoMyk7XG4gKiAgICAgIGcoNCk7IC8vPT4gMTBcbiAqL1xuXG5cbnZhciBjdXJyeU4gPSAvKiNfX1BVUkVfXyovX2N1cnJ5MihmdW5jdGlvbiBjdXJyeU4obGVuZ3RoLCBmbikge1xuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIF9jdXJyeTEoZm4pO1xuICB9XG4gIHJldHVybiBfYXJpdHkobGVuZ3RoLCBfY3VycnlOKGxlbmd0aCwgW10sIGZuKSk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gY3VycnlOOyIsInZhciBfY3VycnkyID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG52YXIgX2Rpc3BhdGNoYWJsZSA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcblxudmFyIF9maWx0ZXIgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fZmlsdGVyJyk7XG5cbnZhciBfaXNPYmplY3QgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNPYmplY3QnKTtcblxudmFyIF9yZWR1Y2UgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG5cbnZhciBfeGZpbHRlciA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL194ZmlsdGVyJyk7XG5cbnZhciBrZXlzID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIGBGaWx0ZXJhYmxlYCwgYW5kIHJldHVybnMgYSBuZXcgZmlsdGVyYWJsZSBvZiB0aGVcbiAqIHNhbWUgdHlwZSBjb250YWluaW5nIHRoZSBtZW1iZXJzIG9mIHRoZSBnaXZlbiBmaWx0ZXJhYmxlIHdoaWNoIHNhdGlzZnkgdGhlXG4gKiBnaXZlbiBwcmVkaWNhdGUuIEZpbHRlcmFibGUgb2JqZWN0cyBpbmNsdWRlIHBsYWluIG9iamVjdHMgb3IgYW55IG9iamVjdFxuICogdGhhdCBoYXMgYSBmaWx0ZXIgbWV0aG9kIHN1Y2ggYXMgYEFycmF5YC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZmlsdGVyYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IGYgYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZFxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyYWJsZVxuICogQHJldHVybiB7QXJyYXl9IEZpbHRlcmFibGVcbiAqIEBzZWUgUi5yZWplY3QsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgaXNFdmVuID0gbiA9PiBuICUgMiA9PT0gMDtcbiAqXG4gKiAgICAgIFIuZmlsdGVyKGlzRXZlbiwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAqXG4gKiAgICAgIFIuZmlsdGVyKGlzRXZlbiwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YjogMiwgZDogNH1cbiAqL1xuXG5cbnZhciBmaWx0ZXIgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWydmaWx0ZXInXSwgX3hmaWx0ZXIsIGZ1bmN0aW9uIChwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gIHJldHVybiBfaXNPYmplY3QoZmlsdGVyYWJsZSkgPyBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIGlmIChwcmVkKGZpbHRlcmFibGVba2V5XSkpIHtcbiAgICAgIGFjY1trZXldID0gZmlsdGVyYWJsZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSwga2V5cyhmaWx0ZXJhYmxlKSkgOlxuICAvLyBlbHNlXG4gIF9maWx0ZXIocHJlZCwgZmlsdGVyYWJsZSk7XG59KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjsiLCJ2YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxudmFyIF9kaXNwYXRjaGFibGUgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG5cbnZhciBfeGZpbmQgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9feGZpbmQnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0IHdoaWNoIG1hdGNoZXMgdGhlIHByZWRpY2F0ZSwgb3JcbiAqIGB1bmRlZmluZWRgIGlmIG5vIGVsZW1lbnQgbWF0Y2hlcy5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZmluZGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IGEgfCB1bmRlZmluZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiAgICAgICAgZGVzaXJlZCBvbmUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGVsZW1lbnQgZm91bmQsIG9yIGB1bmRlZmluZWRgLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHhzID0gW3thOiAxfSwge2E6IDJ9LCB7YTogM31dO1xuICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCAyKSkoeHMpOyAvLz0+IHthOiAyfVxuICogICAgICBSLmZpbmQoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IHVuZGVmaW5lZFxuICovXG5cblxudmFyIGZpbmQgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWydmaW5kJ10sIF94ZmluZCwgZnVuY3Rpb24gZmluZChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBsaXN0W2lkeF07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG59KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZpbmQ7IiwidmFyIF9jaGVja0Zvck1ldGhvZCA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCcpO1xuXG52YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gaW5wdXQgYGxpc3RgLCBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gYGZuYCBmb3IgZWFjaFxuICogZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAqXG4gKiBgZm5gIHJlY2VpdmVzIG9uZSBhcmd1bWVudDogKih2YWx1ZSkqLlxuICpcbiAqIE5vdGU6IGBSLmZvckVhY2hgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZVxuICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QuIEZvciBtb3JlXG4gKiBkZXRhaWxzIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2gjRGVzY3JpcHRpb25cbiAqXG4gKiBBbHNvIG5vdGUgdGhhdCwgdW5saWtlIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAsIFJhbWRhJ3MgYGZvckVhY2hgIHJldHVybnNcbiAqIHRoZSBvcmlnaW5hbCBhcnJheS4gSW4gc29tZSBsaWJyYXJpZXMgdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgZWFjaGAuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGZvckVhY2hgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gKikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBgdmFsdWVgLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9yaWdpbmFsIGxpc3QuXG4gKiBAc2VlIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBwcmludFhQbHVzRml2ZSA9IHggPT4gY29uc29sZS5sb2coeCArIDUpO1xuICogICAgICBSLmZvckVhY2gocHJpbnRYUGx1c0ZpdmUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDNdXG4gKiAgICAgIC8vIGxvZ3MgNlxuICogICAgICAvLyBsb2dzIDdcbiAqICAgICAgLy8gbG9ncyA4XG4gKiBAc3ltYiBSLmZvckVhY2goZiwgW2EsIGIsIGNdKSA9IFthLCBiLCBjXVxuICovXG5cblxudmFyIGZvckVhY2ggPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19jaGVja0Zvck1ldGhvZCgnZm9yRWFjaCcsIGZ1bmN0aW9uIGZvckVhY2goZm4sIGxpc3QpIHtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGZuKGxpc3RbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59KSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7IiwiZnVuY3Rpb24gX2FyaXR5KG4sIGZuKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gX2FyaXR5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuJyk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2FyaXR5OyIsInZhciBfaXNBcnJheSA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL19pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhpcyBjaGVja3Mgd2hldGhlciBhIGZ1bmN0aW9uIGhhcyBhIFttZXRob2RuYW1lXSBmdW5jdGlvbi4gSWYgaXQgaXNuJ3QgYW5cbiAqIGFycmF5IGl0IHdpbGwgZXhlY3V0ZSB0aGF0IGZ1bmN0aW9uIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIHJhbWRhXG4gKiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gcmFtZGEgaW1wbGVtdGF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kbmFtZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm4ge09iamVjdH0gV2hhdGV2ZXIgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbWV0aG9kIGlzLlxuICovXG5cblxuZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHZhciBvYmogPSBhcmd1bWVudHNbbGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF9pc0FycmF5KG9iaikgfHwgdHlwZW9mIG9ialttZXRob2RuYW1lXSAhPT0gJ2Z1bmN0aW9uJyA/IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvYmpbbWV0aG9kbmFtZV0uYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGxlbmd0aCAtIDEpKTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NoZWNrRm9yTWV0aG9kOyIsImZ1bmN0aW9uIF9jb21wbGVtZW50KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NvbXBsZW1lbnQ7IiwiLyoqXG4gKiBQcml2YXRlIGBjb25jYXRgIGZ1bmN0aW9uIHRvIG1lcmdlIHR3byBhcnJheS1saWtlIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8QXJndW1lbnRzfSBbc2V0MT1bXV0gQW4gYXJyYXktbGlrZSBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDI9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3LCBtZXJnZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2NvbmNhdChbNCwgNSwgNl0sIFsxLCAyLCAzXSk7IC8vPT4gWzQsIDUsIDYsIDEsIDIsIDNdXG4gKi9cbmZ1bmN0aW9uIF9jb25jYXQoc2V0MSwgc2V0Mikge1xuICBzZXQxID0gc2V0MSB8fCBbXTtcbiAgc2V0MiA9IHNldDIgfHwgW107XG4gIHZhciBpZHg7XG4gIHZhciBsZW4xID0gc2V0MS5sZW5ndGg7XG4gIHZhciBsZW4yID0gc2V0Mi5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGVuMSkge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHNldDFbaWR4XTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGVuMikge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHNldDJbaWR4XTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY29uY2F0OyIsInZhciBfaXNQbGFjZWhvbGRlciA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIG9uZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBfY3VycnkxKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMShhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgX2lzUGxhY2Vob2xkZXIoYSkpIHtcbiAgICAgIHJldHVybiBmMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxOyIsInZhciBfY3VycnkxID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vX2N1cnJ5MScpO1xuXG52YXIgX2lzUGxhY2Vob2xkZXIgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9faXNQbGFjZWhvbGRlcicpO1xuXG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCB0d28tYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gX2N1cnJ5Mihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjIoYSwgYikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjI7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYyIDogX2N1cnJ5MShmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IpO1xuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IGYyIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkxKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHJldHVybiBmbihfYSwgYik7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkxKGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgIHJldHVybiBmbihhLCBfYik7XG4gICAgICAgIH0pIDogZm4oYSwgYik7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyOyIsInZhciBfY3VycnkxID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vX2N1cnJ5MScpO1xuXG52YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL19jdXJyeTInKTtcblxudmFyIF9pc1BsYWNlaG9sZGVyID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vX2lzUGxhY2Vob2xkZXInKTtcblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgdGhyZWUtYXJpdHkgY3VycnkgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjdXJyaWVkIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gX2N1cnJ5Myhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjMoYSwgYiwgYykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjM7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYzIDogX2N1cnJ5MihmdW5jdGlvbiAoX2IsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBfYyk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBfYyk7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgfSkgOiBfY3VycnkxKGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgIHJldHVybiBmbihhLCBiLCBfYyk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gZjMgOiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICAgIHJldHVybiBmbihfYSwgX2IsIGMpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBfYyk7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBjKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBjKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIF9jKTtcbiAgICAgICAgfSkgOiBmbihhLCBiLCBjKTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTM7IiwidmFyIF9hcml0eSA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL19hcml0eScpO1xuXG52YXIgX2lzUGxhY2Vob2xkZXIgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9faXNQbGFjZWhvbGRlcicpO1xuXG4vKipcbiAqIEludGVybmFsIGN1cnJ5TiBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBvZiB0aGUgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlY2VpdmVkIEFuIGFycmF5IG9mIGFyZ3VtZW50cyByZWNlaXZlZCB0aHVzIGZhci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIF9jdXJyeU4obGVuZ3RoLCByZWNlaXZlZCwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tYmluZWQgPSBbXTtcbiAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgdmFyIGxlZnQgPSBsZW5ndGg7XG4gICAgdmFyIGNvbWJpbmVkSWR4ID0gMDtcbiAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggJiYgKCFfaXNQbGFjZWhvbGRlcihyZWNlaXZlZFtjb21iaW5lZElkeF0pIHx8IGFyZ3NJZHggPj0gYXJndW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZWRbY29tYmluZWRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzW2FyZ3NJZHhdO1xuICAgICAgICBhcmdzSWR4ICs9IDE7XG4gICAgICB9XG4gICAgICBjb21iaW5lZFtjb21iaW5lZElkeF0gPSByZXN1bHQ7XG4gICAgICBpZiAoIV9pc1BsYWNlaG9sZGVyKHJlc3VsdCkpIHtcbiAgICAgICAgbGVmdCAtPSAxO1xuICAgICAgfVxuICAgICAgY29tYmluZWRJZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQgPD0gMCA/IGZuLmFwcGx5KHRoaXMsIGNvbWJpbmVkKSA6IF9hcml0eShsZWZ0LCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuKSk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeU47IiwidmFyIF9pc0FycmF5ID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vX2lzQXJyYXknKTtcblxudmFyIF9pc1RyYW5zZm9ybWVyID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vX2lzVHJhbnNmb3JtZXInKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIHdpdGggZGlmZmVyZW50IHN0cmF0ZWdpZXMgYmFzZWQgb24gdGhlXG4gKiBvYmplY3QgaW4gbGlzdCBwb3NpdGlvbiAobGFzdCBhcmd1bWVudCkuIElmIGl0IGlzIGFuIGFycmF5LCBleGVjdXRlcyBbZm5dLlxuICogT3RoZXJ3aXNlLCBpZiBpdCBoYXMgYSBmdW5jdGlvbiB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbWV0aG9kIG5hbWVzLCBpdCB3aWxsXG4gKiBleGVjdXRlIHRoYXQgZnVuY3Rpb24gKGZ1bmN0b3IgY2FzZSkuIE90aGVyd2lzZSwgaWYgaXQgaXMgYSB0cmFuc2Zvcm1lcixcbiAqIHVzZXMgdHJhbnNkdWNlciBbeGZdIHRvIHJldHVybiBhIG5ldyB0cmFuc2Zvcm1lciAodHJhbnNkdWNlciBjYXNlKS5cbiAqIE90aGVyd2lzZSwgaXQgd2lsbCBkZWZhdWx0IHRvIGV4ZWN1dGluZyBbZm5dLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBtZXRob2ROYW1lcyBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0geGYgdHJhbnNkdWNlciB0byBpbml0aWFsaXplIGlmIG9iamVjdCBpcyB0cmFuc2Zvcm1lclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZGVmYXVsdCByYW1kYSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9uIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBfZGlzcGF0Y2hhYmxlKG1ldGhvZE5hbWVzLCB4ZiwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB2YXIgb2JqID0gYXJncy5wb3AoKTtcbiAgICBpZiAoIV9pc0FycmF5KG9iaikpIHtcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgd2hpbGUgKGlkeCA8IG1ldGhvZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIG9ialttZXRob2ROYW1lc1tpZHhdXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBvYmpbbWV0aG9kTmFtZXNbaWR4XV0uYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZHggKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgIHZhciB0cmFuc2R1Y2VyID0geGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0cmFuc2R1Y2VyKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZGlzcGF0Y2hhYmxlOyIsImZ1bmN0aW9uIF9maWx0ZXIoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZmlsdGVyOyIsImZ1bmN0aW9uIF9oYXMocHJvcCwgb2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2hhczsiLCJ2YXIgX2hhcyA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBfaXNBcmd1bWVudHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcmd1bWVudHMpID09PSAnW29iamVjdCBBcmd1bWVudHNdJyA/IGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuICB9IDogZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHtcbiAgICByZXR1cm4gX2hhcygnY2FsbGVlJywgeCk7XG4gIH07XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzQXJndW1lbnRzOyIsIi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHZhbGAgaXMgYW4gYXJyYXksIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIF9pc0FycmF5KFtdKTsgLy89PiB0cnVlXG4gKiAgICAgIF9pc0FycmF5KG51bGwpOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5KHt9KTsgLy89PiBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gX2lzQXJyYXkodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoID49IDAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59OyIsInZhciBfY3VycnkxID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vX2N1cnJ5MScpO1xuXG52YXIgX2lzQXJyYXkgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9faXNBcnJheScpO1xuXG52YXIgX2lzU3RyaW5nID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vX2lzU3RyaW5nJyk7XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIHNpbWlsYXIgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGhhcyBhIG51bWVyaWMgbGVuZ3RoIHByb3BlcnR5IGFuZCBleHRyZW1lIGluZGljZXMgZGVmaW5lZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2lzQXJyYXlMaWtlKFtdKTsgLy89PiB0cnVlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh0cnVlKTsgLy89PiBmYWxzZVxuICogICAgICBfaXNBcnJheUxpa2Uoe30pOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh7bGVuZ3RoOiAxMH0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh7MDogJ3plcm8nLCA5OiAnbmluZScsIGxlbmd0aDogMTB9KTsgLy89PiB0cnVlXG4gKi9cblxuXG52YXIgX2lzQXJyYXlMaWtlID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICBpZiAoX2lzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoX2lzU3RyaW5nKHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgcmV0dXJuICEheC5sZW5ndGg7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB4Lmhhc093blByb3BlcnR5KDApICYmIHguaGFzT3duUHJvcGVydHkoeC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX2lzQXJyYXlMaWtlOyIsImZ1bmN0aW9uIF9pc09iamVjdCh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaXNPYmplY3Q7IiwiZnVuY3Rpb24gX2lzUGxhY2Vob2xkZXIoYSkge1xuICAgICAgIHJldHVybiBhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGFbJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlciddID09PSB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaXNQbGFjZWhvbGRlcjsiLCJmdW5jdGlvbiBfaXNTdHJpbmcoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cbm1vZHVsZS5leHBvcnRzID0gX2lzU3RyaW5nOyIsImZ1bmN0aW9uIF9pc1RyYW5zZm9ybWVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9ialsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbm1vZHVsZS5leHBvcnRzID0gX2lzVHJhbnNmb3JtZXI7IiwiZnVuY3Rpb24gX21hcChmbiwgZnVuY3Rvcikge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGZ1bmN0b3IubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuKTtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJlc3VsdFtpZHhdID0gZm4oZnVuY3RvcltpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfbWFwOyIsInZhciBfaXNBcnJheUxpa2UgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9faXNBcnJheUxpa2UnKTtcblxudmFyIF94d3JhcCA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL194d3JhcCcpO1xuXG52YXIgYmluZCA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuLi9iaW5kJyk7XG5cbmZ1bmN0aW9uIF9hcnJheVJlZHVjZSh4ZiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIGxpc3RbaWR4XSk7XG4gICAgaWYgKGFjYyAmJiBhY2NbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10pIHtcbiAgICAgIGFjYyA9IGFjY1snQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10oYWNjKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlUmVkdWNlKHhmLCBhY2MsIGl0ZXIpIHtcbiAgdmFyIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgd2hpbGUgKCFzdGVwLmRvbmUpIHtcbiAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIHN0ZXAudmFsdWUpO1xuICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgfVxuICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShhY2MpO1xufVxuXG5mdW5jdGlvbiBfbWV0aG9kUmVkdWNlKHhmLCBhY2MsIG9iaiwgbWV0aG9kTmFtZSkge1xuICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShvYmpbbWV0aG9kTmFtZV0oYmluZCh4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSwgeGYpLCBhY2MpKTtcbn1cblxudmFyIHN5bUl0ZXJhdG9yID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wuaXRlcmF0b3IgOiAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIF9yZWR1Y2UoZm4sIGFjYywgbGlzdCkge1xuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBfeHdyYXAoZm4pO1xuICB9XG4gIGlmIChfaXNBcnJheUxpa2UobGlzdCkpIHtcbiAgICByZXR1cm4gX2FycmF5UmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICB9XG4gIGlmICh0eXBlb2YgbGlzdFsnZmFudGFzeS1sYW5kL3JlZHVjZSddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCwgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnKTtcbiAgfVxuICBpZiAobGlzdFtzeW1JdGVyYXRvcl0gIT0gbnVsbCkge1xuICAgIHJldHVybiBfaXRlcmFibGVSZWR1Y2UoZm4sIGFjYywgbGlzdFtzeW1JdGVyYXRvcl0oKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBsaXN0Lm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX2l0ZXJhYmxlUmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICB9XG4gIGlmICh0eXBlb2YgbGlzdC5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX21ldGhvZFJlZHVjZShmbiwgYWNjLCBsaXN0LCAncmVkdWNlJyk7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2U6IGxpc3QgbXVzdCBiZSBhcnJheSBvciBpdGVyYWJsZScpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVkdWNlOyIsImZ1bmN0aW9uIF9yZWR1Y2VkKHgpIHtcbiAgcmV0dXJuIHggJiYgeFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSA/IHggOiB7XG4gICAgJ0BAdHJhbnNkdWNlci92YWx1ZSc6IHgsXG4gICAgJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJzogdHJ1ZVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVkdWNlZDsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfVxufTsiLCJ2YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL19jdXJyeTInKTtcblxudmFyIF94ZkJhc2UgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cbnZhciBYRmlsdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcblxuICBmdW5jdGlvbiBYRmlsdGVyKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaWx0ZXIucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmYoaW5wdXQpID8gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSA6IHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gWEZpbHRlcjtcbn0oKTtcblxudmFyIF94ZmlsdGVyID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hmaWx0ZXIoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRmlsdGVyKGYsIHhmKTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfeGZpbHRlcjsiLCJ2YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL19jdXJyeTInKTtcblxudmFyIF9yZWR1Y2VkID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vX3JlZHVjZWQnKTtcblxudmFyIF94ZkJhc2UgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cbnZhciBYRmluZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG5cbiAgZnVuY3Rpb24gWEZpbmQoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gIH1cbiAgWEZpbmQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAoIXRoaXMuZm91bmQpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB2b2lkIDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH07XG4gIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhGaW5kO1xufSgpO1xuXG52YXIgX3hmaW5kID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gX3hmaW5kKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWEZpbmQoZiwgeGYpO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF94ZmluZDsiLCJ2YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL19jdXJyeTInKTtcblxudmFyIF94ZkJhc2UgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cbnZhciBYTWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcblxuICBmdW5jdGlvbiBYTWFwKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5mKGlucHV0KSk7XG4gIH07XG5cbiAgcmV0dXJuIFhNYXA7XG59KCk7XG5cbnZhciBfeG1hcCA9IC8qI19fUFVSRV9fKi9fY3VycnkyKGZ1bmN0aW9uIF94bWFwKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWE1hcChmLCB4Zik7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX3htYXA7IiwidmFyIFhXcmFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWFdyYXAoZm4pIHtcbiAgICB0aGlzLmYgPSBmbjtcbiAgfVxuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IG5vdCBpbXBsZW1lbnRlZCBvbiBYV3JhcCcpO1xuICB9O1xuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChhY2MpIHtcbiAgICByZXR1cm4gYWNjO1xuICB9O1xuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAoYWNjLCB4KSB7XG4gICAgcmV0dXJuIHRoaXMuZihhY2MsIHgpO1xuICB9O1xuXG4gIHJldHVybiBYV3JhcDtcbn0oKTtcblxuZnVuY3Rpb24gX3h3cmFwKGZuKSB7XG4gIHJldHVybiBuZXcgWFdyYXAoZm4pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfeHdyYXA7IiwidmFyIF9jdXJyeTEgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cbnZhciBfaGFzID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX2hhcycpO1xuXG52YXIgX2lzQXJndW1lbnRzID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX2lzQXJndW1lbnRzJyk7XG5cbi8vIGNvdmVyIElFIDwgOSBrZXlzIGlzc3Vlc1xuXG5cbnZhciBoYXNFbnVtQnVnID0gISAvKiNfX1BVUkVfXyoveyB0b1N0cmluZzogbnVsbCB9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xudmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsnY29uc3RydWN0b3InLCAndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG4vLyBTYWZhcmkgYnVnXG52YXIgaGFzQXJnc0VudW1CdWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5wcm9wZXJ0eUlzRW51bWVyYWJsZSgnbGVuZ3RoJyk7XG59KCk7XG5cbnZhciBjb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKGxpc3QsIGl0ZW0pIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGlmIChsaXN0W2lkeF0gPT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZlxuICogdGhlIHN1cHBsaWVkIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICogQHNlZSBSLmtleXNJbiwgUi52YWx1ZXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmtleXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqL1xudmFyIGtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgIWhhc0FyZ3NFbnVtQnVnID8gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdChvYmopICE9PSBvYmogPyBbXSA6IE9iamVjdC5rZXlzKG9iaik7XG59KSA6IC8qI19fUFVSRV9fKi9fY3VycnkxKGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIGlmIChPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBwcm9wLCBuSWR4O1xuICB2YXIga3MgPSBbXTtcbiAgdmFyIGNoZWNrQXJnc0xlbmd0aCA9IGhhc0FyZ3NFbnVtQnVnICYmIF9pc0FyZ3VtZW50cyhvYmopO1xuICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKF9oYXMocHJvcCwgb2JqKSAmJiAoIWNoZWNrQXJnc0xlbmd0aCB8fCBwcm9wICE9PSAnbGVuZ3RoJykpIHtcbiAgICAgIGtzW2tzLmxlbmd0aF0gPSBwcm9wO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzRW51bUJ1Zykge1xuICAgIG5JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAobklkeCA+PSAwKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25JZHhdO1xuICAgICAgaWYgKF9oYXMocHJvcCwgb2JqKSAmJiAhY29udGFpbnMoa3MsIHByb3ApKSB7XG4gICAgICAgIGtzW2tzLmxlbmd0aF0gPSBwcm9wO1xuICAgICAgfVxuICAgICAgbklkeCAtPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga3M7XG59KTtcbm1vZHVsZS5leHBvcnRzID0ga2V5czsiLCJ2YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxudmFyIF9kaXNwYXRjaGFibGUgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG5cbnZhciBfbWFwID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX21hcCcpO1xuXG52YXIgX3JlZHVjZSA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19yZWR1Y2UnKTtcblxudmFyIF94bWFwID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX3htYXAnKTtcblxudmFyIGN1cnJ5TiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2N1cnJ5TicpO1xuXG52YXIga2V5cyA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZFxuICogYSBbZnVuY3Rvcl0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmdW5jdG9yKSxcbiAqIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGVhY2ggb2YgdGhlIGZ1bmN0b3IncyB2YWx1ZXMsIGFuZCByZXR1cm5zXG4gKiBhIGZ1bmN0b3Igb2YgdGhlIHNhbWUgc2hhcGUuXG4gKlxuICogUmFtZGEgcHJvdmlkZXMgc3VpdGFibGUgYG1hcGAgaW1wbGVtZW50YXRpb25zIGZvciBgQXJyYXlgIGFuZCBgT2JqZWN0YCxcbiAqIHNvIHRoaXMgZnVuY3Rpb24gbWF5IGJlIGFwcGxpZWQgdG8gYFsxLCAyLCAzXWAgb3IgYHt4OiAxLCB5OiAyLCB6OiAzfWAuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYG1hcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEFsc28gdHJlYXRzIGZ1bmN0aW9ucyBhcyBmdW5jdG9ycyBhbmQgd2lsbCBjb21wb3NlIHRoZW0gdG9nZXRoZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBGdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0LlxuICogQHNlZSBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGRvdWJsZSA9IHggPT4geCAqIDI7XG4gKlxuICogICAgICBSLm1hcChkb3VibGUsIFsxLCAyLCAzXSk7IC8vPT4gWzIsIDQsIDZdXG4gKlxuICogICAgICBSLm1hcChkb3VibGUsIHt4OiAxLCB5OiAyLCB6OiAzfSk7IC8vPT4ge3g6IDIsIHk6IDQsIHo6IDZ9XG4gKiBAc3ltYiBSLm1hcChmLCBbYSwgYl0pID0gW2YoYSksIGYoYildXG4gKiBAc3ltYiBSLm1hcChmLCB7IHg6IGEsIHk6IGIgfSkgPSB7IHg6IGYoYSksIHk6IGYoYikgfVxuICogQHN5bWIgUi5tYXAoZiwgZnVuY3Rvcl9vKSA9IGZ1bmN0b3Jfby5tYXAoZilcbiAqL1xuXG5cbnZhciBtYXAgPSAvKiNfX1BVUkVfXyovX2N1cnJ5MiggLyojX19QVVJFX18qL19kaXNwYXRjaGFibGUoWydmYW50YXN5LWxhbmQvbWFwJywgJ21hcCddLCBfeG1hcCwgZnVuY3Rpb24gbWFwKGZuLCBmdW5jdG9yKSB7XG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0b3IpKSB7XG4gICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOlxuICAgICAgcmV0dXJuIGN1cnJ5TihmdW5jdG9yLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBmdW5jdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSk7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzpcbiAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IGZuKGZ1bmN0b3Jba2V5XSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSwga2V5cyhmdW5jdG9yKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBfbWFwKGZuLCBmdW5jdG9yKTtcbiAgfVxufSkpO1xubW9kdWxlLmV4cG9ydHMgPSBtYXA7IiwidmFyIF9jdXJyeTMgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cbnZhciBfcmVkdWNlID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZScpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGUgaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmdcbiAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAqIHZhbHVlIGZyb20gdGhlIGFycmF5LCBhbmQgdGhlbiBwYXNzaW5nIHRoZSByZXN1bHQgdG8gdGhlIG5leHQgY2FsbC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouIEl0IG1heSB1c2VcbiAqIFtgUi5yZWR1Y2VkYF0oI3JlZHVjZWQpIHRvIHNob3J0Y3V0IHRoZSBpdGVyYXRpb24uXG4gKlxuICogVGhlIGFyZ3VtZW50cycgb3JkZXIgb2YgW2ByZWR1Y2VSaWdodGBdKCNyZWR1Y2VSaWdodCkncyBpdGVyYXRvciBmdW5jdGlvblxuICogaXMgKih2YWx1ZSwgYWNjKSouXG4gKlxuICogTm90ZTogYFIucmVkdWNlYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAqIGFycmF5cyksIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHNcbiAqIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSNEZXNjcmlwdGlvblxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGByZWR1Y2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuIFdoZW5cbiAqIGRvaW5nIHNvLCBpdCBpcyB1cCB0byB0aGUgdXNlciB0byBoYW5kbGUgdGhlIFtgUi5yZWR1Y2VkYF0oI3JlZHVjZWQpXG4gKiBzaG9ydGN1dGluZywgYXMgdGhpcyBpcyBub3QgaW1wbGVtZW50ZWQgYnkgYHJlZHVjZWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlZCwgUi5hZGRJbmRleCwgUi5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVkdWNlKFIuc3VidHJhY3QsIDAsIFsxLCAyLCAzLCA0XSkgLy8gPT4gKCgoKDAgLSAxKSAtIDIpIC0gMykgLSA0KSA9IC0xMFxuICogICAgICAvLyAgICAgICAgICAtICAgICAgICAgICAgICAgLTEwXG4gKiAgICAgIC8vICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAgICAgLSAgIDQgICAgICAgICAgIC02ICAgNFxuICogICAgICAvLyAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgIC8vICAgICAgLSAgIDMgICA9PT4gICAgIC0zICAgM1xuICogICAgICAvLyAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAtICAgMiAgICAgICAgICAgLTEgICAyXG4gKiAgICAgIC8vICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgMCAgIDEgICAgICAgICAgICAwICAgMVxuICpcbiAqIEBzeW1iIFIucmVkdWNlKGYsIGEsIFtiLCBjLCBkXSkgPSBmKGYoZihhLCBiKSwgYyksIGQpXG4gKi9cblxuXG52YXIgcmVkdWNlID0gLyojX19QVVJFX18qL19jdXJyeTMoX3JlZHVjZSk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTsiLCJ2YXIgX2NvbXBsZW1lbnQgPSAvKiNfX1BVUkVfXyovcmVxdWlyZSgnLi9pbnRlcm5hbC9fY29tcGxlbWVudCcpO1xuXG52YXIgX2N1cnJ5MiA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxudmFyIGZpbHRlciA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG4vKipcbiAqIFRoZSBjb21wbGVtZW50IG9mIFtgZmlsdGVyYF0oI2ZpbHRlcikuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLiBGaWx0ZXJhYmxlXG4gKiBvYmplY3RzIGluY2x1ZGUgcGxhaW4gb2JqZWN0cyBvciBhbnkgb2JqZWN0IHRoYXQgaGFzIGEgZmlsdGVyIG1ldGhvZCBzdWNoXG4gKiBhcyBgQXJyYXlgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmFibGVcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHNlZSBSLmZpbHRlciwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBpc09kZCA9IChuKSA9PiBuICUgMiA9PT0gMTtcbiAqXG4gKiAgICAgIFIucmVqZWN0KGlzT2RkLCBbMSwgMiwgMywgNF0pOyAvLz0+IFsyLCA0XVxuICpcbiAqICAgICAgUi5yZWplY3QoaXNPZGQsIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2I6IDIsIGQ6IDR9XG4gKi9cblxuXG52YXIgcmVqZWN0ID0gLyojX19QVVJFX18qL19jdXJyeTIoZnVuY3Rpb24gcmVqZWN0KHByZWQsIGZpbHRlcmFibGUpIHtcbiAgcmV0dXJuIGZpbHRlcihfY29tcGxlbWVudChwcmVkKSwgZmlsdGVyYWJsZSk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gcmVqZWN0OyIsInZhciBfY3VycnkxID0gLyojX19QVVJFX18qL3JlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xuXG52YXIgX2hhcyA9IC8qI19fUFVSRV9fKi9yZXF1aXJlKCcuL2ludGVybmFsL19oYXMnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cy4gT25seSB0aGUgb2JqZWN0J3NcbiAqIG93biBwcm9wZXJ0aWVzIGFyZSB1c2VkLlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cyBmcm9tIHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAqIEBzZWUgUi5mcm9tUGFpcnNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRvUGFpcnMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV1cbiAqL1xuXG5cbnZhciB0b1BhaXJzID0gLyojX19QVVJFX18qL19jdXJyeTEoZnVuY3Rpb24gdG9QYWlycyhvYmopIHtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKF9oYXMocHJvcCwgb2JqKSkge1xuICAgICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtwcm9wLCBvYmpbcHJvcF1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFpcnM7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gdG9QYWlyczsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgc2l6ZXJTdHlsZSA9IHtcblx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdHRvcDogMCxcblx0bGVmdDogMCxcblx0dmlzaWJpbGl0eTogJ2hpZGRlbicsXG5cdGhlaWdodDogMCxcblx0b3ZlcmZsb3c6ICdzY3JvbGwnLFxuXHR3aGl0ZVNwYWNlOiAncHJlJ1xufTtcblxudmFyIElOUFVUX1BST1BTX0JMQUNLTElTVCA9IFsnZXh0cmFXaWR0aCcsICdpbmplY3RTdHlsZXMnLCAnaW5wdXRDbGFzc05hbWUnLCAnaW5wdXRSZWYnLCAnaW5wdXRTdHlsZScsICdtaW5XaWR0aCcsICdvbkF1dG9zaXplJywgJ3BsYWNlaG9sZGVySXNNaW5XaWR0aCddO1xuXG52YXIgY2xlYW5JbnB1dFByb3BzID0gZnVuY3Rpb24gY2xlYW5JbnB1dFByb3BzKGlucHV0UHJvcHMpIHtcblx0SU5QVVRfUFJPUFNfQkxBQ0tMSVNULmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG5cdFx0cmV0dXJuIGRlbGV0ZSBpbnB1dFByb3BzW2ZpZWxkXTtcblx0fSk7XG5cdHJldHVybiBpbnB1dFByb3BzO1xufTtcblxudmFyIGNvcHlTdHlsZXMgPSBmdW5jdGlvbiBjb3B5U3R5bGVzKHN0eWxlcywgbm9kZSkge1xuXHRub2RlLnN0eWxlLmZvbnRTaXplID0gc3R5bGVzLmZvbnRTaXplO1xuXHRub2RlLnN0eWxlLmZvbnRGYW1pbHkgPSBzdHlsZXMuZm9udEZhbWlseTtcblx0bm9kZS5zdHlsZS5mb250V2VpZ2h0ID0gc3R5bGVzLmZvbnRXZWlnaHQ7XG5cdG5vZGUuc3R5bGUuZm9udFN0eWxlID0gc3R5bGVzLmZvbnRTdHlsZTtcblx0bm9kZS5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gc3R5bGVzLmxldHRlclNwYWNpbmc7XG5cdG5vZGUuc3R5bGUudGV4dFRyYW5zZm9ybSA9IHN0eWxlcy50ZXh0VHJhbnNmb3JtO1xufTtcblxudmFyIGlzSUUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yID8gL01TSUUgfFRyaWRlbnRcXC98RWRnZVxcLy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgOiBmYWxzZTtcblxudmFyIGdlbmVyYXRlSWQgPSBmdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuXHQvLyB3ZSBvbmx5IG5lZWQgYW4gYXV0by1nZW5lcmF0ZWQgSUQgZm9yIHN0eWxlc2hlZXQgaW5qZWN0aW9uLCB3aGljaCBpcyBvbmx5XG5cdC8vIHVzZWQgZm9yIElFLiBzbyBpZiB0aGUgYnJvd3NlciBpcyBub3QgSUUsIHRoaXMgc2hvdWxkIHJldHVybiB1bmRlZmluZWQuXG5cdHJldHVybiBpc0lFID8gJ18nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDEyKSA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBBdXRvc2l6ZUlucHV0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcblx0X2luaGVyaXRzKEF1dG9zaXplSW5wdXQsIF9Db21wb25lbnQpO1xuXG5cdGZ1bmN0aW9uIEF1dG9zaXplSW5wdXQocHJvcHMpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXV0b3NpemVJbnB1dCk7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQXV0b3NpemVJbnB1dC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEF1dG9zaXplSW5wdXQpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cblx0XHRfdGhpcy5pbnB1dFJlZiA9IGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0X3RoaXMuaW5wdXQgPSBlbDtcblx0XHRcdGlmICh0eXBlb2YgX3RoaXMucHJvcHMuaW5wdXRSZWYgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0X3RoaXMucHJvcHMuaW5wdXRSZWYoZWwpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRfdGhpcy5wbGFjZUhvbGRlclNpemVyUmVmID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRfdGhpcy5wbGFjZUhvbGRlclNpemVyID0gZWw7XG5cdFx0fTtcblxuXHRcdF90aGlzLnNpemVyUmVmID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRfdGhpcy5zaXplciA9IGVsO1xuXHRcdH07XG5cblx0XHRfdGhpcy5zdGF0ZSA9IHtcblx0XHRcdGlucHV0V2lkdGg6IHByb3BzLm1pbldpZHRoLFxuXHRcdFx0aW5wdXRJZDogcHJvcHMuaWQgfHwgZ2VuZXJhdGVJZCgpXG5cdFx0fTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoQXV0b3NpemVJbnB1dCwgW3tcblx0XHRrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdFx0dGhpcy5tb3VudGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuY29weUlucHV0U3R5bGVzKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZUlucHV0V2lkdGgoKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuXHRcdFx0dmFyIGlkID0gbmV4dFByb3BzLmlkO1xuXG5cdFx0XHRpZiAoaWQgIT09IHRoaXMucHJvcHMuaWQpIHtcblx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7IGlucHV0SWQ6IGlkIHx8IGdlbmVyYXRlSWQoKSB9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcblx0XHRcdGlmIChwcmV2U3RhdGUuaW5wdXRXaWR0aCAhPT0gdGhpcy5zdGF0ZS5pbnB1dFdpZHRoKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vbkF1dG9zaXplID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5vbkF1dG9zaXplKHRoaXMuc3RhdGUuaW5wdXRXaWR0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlSW5wdXRXaWR0aCgpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0XHR0aGlzLm1vdW50ZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdjb3B5SW5wdXRTdHlsZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb3B5SW5wdXRTdHlsZXMoKSB7XG5cdFx0XHRpZiAoIXRoaXMubW91bnRlZCB8fCAhd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGlucHV0U3R5bGVzID0gdGhpcy5pbnB1dCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmlucHV0KTtcblx0XHRcdGlmICghaW5wdXRTdHlsZXMpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29weVN0eWxlcyhpbnB1dFN0eWxlcywgdGhpcy5zaXplcik7XG5cdFx0XHRpZiAodGhpcy5wbGFjZUhvbGRlclNpemVyKSB7XG5cdFx0XHRcdGNvcHlTdHlsZXMoaW5wdXRTdHlsZXMsIHRoaXMucGxhY2VIb2xkZXJTaXplcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAndXBkYXRlSW5wdXRXaWR0aCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUlucHV0V2lkdGgoKSB7XG5cdFx0XHRpZiAoIXRoaXMubW91bnRlZCB8fCAhdGhpcy5zaXplciB8fCB0eXBlb2YgdGhpcy5zaXplci5zY3JvbGxXaWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5ld0lucHV0V2lkdGggPSB2b2lkIDA7XG5cdFx0XHRpZiAodGhpcy5wcm9wcy5wbGFjZWhvbGRlciAmJiAoIXRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5wcm9wcy52YWx1ZSAmJiB0aGlzLnByb3BzLnBsYWNlaG9sZGVySXNNaW5XaWR0aCkpIHtcblx0XHRcdFx0bmV3SW5wdXRXaWR0aCA9IE1hdGgubWF4KHRoaXMuc2l6ZXIuc2Nyb2xsV2lkdGgsIHRoaXMucGxhY2VIb2xkZXJTaXplci5zY3JvbGxXaWR0aCkgKyAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3SW5wdXRXaWR0aCA9IHRoaXMuc2l6ZXIuc2Nyb2xsV2lkdGggKyAyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGV4dHJhV2lkdGggdG8gdGhlIGRldGVjdGVkIHdpZHRoLiBmb3IgbnVtYmVyIHR5cGVzLCB0aGlzIGRlZmF1bHRzIHRvIDE2IHRvIGFsbG93IGZvciB0aGUgc3RlcHBlciBVSVxuXHRcdFx0dmFyIGV4dHJhV2lkdGggPSB0aGlzLnByb3BzLnR5cGUgPT09ICdudW1iZXInICYmIHRoaXMucHJvcHMuZXh0cmFXaWR0aCA9PT0gdW5kZWZpbmVkID8gMTYgOiBwYXJzZUludCh0aGlzLnByb3BzLmV4dHJhV2lkdGgpIHx8IDA7XG5cdFx0XHRuZXdJbnB1dFdpZHRoICs9IGV4dHJhV2lkdGg7XG5cdFx0XHRpZiAobmV3SW5wdXRXaWR0aCA8IHRoaXMucHJvcHMubWluV2lkdGgpIHtcblx0XHRcdFx0bmV3SW5wdXRXaWR0aCA9IHRoaXMucHJvcHMubWluV2lkdGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmV3SW5wdXRXaWR0aCAhPT0gdGhpcy5zdGF0ZS5pbnB1dFdpZHRoKSB7XG5cdFx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRcdGlucHV0V2lkdGg6IG5ld0lucHV0V2lkdGhcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0SW5wdXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRJbnB1dCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmlucHV0O1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2ZvY3VzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZm9jdXMoKSB7XG5cdFx0XHR0aGlzLmlucHV0LmZvY3VzKCk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYmx1cicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGJsdXIoKSB7XG5cdFx0XHR0aGlzLmlucHV0LmJsdXIoKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdzZWxlY3QnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG5cdFx0XHR0aGlzLmlucHV0LnNlbGVjdCgpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlbmRlclN0eWxlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlclN0eWxlcygpIHtcblx0XHRcdC8vIHRoaXMgbWV0aG9kIGluamVjdHMgc3R5bGVzIHRvIGhpZGUgSUUncyBjbGVhciBpbmRpY2F0b3IsIHdoaWNoIG1lc3Nlc1xuXHRcdFx0Ly8gd2l0aCBpbnB1dCBzaXplIGRldGVjdGlvbi4gdGhlIHN0eWxlc2hlZXQgaXMgb25seSBpbmplY3RlZCB3aGVuIHRoZVxuXHRcdFx0Ly8gYnJvd3NlciBpcyBJRSwgYW5kIGNhbiBhbHNvIGJlIGRpc2FibGVkIGJ5IHRoZSBgaW5qZWN0U3R5bGVzYCBwcm9wLlxuXHRcdFx0dmFyIGluamVjdFN0eWxlcyA9IHRoaXMucHJvcHMuaW5qZWN0U3R5bGVzO1xuXG5cdFx0XHRyZXR1cm4gaXNJRSAmJiBpbmplY3RTdHlsZXMgPyBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnc3R5bGUnLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG5cdFx0XHRcdFx0X19odG1sOiAnaW5wdXQjJyArIHRoaXMuc3RhdGUuaW5wdXRJZCArICc6Oi1tcy1jbGVhciB7ZGlzcGxheTogbm9uZTt9J1xuXHRcdFx0XHR9IH0pIDogbnVsbDtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdFx0XHR2YXIgc2l6ZXJWYWx1ZSA9IFt0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSwgdGhpcy5wcm9wcy52YWx1ZSwgJyddLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSB7XG5cdFx0XHRcdGlmIChwcmV2aW91c1ZhbHVlICE9PSBudWxsICYmIHByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2aW91c1ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjdXJyZW50VmFsdWU7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHdyYXBwZXJTdHlsZSA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLnN0eWxlKTtcblx0XHRcdGlmICghd3JhcHBlclN0eWxlLmRpc3BsYXkpIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG5cblx0XHRcdHZhciBpbnB1dFN0eWxlID0gX2V4dGVuZHMoe1xuXHRcdFx0XHRib3hTaXppbmc6ICdjb250ZW50LWJveCcsXG5cdFx0XHRcdHdpZHRoOiB0aGlzLnN0YXRlLmlucHV0V2lkdGggKyAncHgnXG5cdFx0XHR9LCB0aGlzLnByb3BzLmlucHV0U3R5bGUpO1xuXG5cdFx0XHR2YXIgaW5wdXRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyh0aGlzLnByb3BzLCBbXSk7XG5cblx0XHRcdGNsZWFuSW5wdXRQcm9wcyhpbnB1dFByb3BzKTtcblx0XHRcdGlucHV0UHJvcHMuY2xhc3NOYW1lID0gdGhpcy5wcm9wcy5pbnB1dENsYXNzTmFtZTtcblx0XHRcdGlucHV0UHJvcHMuaWQgPSB0aGlzLnN0YXRlLmlucHV0SWQ7XG5cdFx0XHRpbnB1dFByb3BzLnN0eWxlID0gaW5wdXRTdHlsZTtcblxuXHRcdFx0cmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQnZGl2Jyxcblx0XHRcdFx0eyBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lLCBzdHlsZTogd3JhcHBlclN0eWxlIH0sXG5cdFx0XHRcdHRoaXMucmVuZGVyU3R5bGVzKCksXG5cdFx0XHRcdF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIF9leHRlbmRzKHt9LCBpbnB1dFByb3BzLCB7IHJlZjogdGhpcy5pbnB1dFJlZiB9KSksXG5cdFx0XHRcdF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdCdkaXYnLFxuXHRcdFx0XHRcdHsgcmVmOiB0aGlzLnNpemVyUmVmLCBzdHlsZTogc2l6ZXJTdHlsZSB9LFxuXHRcdFx0XHRcdHNpemVyVmFsdWVcblx0XHRcdFx0KSxcblx0XHRcdFx0dGhpcy5wcm9wcy5wbGFjZWhvbGRlciA/IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdCdkaXYnLFxuXHRcdFx0XHRcdHsgcmVmOiB0aGlzLnBsYWNlSG9sZGVyU2l6ZXJSZWYsIHN0eWxlOiBzaXplclN0eWxlIH0sXG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5wbGFjZWhvbGRlclxuXHRcdFx0XHQpIDogbnVsbFxuXHRcdFx0KTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gQXV0b3NpemVJbnB1dDtcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbkF1dG9zaXplSW5wdXQucHJvcFR5cGVzID0ge1xuXHRjbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCAvLyBjbGFzc05hbWUgZm9yIHRoZSBvdXRlciBlbGVtZW50XG5cdGRlZmF1bHRWYWx1ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5hbnksIC8vIGRlZmF1bHQgZmllbGQgdmFsdWVcblx0ZXh0cmFXaWR0aDogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoWy8vIGFkZGl0aW9uYWwgd2lkdGggZm9yIGlucHV0IGVsZW1lbnRcblx0X3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nXSksXG5cdGlkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZywgLy8gaWQgdG8gdXNlIGZvciB0aGUgaW5wdXQsIGNhbiBiZSBzZXQgZm9yIGNvbnNpc3RlbnQgc25hcHNob3RzXG5cdGluamVjdFN0eWxlczogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLCAvLyBpbmplY3QgdGhlIGN1c3RvbSBzdHlsZXNoZWV0IHRvIGhpZGUgY2xlYXIgVUksIGRlZmF1bHRzIHRvIHRydWVcblx0aW5wdXRDbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCAvLyBjbGFzc05hbWUgZm9yIHRoZSBpbnB1dCBlbGVtZW50XG5cdGlucHV0UmVmOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsIC8vIHJlZiBjYWxsYmFjayBmb3IgdGhlIGlucHV0IGVsZW1lbnRcblx0aW5wdXRTdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsIC8vIGNzcyBzdHlsZXMgZm9yIHRoZSBpbnB1dCBlbGVtZW50XG5cdG1pbldpZHRoOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbLy8gbWluaW11bSB3aWR0aCBmb3IgaW5wdXQgZWxlbWVudFxuXHRfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmddKSxcblx0b25BdXRvc2l6ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLCAvLyBvbkF1dG9zaXplIGhhbmRsZXI6IGZ1bmN0aW9uKG5ld1dpZHRoKSB7fVxuXHRvbkNoYW5nZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLCAvLyBvbkNoYW5nZSBoYW5kbGVyOiBmdW5jdGlvbihldmVudCkge31cblx0cGxhY2Vob2xkZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCAvLyBwbGFjZWhvbGRlciB0ZXh0XG5cdHBsYWNlaG9sZGVySXNNaW5XaWR0aDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLCAvLyBkb24ndCBjb2xsYXBzZSBzaXplIHRvIGxlc3MgdGhhbiB0aGUgcGxhY2Vob2xkZXJcblx0c3R5bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LCAvLyBjc3Mgc3R5bGVzIGZvciB0aGUgb3V0ZXIgZWxlbWVudFxuXHR2YWx1ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5hbnkgLy8gZmllbGQgdmFsdWVcbn07XG5BdXRvc2l6ZUlucHV0LmRlZmF1bHRQcm9wcyA9IHtcblx0bWluV2lkdGg6IDEsXG5cdGluamVjdFN0eWxlczogdHJ1ZVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQXV0b3NpemVJbnB1dDsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtZW1vaXplT25lIGZyb20gJ21lbW9pemUtb25lJztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL2NvcmUnO1xuaW1wb3J0IHsgZmluZERPTU5vZGUgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgaSBhcyBpc1RvdWNoQ2FwYWJsZSwgZCBhcyBpc01vYmlsZURldmljZSwgZSBhcyBjbGVhblZhbHVlLCBmIGFzIHNjcm9sbEludG9WaWV3LCBoIGFzIGNsYXNzTmFtZXMsIG4gYXMgbm9vcCwgaiBhcyBpc0RvY3VtZW50RWxlbWVudCB9IGZyb20gJy4vdXRpbHMtMDZiMGQ1YTQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgYyBhcyBjbGVhckluZGljYXRvckNTUywgYSBhcyBjb250YWluZXJDU1MsIGIgYXMgY3NzLCBkIGFzIGRyb3Bkb3duSW5kaWNhdG9yQ1NTLCBnIGFzIGdyb3VwQ1NTLCBlIGFzIGdyb3VwSGVhZGluZ0NTUywgaSBhcyBpbmRpY2F0b3JzQ29udGFpbmVyQ1NTLCBmIGFzIGluZGljYXRvclNlcGFyYXRvckNTUywgaCBhcyBpbnB1dENTUywgbCBhcyBsb2FkaW5nSW5kaWNhdG9yQ1NTLCBqIGFzIGxvYWRpbmdNZXNzYWdlQ1NTLCBtIGFzIG1lbnVDU1MsIGsgYXMgbWVudUxpc3RDU1MsIG4gYXMgbWVudVBvcnRhbENTUywgbyBhcyBtdWx0aVZhbHVlQ1NTLCBwIGFzIG11bHRpVmFsdWVMYWJlbENTUywgcSBhcyBtdWx0aVZhbHVlUmVtb3ZlQ1NTLCByIGFzIG5vT3B0aW9uc01lc3NhZ2VDU1MsIHMgYXMgb3B0aW9uQ1NTLCB0IGFzIHBsYWNlaG9sZGVyQ1NTLCB1IGFzIGNzcyQxLCB2IGFzIHZhbHVlQ29udGFpbmVyQ1NTLCBNIGFzIE1lbnVQbGFjZXIsIHcgYXMgZGVmYXVsdENvbXBvbmVudHMsIHggYXMgZXhwb3J0ZWRFcXVhbCB9IGZyb20gJy4vaW5kZXgtNDMyMmMwZWQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IF9jc3MgZnJvbSAnQGVtb3Rpb24vY3NzJztcblxudmFyIGRpYWNyaXRpY3MgPSBbe1xuICBiYXNlOiAnQScsXG4gIGxldHRlcnM6IC9bXFx1MDA0MVxcdTI0QjZcXHVGRjIxXFx1MDBDMFxcdTAwQzFcXHUwMEMyXFx1MUVBNlxcdTFFQTRcXHUxRUFBXFx1MUVBOFxcdTAwQzNcXHUwMTAwXFx1MDEwMlxcdTFFQjBcXHUxRUFFXFx1MUVCNFxcdTFFQjJcXHUwMjI2XFx1MDFFMFxcdTAwQzRcXHUwMURFXFx1MUVBMlxcdTAwQzVcXHUwMUZBXFx1MDFDRFxcdTAyMDBcXHUwMjAyXFx1MUVBMFxcdTFFQUNcXHUxRUI2XFx1MUUwMFxcdTAxMDRcXHUwMjNBXFx1MkM2Rl0vZ1xufSwge1xuICBiYXNlOiAnQUEnLFxuICBsZXR0ZXJzOiAvW1xcdUE3MzJdL2dcbn0sIHtcbiAgYmFzZTogJ0FFJyxcbiAgbGV0dGVyczogL1tcXHUwMEM2XFx1MDFGQ1xcdTAxRTJdL2dcbn0sIHtcbiAgYmFzZTogJ0FPJyxcbiAgbGV0dGVyczogL1tcXHVBNzM0XS9nXG59LCB7XG4gIGJhc2U6ICdBVScsXG4gIGxldHRlcnM6IC9bXFx1QTczNl0vZ1xufSwge1xuICBiYXNlOiAnQVYnLFxuICBsZXR0ZXJzOiAvW1xcdUE3MzhcXHVBNzNBXS9nXG59LCB7XG4gIGJhc2U6ICdBWScsXG4gIGxldHRlcnM6IC9bXFx1QTczQ10vZ1xufSwge1xuICBiYXNlOiAnQicsXG4gIGxldHRlcnM6IC9bXFx1MDA0MlxcdTI0QjdcXHVGRjIyXFx1MUUwMlxcdTFFMDRcXHUxRTA2XFx1MDI0M1xcdTAxODJcXHUwMTgxXS9nXG59LCB7XG4gIGJhc2U6ICdDJyxcbiAgbGV0dGVyczogL1tcXHUwMDQzXFx1MjRCOFxcdUZGMjNcXHUwMTA2XFx1MDEwOFxcdTAxMEFcXHUwMTBDXFx1MDBDN1xcdTFFMDhcXHUwMTg3XFx1MDIzQlxcdUE3M0VdL2dcbn0sIHtcbiAgYmFzZTogJ0QnLFxuICBsZXR0ZXJzOiAvW1xcdTAwNDRcXHUyNEI5XFx1RkYyNFxcdTFFMEFcXHUwMTBFXFx1MUUwQ1xcdTFFMTBcXHUxRTEyXFx1MUUwRVxcdTAxMTBcXHUwMThCXFx1MDE4QVxcdTAxODlcXHVBNzc5XS9nXG59LCB7XG4gIGJhc2U6ICdEWicsXG4gIGxldHRlcnM6IC9bXFx1MDFGMVxcdTAxQzRdL2dcbn0sIHtcbiAgYmFzZTogJ0R6JyxcbiAgbGV0dGVyczogL1tcXHUwMUYyXFx1MDFDNV0vZ1xufSwge1xuICBiYXNlOiAnRScsXG4gIGxldHRlcnM6IC9bXFx1MDA0NVxcdTI0QkFcXHVGRjI1XFx1MDBDOFxcdTAwQzlcXHUwMENBXFx1MUVDMFxcdTFFQkVcXHUxRUM0XFx1MUVDMlxcdTFFQkNcXHUwMTEyXFx1MUUxNFxcdTFFMTZcXHUwMTE0XFx1MDExNlxcdTAwQ0JcXHUxRUJBXFx1MDExQVxcdTAyMDRcXHUwMjA2XFx1MUVCOFxcdTFFQzZcXHUwMjI4XFx1MUUxQ1xcdTAxMThcXHUxRTE4XFx1MUUxQVxcdTAxOTBcXHUwMThFXS9nXG59LCB7XG4gIGJhc2U6ICdGJyxcbiAgbGV0dGVyczogL1tcXHUwMDQ2XFx1MjRCQlxcdUZGMjZcXHUxRTFFXFx1MDE5MVxcdUE3N0JdL2dcbn0sIHtcbiAgYmFzZTogJ0cnLFxuICBsZXR0ZXJzOiAvW1xcdTAwNDdcXHUyNEJDXFx1RkYyN1xcdTAxRjRcXHUwMTFDXFx1MUUyMFxcdTAxMUVcXHUwMTIwXFx1MDFFNlxcdTAxMjJcXHUwMUU0XFx1MDE5M1xcdUE3QTBcXHVBNzdEXFx1QTc3RV0vZ1xufSwge1xuICBiYXNlOiAnSCcsXG4gIGxldHRlcnM6IC9bXFx1MDA0OFxcdTI0QkRcXHVGRjI4XFx1MDEyNFxcdTFFMjJcXHUxRTI2XFx1MDIxRVxcdTFFMjRcXHUxRTI4XFx1MUUyQVxcdTAxMjZcXHUyQzY3XFx1MkM3NVxcdUE3OERdL2dcbn0sIHtcbiAgYmFzZTogJ0knLFxuICBsZXR0ZXJzOiAvW1xcdTAwNDlcXHUyNEJFXFx1RkYyOVxcdTAwQ0NcXHUwMENEXFx1MDBDRVxcdTAxMjhcXHUwMTJBXFx1MDEyQ1xcdTAxMzBcXHUwMENGXFx1MUUyRVxcdTFFQzhcXHUwMUNGXFx1MDIwOFxcdTAyMEFcXHUxRUNBXFx1MDEyRVxcdTFFMkNcXHUwMTk3XS9nXG59LCB7XG4gIGJhc2U6ICdKJyxcbiAgbGV0dGVyczogL1tcXHUwMDRBXFx1MjRCRlxcdUZGMkFcXHUwMTM0XFx1MDI0OF0vZ1xufSwge1xuICBiYXNlOiAnSycsXG4gIGxldHRlcnM6IC9bXFx1MDA0QlxcdTI0QzBcXHVGRjJCXFx1MUUzMFxcdTAxRThcXHUxRTMyXFx1MDEzNlxcdTFFMzRcXHUwMTk4XFx1MkM2OVxcdUE3NDBcXHVBNzQyXFx1QTc0NFxcdUE3QTJdL2dcbn0sIHtcbiAgYmFzZTogJ0wnLFxuICBsZXR0ZXJzOiAvW1xcdTAwNENcXHUyNEMxXFx1RkYyQ1xcdTAxM0ZcXHUwMTM5XFx1MDEzRFxcdTFFMzZcXHUxRTM4XFx1MDEzQlxcdTFFM0NcXHUxRTNBXFx1MDE0MVxcdTAyM0RcXHUyQzYyXFx1MkM2MFxcdUE3NDhcXHVBNzQ2XFx1QTc4MF0vZ1xufSwge1xuICBiYXNlOiAnTEonLFxuICBsZXR0ZXJzOiAvW1xcdTAxQzddL2dcbn0sIHtcbiAgYmFzZTogJ0xqJyxcbiAgbGV0dGVyczogL1tcXHUwMUM4XS9nXG59LCB7XG4gIGJhc2U6ICdNJyxcbiAgbGV0dGVyczogL1tcXHUwMDREXFx1MjRDMlxcdUZGMkRcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUyQzZFXFx1MDE5Q10vZ1xufSwge1xuICBiYXNlOiAnTicsXG4gIGxldHRlcnM6IC9bXFx1MDA0RVxcdTI0QzNcXHVGRjJFXFx1MDFGOFxcdTAxNDNcXHUwMEQxXFx1MUU0NFxcdTAxNDdcXHUxRTQ2XFx1MDE0NVxcdTFFNEFcXHUxRTQ4XFx1MDIyMFxcdTAxOURcXHVBNzkwXFx1QTdBNF0vZ1xufSwge1xuICBiYXNlOiAnTkonLFxuICBsZXR0ZXJzOiAvW1xcdTAxQ0FdL2dcbn0sIHtcbiAgYmFzZTogJ05qJyxcbiAgbGV0dGVyczogL1tcXHUwMUNCXS9nXG59LCB7XG4gIGJhc2U6ICdPJyxcbiAgbGV0dGVyczogL1tcXHUwMDRGXFx1MjRDNFxcdUZGMkZcXHUwMEQyXFx1MDBEM1xcdTAwRDRcXHUxRUQyXFx1MUVEMFxcdTFFRDZcXHUxRUQ0XFx1MDBENVxcdTFFNENcXHUwMjJDXFx1MUU0RVxcdTAxNENcXHUxRTUwXFx1MUU1MlxcdTAxNEVcXHUwMjJFXFx1MDIzMFxcdTAwRDZcXHUwMjJBXFx1MUVDRVxcdTAxNTBcXHUwMUQxXFx1MDIwQ1xcdTAyMEVcXHUwMUEwXFx1MUVEQ1xcdTFFREFcXHUxRUUwXFx1MUVERVxcdTFFRTJcXHUxRUNDXFx1MUVEOFxcdTAxRUFcXHUwMUVDXFx1MDBEOFxcdTAxRkVcXHUwMTg2XFx1MDE5RlxcdUE3NEFcXHVBNzRDXS9nXG59LCB7XG4gIGJhc2U6ICdPSScsXG4gIGxldHRlcnM6IC9bXFx1MDFBMl0vZ1xufSwge1xuICBiYXNlOiAnT08nLFxuICBsZXR0ZXJzOiAvW1xcdUE3NEVdL2dcbn0sIHtcbiAgYmFzZTogJ09VJyxcbiAgbGV0dGVyczogL1tcXHUwMjIyXS9nXG59LCB7XG4gIGJhc2U6ICdQJyxcbiAgbGV0dGVyczogL1tcXHUwMDUwXFx1MjRDNVxcdUZGMzBcXHUxRTU0XFx1MUU1NlxcdTAxQTRcXHUyQzYzXFx1QTc1MFxcdUE3NTJcXHVBNzU0XS9nXG59LCB7XG4gIGJhc2U6ICdRJyxcbiAgbGV0dGVyczogL1tcXHUwMDUxXFx1MjRDNlxcdUZGMzFcXHVBNzU2XFx1QTc1OFxcdTAyNEFdL2dcbn0sIHtcbiAgYmFzZTogJ1InLFxuICBsZXR0ZXJzOiAvW1xcdTAwNTJcXHUyNEM3XFx1RkYzMlxcdTAxNTRcXHUxRTU4XFx1MDE1OFxcdTAyMTBcXHUwMjEyXFx1MUU1QVxcdTFFNUNcXHUwMTU2XFx1MUU1RVxcdTAyNENcXHUyQzY0XFx1QTc1QVxcdUE3QTZcXHVBNzgyXS9nXG59LCB7XG4gIGJhc2U6ICdTJyxcbiAgbGV0dGVyczogL1tcXHUwMDUzXFx1MjRDOFxcdUZGMzNcXHUxRTlFXFx1MDE1QVxcdTFFNjRcXHUwMTVDXFx1MUU2MFxcdTAxNjBcXHUxRTY2XFx1MUU2MlxcdTFFNjhcXHUwMjE4XFx1MDE1RVxcdTJDN0VcXHVBN0E4XFx1QTc4NF0vZ1xufSwge1xuICBiYXNlOiAnVCcsXG4gIGxldHRlcnM6IC9bXFx1MDA1NFxcdTI0QzlcXHVGRjM0XFx1MUU2QVxcdTAxNjRcXHUxRTZDXFx1MDIxQVxcdTAxNjJcXHUxRTcwXFx1MUU2RVxcdTAxNjZcXHUwMUFDXFx1MDFBRVxcdTAyM0VcXHVBNzg2XS9nXG59LCB7XG4gIGJhc2U6ICdUWicsXG4gIGxldHRlcnM6IC9bXFx1QTcyOF0vZ1xufSwge1xuICBiYXNlOiAnVScsXG4gIGxldHRlcnM6IC9bXFx1MDA1NVxcdTI0Q0FcXHVGRjM1XFx1MDBEOVxcdTAwREFcXHUwMERCXFx1MDE2OFxcdTFFNzhcXHUwMTZBXFx1MUU3QVxcdTAxNkNcXHUwMERDXFx1MDFEQlxcdTAxRDdcXHUwMUQ1XFx1MDFEOVxcdTFFRTZcXHUwMTZFXFx1MDE3MFxcdTAxRDNcXHUwMjE0XFx1MDIxNlxcdTAxQUZcXHUxRUVBXFx1MUVFOFxcdTFFRUVcXHUxRUVDXFx1MUVGMFxcdTFFRTRcXHUxRTcyXFx1MDE3MlxcdTFFNzZcXHUxRTc0XFx1MDI0NF0vZ1xufSwge1xuICBiYXNlOiAnVicsXG4gIGxldHRlcnM6IC9bXFx1MDA1NlxcdTI0Q0JcXHVGRjM2XFx1MUU3Q1xcdTFFN0VcXHUwMUIyXFx1QTc1RVxcdTAyNDVdL2dcbn0sIHtcbiAgYmFzZTogJ1ZZJyxcbiAgbGV0dGVyczogL1tcXHVBNzYwXS9nXG59LCB7XG4gIGJhc2U6ICdXJyxcbiAgbGV0dGVyczogL1tcXHUwMDU3XFx1MjRDQ1xcdUZGMzdcXHUxRTgwXFx1MUU4MlxcdTAxNzRcXHUxRTg2XFx1MUU4NFxcdTFFODhcXHUyQzcyXS9nXG59LCB7XG4gIGJhc2U6ICdYJyxcbiAgbGV0dGVyczogL1tcXHUwMDU4XFx1MjRDRFxcdUZGMzhcXHUxRThBXFx1MUU4Q10vZ1xufSwge1xuICBiYXNlOiAnWScsXG4gIGxldHRlcnM6IC9bXFx1MDA1OVxcdTI0Q0VcXHVGRjM5XFx1MUVGMlxcdTAwRERcXHUwMTc2XFx1MUVGOFxcdTAyMzJcXHUxRThFXFx1MDE3OFxcdTFFRjZcXHUxRUY0XFx1MDFCM1xcdTAyNEVcXHUxRUZFXS9nXG59LCB7XG4gIGJhc2U6ICdaJyxcbiAgbGV0dGVyczogL1tcXHUwMDVBXFx1MjRDRlxcdUZGM0FcXHUwMTc5XFx1MUU5MFxcdTAxN0JcXHUwMTdEXFx1MUU5MlxcdTFFOTRcXHUwMUI1XFx1MDIyNFxcdTJDN0ZcXHUyQzZCXFx1QTc2Ml0vZ1xufSwge1xuICBiYXNlOiAnYScsXG4gIGxldHRlcnM6IC9bXFx1MDA2MVxcdTI0RDBcXHVGRjQxXFx1MUU5QVxcdTAwRTBcXHUwMEUxXFx1MDBFMlxcdTFFQTdcXHUxRUE1XFx1MUVBQlxcdTFFQTlcXHUwMEUzXFx1MDEwMVxcdTAxMDNcXHUxRUIxXFx1MUVBRlxcdTFFQjVcXHUxRUIzXFx1MDIyN1xcdTAxRTFcXHUwMEU0XFx1MDFERlxcdTFFQTNcXHUwMEU1XFx1MDFGQlxcdTAxQ0VcXHUwMjAxXFx1MDIwM1xcdTFFQTFcXHUxRUFEXFx1MUVCN1xcdTFFMDFcXHUwMTA1XFx1MkM2NVxcdTAyNTBdL2dcbn0sIHtcbiAgYmFzZTogJ2FhJyxcbiAgbGV0dGVyczogL1tcXHVBNzMzXS9nXG59LCB7XG4gIGJhc2U6ICdhZScsXG4gIGxldHRlcnM6IC9bXFx1MDBFNlxcdTAxRkRcXHUwMUUzXS9nXG59LCB7XG4gIGJhc2U6ICdhbycsXG4gIGxldHRlcnM6IC9bXFx1QTczNV0vZ1xufSwge1xuICBiYXNlOiAnYXUnLFxuICBsZXR0ZXJzOiAvW1xcdUE3MzddL2dcbn0sIHtcbiAgYmFzZTogJ2F2JyxcbiAgbGV0dGVyczogL1tcXHVBNzM5XFx1QTczQl0vZ1xufSwge1xuICBiYXNlOiAnYXknLFxuICBsZXR0ZXJzOiAvW1xcdUE3M0RdL2dcbn0sIHtcbiAgYmFzZTogJ2InLFxuICBsZXR0ZXJzOiAvW1xcdTAwNjJcXHUyNEQxXFx1RkY0MlxcdTFFMDNcXHUxRTA1XFx1MUUwN1xcdTAxODBcXHUwMTgzXFx1MDI1M10vZ1xufSwge1xuICBiYXNlOiAnYycsXG4gIGxldHRlcnM6IC9bXFx1MDA2M1xcdTI0RDJcXHVGRjQzXFx1MDEwN1xcdTAxMDlcXHUwMTBCXFx1MDEwRFxcdTAwRTdcXHUxRTA5XFx1MDE4OFxcdTAyM0NcXHVBNzNGXFx1MjE4NF0vZ1xufSwge1xuICBiYXNlOiAnZCcsXG4gIGxldHRlcnM6IC9bXFx1MDA2NFxcdTI0RDNcXHVGRjQ0XFx1MUUwQlxcdTAxMEZcXHUxRTBEXFx1MUUxMVxcdTFFMTNcXHUxRTBGXFx1MDExMVxcdTAxOENcXHUwMjU2XFx1MDI1N1xcdUE3N0FdL2dcbn0sIHtcbiAgYmFzZTogJ2R6JyxcbiAgbGV0dGVyczogL1tcXHUwMUYzXFx1MDFDNl0vZ1xufSwge1xuICBiYXNlOiAnZScsXG4gIGxldHRlcnM6IC9bXFx1MDA2NVxcdTI0RDRcXHVGRjQ1XFx1MDBFOFxcdTAwRTlcXHUwMEVBXFx1MUVDMVxcdTFFQkZcXHUxRUM1XFx1MUVDM1xcdTFFQkRcXHUwMTEzXFx1MUUxNVxcdTFFMTdcXHUwMTE1XFx1MDExN1xcdTAwRUJcXHUxRUJCXFx1MDExQlxcdTAyMDVcXHUwMjA3XFx1MUVCOVxcdTFFQzdcXHUwMjI5XFx1MUUxRFxcdTAxMTlcXHUxRTE5XFx1MUUxQlxcdTAyNDdcXHUwMjVCXFx1MDFERF0vZ1xufSwge1xuICBiYXNlOiAnZicsXG4gIGxldHRlcnM6IC9bXFx1MDA2NlxcdTI0RDVcXHVGRjQ2XFx1MUUxRlxcdTAxOTJcXHVBNzdDXS9nXG59LCB7XG4gIGJhc2U6ICdnJyxcbiAgbGV0dGVyczogL1tcXHUwMDY3XFx1MjRENlxcdUZGNDdcXHUwMUY1XFx1MDExRFxcdTFFMjFcXHUwMTFGXFx1MDEyMVxcdTAxRTdcXHUwMTIzXFx1MDFFNVxcdTAyNjBcXHVBN0ExXFx1MUQ3OVxcdUE3N0ZdL2dcbn0sIHtcbiAgYmFzZTogJ2gnLFxuICBsZXR0ZXJzOiAvW1xcdTAwNjhcXHUyNEQ3XFx1RkY0OFxcdTAxMjVcXHUxRTIzXFx1MUUyN1xcdTAyMUZcXHUxRTI1XFx1MUUyOVxcdTFFMkJcXHUxRTk2XFx1MDEyN1xcdTJDNjhcXHUyQzc2XFx1MDI2NV0vZ1xufSwge1xuICBiYXNlOiAnaHYnLFxuICBsZXR0ZXJzOiAvW1xcdTAxOTVdL2dcbn0sIHtcbiAgYmFzZTogJ2knLFxuICBsZXR0ZXJzOiAvW1xcdTAwNjlcXHUyNEQ4XFx1RkY0OVxcdTAwRUNcXHUwMEVEXFx1MDBFRVxcdTAxMjlcXHUwMTJCXFx1MDEyRFxcdTAwRUZcXHUxRTJGXFx1MUVDOVxcdTAxRDBcXHUwMjA5XFx1MDIwQlxcdTFFQ0JcXHUwMTJGXFx1MUUyRFxcdTAyNjhcXHUwMTMxXS9nXG59LCB7XG4gIGJhc2U6ICdqJyxcbiAgbGV0dGVyczogL1tcXHUwMDZBXFx1MjREOVxcdUZGNEFcXHUwMTM1XFx1MDFGMFxcdTAyNDldL2dcbn0sIHtcbiAgYmFzZTogJ2snLFxuICBsZXR0ZXJzOiAvW1xcdTAwNkJcXHUyNERBXFx1RkY0QlxcdTFFMzFcXHUwMUU5XFx1MUUzM1xcdTAxMzdcXHUxRTM1XFx1MDE5OVxcdTJDNkFcXHVBNzQxXFx1QTc0M1xcdUE3NDVcXHVBN0EzXS9nXG59LCB7XG4gIGJhc2U6ICdsJyxcbiAgbGV0dGVyczogL1tcXHUwMDZDXFx1MjREQlxcdUZGNENcXHUwMTQwXFx1MDEzQVxcdTAxM0VcXHUxRTM3XFx1MUUzOVxcdTAxM0NcXHUxRTNEXFx1MUUzQlxcdTAxN0ZcXHUwMTQyXFx1MDE5QVxcdTAyNkJcXHUyQzYxXFx1QTc0OVxcdUE3ODFcXHVBNzQ3XS9nXG59LCB7XG4gIGJhc2U6ICdsaicsXG4gIGxldHRlcnM6IC9bXFx1MDFDOV0vZ1xufSwge1xuICBiYXNlOiAnbScsXG4gIGxldHRlcnM6IC9bXFx1MDA2RFxcdTI0RENcXHVGRjREXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MDI3MVxcdTAyNkZdL2dcbn0sIHtcbiAgYmFzZTogJ24nLFxuICBsZXR0ZXJzOiAvW1xcdTAwNkVcXHUyNEREXFx1RkY0RVxcdTAxRjlcXHUwMTQ0XFx1MDBGMVxcdTFFNDVcXHUwMTQ4XFx1MUU0N1xcdTAxNDZcXHUxRTRCXFx1MUU0OVxcdTAxOUVcXHUwMjcyXFx1MDE0OVxcdUE3OTFcXHVBN0E1XS9nXG59LCB7XG4gIGJhc2U6ICduaicsXG4gIGxldHRlcnM6IC9bXFx1MDFDQ10vZ1xufSwge1xuICBiYXNlOiAnbycsXG4gIGxldHRlcnM6IC9bXFx1MDA2RlxcdTI0REVcXHVGRjRGXFx1MDBGMlxcdTAwRjNcXHUwMEY0XFx1MUVEM1xcdTFFRDFcXHUxRUQ3XFx1MUVENVxcdTAwRjVcXHUxRTREXFx1MDIyRFxcdTFFNEZcXHUwMTREXFx1MUU1MVxcdTFFNTNcXHUwMTRGXFx1MDIyRlxcdTAyMzFcXHUwMEY2XFx1MDIyQlxcdTFFQ0ZcXHUwMTUxXFx1MDFEMlxcdTAyMERcXHUwMjBGXFx1MDFBMVxcdTFFRERcXHUxRURCXFx1MUVFMVxcdTFFREZcXHUxRUUzXFx1MUVDRFxcdTFFRDlcXHUwMUVCXFx1MDFFRFxcdTAwRjhcXHUwMUZGXFx1MDI1NFxcdUE3NEJcXHVBNzREXFx1MDI3NV0vZ1xufSwge1xuICBiYXNlOiAnb2knLFxuICBsZXR0ZXJzOiAvW1xcdTAxQTNdL2dcbn0sIHtcbiAgYmFzZTogJ291JyxcbiAgbGV0dGVyczogL1tcXHUwMjIzXS9nXG59LCB7XG4gIGJhc2U6ICdvbycsXG4gIGxldHRlcnM6IC9bXFx1QTc0Rl0vZ1xufSwge1xuICBiYXNlOiAncCcsXG4gIGxldHRlcnM6IC9bXFx1MDA3MFxcdTI0REZcXHVGRjUwXFx1MUU1NVxcdTFFNTdcXHUwMUE1XFx1MUQ3RFxcdUE3NTFcXHVBNzUzXFx1QTc1NV0vZ1xufSwge1xuICBiYXNlOiAncScsXG4gIGxldHRlcnM6IC9bXFx1MDA3MVxcdTI0RTBcXHVGRjUxXFx1MDI0QlxcdUE3NTdcXHVBNzU5XS9nXG59LCB7XG4gIGJhc2U6ICdyJyxcbiAgbGV0dGVyczogL1tcXHUwMDcyXFx1MjRFMVxcdUZGNTJcXHUwMTU1XFx1MUU1OVxcdTAxNTlcXHUwMjExXFx1MDIxM1xcdTFFNUJcXHUxRTVEXFx1MDE1N1xcdTFFNUZcXHUwMjREXFx1MDI3RFxcdUE3NUJcXHVBN0E3XFx1QTc4M10vZ1xufSwge1xuICBiYXNlOiAncycsXG4gIGxldHRlcnM6IC9bXFx1MDA3M1xcdTI0RTJcXHVGRjUzXFx1MDBERlxcdTAxNUJcXHUxRTY1XFx1MDE1RFxcdTFFNjFcXHUwMTYxXFx1MUU2N1xcdTFFNjNcXHUxRTY5XFx1MDIxOVxcdTAxNUZcXHUwMjNGXFx1QTdBOVxcdUE3ODVcXHUxRTlCXS9nXG59LCB7XG4gIGJhc2U6ICd0JyxcbiAgbGV0dGVyczogL1tcXHUwMDc0XFx1MjRFM1xcdUZGNTRcXHUxRTZCXFx1MUU5N1xcdTAxNjVcXHUxRTZEXFx1MDIxQlxcdTAxNjNcXHUxRTcxXFx1MUU2RlxcdTAxNjdcXHUwMUFEXFx1MDI4OFxcdTJDNjZcXHVBNzg3XS9nXG59LCB7XG4gIGJhc2U6ICd0eicsXG4gIGxldHRlcnM6IC9bXFx1QTcyOV0vZ1xufSwge1xuICBiYXNlOiAndScsXG4gIGxldHRlcnM6IC9bXFx1MDA3NVxcdTI0RTRcXHVGRjU1XFx1MDBGOVxcdTAwRkFcXHUwMEZCXFx1MDE2OVxcdTFFNzlcXHUwMTZCXFx1MUU3QlxcdTAxNkRcXHUwMEZDXFx1MDFEQ1xcdTAxRDhcXHUwMUQ2XFx1MDFEQVxcdTFFRTdcXHUwMTZGXFx1MDE3MVxcdTAxRDRcXHUwMjE1XFx1MDIxN1xcdTAxQjBcXHUxRUVCXFx1MUVFOVxcdTFFRUZcXHUxRUVEXFx1MUVGMVxcdTFFRTVcXHUxRTczXFx1MDE3M1xcdTFFNzdcXHUxRTc1XFx1MDI4OV0vZ1xufSwge1xuICBiYXNlOiAndicsXG4gIGxldHRlcnM6IC9bXFx1MDA3NlxcdTI0RTVcXHVGRjU2XFx1MUU3RFxcdTFFN0ZcXHUwMjhCXFx1QTc1RlxcdTAyOENdL2dcbn0sIHtcbiAgYmFzZTogJ3Z5JyxcbiAgbGV0dGVyczogL1tcXHVBNzYxXS9nXG59LCB7XG4gIGJhc2U6ICd3JyxcbiAgbGV0dGVyczogL1tcXHUwMDc3XFx1MjRFNlxcdUZGNTdcXHUxRTgxXFx1MUU4M1xcdTAxNzVcXHUxRTg3XFx1MUU4NVxcdTFFOThcXHUxRTg5XFx1MkM3M10vZ1xufSwge1xuICBiYXNlOiAneCcsXG4gIGxldHRlcnM6IC9bXFx1MDA3OFxcdTI0RTdcXHVGRjU4XFx1MUU4QlxcdTFFOERdL2dcbn0sIHtcbiAgYmFzZTogJ3knLFxuICBsZXR0ZXJzOiAvW1xcdTAwNzlcXHUyNEU4XFx1RkY1OVxcdTFFRjNcXHUwMEZEXFx1MDE3N1xcdTFFRjlcXHUwMjMzXFx1MUU4RlxcdTAwRkZcXHUxRUY3XFx1MUU5OVxcdTFFRjVcXHUwMUI0XFx1MDI0RlxcdTFFRkZdL2dcbn0sIHtcbiAgYmFzZTogJ3onLFxuICBsZXR0ZXJzOiAvW1xcdTAwN0FcXHUyNEU5XFx1RkY1QVxcdTAxN0FcXHUxRTkxXFx1MDE3Q1xcdTAxN0VcXHUxRTkzXFx1MUU5NVxcdTAxQjZcXHUwMjI1XFx1MDI0MFxcdTJDNkNcXHVBNzYzXS9nXG59XTtcbnZhciBzdHJpcERpYWNyaXRpY3MgPSBmdW5jdGlvbiBzdHJpcERpYWNyaXRpY3Moc3RyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlhY3JpdGljcy5sZW5ndGg7IGkrKykge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKGRpYWNyaXRpY3NbaV0ubGV0dGVycywgZGlhY3JpdGljc1tpXS5iYXNlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG52YXIgdHJpbVN0cmluZyA9IGZ1bmN0aW9uIHRyaW1TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufTtcblxudmFyIGRlZmF1bHRTdHJpbmdpZnkgPSBmdW5jdGlvbiBkZWZhdWx0U3RyaW5naWZ5KG9wdGlvbikge1xuICByZXR1cm4gb3B0aW9uLmxhYmVsICsgXCIgXCIgKyBvcHRpb24udmFsdWU7XG59O1xuXG52YXIgY3JlYXRlRmlsdGVyID0gZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGNvbmZpZykge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbiwgcmF3SW5wdXQpIHtcbiAgICB2YXIgX2lnbm9yZUNhc2UkaWdub3JlQWNjID0gX2V4dGVuZHMoe1xuICAgICAgaWdub3JlQ2FzZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUFjY2VudHM6IHRydWUsXG4gICAgICBzdHJpbmdpZnk6IGRlZmF1bHRTdHJpbmdpZnksXG4gICAgICB0cmltOiB0cnVlLFxuICAgICAgbWF0Y2hGcm9tOiAnYW55J1xuICAgIH0sIGNvbmZpZyksXG4gICAgICAgIGlnbm9yZUNhc2UgPSBfaWdub3JlQ2FzZSRpZ25vcmVBY2MuaWdub3JlQ2FzZSxcbiAgICAgICAgaWdub3JlQWNjZW50cyA9IF9pZ25vcmVDYXNlJGlnbm9yZUFjYy5pZ25vcmVBY2NlbnRzLFxuICAgICAgICBzdHJpbmdpZnkgPSBfaWdub3JlQ2FzZSRpZ25vcmVBY2Muc3RyaW5naWZ5LFxuICAgICAgICB0cmltID0gX2lnbm9yZUNhc2UkaWdub3JlQWNjLnRyaW0sXG4gICAgICAgIG1hdGNoRnJvbSA9IF9pZ25vcmVDYXNlJGlnbm9yZUFjYy5tYXRjaEZyb207XG5cbiAgICB2YXIgaW5wdXQgPSB0cmltID8gdHJpbVN0cmluZyhyYXdJbnB1dCkgOiByYXdJbnB1dDtcbiAgICB2YXIgY2FuZGlkYXRlID0gdHJpbSA/IHRyaW1TdHJpbmcoc3RyaW5naWZ5KG9wdGlvbikpIDogc3RyaW5naWZ5KG9wdGlvbik7XG5cbiAgICBpZiAoaWdub3JlQ2FzZSkge1xuICAgICAgaW5wdXQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGlnbm9yZUFjY2VudHMpIHtcbiAgICAgIGlucHV0ID0gc3RyaXBEaWFjcml0aWNzKGlucHV0KTtcbiAgICAgIGNhbmRpZGF0ZSA9IHN0cmlwRGlhY3JpdGljcyhjYW5kaWRhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaEZyb20gPT09ICdzdGFydCcgPyBjYW5kaWRhdGUuc3Vic3RyKDAsIGlucHV0Lmxlbmd0aCkgPT09IGlucHV0IDogY2FuZGlkYXRlLmluZGV4T2YoaW5wdXQpID4gLTE7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcyQxKCkgeyBfZXh0ZW5kcyQxID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG52YXIgX3JlZiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgbmFtZTogXCIxbGFhbzIxLWExMXlUZXh0XCIsXG4gIHN0eWxlczogXCJsYWJlbDphMTF5VGV4dDt6LWluZGV4Ojk5OTk7Ym9yZGVyOjA7Y2xpcDpyZWN0KDFweCwgMXB4LCAxcHgsIDFweCk7aGVpZ2h0OjFweDt3aWR0aDoxcHg7cG9zaXRpb246YWJzb2x1dGU7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MDt3aGl0ZS1zcGFjZTpub3dyYXA7XCJcbn0gOiB7XG4gIG5hbWU6IFwiMWxhYW8yMS1hMTF5VGV4dFwiLFxuICBzdHlsZXM6IFwibGFiZWw6YTExeVRleHQ7ei1pbmRleDo5OTk5O2JvcmRlcjowO2NsaXA6cmVjdCgxcHgsIDFweCwgMXB4LCAxcHgpO2hlaWdodDoxcHg7d2lkdGg6MXB4O3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7d2hpdGUtc3BhY2U6bm93cmFwO1wiLFxuICBtYXA6IFwiLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSWtFeE1YbFVaWGgwTG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lKQlFWRk5JaXdpWm1sc1pTSTZJa0V4TVhsVVpYaDBMbXB6SWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5OGdRR1pzYjNkY2JpOHFLaUJBYW5ONElHcHplQ0FxTDF4dWFXMXdiM0owSUhzZ2RIbHdaU0JGYkdWdFpXNTBRMjl1Wm1sbklIMGdabkp2YlNBbmNtVmhZM1FuTzF4dWFXMXdiM0owSUhzZ2FuTjRJSDBnWm5KdmJTQW5RR1Z0YjNScGIyNHZZMjl5WlNjN1hHNWNiaTh2SUVGemMybHpkR2wyWlNCMFpYaDBJSFJ2SUdSbGMyTnlhV0psSUhacGMzVmhiQ0JsYkdWdFpXNTBjeTRnU0dsa1pHVnVJR1p2Y2lCemFXZG9kR1ZrSUhWelpYSnpMbHh1WTI5dWMzUWdRVEV4ZVZSbGVIUWdQU0FvY0hKdmNITTZJRVZzWlcxbGJuUkRiMjVtYVdjOEozTndZVzRuUGlrZ1BUNGdLRnh1SUNBZ0lEeHpjR0Z1WEc0Z0lDQWdJQ0JqYzNNOWUzdGNiaUFnSUNBZ0lDQWdiR0ZpWld3NklDZGhNVEY1VkdWNGRDY3NYRzRnSUNBZ0lDQWdJSHBKYm1SbGVEb2dPVGs1T1N4Y2JpQWdJQ0FnSUNBZ1ltOXlaR1Z5T2lBd0xGeHVJQ0FnSUNBZ0lDQmpiR2x3T2lBbmNtVmpkQ2d4Y0hnc0lERndlQ3dnTVhCNExDQXhjSGdwSnl4Y2JpQWdJQ0FnSUNBZ2FHVnBaMmgwT2lBeExGeHVJQ0FnSUNBZ0lDQjNhV1IwYURvZ01TeGNiaUFnSUNBZ0lDQWdjRzl6YVhScGIyNDZJQ2RoWW5OdmJIVjBaU2NzWEc0Z0lDQWdJQ0FnSUc5MlpYSm1iRzkzT2lBbmFHbGtaR1Z1Snl4Y2JpQWdJQ0FnSUNBZ2NHRmtaR2x1WnpvZ01DeGNiaUFnSUNBZ0lDQWdkMmhwZEdWVGNHRmpaVG9nSjI1dmQzSmhjQ2NzWEc0Z0lDQWdJQ0I5ZlZ4dUlDQWdJQ0FnZXk0dUxuQnliM0J6ZlZ4dUlDQWdJQzgrWEc0cE8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQkJNVEY1VkdWNGREdGNiaUpkZlE9PSAqL1wiXG59O1xuXG52YXIgQTExeVRleHQgPSBmdW5jdGlvbiBBMTF5VGV4dChwcm9wcykge1xuICByZXR1cm4ganN4KFwic3BhblwiLCBfZXh0ZW5kcyQxKHtcbiAgICBjc3M6IF9yZWZcbiAgfSwgcHJvcHMpKTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDIoKSB7IF9leHRlbmRzJDIgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIER1bW15SW5wdXQoX3JlZikge1xuICB2YXIgaW5Qcm9wID0gX3JlZi5pbixcbiAgICAgIG91dCA9IF9yZWYub3V0LFxuICAgICAgb25FeGl0ZWQgPSBfcmVmLm9uRXhpdGVkLFxuICAgICAgYXBwZWFyID0gX3JlZi5hcHBlYXIsXG4gICAgICBlbnRlciA9IF9yZWYuZW50ZXIsXG4gICAgICBleGl0ID0gX3JlZi5leGl0LFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgZW1vdGlvbiA9IF9yZWYuZW1vdGlvbixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiaW5cIiwgXCJvdXRcIiwgXCJvbkV4aXRlZFwiLCBcImFwcGVhclwiLCBcImVudGVyXCIsIFwiZXhpdFwiLCBcImlubmVyUmVmXCIsIFwiZW1vdGlvblwiXSk7XG5cbiAgcmV0dXJuIGpzeChcImlucHV0XCIsIF9leHRlbmRzJDIoe1xuICAgIHJlZjogaW5uZXJSZWZcbiAgfSwgcHJvcHMsIHtcbiAgICBjc3M6XG4gICAgLyojX19QVVJFX18qL1xuICAgIF9jc3Moe1xuICAgICAgbGFiZWw6ICdkdW1teUlucHV0JyxcbiAgICAgIC8vIGdldCByaWQgb2YgYW55IGRlZmF1bHQgc3R5bGVzXG4gICAgICBiYWNrZ3JvdW5kOiAwLFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgZm9udFNpemU6ICdpbmhlcml0JyxcbiAgICAgIG91dGxpbmU6IDAsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgLy8gaW1wb3J0YW50ISB3aXRob3V0IGB3aWR0aGAgYnJvd3NlcnMgd29uJ3QgYWxsb3cgZm9jdXNcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBkZXNrdG9wXG4gICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gbW9iaWxlIHdoaWxzdCBtYWludGFpbmluZyBcInNjcm9sbCBpbnRvIHZpZXdcIiBiZWhhdmlvdXJcbiAgICAgIGxlZnQ6IC0xMDAsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwKSdcbiAgICB9LCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBcIlwiIDogXCIvKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJa1IxYlcxNVNXNXdkWFF1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWtGQmJVSk5JaXdpWm1sc1pTSTZJa1IxYlcxNVNXNXdkWFF1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZMeUJBWm14dmQxeHVMeW9xSUVCcWMzZ2dhbk40SUNvdlhHNXBiWEJ2Y25RZ2V5QnFjM2dnZlNCbWNtOXRJQ2RBWlcxdmRHbHZiaTlqYjNKbEp6dGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdablZ1WTNScGIyNGdSSFZ0YlhsSmJuQjFkQ2g3WEc0Z0lHbHVPaUJwYmxCeWIzQXNYRzRnSUc5MWRDeGNiaUFnYjI1RmVHbDBaV1FzWEc0Z0lHRndjR1ZoY2l4Y2JpQWdaVzUwWlhJc1hHNGdJR1Y0YVhRc1hHNGdJR2x1Ym1WeVVtVm1MRnh1SUNCbGJXOTBhVzl1TEZ4dUlDQXVMaTV3Y205d2MxeHVmVG9nWVc1NUtTQjdYRzRnSUhKbGRIVnliaUFvWEc0Z0lDQWdQR2x1Y0hWMFhHNGdJQ0FnSUNCeVpXWTllMmx1Ym1WeVVtVm1mVnh1SUNBZ0lDQWdleTR1TG5CeWIzQnpmVnh1SUNBZ0lDQWdZM056UFh0N1hHNGdJQ0FnSUNBZ0lHeGhZbVZzT2lBblpIVnRiWGxKYm5CMWRDY3NYRzRnSUNBZ0lDQWdJQzh2SUdkbGRDQnlhV1FnYjJZZ1lXNTVJR1JsWm1GMWJIUWdjM1I1YkdWelhHNGdJQ0FnSUNBZ0lHSmhZMnRuY205MWJtUTZJREFzWEc0Z0lDQWdJQ0FnSUdKdmNtUmxjam9nTUN4Y2JpQWdJQ0FnSUNBZ1ptOXVkRk5wZW1VNklDZHBibWhsY21sMEp5eGNiaUFnSUNBZ0lDQWdiM1YwYkdsdVpUb2dNQ3hjYmlBZ0lDQWdJQ0FnY0dGa1pHbHVaem9nTUN4Y2JpQWdJQ0FnSUNBZ0x5OGdhVzF3YjNKMFlXNTBJU0IzYVhSb2IzVjBJR0IzYVdSMGFHQWdZbkp2ZDNObGNuTWdkMjl1SjNRZ1lXeHNiM2NnWm05amRYTmNiaUFnSUNBZ0lDQWdkMmxrZEdnNklERXNYRzVjYmlBZ0lDQWdJQ0FnTHk4Z2NtVnRiM1psSUdOMWNuTnZjaUJ2YmlCa1pYTnJkRzl3WEc0Z0lDQWdJQ0FnSUdOdmJHOXlPaUFuZEhKaGJuTndZWEpsYm5RbkxGeHVYRzRnSUNBZ0lDQWdJQzh2SUhKbGJXOTJaU0JqZFhKemIzSWdiMjRnYlc5aWFXeGxJSGRvYVd4emRDQnRZV2x1ZEdGcGJtbHVaeUJjSW5OamNtOXNiQ0JwYm5SdklIWnBaWGRjSWlCaVpXaGhkbWx2ZFhKY2JpQWdJQ0FnSUNBZ2JHVm1kRG9nTFRFd01DeGNiaUFnSUNBZ0lDQWdiM0JoWTJsMGVUb2dNQ3hjYmlBZ0lDQWdJQ0FnY0c5emFYUnBiMjQ2SUNkeVpXeGhkR2wyWlNjc1hHNGdJQ0FnSUNBZ0lIUnlZVzV6Wm05eWJUb2dKM05qWVd4bEtEQXBKeXhjYmlBZ0lDQWdJSDE5WEc0Z0lDQWdMejVjYmlBZ0tUdGNibjFjYmlKZGZRPT0gKi9cIilcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIE5vZGVSZXNvbHZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShOb2RlUmVzb2x2ZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE5vZGVSZXNvbHZlcigpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTm9kZVJlc29sdmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnByb3BzLmlubmVyUmVmKGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnByb3BzLmlubmVyUmVmKG51bGwpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH07XG5cbiAgcmV0dXJuIE5vZGVSZXNvbHZlcjtcbn0oQ29tcG9uZW50KTtcblxudmFyIFNUWUxFX0tFWVMgPSBbJ2JveFNpemluZycsICdoZWlnaHQnLCAnb3ZlcmZsb3cnLCAncGFkZGluZ1JpZ2h0JywgJ3Bvc2l0aW9uJ107XG52YXIgTE9DS19TVFlMRVMgPSB7XG4gIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAvLyBhY2NvdW50IGZvciBwb3NzaWJsZSBkZWNsYXJhdGlvbiBgd2lkdGg6IDEwMCU7YCBvbiBib2R5XG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIGhlaWdodDogJzEwMCUnXG59O1xuXG5mdW5jdGlvbiBwcmV2ZW50VG91Y2hNb3ZlKGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gYWxsb3dUb3VjaE1vdmUoZSkge1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gcHJldmVudEluZXJ0aWFTY3JvbGwoKSB7XG4gIHZhciB0b3AgPSB0aGlzLnNjcm9sbFRvcDtcbiAgdmFyIHRvdGFsU2Nyb2xsID0gdGhpcy5zY3JvbGxIZWlnaHQ7XG4gIHZhciBjdXJyZW50U2Nyb2xsID0gdG9wICsgdGhpcy5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKHRvcCA9PT0gMCkge1xuICAgIHRoaXMuc2Nyb2xsVG9wID0gMTtcbiAgfSBlbHNlIGlmIChjdXJyZW50U2Nyb2xsID09PSB0b3RhbFNjcm9sbCkge1xuICAgIHRoaXMuc2Nyb2xsVG9wID0gdG9wIC0gMTtcbiAgfVxufSAvLyBgb250b3VjaHN0YXJ0YCBjaGVjayB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4vLyBgbWF4VG91Y2hQb2ludHNgIHdvcmtzIG9uIElFMTAvMTEgYW5kIFN1cmZhY2VcblxuZnVuY3Rpb24gaXNUb3VjaERldmljZSgpIHtcbiAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlJDEoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG52YXIgY2FuVXNlRE9NID0gISEoIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG52YXIgYWN0aXZlU2Nyb2xsTG9ja3MgPSAwO1xuXG52YXIgU2Nyb2xsTG9jayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZSQxKFNjcm9sbExvY2ssIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNjcm9sbExvY2soKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsLmFwcGx5KF9Db21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMub3JpZ2luYWxTdHlsZXMgPSB7fTtcbiAgICBfdGhpcy5saXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2Nyb2xsTG9jay5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoIWNhblVzZURPTSkgcmV0dXJuO1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGFjY291bnRGb3JTY3JvbGxiYXJzID0gX3RoaXMkcHJvcHMuYWNjb3VudEZvclNjcm9sbGJhcnMsXG4gICAgICAgIHRvdWNoU2Nyb2xsVGFyZ2V0ID0gX3RoaXMkcHJvcHMudG91Y2hTY3JvbGxUYXJnZXQ7XG4gICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIHRhcmdldFN0eWxlID0gdGFyZ2V0ICYmIHRhcmdldC5zdHlsZTtcblxuICAgIGlmIChhY2NvdW50Rm9yU2Nyb2xsYmFycykge1xuICAgICAgLy8gc3RvcmUgYW55IHN0eWxlcyBhbHJlYWR5IGFwcGxpZWQgdG8gdGhlIGJvZHlcbiAgICAgIFNUWUxFX0tFWVMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWwgPSB0YXJnZXRTdHlsZSAmJiB0YXJnZXRTdHlsZVtrZXldO1xuICAgICAgICBfdGhpczIub3JpZ2luYWxTdHlsZXNba2V5XSA9IHZhbDtcbiAgICAgIH0pO1xuICAgIH0gLy8gYXBwbHkgdGhlIGxvY2sgc3R5bGVzIGFuZCBwYWRkaW5nIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHNjcm9sbCBsb2NrXG5cblxuICAgIGlmIChhY2NvdW50Rm9yU2Nyb2xsYmFycyAmJiBhY3RpdmVTY3JvbGxMb2NrcyA8IDEpIHtcbiAgICAgIHZhciBjdXJyZW50UGFkZGluZyA9IHBhcnNlSW50KHRoaXMub3JpZ2luYWxTdHlsZXMucGFkZGluZ1JpZ2h0LCAxMCkgfHwgMDtcbiAgICAgIHZhciBjbGllbnRXaWR0aCA9IGRvY3VtZW50LmJvZHkgPyBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDogMDtcbiAgICAgIHZhciBhZGp1c3RlZFBhZGRpbmcgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGNsaWVudFdpZHRoICsgY3VycmVudFBhZGRpbmcgfHwgMDtcbiAgICAgIE9iamVjdC5rZXlzKExPQ0tfU1RZTEVTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbCA9IExPQ0tfU1RZTEVTW2tleV07XG5cbiAgICAgICAgaWYgKHRhcmdldFN0eWxlKSB7XG4gICAgICAgICAgdGFyZ2V0U3R5bGVba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0YXJnZXRTdHlsZSkge1xuICAgICAgICB0YXJnZXRTdHlsZS5wYWRkaW5nUmlnaHQgPSBhZGp1c3RlZFBhZGRpbmcgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfSAvLyBhY2NvdW50IGZvciB0b3VjaCBkZXZpY2VzXG5cblxuICAgIGlmICh0YXJnZXQgJiYgaXNUb3VjaERldmljZSgpKSB7XG4gICAgICAvLyBNb2JpbGUgU2FmYXJpIGlnbm9yZXMgeyBvdmVyZmxvdzogaGlkZGVuIH0gZGVjbGFyYXRpb24gb24gdGhlIGJvZHkuXG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudFRvdWNoTW92ZSwgdGhpcy5saXN0ZW5lck9wdGlvbnMpOyAvLyBBbGxvdyBzY3JvbGwgb24gcHJvdmlkZWQgdGFyZ2V0XG5cbiAgICAgIGlmICh0b3VjaFNjcm9sbFRhcmdldCkge1xuICAgICAgICB0b3VjaFNjcm9sbFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgcHJldmVudEluZXJ0aWFTY3JvbGwsIHRoaXMubGlzdGVuZXJPcHRpb25zKTtcbiAgICAgICAgdG91Y2hTY3JvbGxUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgYWxsb3dUb3VjaE1vdmUsIHRoaXMubGlzdGVuZXJPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IC8vIGluY3JlbWVudCBhY3RpdmUgc2Nyb2xsIGxvY2tzXG5cblxuICAgIGFjdGl2ZVNjcm9sbExvY2tzICs9IDE7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAoIWNhblVzZURPTSkgcmV0dXJuO1xuICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBhY2NvdW50Rm9yU2Nyb2xsYmFycyA9IF90aGlzJHByb3BzMi5hY2NvdW50Rm9yU2Nyb2xsYmFycyxcbiAgICAgICAgdG91Y2hTY3JvbGxUYXJnZXQgPSBfdGhpcyRwcm9wczIudG91Y2hTY3JvbGxUYXJnZXQ7XG4gICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIHRhcmdldFN0eWxlID0gdGFyZ2V0ICYmIHRhcmdldC5zdHlsZTsgLy8gc2FmZWx5IGRlY3JlbWVudCBhY3RpdmUgc2Nyb2xsIGxvY2tzXG5cbiAgICBhY3RpdmVTY3JvbGxMb2NrcyA9IE1hdGgubWF4KGFjdGl2ZVNjcm9sbExvY2tzIC0gMSwgMCk7IC8vIHJlYXBwbHkgb3JpZ2luYWwgYm9keSBzdHlsZXMsIGlmIGFueVxuXG4gICAgaWYgKGFjY291bnRGb3JTY3JvbGxiYXJzICYmIGFjdGl2ZVNjcm9sbExvY2tzIDwgMSkge1xuICAgICAgU1RZTEVfS0VZUy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbCA9IF90aGlzMy5vcmlnaW5hbFN0eWxlc1trZXldO1xuXG4gICAgICAgIGlmICh0YXJnZXRTdHlsZSkge1xuICAgICAgICAgIHRhcmdldFN0eWxlW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gcmVtb3ZlIHRvdWNoIGxpc3RlbmVyc1xuXG5cbiAgICBpZiAodGFyZ2V0ICYmIGlzVG91Y2hEZXZpY2UoKSkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnRUb3VjaE1vdmUsIHRoaXMubGlzdGVuZXJPcHRpb25zKTtcblxuICAgICAgaWYgKHRvdWNoU2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIHRvdWNoU2Nyb2xsVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50SW5lcnRpYVNjcm9sbCwgdGhpcy5saXN0ZW5lck9wdGlvbnMpO1xuICAgICAgICB0b3VjaFNjcm9sbFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBhbGxvd1RvdWNoTW92ZSwgdGhpcy5saXN0ZW5lck9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBTY3JvbGxMb2NrO1xufShDb21wb25lbnQpO1xuXG5TY3JvbGxMb2NrLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWNjb3VudEZvclNjcm9sbGJhcnM6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlJDIoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVmJDEgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIG5hbWU6IFwiMWRzYnBjcFwiLFxuICBzdHlsZXM6IFwicG9zaXRpb246Zml4ZWQ7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjA7dG9wOjA7XCJcbn0gOiB7XG4gIG5hbWU6IFwiMWRzYnBjcFwiLFxuICBzdHlsZXM6IFwicG9zaXRpb246Zml4ZWQ7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjA7dG9wOjA7XCIsXG4gIG1hcDogXCIvKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbE5qY205c2JFSnNiMk5yTG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lKQlFUWkVWU0lzSW1acGJHVWlPaUpUWTNKdmJHeENiRzlqYXk1cWN5SXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaTh2SUVCbWJHOTNYRzR2S2lvZ1FHcHplQ0JxYzNnZ0tpOWNibWx0Y0c5eWRDQjdJRkIxY21WRGIyMXdiMjVsYm5Rc0lIUjVjR1VnUld4bGJXVnVkQ0I5SUdaeWIyMGdKM0psWVdOMEp6dGNibWx0Y0c5eWRDQjdJR3B6ZUNCOUlHWnliMjBnSjBCbGJXOTBhVzl1TDJOdmNtVW5PMXh1YVcxd2IzSjBJRTV2WkdWU1pYTnZiSFpsY2lCbWNtOXRJQ2N1TDA1dlpHVlNaWE52YkhabGNpYzdYRzVwYlhCdmNuUWdVMk55YjJ4c1RHOWpheUJtY205dElDY3VMMU5qY205c2JFeHZZMnN2YVc1a1pYZ25PMXh1WEc1MGVYQmxJRkJ5YjNCeklEMGdlMXh1SUNCamFHbHNaSEpsYmpvZ1JXeGxiV1Z1ZER3cVBpeGNiaUFnYVhORmJtRmliR1ZrT2lCaWIyOXNaV0Z1TEZ4dWZUdGNiblI1Y0dVZ1UzUmhkR1VnUFNCN1hHNGdJSFJ2ZFdOb1UyTnliMnhzVkdGeVoyVjBPaUJJVkUxTVJXeGxiV1Z1ZENCOElHNTFiR3dzWEc1OU8xeHVYRzR2THlCT1QxUkZPbHh1THk4Z1YyVWdjMmh2ZFd4a2JpZDBJRzVsWldRZ2RHaHBjeUJoWm5SbGNpQjFjR1JoZEdsdVp5QjBieUJTWldGamRDQjJNVFl1TXk0d0xDQjNhR2xqYUNCcGJuUnliMlIxWTJWek9seHVMeThnTFNCamNtVmhkR1ZTWldZb0tTQm9kSFJ3Y3pvdkwzSmxZV04wYW5NdWIzSm5MMlJ2WTNNdmNtVmhZM1F0WVhCcExtaDBiV3dqY21WaFkzUmpjbVZoZEdWeVpXWmNiaTh2SUMwZ1ptOXlkMkZ5WkZKbFppZ3BJR2gwZEhCek9pOHZjbVZoWTNScWN5NXZjbWN2Wkc5amN5OXlaV0ZqZEMxaGNHa3VhSFJ0YkNOeVpXRmpkR1p2Y25kaGNtUnlaV1pjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdVMk55YjJ4c1FteHZZMnNnWlhoMFpXNWtjeUJRZFhKbFEyOXRjRzl1Wlc1MFBGQnliM0J6TENCVGRHRjBaVDRnZTF4dUlDQnpkR0YwWlNBOUlIc2dkRzkxWTJoVFkzSnZiR3hVWVhKblpYUTZJRzUxYkd3Z2ZUdGNibHh1SUNBdkx5QnRkWE4wSUdKbElHbHVJSE4wWVhSbElIUnZJSFJ5YVdkblpYSWdZU0J5WlMxeVpXNWtaWElzSUc5dWJIa2djblZ1Y3lCdmJtTmxJSEJsY2lCcGJuTjBZVzVqWlZ4dUlDQm5aWFJUWTNKdmJHeFVZWEpuWlhRZ1BTQW9jbVZtT2lCSVZFMU1SV3hsYldWdWRDa2dQVDRnZTF4dUlDQWdJR2xtSUNoeVpXWWdQVDA5SUhSb2FYTXVjM1JoZEdVdWRHOTFZMmhUWTNKdmJHeFVZWEpuWlhRcElISmxkSFZ5Ymp0Y2JpQWdJQ0IwYUdsekxuTmxkRk4wWVhSbEtIc2dkRzkxWTJoVFkzSnZiR3hVWVhKblpYUTZJSEpsWmlCOUtUdGNiaUFnZlR0Y2JseHVJQ0F2THlCMGFHbHpJSGRwYkd3Z1kyeHZjMlVnZEdobElHMWxiblVnZDJobGJpQmhJSFZ6WlhJZ1kyeHBZMnR6SUc5MWRITnBaR1ZjYmlBZ1lteDFjbE5sYkdWamRFbHVjSFYwSUQwZ0tDa2dQVDRnZTF4dUlDQWdJR2xtSUNoa2IyTjFiV1Z1ZEM1aFkzUnBkbVZGYkdWdFpXNTBLU0I3WEc0Z0lDQWdJQ0JrYjJOMWJXVnVkQzVoWTNScGRtVkZiR1Z0Wlc1MExtSnNkWElvS1R0Y2JpQWdJQ0I5WEc0Z0lIMDdYRzVjYmlBZ2NtVnVaR1Z5S0NrZ2UxeHVJQ0FnSUdOdmJuTjBJSHNnWTJocGJHUnlaVzRzSUdselJXNWhZbXhsWkNCOUlEMGdkR2hwY3k1d2NtOXdjenRjYmlBZ0lDQmpiMjV6ZENCN0lIUnZkV05vVTJOeWIyeHNWR0Z5WjJWMElIMGdQU0IwYUdsekxuTjBZWFJsTzF4dVhHNGdJQ0FnTHk4Z1ltRnBiQ0JsWVhKc2VTQnBaaUJ1YjNRZ1pXNWhZbXhsWkZ4dUlDQWdJR2xtSUNnaGFYTkZibUZpYkdWa0tTQnlaWFIxY200Z1kyaHBiR1J5Wlc0N1hHNWNiaUFnSUNBdktseHVJQ0FnSUNBcUlFUnBkbHh1SUNBZ0lDQXFJQzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFZ4dUlDQWdJQ0FxSUdKc2IyTnJjeUJ6WTNKdmJHeHBibWNnYjI0Z2JtOXVMV0p2WkhrZ1pXeGxiV1Z1ZEhNZ1ltVm9hVzVrSUhSb1pTQnRaVzUxWEc1Y2JpQWdJQ0FnS2lCT2IyUmxVbVZ6YjJ4MlpYSmNiaUFnSUNBZ0tpQXRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzFjYmlBZ0lDQWdLaUIzWlNCdVpXVmtJR0VnY21WbVpYSmxibU5sSUhSdklIUm9aU0J6WTNKdmJHeGhZbXhsSUdWc1pXMWxiblFnZEc4Z1hDSjFibXh2WTJ0Y0lpQnpZM0p2Ykd3Z2IyNWNiaUFnSUNBZ0tpQnRiMkpwYkdVZ1pHVjJhV05sYzF4dVhHNGdJQ0FnSUNvZ1UyTnliMnhzVEc5amExeHVJQ0FnSUNBcUlDMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMVnh1SUNBZ0lDQXFJR0ZqZEhWaGJHeDVJR1J2WlhNZ2RHaGxJSE5qY205c2JDQnNiMk5yYVc1blhHNGdJQ0FnSUNvdlhHNGdJQ0FnY21WMGRYSnVJQ2hjYmlBZ0lDQWdJRHhrYVhZK1hHNGdJQ0FnSUNBZ0lEeGthWFpjYmlBZ0lDQWdJQ0FnSUNCdmJrTnNhV05yUFh0MGFHbHpMbUpzZFhKVFpXeGxZM1JKYm5CMWRIMWNiaUFnSUNBZ0lDQWdJQ0JqYzNNOWUzc2djRzl6YVhScGIyNDZJQ2RtYVhobFpDY3NJR3hsWm5RNklEQXNJR0p2ZEhSdmJUb2dNQ3dnY21sbmFIUTZJREFzSUhSdmNEb2dNQ0I5ZlZ4dUlDQWdJQ0FnSUNBdlBseHVJQ0FnSUNBZ0lDQThUbTlrWlZKbGMyOXNkbVZ5SUdsdWJtVnlVbVZtUFh0MGFHbHpMbWRsZEZOamNtOXNiRlJoY21kbGRIMCtlMk5vYVd4a2NtVnVmVHd2VG05a1pWSmxjMjlzZG1WeVBseHVJQ0FnSUNBZ0lDQjdkRzkxWTJoVFkzSnZiR3hVWVhKblpYUWdQeUFvWEc0Z0lDQWdJQ0FnSUNBZ1BGTmpjbTlzYkV4dlkyc2dkRzkxWTJoVFkzSnZiR3hVWVhKblpYUTllM1J2ZFdOb1UyTnliMnhzVkdGeVoyVjBmU0F2UGx4dUlDQWdJQ0FnSUNBcElEb2diblZzYkgxY2JpQWdJQ0FnSUR3dlpHbDJQbHh1SUNBZ0lDazdYRzRnSUgxY2JuMWNiaUpkZlE9PSAqL1wiXG59O1xuXG4vLyBOT1RFOlxuLy8gV2Ugc2hvdWxkbid0IG5lZWQgdGhpcyBhZnRlciB1cGRhdGluZyB0byBSZWFjdCB2MTYuMy4wLCB3aGljaCBpbnRyb2R1Y2VzOlxuLy8gLSBjcmVhdGVSZWYoKSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjcmVhdGVyZWZcbi8vIC0gZm9yd2FyZFJlZigpIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGZvcndhcmRyZWZcbnZhciBTY3JvbGxCbG9jayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UkMihTY3JvbGxCbG9jaywgX1B1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNjcm9sbEJsb2NrKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9QdXJlQ29tcG9uZW50LmNhbGwuYXBwbHkoX1B1cmVDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICB0b3VjaFNjcm9sbFRhcmdldDogbnVsbFxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRTY3JvbGxUYXJnZXQgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICBpZiAocmVmID09PSBfdGhpcy5zdGF0ZS50b3VjaFNjcm9sbFRhcmdldCkgcmV0dXJuO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHRvdWNoU2Nyb2xsVGFyZ2V0OiByZWZcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5ibHVyU2VsZWN0SW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjcm9sbEJsb2NrLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGlzRW5hYmxlZCA9IF90aGlzJHByb3BzLmlzRW5hYmxlZDtcbiAgICB2YXIgdG91Y2hTY3JvbGxUYXJnZXQgPSB0aGlzLnN0YXRlLnRvdWNoU2Nyb2xsVGFyZ2V0OyAvLyBiYWlsIGVhcmx5IGlmIG5vdCBlbmFibGVkXG5cbiAgICBpZiAoIWlzRW5hYmxlZCkgcmV0dXJuIGNoaWxkcmVuO1xuICAgIC8qXG4gICAgICogRGl2XG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogYmxvY2tzIHNjcm9sbGluZyBvbiBub24tYm9keSBlbGVtZW50cyBiZWhpbmQgdGhlIG1lbnVcbiAgICAgICogTm9kZVJlc29sdmVyXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogd2UgbmVlZCBhIHJlZmVyZW5jZSB0byB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IHRvIFwidW5sb2NrXCIgc2Nyb2xsIG9uXG4gICAgICogbW9iaWxlIGRldmljZXNcbiAgICAgICogU2Nyb2xsTG9ja1xuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIGFjdHVhbGx5IGRvZXMgdGhlIHNjcm9sbCBsb2NraW5nXG4gICAgICovXG5cbiAgICByZXR1cm4ganN4KFwiZGl2XCIsIG51bGwsIGpzeChcImRpdlwiLCB7XG4gICAgICBvbkNsaWNrOiB0aGlzLmJsdXJTZWxlY3RJbnB1dCxcbiAgICAgIGNzczogX3JlZiQxXG4gICAgfSksIGpzeChOb2RlUmVzb2x2ZXIsIHtcbiAgICAgIGlubmVyUmVmOiB0aGlzLmdldFNjcm9sbFRhcmdldFxuICAgIH0sIGNoaWxkcmVuKSwgdG91Y2hTY3JvbGxUYXJnZXQgPyBqc3goU2Nyb2xsTG9jaywge1xuICAgICAgdG91Y2hTY3JvbGxUYXJnZXQ6IHRvdWNoU2Nyb2xsVGFyZ2V0XG4gICAgfSkgOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gU2Nyb2xsQmxvY2s7XG59KFB1cmVDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSQxKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2UkMyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFNjcm9sbENhcHRvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZSQzKFNjcm9sbENhcHRvciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU2Nyb2xsQ2FwdG9yKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbC5hcHBseShfQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmlzQm90dG9tID0gZmFsc2U7XG4gICAgX3RoaXMuaXNUb3AgPSBmYWxzZTtcbiAgICBfdGhpcy5zY3JvbGxUYXJnZXQgPSB2b2lkIDA7XG4gICAgX3RoaXMudG91Y2hTdGFydCA9IHZvaWQgMDtcblxuICAgIF90aGlzLmNhbmNlbFNjcm9sbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFdmVudERlbHRhID0gZnVuY3Rpb24gKGV2ZW50LCBkZWx0YSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgb25Cb3R0b21BcnJpdmUgPSBfdGhpcyRwcm9wcy5vbkJvdHRvbUFycml2ZSxcbiAgICAgICAgICBvbkJvdHRvbUxlYXZlID0gX3RoaXMkcHJvcHMub25Cb3R0b21MZWF2ZSxcbiAgICAgICAgICBvblRvcEFycml2ZSA9IF90aGlzJHByb3BzLm9uVG9wQXJyaXZlLFxuICAgICAgICAgIG9uVG9wTGVhdmUgPSBfdGhpcyRwcm9wcy5vblRvcExlYXZlO1xuICAgICAgdmFyIF90aGlzJHNjcm9sbFRhcmdldCA9IF90aGlzLnNjcm9sbFRhcmdldCxcbiAgICAgICAgICBzY3JvbGxUb3AgPSBfdGhpcyRzY3JvbGxUYXJnZXQuc2Nyb2xsVG9wLFxuICAgICAgICAgIHNjcm9sbEhlaWdodCA9IF90aGlzJHNjcm9sbFRhcmdldC5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgY2xpZW50SGVpZ2h0ID0gX3RoaXMkc2Nyb2xsVGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICAgIHZhciB0YXJnZXQgPSBfdGhpcy5zY3JvbGxUYXJnZXQ7XG4gICAgICB2YXIgaXNEZWx0YVBvc2l0aXZlID0gZGVsdGEgPiAwO1xuICAgICAgdmFyIGF2YWlsYWJsZVNjcm9sbCA9IHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCAtIHNjcm9sbFRvcDtcbiAgICAgIHZhciBzaG91bGRDYW5jZWxTY3JvbGwgPSBmYWxzZTsgLy8gcmVzZXQgYm90dG9tL3RvcCBmbGFnc1xuXG4gICAgICBpZiAoYXZhaWxhYmxlU2Nyb2xsID4gZGVsdGEgJiYgX3RoaXMuaXNCb3R0b20pIHtcbiAgICAgICAgaWYgKG9uQm90dG9tTGVhdmUpIG9uQm90dG9tTGVhdmUoZXZlbnQpO1xuICAgICAgICBfdGhpcy5pc0JvdHRvbSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWx0YVBvc2l0aXZlICYmIF90aGlzLmlzVG9wKSB7XG4gICAgICAgIGlmIChvblRvcExlYXZlKSBvblRvcExlYXZlKGV2ZW50KTtcbiAgICAgICAgX3RoaXMuaXNUb3AgPSBmYWxzZTtcbiAgICAgIH0gLy8gYm90dG9tIGxpbWl0XG5cblxuICAgICAgaWYgKGlzRGVsdGFQb3NpdGl2ZSAmJiBkZWx0YSA+IGF2YWlsYWJsZVNjcm9sbCkge1xuICAgICAgICBpZiAob25Cb3R0b21BcnJpdmUgJiYgIV90aGlzLmlzQm90dG9tKSB7XG4gICAgICAgICAgb25Cb3R0b21BcnJpdmUoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHNjcm9sbEhlaWdodDtcbiAgICAgICAgc2hvdWxkQ2FuY2VsU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuaXNCb3R0b20gPSB0cnVlOyAvLyB0b3AgbGltaXRcbiAgICAgIH0gZWxzZSBpZiAoIWlzRGVsdGFQb3NpdGl2ZSAmJiAtZGVsdGEgPiBzY3JvbGxUb3ApIHtcbiAgICAgICAgaWYgKG9uVG9wQXJyaXZlICYmICFfdGhpcy5pc1RvcCkge1xuICAgICAgICAgIG9uVG9wQXJyaXZlKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICBzaG91bGRDYW5jZWxTY3JvbGwgPSB0cnVlO1xuICAgICAgICBfdGhpcy5pc1RvcCA9IHRydWU7XG4gICAgICB9IC8vIGNhbmNlbCBzY3JvbGxcblxuXG4gICAgICBpZiAoc2hvdWxkQ2FuY2VsU2Nyb2xsKSB7XG4gICAgICAgIF90aGlzLmNhbmNlbFNjcm9sbChldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uV2hlZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLmhhbmRsZUV2ZW50RGVsdGEoZXZlbnQsIGV2ZW50LmRlbHRhWSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gc2V0IHRvdWNoIHN0YXJ0IHNvIHdlIGNhbiBjYWxjdWxhdGUgdG91Y2htb3ZlIGRlbHRhXG4gICAgICBfdGhpcy50b3VjaFN0YXJ0ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBkZWx0YVkgPSBfdGhpcy50b3VjaFN0YXJ0IC0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcblxuICAgICAgX3RoaXMuaGFuZGxlRXZlbnREZWx0YShldmVudCwgZGVsdGFZKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0U2Nyb2xsVGFyZ2V0ID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgX3RoaXMuc2Nyb2xsVGFyZ2V0ID0gcmVmO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2Nyb2xsQ2FwdG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnN0YXJ0TGlzdGVuaW5nKHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcodGhpcy5zY3JvbGxUYXJnZXQpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydExpc3RlbmluZyA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuaW5nKGVsKSB7XG4gICAgLy8gYmFpbCBlYXJseSBpZiBubyBlbGVtZW50IGlzIGF2YWlsYWJsZSB0byBhdHRhY2ggdG9cbiAgICBpZiAoIWVsKSByZXR1cm47IC8vIGFsbCB0aGUgaWYgc3RhdGVtZW50cyBhcmUgdG8gYXBwZWFzZSBGbG93IPCfmKJcblxuICAgIGlmICh0eXBlb2YgZWwuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVsLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZWwuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc3RvcExpc3RlbmluZyA9IGZ1bmN0aW9uIHN0b3BMaXN0ZW5pbmcoZWwpIHtcbiAgICAvLyBhbGwgdGhlIGlmIHN0YXRlbWVudHMgYXJlIHRvIGFwcGVhc2UgRmxvdyDwn5iiXG4gICAgaWYgKHR5cGVvZiBlbC5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlbC5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm9kZVJlc29sdmVyLCB7XG4gICAgICBpbm5lclJlZjogdGhpcy5nZXRTY3JvbGxUYXJnZXRcbiAgICB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfTtcblxuICByZXR1cm4gU2Nyb2xsQ2FwdG9yO1xufShDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBTY3JvbGxDYXB0b3JTd2l0Y2goX3JlZikge1xuICB2YXIgX3JlZiRpc0VuYWJsZWQgPSBfcmVmLmlzRW5hYmxlZCxcbiAgICAgIGlzRW5hYmxlZCA9IF9yZWYkaXNFbmFibGVkID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRpc0VuYWJsZWQsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJDEoX3JlZiwgW1wiaXNFbmFibGVkXCJdKTtcblxuICByZXR1cm4gaXNFbmFibGVkID8gUmVhY3QuY3JlYXRlRWxlbWVudChTY3JvbGxDYXB0b3IsIHByb3BzKSA6IHByb3BzLmNoaWxkcmVuO1xufVxuXG52YXIgaW5zdHJ1Y3Rpb25zQXJpYU1lc3NhZ2UgPSBmdW5jdGlvbiBpbnN0cnVjdGlvbnNBcmlhTWVzc2FnZShldmVudCwgY29udGV4dCkge1xuICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgY29udGV4dCA9IHt9O1xuICB9XG5cbiAgdmFyIF9jb250ZXh0ID0gY29udGV4dCxcbiAgICAgIGlzU2VhcmNoYWJsZSA9IF9jb250ZXh0LmlzU2VhcmNoYWJsZSxcbiAgICAgIGlzTXVsdGkgPSBfY29udGV4dC5pc011bHRpLFxuICAgICAgbGFiZWwgPSBfY29udGV4dC5sYWJlbCxcbiAgICAgIGlzRGlzYWJsZWQgPSBfY29udGV4dC5pc0Rpc2FibGVkO1xuXG4gIHN3aXRjaCAoZXZlbnQpIHtcbiAgICBjYXNlICdtZW51JzpcbiAgICAgIHJldHVybiBcIlVzZSBVcCBhbmQgRG93biB0byBjaG9vc2Ugb3B0aW9uc1wiICsgKGlzRGlzYWJsZWQgPyAnJyA6ICcsIHByZXNzIEVudGVyIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IGZvY3VzZWQgb3B0aW9uJykgKyBcIiwgcHJlc3MgRXNjYXBlIHRvIGV4aXQgdGhlIG1lbnUsIHByZXNzIFRhYiB0byBzZWxlY3QgdGhlIG9wdGlvbiBhbmQgZXhpdCB0aGUgbWVudS5cIjtcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJldHVybiAobGFiZWwgPyBsYWJlbCA6ICdTZWxlY3QnKSArIFwiIGlzIGZvY3VzZWQgXCIgKyAoaXNTZWFyY2hhYmxlID8gJyx0eXBlIHRvIHJlZmluZSBsaXN0JyA6ICcnKSArIFwiLCBwcmVzcyBEb3duIHRvIG9wZW4gdGhlIG1lbnUsIFwiICsgKGlzTXVsdGkgPyAnIHByZXNzIGxlZnQgdG8gZm9jdXMgc2VsZWN0ZWQgdmFsdWVzJyA6ICcnKTtcblxuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgIHJldHVybiAnVXNlIGxlZnQgYW5kIHJpZ2h0IHRvIHRvZ2dsZSBiZXR3ZWVuIGZvY3VzZWQgdmFsdWVzLCBwcmVzcyBCYWNrc3BhY2UgdG8gcmVtb3ZlIHRoZSBjdXJyZW50bHkgZm9jdXNlZCB2YWx1ZSc7XG4gIH1cbn07XG52YXIgdmFsdWVFdmVudEFyaWFNZXNzYWdlID0gZnVuY3Rpb24gdmFsdWVFdmVudEFyaWFNZXNzYWdlKGV2ZW50LCBjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHQudmFsdWUsXG4gICAgICBpc0Rpc2FibGVkID0gY29udGV4dC5pc0Rpc2FibGVkO1xuICBpZiAoIXZhbHVlKSByZXR1cm47XG5cbiAgc3dpdGNoIChldmVudCkge1xuICAgIGNhc2UgJ2Rlc2VsZWN0LW9wdGlvbic6XG4gICAgY2FzZSAncG9wLXZhbHVlJzpcbiAgICBjYXNlICdyZW1vdmUtdmFsdWUnOlxuICAgICAgcmV0dXJuIFwib3B0aW9uIFwiICsgdmFsdWUgKyBcIiwgZGVzZWxlY3RlZC5cIjtcblxuICAgIGNhc2UgJ3NlbGVjdC1vcHRpb24nOlxuICAgICAgcmV0dXJuIGlzRGlzYWJsZWQgPyBcIm9wdGlvbiBcIiArIHZhbHVlICsgXCIgaXMgZGlzYWJsZWQuIFNlbGVjdCBhbm90aGVyIG9wdGlvbi5cIiA6IFwib3B0aW9uIFwiICsgdmFsdWUgKyBcIiwgc2VsZWN0ZWQuXCI7XG4gIH1cbn07XG52YXIgdmFsdWVGb2N1c0FyaWFNZXNzYWdlID0gZnVuY3Rpb24gdmFsdWVGb2N1c0FyaWFNZXNzYWdlKF9yZWYpIHtcbiAgdmFyIGZvY3VzZWRWYWx1ZSA9IF9yZWYuZm9jdXNlZFZhbHVlLFxuICAgICAgZ2V0T3B0aW9uTGFiZWwgPSBfcmVmLmdldE9wdGlvbkxhYmVsLFxuICAgICAgc2VsZWN0VmFsdWUgPSBfcmVmLnNlbGVjdFZhbHVlO1xuICByZXR1cm4gXCJ2YWx1ZSBcIiArIGdldE9wdGlvbkxhYmVsKGZvY3VzZWRWYWx1ZSkgKyBcIiBmb2N1c2VkLCBcIiArIChzZWxlY3RWYWx1ZS5pbmRleE9mKGZvY3VzZWRWYWx1ZSkgKyAxKSArIFwiIG9mIFwiICsgc2VsZWN0VmFsdWUubGVuZ3RoICsgXCIuXCI7XG59O1xudmFyIG9wdGlvbkZvY3VzQXJpYU1lc3NhZ2UgPSBmdW5jdGlvbiBvcHRpb25Gb2N1c0FyaWFNZXNzYWdlKF9yZWYyKSB7XG4gIHZhciBmb2N1c2VkT3B0aW9uID0gX3JlZjIuZm9jdXNlZE9wdGlvbixcbiAgICAgIGdldE9wdGlvbkxhYmVsID0gX3JlZjIuZ2V0T3B0aW9uTGFiZWwsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgcmV0dXJuIFwib3B0aW9uIFwiICsgZ2V0T3B0aW9uTGFiZWwoZm9jdXNlZE9wdGlvbikgKyBcIiBmb2N1c2VkXCIgKyAoZm9jdXNlZE9wdGlvbi5pc0Rpc2FibGVkID8gJyBkaXNhYmxlZCcgOiAnJykgKyBcIiwgXCIgKyAob3B0aW9ucy5pbmRleE9mKGZvY3VzZWRPcHRpb24pICsgMSkgKyBcIiBvZiBcIiArIG9wdGlvbnMubGVuZ3RoICsgXCIuXCI7XG59O1xudmFyIHJlc3VsdHNBcmlhTWVzc2FnZSA9IGZ1bmN0aW9uIHJlc3VsdHNBcmlhTWVzc2FnZShfcmVmMykge1xuICB2YXIgaW5wdXRWYWx1ZSA9IF9yZWYzLmlucHV0VmFsdWUsXG4gICAgICBzY3JlZW5SZWFkZXJNZXNzYWdlID0gX3JlZjMuc2NyZWVuUmVhZGVyTWVzc2FnZTtcbiAgcmV0dXJuIFwiXCIgKyBzY3JlZW5SZWFkZXJNZXNzYWdlICsgKGlucHV0VmFsdWUgPyAnIGZvciBzZWFyY2ggdGVybSAnICsgaW5wdXRWYWx1ZSA6ICcnKSArIFwiLlwiO1xufTtcblxudmFyIGZvcm1hdEdyb3VwTGFiZWwgPSBmdW5jdGlvbiBmb3JtYXRHcm91cExhYmVsKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5sYWJlbDtcbn07XG52YXIgZ2V0T3B0aW9uTGFiZWwgPSBmdW5jdGlvbiBnZXRPcHRpb25MYWJlbChvcHRpb24pIHtcbiAgcmV0dXJuIG9wdGlvbi5sYWJlbDtcbn07XG52YXIgZ2V0T3B0aW9uVmFsdWUgPSBmdW5jdGlvbiBnZXRPcHRpb25WYWx1ZShvcHRpb24pIHtcbiAgcmV0dXJuIG9wdGlvbi52YWx1ZTtcbn07XG52YXIgaXNPcHRpb25EaXNhYmxlZCA9IGZ1bmN0aW9uIGlzT3B0aW9uRGlzYWJsZWQob3B0aW9uKSB7XG4gIHJldHVybiAhIW9wdGlvbi5pc0Rpc2FibGVkO1xufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMkMygpIHsgX2V4dGVuZHMkMyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcyQzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbnZhciBkZWZhdWx0U3R5bGVzID0ge1xuICBjbGVhckluZGljYXRvcjogY2xlYXJJbmRpY2F0b3JDU1MsXG4gIGNvbnRhaW5lcjogY29udGFpbmVyQ1NTLFxuICBjb250cm9sOiBjc3MsXG4gIGRyb3Bkb3duSW5kaWNhdG9yOiBkcm9wZG93bkluZGljYXRvckNTUyxcbiAgZ3JvdXA6IGdyb3VwQ1NTLFxuICBncm91cEhlYWRpbmc6IGdyb3VwSGVhZGluZ0NTUyxcbiAgaW5kaWNhdG9yc0NvbnRhaW5lcjogaW5kaWNhdG9yc0NvbnRhaW5lckNTUyxcbiAgaW5kaWNhdG9yU2VwYXJhdG9yOiBpbmRpY2F0b3JTZXBhcmF0b3JDU1MsXG4gIGlucHV0OiBpbnB1dENTUyxcbiAgbG9hZGluZ0luZGljYXRvcjogbG9hZGluZ0luZGljYXRvckNTUyxcbiAgbG9hZGluZ01lc3NhZ2U6IGxvYWRpbmdNZXNzYWdlQ1NTLFxuICBtZW51OiBtZW51Q1NTLFxuICBtZW51TGlzdDogbWVudUxpc3RDU1MsXG4gIG1lbnVQb3J0YWw6IG1lbnVQb3J0YWxDU1MsXG4gIG11bHRpVmFsdWU6IG11bHRpVmFsdWVDU1MsXG4gIG11bHRpVmFsdWVMYWJlbDogbXVsdGlWYWx1ZUxhYmVsQ1NTLFxuICBtdWx0aVZhbHVlUmVtb3ZlOiBtdWx0aVZhbHVlUmVtb3ZlQ1NTLFxuICBub09wdGlvbnNNZXNzYWdlOiBub09wdGlvbnNNZXNzYWdlQ1NTLFxuICBvcHRpb246IG9wdGlvbkNTUyxcbiAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyQ1NTLFxuICBzaW5nbGVWYWx1ZTogY3NzJDEsXG4gIHZhbHVlQ29udGFpbmVyOiB2YWx1ZUNvbnRhaW5lckNTU1xufTsgLy8gTWVyZ2UgVXRpbGl0eVxuLy8gQWxsb3dzIGNvbnN1bWVycyB0byBleHRlbmQgYSBiYXNlIFNlbGVjdCB3aXRoIGFkZGl0aW9uYWwgc3R5bGVzXG5cbmZ1bmN0aW9uIG1lcmdlU3R5bGVzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQgPT09IHZvaWQgMCkge1xuICAgIHRhcmdldCA9IHt9O1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB3aXRoIHNvdXJjZSBzdHlsZXNcbiAgdmFyIHN0eWxlcyA9IF9leHRlbmRzJDMoe30sIHNvdXJjZSk7IC8vIG1hc3NhZ2UgaW4gdGFyZ2V0IHN0eWxlc1xuXG5cbiAgT2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoc291cmNlW2tleV0pIHtcbiAgICAgIHN0eWxlc1trZXldID0gZnVuY3Rpb24gKHJzQ3NzLCBwcm9wcykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV0oc291cmNlW2tleV0ocnNDc3MsIHByb3BzKSwgcHJvcHMpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3R5bGVzO1xufVxuXG52YXIgY29sb3JzID0ge1xuICBwcmltYXJ5OiAnIzI2ODRGRicsXG4gIHByaW1hcnk3NTogJyM0QzlBRkYnLFxuICBwcmltYXJ5NTA6ICcjQjJENEZGJyxcbiAgcHJpbWFyeTI1OiAnI0RFRUJGRicsXG4gIGRhbmdlcjogJyNERTM1MEInLFxuICBkYW5nZXJMaWdodDogJyNGRkJEQUQnLFxuICBuZXV0cmFsMDogJ2hzbCgwLCAwJSwgMTAwJSknLFxuICBuZXV0cmFsNTogJ2hzbCgwLCAwJSwgOTUlKScsXG4gIG5ldXRyYWwxMDogJ2hzbCgwLCAwJSwgOTAlKScsXG4gIG5ldXRyYWwyMDogJ2hzbCgwLCAwJSwgODAlKScsXG4gIG5ldXRyYWwzMDogJ2hzbCgwLCAwJSwgNzAlKScsXG4gIG5ldXRyYWw0MDogJ2hzbCgwLCAwJSwgNjAlKScsXG4gIG5ldXRyYWw1MDogJ2hzbCgwLCAwJSwgNTAlKScsXG4gIG5ldXRyYWw2MDogJ2hzbCgwLCAwJSwgNDAlKScsXG4gIG5ldXRyYWw3MDogJ2hzbCgwLCAwJSwgMzAlKScsXG4gIG5ldXRyYWw4MDogJ2hzbCgwLCAwJSwgMjAlKScsXG4gIG5ldXRyYWw5MDogJ2hzbCgwLCAwJSwgMTAlKSdcbn07XG52YXIgYm9yZGVyUmFkaXVzID0gNDsgLy8gVXNlZCB0byBjYWxjdWxhdGUgY29uc2lzdGVudCBtYXJnaW4vcGFkZGluZyBvbiBlbGVtZW50c1xuXG52YXIgYmFzZVVuaXQgPSA0OyAvLyBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIGNvbnRyb2xcblxudmFyIGNvbnRyb2xIZWlnaHQgPSAzODsgLy8gVGhlIGFtb3VudCBvZiBzcGFjZSBiZXR3ZWVuIHRoZSBjb250cm9sIGFuZCBtZW51ICovXG5cbnZhciBtZW51R3V0dGVyID0gYmFzZVVuaXQgKiAyO1xudmFyIHNwYWNpbmcgPSB7XG4gIGJhc2VVbml0OiBiYXNlVW5pdCxcbiAgY29udHJvbEhlaWdodDogY29udHJvbEhlaWdodCxcbiAgbWVudUd1dHRlcjogbWVudUd1dHRlclxufTtcbnZhciBkZWZhdWx0VGhlbWUgPSB7XG4gIGJvcmRlclJhZGl1czogYm9yZGVyUmFkaXVzLFxuICBjb2xvcnM6IGNvbG9ycyxcbiAgc3BhY2luZzogc3BhY2luZ1xufTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UkMihzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDQoKSB7IF9leHRlbmRzJDQgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMkNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlJDQoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgYmFja3NwYWNlUmVtb3Zlc1ZhbHVlOiB0cnVlLFxuICBibHVySW5wdXRPblNlbGVjdDogaXNUb3VjaENhcGFibGUoKSxcbiAgY2FwdHVyZU1lbnVTY3JvbGw6ICFpc1RvdWNoQ2FwYWJsZSgpLFxuICBjbG9zZU1lbnVPblNlbGVjdDogdHJ1ZSxcbiAgY2xvc2VNZW51T25TY3JvbGw6IGZhbHNlLFxuICBjb21wb25lbnRzOiB7fSxcbiAgY29udHJvbFNob3VsZFJlbmRlclZhbHVlOiB0cnVlLFxuICBlc2NhcGVDbGVhcnNWYWx1ZTogZmFsc2UsXG4gIGZpbHRlck9wdGlvbjogY3JlYXRlRmlsdGVyKCksXG4gIGZvcm1hdEdyb3VwTGFiZWw6IGZvcm1hdEdyb3VwTGFiZWwsXG4gIGdldE9wdGlvbkxhYmVsOiBnZXRPcHRpb25MYWJlbCxcbiAgZ2V0T3B0aW9uVmFsdWU6IGdldE9wdGlvblZhbHVlLFxuICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgaXNNdWx0aTogZmFsc2UsXG4gIGlzUnRsOiBmYWxzZSxcbiAgaXNTZWFyY2hhYmxlOiB0cnVlLFxuICBpc09wdGlvbkRpc2FibGVkOiBpc09wdGlvbkRpc2FibGVkLFxuICBsb2FkaW5nTWVzc2FnZTogZnVuY3Rpb24gbG9hZGluZ01lc3NhZ2UoKSB7XG4gICAgcmV0dXJuICdMb2FkaW5nLi4uJztcbiAgfSxcbiAgbWF4TWVudUhlaWdodDogMzAwLFxuICBtaW5NZW51SGVpZ2h0OiAxNDAsXG4gIG1lbnVJc09wZW46IGZhbHNlLFxuICBtZW51UGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbWVudVBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICBtZW51U2hvdWxkQmxvY2tTY3JvbGw6IGZhbHNlLFxuICBtZW51U2hvdWxkU2Nyb2xsSW50b1ZpZXc6ICFpc01vYmlsZURldmljZSgpLFxuICBub09wdGlvbnNNZXNzYWdlOiBmdW5jdGlvbiBub09wdGlvbnNNZXNzYWdlKCkge1xuICAgIHJldHVybiAnTm8gb3B0aW9ucyc7XG4gIH0sXG4gIG9wZW5NZW51T25Gb2N1czogZmFsc2UsXG4gIG9wZW5NZW51T25DbGljazogdHJ1ZSxcbiAgb3B0aW9uczogW10sXG4gIHBhZ2VTaXplOiA1LFxuICBwbGFjZWhvbGRlcjogJ1NlbGVjdC4uLicsXG4gIHNjcmVlblJlYWRlclN0YXR1czogZnVuY3Rpb24gc2NyZWVuUmVhZGVyU3RhdHVzKF9yZWYpIHtcbiAgICB2YXIgY291bnQgPSBfcmVmLmNvdW50O1xuICAgIHJldHVybiBjb3VudCArIFwiIHJlc3VsdFwiICsgKGNvdW50ICE9PSAxID8gJ3MnIDogJycpICsgXCIgYXZhaWxhYmxlXCI7XG4gIH0sXG4gIHN0eWxlczoge30sXG4gIHRhYkluZGV4OiAnMCcsXG4gIHRhYlNlbGVjdHNWYWx1ZTogdHJ1ZVxufTtcbnZhciBpbnN0YW5jZUlkID0gMTtcblxudmFyIFNlbGVjdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZSQ0KFNlbGVjdCwgX0NvbXBvbmVudCk7XG5cbiAgLy8gTWlzYy4gSW5zdGFuY2UgUHJvcGVydGllc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVE9ET1xuICAvLyBSZWZzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBMaWZlY3ljbGVcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIFNlbGVjdChfcHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBfcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBhcmlhTGl2ZVNlbGVjdGlvbjogJycsXG4gICAgICBhcmlhTGl2ZUNvbnRleHQ6ICcnLFxuICAgICAgZm9jdXNlZE9wdGlvbjogbnVsbCxcbiAgICAgIGZvY3VzZWRWYWx1ZTogbnVsbCxcbiAgICAgIGlucHV0SXNIaWRkZW46IGZhbHNlLFxuICAgICAgaXNGb2N1c2VkOiBmYWxzZSxcbiAgICAgIG1lbnVPcHRpb25zOiB7XG4gICAgICAgIHJlbmRlcjogW10sXG4gICAgICAgIGZvY3VzYWJsZTogW11cbiAgICAgIH0sXG4gICAgICBzZWxlY3RWYWx1ZTogW11cbiAgICB9O1xuICAgIF90aGlzLmJsb2NrT3B0aW9uSG92ZXIgPSBmYWxzZTtcbiAgICBfdGhpcy5pc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgIF90aGlzLmNsZWFyRm9jdXNWYWx1ZU9uVXBkYXRlID0gZmFsc2U7XG4gICAgX3RoaXMuY29tbW9uUHJvcHMgPSB2b2lkIDA7XG4gICAgX3RoaXMuY29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICBfdGhpcy5oYXNHcm91cHMgPSBmYWxzZTtcbiAgICBfdGhpcy5pbml0aWFsVG91Y2hYID0gMDtcbiAgICBfdGhpcy5pbml0aWFsVG91Y2hZID0gMDtcbiAgICBfdGhpcy5pbnB1dElzSGlkZGVuQWZ0ZXJVcGRhdGUgPSB2b2lkIDA7XG4gICAgX3RoaXMuaW5zdGFuY2VQcmVmaXggPSAnJztcbiAgICBfdGhpcy5vcGVuQWZ0ZXJGb2N1cyA9IGZhbHNlO1xuICAgIF90aGlzLnNjcm9sbFRvRm9jdXNlZE9wdGlvbk9uVXBkYXRlID0gZmFsc2U7XG4gICAgX3RoaXMudXNlcklzRHJhZ2dpbmcgPSB2b2lkIDA7XG4gICAgX3RoaXMuY29udHJvbFJlZiA9IG51bGw7XG5cbiAgICBfdGhpcy5nZXRDb250cm9sUmVmID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgX3RoaXMuY29udHJvbFJlZiA9IHJlZjtcbiAgICB9O1xuXG4gICAgX3RoaXMuZm9jdXNlZE9wdGlvblJlZiA9IG51bGw7XG5cbiAgICBfdGhpcy5nZXRGb2N1c2VkT3B0aW9uUmVmID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgX3RoaXMuZm9jdXNlZE9wdGlvblJlZiA9IHJlZjtcbiAgICB9O1xuXG4gICAgX3RoaXMubWVudUxpc3RSZWYgPSBudWxsO1xuXG4gICAgX3RoaXMuZ2V0TWVudUxpc3RSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICBfdGhpcy5tZW51TGlzdFJlZiA9IHJlZjtcbiAgICB9O1xuXG4gICAgX3RoaXMuaW5wdXRSZWYgPSBudWxsO1xuXG4gICAgX3RoaXMuZ2V0SW5wdXRSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICBfdGhpcy5pbnB1dFJlZiA9IHJlZjtcbiAgICB9O1xuXG4gICAgX3RoaXMuY2FjaGVDb21wb25lbnRzID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcbiAgICAgIF90aGlzLmNvbXBvbmVudHMgPSBkZWZhdWx0Q29tcG9uZW50cyh7XG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5mb2N1cyA9IF90aGlzLmZvY3VzSW5wdXQ7XG4gICAgX3RoaXMuYmx1ciA9IF90aGlzLmJsdXJJbnB1dDtcblxuICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBhY3Rpb25NZXRhKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBvbkNoYW5nZSA9IF90aGlzJHByb3BzLm9uQ2hhbmdlLFxuICAgICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wcy5uYW1lO1xuICAgICAgb25DaGFuZ2UobmV3VmFsdWUsIF9leHRlbmRzJDQoe30sIGFjdGlvbk1ldGEsIHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgYWN0aW9uLCBvcHRpb24pIHtcbiAgICAgIGlmIChhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgICAgICBhY3Rpb24gPSAnc2V0LXZhbHVlJztcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGNsb3NlTWVudU9uU2VsZWN0ID0gX3RoaXMkcHJvcHMyLmNsb3NlTWVudU9uU2VsZWN0LFxuICAgICAgICAgIGlzTXVsdGkgPSBfdGhpcyRwcm9wczIuaXNNdWx0aTtcblxuICAgICAgX3RoaXMub25JbnB1dENoYW5nZSgnJywge1xuICAgICAgICBhY3Rpb246ICdzZXQtdmFsdWUnXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNsb3NlTWVudU9uU2VsZWN0KSB7XG4gICAgICAgIF90aGlzLmlucHV0SXNIaWRkZW5BZnRlclVwZGF0ZSA9ICFpc011bHRpO1xuXG4gICAgICAgIF90aGlzLm9uTWVudUNsb3NlKCk7XG4gICAgICB9IC8vIHdoZW4gdGhlIHNlbGVjdCB2YWx1ZSBzaG91bGQgY2hhbmdlLCB3ZSBzaG91bGQgcmVzZXQgZm9jdXNlZFZhbHVlXG5cblxuICAgICAgX3RoaXMuY2xlYXJGb2N1c1ZhbHVlT25VcGRhdGUgPSB0cnVlO1xuXG4gICAgICBfdGhpcy5vbkNoYW5nZShuZXdWYWx1ZSwge1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgb3B0aW9uOiBvcHRpb25cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5zZWxlY3RPcHRpb24gPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBibHVySW5wdXRPblNlbGVjdCA9IF90aGlzJHByb3BzMy5ibHVySW5wdXRPblNlbGVjdCxcbiAgICAgICAgICBpc011bHRpID0gX3RoaXMkcHJvcHMzLmlzTXVsdGk7XG4gICAgICB2YXIgc2VsZWN0VmFsdWUgPSBfdGhpcy5zdGF0ZS5zZWxlY3RWYWx1ZTtcblxuICAgICAgaWYgKGlzTXVsdGkpIHtcbiAgICAgICAgaWYgKF90aGlzLmlzT3B0aW9uU2VsZWN0ZWQobmV3VmFsdWUsIHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBfdGhpcy5nZXRPcHRpb25WYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgICAgICBfdGhpcy5zZXRWYWx1ZShzZWxlY3RWYWx1ZS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRPcHRpb25WYWx1ZShpKSAhPT0gY2FuZGlkYXRlO1xuICAgICAgICAgIH0pLCAnZGVzZWxlY3Qtb3B0aW9uJywgbmV3VmFsdWUpO1xuXG4gICAgICAgICAgX3RoaXMuYW5ub3VuY2VBcmlhTGl2ZVNlbGVjdGlvbih7XG4gICAgICAgICAgICBldmVudDogJ2Rlc2VsZWN0LW9wdGlvbicsXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5nZXRPcHRpb25MYWJlbChuZXdWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmlzT3B0aW9uRGlzYWJsZWQobmV3VmFsdWUsIHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAgICAgX3RoaXMuc2V0VmFsdWUoW10uY29uY2F0KHNlbGVjdFZhbHVlLCBbbmV3VmFsdWVdKSwgJ3NlbGVjdC1vcHRpb24nLCBuZXdWYWx1ZSk7XG5cbiAgICAgICAgICAgIF90aGlzLmFubm91bmNlQXJpYUxpdmVTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICBldmVudDogJ3NlbGVjdC1vcHRpb24nLFxuICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLmdldE9wdGlvbkxhYmVsKG5ld1ZhbHVlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYW5ub3VuY2UgdGhhdCBvcHRpb24gaXMgZGlzYWJsZWRcbiAgICAgICAgICAgIF90aGlzLmFubm91bmNlQXJpYUxpdmVTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICBldmVudDogJ3NlbGVjdC1vcHRpb24nLFxuICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLmdldE9wdGlvbkxhYmVsKG5ld1ZhbHVlKSxcbiAgICAgICAgICAgICAgICBpc0Rpc2FibGVkOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFfdGhpcy5pc09wdGlvbkRpc2FibGVkKG5ld1ZhbHVlLCBzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgICBfdGhpcy5zZXRWYWx1ZShuZXdWYWx1ZSwgJ3NlbGVjdC1vcHRpb24nKTtcblxuICAgICAgICAgIF90aGlzLmFubm91bmNlQXJpYUxpdmVTZWxlY3Rpb24oe1xuICAgICAgICAgICAgZXZlbnQ6ICdzZWxlY3Qtb3B0aW9uJyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLmdldE9wdGlvbkxhYmVsKG5ld1ZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFubm91bmNlIHRoYXQgb3B0aW9uIGlzIGRpc2FibGVkXG4gICAgICAgICAgX3RoaXMuYW5ub3VuY2VBcmlhTGl2ZVNlbGVjdGlvbih7XG4gICAgICAgICAgICBldmVudDogJ3NlbGVjdC1vcHRpb24nLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuZ2V0T3B0aW9uTGFiZWwobmV3VmFsdWUpLFxuICAgICAgICAgICAgICBpc0Rpc2FibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJsdXJJbnB1dE9uU2VsZWN0KSB7XG4gICAgICAgIF90aGlzLmJsdXJJbnB1dCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5yZW1vdmVWYWx1ZSA9IGZ1bmN0aW9uIChyZW1vdmVkVmFsdWUpIHtcbiAgICAgIHZhciBzZWxlY3RWYWx1ZSA9IF90aGlzLnN0YXRlLnNlbGVjdFZhbHVlO1xuXG4gICAgICB2YXIgY2FuZGlkYXRlID0gX3RoaXMuZ2V0T3B0aW9uVmFsdWUocmVtb3ZlZFZhbHVlKTtcblxuICAgICAgdmFyIG5ld1ZhbHVlID0gc2VsZWN0VmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5nZXRPcHRpb25WYWx1ZShpKSAhPT0gY2FuZGlkYXRlO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLm9uQ2hhbmdlKG5ld1ZhbHVlLmxlbmd0aCA/IG5ld1ZhbHVlIDogbnVsbCwge1xuICAgICAgICBhY3Rpb246ICdyZW1vdmUtdmFsdWUnLFxuICAgICAgICByZW1vdmVkVmFsdWU6IHJlbW92ZWRWYWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLmFubm91bmNlQXJpYUxpdmVTZWxlY3Rpb24oe1xuICAgICAgICBldmVudDogJ3JlbW92ZS12YWx1ZScsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICB2YWx1ZTogcmVtb3ZlZFZhbHVlID8gX3RoaXMuZ2V0T3B0aW9uTGFiZWwocmVtb3ZlZFZhbHVlKSA6ICcnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgfTtcblxuICAgIF90aGlzLmNsZWFyVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNNdWx0aSA9IF90aGlzLnByb3BzLmlzTXVsdGk7XG5cbiAgICAgIF90aGlzLm9uQ2hhbmdlKGlzTXVsdGkgPyBbXSA6IG51bGwsIHtcbiAgICAgICAgYWN0aW9uOiAnY2xlYXInXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMucG9wVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZWN0VmFsdWUgPSBfdGhpcy5zdGF0ZS5zZWxlY3RWYWx1ZTtcbiAgICAgIHZhciBsYXN0U2VsZWN0ZWRWYWx1ZSA9IHNlbGVjdFZhbHVlW3NlbGVjdFZhbHVlLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIG5ld1ZhbHVlID0gc2VsZWN0VmFsdWUuc2xpY2UoMCwgc2VsZWN0VmFsdWUubGVuZ3RoIC0gMSk7XG5cbiAgICAgIF90aGlzLmFubm91bmNlQXJpYUxpdmVTZWxlY3Rpb24oe1xuICAgICAgICBldmVudDogJ3BvcC12YWx1ZScsXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICB2YWx1ZTogbGFzdFNlbGVjdGVkVmFsdWUgPyBfdGhpcy5nZXRPcHRpb25MYWJlbChsYXN0U2VsZWN0ZWRWYWx1ZSkgOiAnJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMub25DaGFuZ2UobmV3VmFsdWUubGVuZ3RoID8gbmV3VmFsdWUgOiBudWxsLCB7XG4gICAgICAgIGFjdGlvbjogJ3BvcC12YWx1ZScsXG4gICAgICAgIHJlbW92ZWRWYWx1ZTogbGFzdFNlbGVjdGVkVmFsdWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRPcHRpb25MYWJlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMuZ2V0T3B0aW9uTGFiZWwoZGF0YSk7XG4gICAgfTtcblxuICAgIF90aGlzLmdldE9wdGlvblZhbHVlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5nZXRPcHRpb25WYWx1ZShkYXRhKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKGtleSwgcHJvcHMpIHtcbiAgICAgIHZhciBiYXNlID0gZGVmYXVsdFN0eWxlc1trZXldKHByb3BzKTtcbiAgICAgIGJhc2UuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgICAgdmFyIGN1c3RvbSA9IF90aGlzLnByb3BzLnN0eWxlc1trZXldO1xuICAgICAgcmV0dXJuIGN1c3RvbSA/IGN1c3RvbShiYXNlLCBwcm9wcykgOiBiYXNlO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRFbGVtZW50SWQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIF90aGlzLmluc3RhbmNlUHJlZml4ICsgXCItXCIgKyBlbGVtZW50O1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRBY3RpdmVEZXNjZW5kZW50SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWVudUlzT3BlbiA9IF90aGlzLnByb3BzLm1lbnVJc09wZW47XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICBtZW51T3B0aW9ucyA9IF90aGlzJHN0YXRlLm1lbnVPcHRpb25zLFxuICAgICAgICAgIGZvY3VzZWRPcHRpb24gPSBfdGhpcyRzdGF0ZS5mb2N1c2VkT3B0aW9uO1xuICAgICAgaWYgKCFmb2N1c2VkT3B0aW9uIHx8ICFtZW51SXNPcGVuKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgdmFyIGluZGV4ID0gbWVudU9wdGlvbnMuZm9jdXNhYmxlLmluZGV4T2YoZm9jdXNlZE9wdGlvbik7XG4gICAgICB2YXIgb3B0aW9uID0gbWVudU9wdGlvbnMucmVuZGVyW2luZGV4XTtcbiAgICAgIHJldHVybiBvcHRpb24gJiYgb3B0aW9uLmtleTtcbiAgICB9O1xuXG4gICAgX3RoaXMuYW5ub3VuY2VBcmlhTGl2ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIGV2ZW50ID0gX3JlZjIuZXZlbnQsXG4gICAgICAgICAgY29udGV4dCA9IF9yZWYyLmNvbnRleHQ7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYXJpYUxpdmVTZWxlY3Rpb246IHZhbHVlRXZlbnRBcmlhTWVzc2FnZShldmVudCwgY29udGV4dClcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5hbm5vdW5jZUFyaWFMaXZlQ29udGV4dCA9IGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIGV2ZW50ID0gX3JlZjMuZXZlbnQsXG4gICAgICAgICAgY29udGV4dCA9IF9yZWYzLmNvbnRleHQ7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYXJpYUxpdmVDb250ZXh0OiBpbnN0cnVjdGlvbnNBcmlhTWVzc2FnZShldmVudCwgX2V4dGVuZHMkNCh7fSwgY29udGV4dCwge1xuICAgICAgICAgIGxhYmVsOiBfdGhpcy5wcm9wc1snYXJpYS1sYWJlbCddXG4gICAgICAgIH0pKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uTWVudU1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgX3RoaXMuZm9jdXNJbnB1dCgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbk1lbnVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzLmJsb2NrT3B0aW9uSG92ZXIgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Db250cm9sTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgb3Blbk1lbnVPbkNsaWNrID0gX3RoaXMucHJvcHMub3Blbk1lbnVPbkNsaWNrO1xuXG4gICAgICBpZiAoIV90aGlzLnN0YXRlLmlzRm9jdXNlZCkge1xuICAgICAgICBpZiAob3Blbk1lbnVPbkNsaWNrKSB7XG4gICAgICAgICAgX3RoaXMub3BlbkFmdGVyRm9jdXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZm9jdXNJbnB1dCgpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMucHJvcHMubWVudUlzT3Blbikge1xuICAgICAgICBpZiAob3Blbk1lbnVPbkNsaWNrKSB7XG4gICAgICAgICAgX3RoaXMub3Blbk1lbnUoJ2ZpcnN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggLy8gJEZsb3dGaXhNZVxuICAgICAgICBldmVudC50YXJnZXQudGFnTmFtZSAhPT0gJ0lOUFVUJyAmJiBldmVudC50YXJnZXQudGFnTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgIF90aGlzLm9uTWVudUNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCAvLyAkRmxvd0ZpeE1lXG4gICAgICBldmVudC50YXJnZXQudGFnTmFtZSAhPT0gJ0lOUFVUJyAmJiBldmVudC50YXJnZXQudGFnTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyb3Bkb3duSW5kaWNhdG9yTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBpZ25vcmUgbW91c2UgZXZlbnRzIHRoYXQgd2VyZW4ndCB0cmlnZ2VyZWQgYnkgdGhlIHByaW1hcnkgYnV0dG9uXG4gICAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnByb3BzLmlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBpc011bHRpID0gX3RoaXMkcHJvcHM0LmlzTXVsdGksXG4gICAgICAgICAgbWVudUlzT3BlbiA9IF90aGlzJHByb3BzNC5tZW51SXNPcGVuO1xuXG4gICAgICBfdGhpcy5mb2N1c0lucHV0KCk7XG5cbiAgICAgIGlmIChtZW51SXNPcGVuKSB7XG4gICAgICAgIF90aGlzLmlucHV0SXNIaWRkZW5BZnRlclVwZGF0ZSA9ICFpc011bHRpO1xuXG4gICAgICAgIF90aGlzLm9uTWVudUNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5vcGVuTWVudSgnZmlyc3QnKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkNsZWFySW5kaWNhdG9yTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBpZ25vcmUgbW91c2UgZXZlbnRzIHRoYXQgd2VyZW4ndCB0cmlnZ2VyZWQgYnkgdGhlIHByaW1hcnkgYnV0dG9uXG4gICAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY2xlYXJWYWx1ZSgpO1xuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIF90aGlzLm9wZW5BZnRlckZvY3VzID0gZmFsc2U7XG5cbiAgICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgIF90aGlzLmZvY3VzSW5wdXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5mb2N1c0lucHV0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vblNjcm9sbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKHR5cGVvZiBfdGhpcy5wcm9wcy5jbG9zZU1lbnVPblNjcm9sbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBpc0RvY3VtZW50RWxlbWVudChldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgX3RoaXMucHJvcHMub25NZW51Q2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoaXMucHJvcHMuY2xvc2VNZW51T25TY3JvbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmNsb3NlTWVudU9uU2Nyb2xsKGV2ZW50KSkge1xuICAgICAgICAgIF90aGlzLnByb3BzLm9uTWVudUNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25Db21wb3NpdGlvblN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaXNDb21wb3NpbmcgPSB0cnVlO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkNvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICB2YXIgdG91Y2hlcyA9IF9yZWY0LnRvdWNoZXM7XG4gICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzLml0ZW0oMCk7XG5cbiAgICAgIGlmICghdG91Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5pbml0aWFsVG91Y2hYID0gdG91Y2guY2xpZW50WDtcbiAgICAgIF90aGlzLmluaXRpYWxUb3VjaFkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgX3RoaXMudXNlcklzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgIHZhciB0b3VjaGVzID0gX3JlZjUudG91Y2hlcztcbiAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXMuaXRlbSgwKTtcblxuICAgICAgaWYgKCF0b3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YVggPSBNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gX3RoaXMuaW5pdGlhbFRvdWNoWCk7XG4gICAgICB2YXIgZGVsdGFZID0gTWF0aC5hYnModG91Y2guY2xpZW50WSAtIF90aGlzLmluaXRpYWxUb3VjaFkpO1xuICAgICAgdmFyIG1vdmVUaHJlc2hvbGQgPSA1O1xuICAgICAgX3RoaXMudXNlcklzRHJhZ2dpbmcgPSBkZWx0YVggPiBtb3ZlVGhyZXNob2xkIHx8IGRlbHRhWSA+IG1vdmVUaHJlc2hvbGQ7XG4gICAgfTtcblxuICAgIF90aGlzLm9uVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy51c2VySXNEcmFnZ2luZykgcmV0dXJuOyAvLyBjbG9zZSB0aGUgbWVudSBpZiB0aGUgdXNlciB0YXBzIG91dHNpZGVcbiAgICAgIC8vIHdlJ3JlIGNoZWNraW5nIG9uIGV2ZW50LnRhcmdldCBoZXJlIGluc3RlYWQgb2YgZXZlbnQuY3VycmVudFRhcmdldCwgYmVjYXVzZSB3ZSB3YW50IHRvIGFzc2VydCBpbmZvcm1hdGlvblxuICAgICAgLy8gb24gZXZlbnRzIG9uIGNoaWxkIGVsZW1lbnRzLCBub3QgdGhlIGRvY3VtZW50ICh3aGljaCB3ZSd2ZSBhdHRhY2hlZCB0aGlzIGhhbmRsZXIgdG8pLlxuXG4gICAgICBpZiAoX3RoaXMuY29udHJvbFJlZiAmJiAhX3RoaXMuY29udHJvbFJlZi5jb250YWlucyhldmVudC50YXJnZXQpICYmIF90aGlzLm1lbnVMaXN0UmVmICYmICFfdGhpcy5tZW51TGlzdFJlZi5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgIF90aGlzLmJsdXJJbnB1dCgpO1xuICAgICAgfSAvLyByZXNldCBtb3ZlIHZhcnNcblxuXG4gICAgICBfdGhpcy5pbml0aWFsVG91Y2hYID0gMDtcbiAgICAgIF90aGlzLmluaXRpYWxUb3VjaFkgPSAwO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkNvbnRyb2xUb3VjaEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnVzZXJJc0RyYWdnaW5nKSByZXR1cm47XG5cbiAgICAgIF90aGlzLm9uQ29udHJvbE1vdXNlRG93bihldmVudCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uQ2xlYXJJbmRpY2F0b3JUb3VjaEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnVzZXJJc0RyYWdnaW5nKSByZXR1cm47XG5cbiAgICAgIF90aGlzLm9uQ2xlYXJJbmRpY2F0b3JNb3VzZURvd24oZXZlbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkRyb3Bkb3duSW5kaWNhdG9yVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy51c2VySXNEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgICBfdGhpcy5vbkRyb3Bkb3duSW5kaWNhdG9yTW91c2VEb3duKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBpbnB1dFZhbHVlID0gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICAgIF90aGlzLmlucHV0SXNIaWRkZW5BZnRlclVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICBfdGhpcy5vbklucHV0Q2hhbmdlKGlucHV0VmFsdWUsIHtcbiAgICAgICAgYWN0aW9uOiAnaW5wdXQtY2hhbmdlJ1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLm9uTWVudU9wZW4oKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25JbnB1dEZvY3VzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgaXNTZWFyY2hhYmxlID0gX3RoaXMkcHJvcHM1LmlzU2VhcmNoYWJsZSxcbiAgICAgICAgICBpc011bHRpID0gX3RoaXMkcHJvcHM1LmlzTXVsdGk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkZvY3VzKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRm9jdXMoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5pbnB1dElzSGlkZGVuQWZ0ZXJVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgX3RoaXMuYW5ub3VuY2VBcmlhTGl2ZUNvbnRleHQoe1xuICAgICAgICBldmVudDogJ2lucHV0JyxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIGlzU2VhcmNoYWJsZTogaXNTZWFyY2hhYmxlLFxuICAgICAgICAgIGlzTXVsdGk6IGlzTXVsdGlcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNGb2N1c2VkOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKF90aGlzLm9wZW5BZnRlckZvY3VzIHx8IF90aGlzLnByb3BzLm9wZW5NZW51T25Gb2N1cykge1xuICAgICAgICBfdGhpcy5vcGVuTWVudSgnZmlyc3QnKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMub3BlbkFmdGVyRm9jdXMgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25JbnB1dEJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5tZW51TGlzdFJlZiAmJiBfdGhpcy5tZW51TGlzdFJlZi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICBfdGhpcy5pbnB1dFJlZi5mb2N1cygpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQmx1cikge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkJsdXIoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5vbklucHV0Q2hhbmdlKCcnLCB7XG4gICAgICAgIGFjdGlvbjogJ2lucHV0LWJsdXInXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMub25NZW51Q2xvc2UoKTtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBmb2N1c2VkVmFsdWU6IG51bGwsXG4gICAgICAgIGlzRm9jdXNlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbk9wdGlvbkhvdmVyID0gZnVuY3Rpb24gKGZvY3VzZWRPcHRpb24pIHtcbiAgICAgIGlmIChfdGhpcy5ibG9ja09wdGlvbkhvdmVyIHx8IF90aGlzLnN0YXRlLmZvY3VzZWRPcHRpb24gPT09IGZvY3VzZWRPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGZvY3VzZWRPcHRpb246IGZvY3VzZWRPcHRpb25cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5zaG91bGRIaWRlU2VsZWN0ZWRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGhpZGVTZWxlY3RlZE9wdGlvbnMgPSBfdGhpcyRwcm9wczYuaGlkZVNlbGVjdGVkT3B0aW9ucyxcbiAgICAgICAgICBpc011bHRpID0gX3RoaXMkcHJvcHM2LmlzTXVsdGk7XG4gICAgICBpZiAoaGlkZVNlbGVjdGVkT3B0aW9ucyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaXNNdWx0aTtcbiAgICAgIHJldHVybiBoaWRlU2VsZWN0ZWRPcHRpb25zO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczcgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBpc011bHRpID0gX3RoaXMkcHJvcHM3LmlzTXVsdGksXG4gICAgICAgICAgYmFja3NwYWNlUmVtb3Zlc1ZhbHVlID0gX3RoaXMkcHJvcHM3LmJhY2tzcGFjZVJlbW92ZXNWYWx1ZSxcbiAgICAgICAgICBlc2NhcGVDbGVhcnNWYWx1ZSA9IF90aGlzJHByb3BzNy5lc2NhcGVDbGVhcnNWYWx1ZSxcbiAgICAgICAgICBpbnB1dFZhbHVlID0gX3RoaXMkcHJvcHM3LmlucHV0VmFsdWUsXG4gICAgICAgICAgaXNDbGVhcmFibGUgPSBfdGhpcyRwcm9wczcuaXNDbGVhcmFibGUsXG4gICAgICAgICAgaXNEaXNhYmxlZCA9IF90aGlzJHByb3BzNy5pc0Rpc2FibGVkLFxuICAgICAgICAgIG1lbnVJc09wZW4gPSBfdGhpcyRwcm9wczcubWVudUlzT3BlbixcbiAgICAgICAgICBvbktleURvd24gPSBfdGhpcyRwcm9wczcub25LZXlEb3duLFxuICAgICAgICAgIHRhYlNlbGVjdHNWYWx1ZSA9IF90aGlzJHByb3BzNy50YWJTZWxlY3RzVmFsdWUsXG4gICAgICAgICAgb3Blbk1lbnVPbkZvY3VzID0gX3RoaXMkcHJvcHM3Lm9wZW5NZW51T25Gb2N1cztcbiAgICAgIHZhciBfdGhpcyRzdGF0ZTIgPSBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICBmb2N1c2VkT3B0aW9uID0gX3RoaXMkc3RhdGUyLmZvY3VzZWRPcHRpb24sXG4gICAgICAgICAgZm9jdXNlZFZhbHVlID0gX3RoaXMkc3RhdGUyLmZvY3VzZWRWYWx1ZSxcbiAgICAgICAgICBzZWxlY3RWYWx1ZSA9IF90aGlzJHN0YXRlMi5zZWxlY3RWYWx1ZTtcbiAgICAgIGlmIChpc0Rpc2FibGVkKSByZXR1cm47XG5cbiAgICAgIGlmICh0eXBlb2Ygb25LZXlEb3duID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uS2V5RG93bihldmVudCk7XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQmxvY2sgb3B0aW9uIGhvdmVyIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGhhcyBqdXN0IHByZXNzZWQgYSBrZXlcblxuXG4gICAgICBfdGhpcy5ibG9ja09wdGlvbkhvdmVyID0gdHJ1ZTtcblxuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICBpZiAoIWlzTXVsdGkgfHwgaW5wdXRWYWx1ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgX3RoaXMuZm9jdXNWYWx1ZSgncHJldmlvdXMnKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgIGlmICghaXNNdWx0aSB8fCBpbnB1dFZhbHVlKSByZXR1cm47XG5cbiAgICAgICAgICBfdGhpcy5mb2N1c1ZhbHVlKCduZXh0Jyk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdEZWxldGUnOlxuICAgICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgICAgIGlmIChpbnB1dFZhbHVlKSByZXR1cm47XG5cbiAgICAgICAgICBpZiAoZm9jdXNlZFZhbHVlKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVWYWx1ZShmb2N1c2VkVmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWJhY2tzcGFjZVJlbW92ZXNWYWx1ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgICAgICBfdGhpcy5wb3BWYWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NsZWFyYWJsZSkge1xuICAgICAgICAgICAgICBfdGhpcy5jbGVhclZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgICBpZiAoX3RoaXMuaXNDb21wb3NpbmcpIHJldHVybjtcblxuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSB8fCAhbWVudUlzT3BlbiB8fCAhdGFiU2VsZWN0c1ZhbHVlIHx8ICFmb2N1c2VkT3B0aW9uIHx8IC8vIGRvbid0IGNhcHR1cmUgdGhlIGV2ZW50IGlmIHRoZSBtZW51IG9wZW5zIG9uIGZvY3VzIGFuZCB0aGUgZm9jdXNlZFxuICAgICAgICAgIC8vIG9wdGlvbiBpcyBhbHJlYWR5IHNlbGVjdGVkOyBpdCBicmVha3MgdGhlIGZsb3cgb2YgbmF2aWdhdGlvblxuICAgICAgICAgIG9wZW5NZW51T25Gb2N1cyAmJiBfdGhpcy5pc09wdGlvblNlbGVjdGVkKGZvY3VzZWRPcHRpb24sIHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLnNlbGVjdE9wdGlvbihmb2N1c2VkT3B0aW9uKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjI5KSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdGhlIGtleWRvd24gZXZlbnQgZnJvbSBhbiBJbnB1dCBNZXRob2QgRWRpdG9yKElNRSlcbiAgICAgICAgICAgIC8vIHJlZi4gaHR0cHM6Ly93d3cudzMub3JnL1RSL3VpZXZlbnRzLyNkZXRlcm1pbmUta2V5ZG93bi1rZXl1cC1rZXlDb2RlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWVudUlzT3Blbikge1xuICAgICAgICAgICAgaWYgKCFmb2N1c2VkT3B0aW9uKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNDb21wb3NpbmcpIHJldHVybjtcblxuICAgICAgICAgICAgX3RoaXMuc2VsZWN0T3B0aW9uKGZvY3VzZWRPcHRpb24pO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICBpZiAobWVudUlzT3Blbikge1xuICAgICAgICAgICAgX3RoaXMuaW5wdXRJc0hpZGRlbkFmdGVyVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIF90aGlzLm9uSW5wdXRDaGFuZ2UoJycsIHtcbiAgICAgICAgICAgICAgYWN0aW9uOiAnbWVudS1jbG9zZSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfdGhpcy5vbk1lbnVDbG9zZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNDbGVhcmFibGUgJiYgZXNjYXBlQ2xlYXJzVmFsdWUpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyVmFsdWUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAvLyBzcGFjZVxuICAgICAgICAgIGlmIChpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZW51SXNPcGVuKSB7XG4gICAgICAgICAgICBfdGhpcy5vcGVuTWVudSgnZmlyc3QnKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmb2N1c2VkT3B0aW9uKSByZXR1cm47XG5cbiAgICAgICAgICBfdGhpcy5zZWxlY3RPcHRpb24oZm9jdXNlZE9wdGlvbik7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICBpZiAobWVudUlzT3Blbikge1xuICAgICAgICAgICAgX3RoaXMuZm9jdXNPcHRpb24oJ3VwJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm9wZW5NZW51KCdsYXN0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICBpZiAobWVudUlzT3Blbikge1xuICAgICAgICAgICAgX3RoaXMuZm9jdXNPcHRpb24oJ2Rvd24nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMub3Blbk1lbnUoJ2ZpcnN0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgICAgICBpZiAoIW1lbnVJc09wZW4pIHJldHVybjtcblxuICAgICAgICAgIF90aGlzLmZvY3VzT3B0aW9uKCdwYWdldXAnKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1BhZ2VEb3duJzpcbiAgICAgICAgICBpZiAoIW1lbnVJc09wZW4pIHJldHVybjtcblxuICAgICAgICAgIF90aGlzLmZvY3VzT3B0aW9uKCdwYWdlZG93bicpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgaWYgKCFtZW51SXNPcGVuKSByZXR1cm47XG5cbiAgICAgICAgICBfdGhpcy5mb2N1c09wdGlvbignZmlyc3QnKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgaWYgKCFtZW51SXNPcGVuKSByZXR1cm47XG5cbiAgICAgICAgICBfdGhpcy5mb2N1c09wdGlvbignbGFzdCcpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIF90aGlzLmJ1aWxkTWVudU9wdGlvbnMgPSBmdW5jdGlvbiAocHJvcHMsIHNlbGVjdFZhbHVlKSB7XG4gICAgICB2YXIgX3Byb3BzJGlucHV0VmFsdWUgPSBwcm9wcy5pbnB1dFZhbHVlLFxuICAgICAgICAgIGlucHV0VmFsdWUgPSBfcHJvcHMkaW5wdXRWYWx1ZSA9PT0gdm9pZCAwID8gJycgOiBfcHJvcHMkaW5wdXRWYWx1ZSxcbiAgICAgICAgICBvcHRpb25zID0gcHJvcHMub3B0aW9ucztcblxuICAgICAgdmFyIHRvT3B0aW9uID0gZnVuY3Rpb24gdG9PcHRpb24ob3B0aW9uLCBpZCkge1xuICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IF90aGlzLmlzT3B0aW9uRGlzYWJsZWQob3B0aW9uLCBzZWxlY3RWYWx1ZSk7XG5cbiAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBfdGhpcy5pc09wdGlvblNlbGVjdGVkKG9wdGlvbiwgc2VsZWN0VmFsdWUpO1xuXG4gICAgICAgIHZhciBsYWJlbCA9IF90aGlzLmdldE9wdGlvbkxhYmVsKG9wdGlvbik7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZ2V0T3B0aW9uVmFsdWUob3B0aW9uKTtcblxuICAgICAgICBpZiAoX3RoaXMuc2hvdWxkSGlkZVNlbGVjdGVkT3B0aW9ucygpICYmIGlzU2VsZWN0ZWQgfHwgIV90aGlzLmZpbHRlck9wdGlvbih7XG4gICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkYXRhOiBvcHRpb25cbiAgICAgICAgfSwgaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb25Ib3ZlciA9IGlzRGlzYWJsZWQgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm9uT3B0aW9uSG92ZXIob3B0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uU2VsZWN0ID0gaXNEaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc2VsZWN0T3B0aW9uKG9wdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvcHRpb25JZCA9IF90aGlzLmdldEVsZW1lbnRJZCgnb3B0aW9uJykgKyBcIi1cIiArIGlkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlubmVyUHJvcHM6IHtcbiAgICAgICAgICAgIGlkOiBvcHRpb25JZCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IG9uU2VsZWN0LFxuICAgICAgICAgICAgb25Nb3VzZU1vdmU6IG9uSG92ZXIsXG4gICAgICAgICAgICBvbk1vdXNlT3Zlcjogb25Ib3ZlcixcbiAgICAgICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YTogb3B0aW9uLFxuICAgICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgaXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcbiAgICAgICAgICBrZXk6IG9wdGlvbklkLFxuICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICB0eXBlOiAnb3B0aW9uJyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBvcHRpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtLCBpdGVtSW5kZXgpIHtcbiAgICAgICAgaWYgKGl0ZW0ub3B0aW9ucykge1xuICAgICAgICAgIC8vIFRPRE8gbmVlZHMgYSB0aWRpZXIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICBpZiAoIV90aGlzLmhhc0dyb3VwcykgX3RoaXMuaGFzR3JvdXBzID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgaXRlbXMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbXMubWFwKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRvT3B0aW9uKGNoaWxkLCBpdGVtSW5kZXggKyBcIi1cIiArIGkpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbikgYWNjLmZvY3VzYWJsZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XG4gICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwSWQgPSBfdGhpcy5nZXRFbGVtZW50SWQoJ2dyb3VwJykgKyBcIi1cIiArIGl0ZW1JbmRleDtcbiAgICAgICAgICAgIGFjYy5yZW5kZXIucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICAgICAgICAgIGtleTogZ3JvdXBJZCxcbiAgICAgICAgICAgICAgZGF0YTogaXRlbSxcbiAgICAgICAgICAgICAgb3B0aW9uczogY2hpbGRyZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0aW9uID0gdG9PcHRpb24oaXRlbSwgXCJcIiArIGl0ZW1JbmRleCk7XG5cbiAgICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICBhY2MucmVuZGVyLnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgIGFjYy5mb2N1c2FibGUucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge1xuICAgICAgICByZW5kZXI6IFtdLFxuICAgICAgICBmb2N1c2FibGU6IFtdXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIF92YWx1ZSA9IF9wcm9wcy52YWx1ZTtcbiAgICBfdGhpcy5jYWNoZUNvbXBvbmVudHMgPSBtZW1vaXplT25lKF90aGlzLmNhY2hlQ29tcG9uZW50cywgZXhwb3J0ZWRFcXVhbCkuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICBfdGhpcy5jYWNoZUNvbXBvbmVudHMoX3Byb3BzLmNvbXBvbmVudHMpO1xuXG4gICAgX3RoaXMuaW5zdGFuY2VQcmVmaXggPSAncmVhY3Qtc2VsZWN0LScgKyAoX3RoaXMucHJvcHMuaW5zdGFuY2VJZCB8fCArK2luc3RhbmNlSWQpO1xuXG4gICAgdmFyIF9zZWxlY3RWYWx1ZSA9IGNsZWFuVmFsdWUoX3ZhbHVlKTtcblxuICAgIF90aGlzLmJ1aWxkTWVudU9wdGlvbnMgPSBtZW1vaXplT25lKF90aGlzLmJ1aWxkTWVudU9wdGlvbnMsIGZ1bmN0aW9uIChuZXdBcmdzLCBsYXN0QXJncykge1xuICAgICAgdmFyIF9yZWY2ID0gbmV3QXJncyxcbiAgICAgICAgICBuZXdQcm9wcyA9IF9yZWY2WzBdLFxuICAgICAgICAgIG5ld1NlbGVjdFZhbHVlID0gX3JlZjZbMV07XG4gICAgICB2YXIgX3JlZjcgPSBsYXN0QXJncyxcbiAgICAgICAgICBsYXN0UHJvcHMgPSBfcmVmN1swXSxcbiAgICAgICAgICBsYXN0U2VsZWN0VmFsdWUgPSBfcmVmN1sxXTtcbiAgICAgIHJldHVybiBleHBvcnRlZEVxdWFsKG5ld1NlbGVjdFZhbHVlLCBsYXN0U2VsZWN0VmFsdWUpICYmIGV4cG9ydGVkRXF1YWwobmV3UHJvcHMuaW5wdXRWYWx1ZSwgbGFzdFByb3BzLmlucHV0VmFsdWUpICYmIGV4cG9ydGVkRXF1YWwobmV3UHJvcHMub3B0aW9ucywgbGFzdFByb3BzLm9wdGlvbnMpO1xuICAgIH0pLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuXG4gICAgdmFyIF9tZW51T3B0aW9ucyA9IF9wcm9wcy5tZW51SXNPcGVuID8gX3RoaXMuYnVpbGRNZW51T3B0aW9ucyhfcHJvcHMsIF9zZWxlY3RWYWx1ZSkgOiB7XG4gICAgICByZW5kZXI6IFtdLFxuICAgICAgZm9jdXNhYmxlOiBbXVxuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZS5tZW51T3B0aW9ucyA9IF9tZW51T3B0aW9ucztcbiAgICBfdGhpcy5zdGF0ZS5zZWxlY3RWYWx1ZSA9IF9zZWxlY3RWYWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2VsZWN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnN0YXJ0TGlzdGVuaW5nQ29tcG9zaXRpb24oKTtcbiAgICB0aGlzLnN0YXJ0TGlzdGVuaW5nVG9Ub3VjaCgpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMuY2xvc2VNZW51T25TY3JvbGwgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgLy8gTGlzdGVuIHRvIGFsbCBzY3JvbGwgZXZlbnRzLCBhbmQgZmlsdGVyIHRoZW0gb3V0IGluc2lkZSBvZiAnb25TY3JvbGwnXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHM4ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb3B0aW9ucyA9IF90aGlzJHByb3BzOC5vcHRpb25zLFxuICAgICAgICB2YWx1ZSA9IF90aGlzJHByb3BzOC52YWx1ZSxcbiAgICAgICAgbWVudUlzT3BlbiA9IF90aGlzJHByb3BzOC5tZW51SXNPcGVuLFxuICAgICAgICBpbnB1dFZhbHVlID0gX3RoaXMkcHJvcHM4LmlucHV0VmFsdWU7IC8vIHJlLWNhY2hlIGN1c3RvbSBjb21wb25lbnRzXG5cbiAgICB0aGlzLmNhY2hlQ29tcG9uZW50cyhuZXh0UHJvcHMuY29tcG9uZW50cyk7IC8vIHJlYnVpbGQgdGhlIG1lbnUgb3B0aW9uc1xuXG4gICAgaWYgKG5leHRQcm9wcy52YWx1ZSAhPT0gdmFsdWUgfHwgbmV4dFByb3BzLm9wdGlvbnMgIT09IG9wdGlvbnMgfHwgbmV4dFByb3BzLm1lbnVJc09wZW4gIT09IG1lbnVJc09wZW4gfHwgbmV4dFByb3BzLmlucHV0VmFsdWUgIT09IGlucHV0VmFsdWUpIHtcbiAgICAgIHZhciBzZWxlY3RWYWx1ZSA9IGNsZWFuVmFsdWUobmV4dFByb3BzLnZhbHVlKTtcbiAgICAgIHZhciBtZW51T3B0aW9ucyA9IG5leHRQcm9wcy5tZW51SXNPcGVuID8gdGhpcy5idWlsZE1lbnVPcHRpb25zKG5leHRQcm9wcywgc2VsZWN0VmFsdWUpIDoge1xuICAgICAgICByZW5kZXI6IFtdLFxuICAgICAgICBmb2N1c2FibGU6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIGZvY3VzZWRWYWx1ZSA9IHRoaXMuZ2V0TmV4dEZvY3VzZWRWYWx1ZShzZWxlY3RWYWx1ZSk7XG4gICAgICB2YXIgZm9jdXNlZE9wdGlvbiA9IHRoaXMuZ2V0TmV4dEZvY3VzZWRPcHRpb24obWVudU9wdGlvbnMuZm9jdXNhYmxlKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBtZW51T3B0aW9uczogbWVudU9wdGlvbnMsXG4gICAgICAgIHNlbGVjdFZhbHVlOiBzZWxlY3RWYWx1ZSxcbiAgICAgICAgZm9jdXNlZE9wdGlvbjogZm9jdXNlZE9wdGlvbixcbiAgICAgICAgZm9jdXNlZFZhbHVlOiBmb2N1c2VkVmFsdWVcbiAgICAgIH0pO1xuICAgIH0gLy8gc29tZSB1cGRhdGVzIHNob3VsZCB0b2dnbGUgdGhlIHN0YXRlIG9mIHRoZSBpbnB1dCB2aXNpYmlsaXR5XG5cblxuICAgIGlmICh0aGlzLmlucHV0SXNIaWRkZW5BZnRlclVwZGF0ZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW5wdXRJc0hpZGRlbjogdGhpcy5pbnB1dElzSGlkZGVuQWZ0ZXJVcGRhdGVcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHRoaXMuaW5wdXRJc0hpZGRlbkFmdGVyVXBkYXRlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBfdGhpcyRwcm9wczkgPSB0aGlzLnByb3BzLFxuICAgICAgICBpc0Rpc2FibGVkID0gX3RoaXMkcHJvcHM5LmlzRGlzYWJsZWQsXG4gICAgICAgIG1lbnVJc09wZW4gPSBfdGhpcyRwcm9wczkubWVudUlzT3BlbjtcbiAgICB2YXIgaXNGb2N1c2VkID0gdGhpcy5zdGF0ZS5pc0ZvY3VzZWQ7XG5cbiAgICBpZiAoIC8vIGVuc3VyZSBmb2N1cyBpcyByZXN0b3JlZCBjb3JyZWN0bHkgd2hlbiB0aGUgY29udHJvbCBiZWNvbWVzIGVuYWJsZWRcbiAgICBpc0ZvY3VzZWQgJiYgIWlzRGlzYWJsZWQgJiYgcHJldlByb3BzLmlzRGlzYWJsZWQgfHwgLy8gZW5zdXJlIGZvY3VzIGlzIG9uIHRoZSBJbnB1dCB3aGVuIHRoZSBtZW51IG9wZW5zXG4gICAgaXNGb2N1c2VkICYmIG1lbnVJc09wZW4gJiYgIXByZXZQcm9wcy5tZW51SXNPcGVuKSB7XG4gICAgICB0aGlzLmZvY3VzSW5wdXQoKTtcbiAgICB9IC8vIHNjcm9sbCB0aGUgZm9jdXNlZCBvcHRpb24gaW50byB2aWV3IGlmIG5lY2Vzc2FyeVxuXG5cbiAgICBpZiAodGhpcy5tZW51TGlzdFJlZiAmJiB0aGlzLmZvY3VzZWRPcHRpb25SZWYgJiYgdGhpcy5zY3JvbGxUb0ZvY3VzZWRPcHRpb25PblVwZGF0ZSkge1xuICAgICAgc2Nyb2xsSW50b1ZpZXcodGhpcy5tZW51TGlzdFJlZiwgdGhpcy5mb2N1c2VkT3B0aW9uUmVmKTtcbiAgICAgIHRoaXMuc2Nyb2xsVG9Gb2N1c2VkT3B0aW9uT25VcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nQ29tcG9zaXRpb24oKTtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUb1RvdWNoKCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5vblNjcm9sbCwgdHJ1ZSk7XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIENvbnN1bWVyIEhhbmRsZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBfcHJvdG8ub25NZW51T3BlbiA9IGZ1bmN0aW9uIG9uTWVudU9wZW4oKSB7XG4gICAgdGhpcy5wcm9wcy5vbk1lbnVPcGVuKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVudUNsb3NlID0gZnVuY3Rpb24gb25NZW51Q2xvc2UoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzMTAgPSB0aGlzLnByb3BzLFxuICAgICAgICBpc1NlYXJjaGFibGUgPSBfdGhpcyRwcm9wczEwLmlzU2VhcmNoYWJsZSxcbiAgICAgICAgaXNNdWx0aSA9IF90aGlzJHByb3BzMTAuaXNNdWx0aTtcbiAgICB0aGlzLmFubm91bmNlQXJpYUxpdmVDb250ZXh0KHtcbiAgICAgIGV2ZW50OiAnaW5wdXQnLFxuICAgICAgY29udGV4dDoge1xuICAgICAgICBpc1NlYXJjaGFibGU6IGlzU2VhcmNoYWJsZSxcbiAgICAgICAgaXNNdWx0aTogaXNNdWx0aVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub25JbnB1dENoYW5nZSgnJywge1xuICAgICAgYWN0aW9uOiAnbWVudS1jbG9zZSdcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLm9uTWVudUNsb3NlKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiBvbklucHV0Q2hhbmdlKG5ld1ZhbHVlLCBhY3Rpb25NZXRhKSB7XG4gICAgdGhpcy5wcm9wcy5vbklucHV0Q2hhbmdlKG5ld1ZhbHVlLCBhY3Rpb25NZXRhKTtcbiAgfSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gTWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgO1xuXG4gIF9wcm90by5mb2N1c0lucHV0ID0gZnVuY3Rpb24gZm9jdXNJbnB1dCgpIHtcbiAgICBpZiAoIXRoaXMuaW5wdXRSZWYpIHJldHVybjtcbiAgICB0aGlzLmlucHV0UmVmLmZvY3VzKCk7XG4gIH07XG5cbiAgX3Byb3RvLmJsdXJJbnB1dCA9IGZ1bmN0aW9uIGJsdXJJbnB1dCgpIHtcbiAgICBpZiAoIXRoaXMuaW5wdXRSZWYpIHJldHVybjtcbiAgICB0aGlzLmlucHV0UmVmLmJsdXIoKTtcbiAgfSAvLyBhbGlhc2VkIGZvciBjb25zdW1lcnNcbiAgO1xuXG4gIF9wcm90by5vcGVuTWVudSA9IGZ1bmN0aW9uIG9wZW5NZW51KGZvY3VzT3B0aW9uKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkc3RhdGUzID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgc2VsZWN0VmFsdWUgPSBfdGhpcyRzdGF0ZTMuc2VsZWN0VmFsdWUsXG4gICAgICAgIGlzRm9jdXNlZCA9IF90aGlzJHN0YXRlMy5pc0ZvY3VzZWQ7XG4gICAgdmFyIG1lbnVPcHRpb25zID0gdGhpcy5idWlsZE1lbnVPcHRpb25zKHRoaXMucHJvcHMsIHNlbGVjdFZhbHVlKTtcbiAgICB2YXIgaXNNdWx0aSA9IHRoaXMucHJvcHMuaXNNdWx0aTtcbiAgICB2YXIgb3BlbkF0SW5kZXggPSBmb2N1c09wdGlvbiA9PT0gJ2ZpcnN0JyA/IDAgOiBtZW51T3B0aW9ucy5mb2N1c2FibGUubGVuZ3RoIC0gMTtcblxuICAgIGlmICghaXNNdWx0aSkge1xuICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSBtZW51T3B0aW9ucy5mb2N1c2FibGUuaW5kZXhPZihzZWxlY3RWYWx1ZVswXSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgb3BlbkF0SW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgfVxuICAgIH0gLy8gb25seSBzY3JvbGwgaWYgdGhlIG1lbnUgaXNuJ3QgYWxyZWFkeSBvcGVuXG5cblxuICAgIHRoaXMuc2Nyb2xsVG9Gb2N1c2VkT3B0aW9uT25VcGRhdGUgPSAhKGlzRm9jdXNlZCAmJiB0aGlzLm1lbnVMaXN0UmVmKTtcbiAgICB0aGlzLmlucHV0SXNIaWRkZW5BZnRlclVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbWVudU9wdGlvbnM6IG1lbnVPcHRpb25zLFxuICAgICAgZm9jdXNlZFZhbHVlOiBudWxsLFxuICAgICAgZm9jdXNlZE9wdGlvbjogbWVudU9wdGlvbnMuZm9jdXNhYmxlW29wZW5BdEluZGV4XVxuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5vbk1lbnVPcGVuKCk7XG5cbiAgICAgIF90aGlzMi5hbm5vdW5jZUFyaWFMaXZlQ29udGV4dCh7XG4gICAgICAgIGV2ZW50OiAnbWVudSdcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5mb2N1c1ZhbHVlID0gZnVuY3Rpb24gZm9jdXNWYWx1ZShkaXJlY3Rpb24pIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMxMSA9IHRoaXMucHJvcHMsXG4gICAgICAgIGlzTXVsdGkgPSBfdGhpcyRwcm9wczExLmlzTXVsdGksXG4gICAgICAgIGlzU2VhcmNoYWJsZSA9IF90aGlzJHByb3BzMTEuaXNTZWFyY2hhYmxlO1xuICAgIHZhciBfdGhpcyRzdGF0ZTQgPSB0aGlzLnN0YXRlLFxuICAgICAgICBzZWxlY3RWYWx1ZSA9IF90aGlzJHN0YXRlNC5zZWxlY3RWYWx1ZSxcbiAgICAgICAgZm9jdXNlZFZhbHVlID0gX3RoaXMkc3RhdGU0LmZvY3VzZWRWYWx1ZTsgLy8gT25seSBtdWx0aXNlbGVjdHMgc3VwcG9ydCB2YWx1ZSBmb2N1c2luZ1xuXG4gICAgaWYgKCFpc011bHRpKSByZXR1cm47XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmb2N1c2VkT3B0aW9uOiBudWxsXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzZWRJbmRleCA9IHNlbGVjdFZhbHVlLmluZGV4T2YoZm9jdXNlZFZhbHVlKTtcblxuICAgIGlmICghZm9jdXNlZFZhbHVlKSB7XG4gICAgICBmb2N1c2VkSW5kZXggPSAtMTtcbiAgICAgIHRoaXMuYW5ub3VuY2VBcmlhTGl2ZUNvbnRleHQoe1xuICAgICAgICBldmVudDogJ3ZhbHVlJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3RJbmRleCA9IHNlbGVjdFZhbHVlLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5leHRGb2N1cyA9IC0xO1xuICAgIGlmICghc2VsZWN0VmFsdWUubGVuZ3RoKSByZXR1cm47XG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAncHJldmlvdXMnOlxuICAgICAgICBpZiAoZm9jdXNlZEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgLy8gZG9uJ3QgY3ljbGUgZnJvbSB0aGUgc3RhcnQgdG8gdGhlIGVuZFxuICAgICAgICAgIG5leHRGb2N1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9jdXNlZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIC8vIGlmIG5vdGhpbmcgaXMgZm9jdXNlZCwgZm9jdXMgdGhlIGxhc3QgdmFsdWUgZmlyc3RcbiAgICAgICAgICBuZXh0Rm9jdXMgPSBsYXN0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dEZvY3VzID0gZm9jdXNlZEluZGV4IC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgaWYgKGZvY3VzZWRJbmRleCA+IC0xICYmIGZvY3VzZWRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICAgIG5leHRGb2N1cyA9IGZvY3VzZWRJbmRleCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAobmV4dEZvY3VzID09PSAtMSkge1xuICAgICAgdGhpcy5hbm5vdW5jZUFyaWFMaXZlQ29udGV4dCh7XG4gICAgICAgIGV2ZW50OiAnaW5wdXQnLFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgaXNTZWFyY2hhYmxlOiBpc1NlYXJjaGFibGUsXG4gICAgICAgICAgaXNNdWx0aTogaXNNdWx0aVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlucHV0SXNIaWRkZW46IG5leHRGb2N1cyAhPT0gLTEsXG4gICAgICBmb2N1c2VkVmFsdWU6IHNlbGVjdFZhbHVlW25leHRGb2N1c11cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZm9jdXNPcHRpb24gPSBmdW5jdGlvbiBmb2N1c09wdGlvbihkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGRpcmVjdGlvbiA9ICdmaXJzdCc7XG4gICAgfVxuXG4gICAgdmFyIHBhZ2VTaXplID0gdGhpcy5wcm9wcy5wYWdlU2l6ZTtcbiAgICB2YXIgX3RoaXMkc3RhdGU1ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgZm9jdXNlZE9wdGlvbiA9IF90aGlzJHN0YXRlNS5mb2N1c2VkT3B0aW9uLFxuICAgICAgICBtZW51T3B0aW9ucyA9IF90aGlzJHN0YXRlNS5tZW51T3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IG1lbnVPcHRpb25zLmZvY3VzYWJsZTtcbiAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKSByZXR1cm47XG4gICAgdmFyIG5leHRGb2N1cyA9IDA7IC8vIGhhbmRsZXMgJ2ZpcnN0J1xuXG4gICAgdmFyIGZvY3VzZWRJbmRleCA9IG9wdGlvbnMuaW5kZXhPZihmb2N1c2VkT3B0aW9uKTtcblxuICAgIGlmICghZm9jdXNlZE9wdGlvbikge1xuICAgICAgZm9jdXNlZEluZGV4ID0gLTE7XG4gICAgICB0aGlzLmFubm91bmNlQXJpYUxpdmVDb250ZXh0KHtcbiAgICAgICAgZXZlbnQ6ICdtZW51J1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3VwJykge1xuICAgICAgbmV4dEZvY3VzID0gZm9jdXNlZEluZGV4ID4gMCA/IGZvY3VzZWRJbmRleCAtIDEgOiBvcHRpb25zLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgbmV4dEZvY3VzID0gKGZvY3VzZWRJbmRleCArIDEpICUgb3B0aW9ucy5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdwYWdldXAnKSB7XG4gICAgICBuZXh0Rm9jdXMgPSBmb2N1c2VkSW5kZXggLSBwYWdlU2l6ZTtcbiAgICAgIGlmIChuZXh0Rm9jdXMgPCAwKSBuZXh0Rm9jdXMgPSAwO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncGFnZWRvd24nKSB7XG4gICAgICBuZXh0Rm9jdXMgPSBmb2N1c2VkSW5kZXggKyBwYWdlU2l6ZTtcbiAgICAgIGlmIChuZXh0Rm9jdXMgPiBvcHRpb25zLmxlbmd0aCAtIDEpIG5leHRGb2N1cyA9IG9wdGlvbnMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xhc3QnKSB7XG4gICAgICBuZXh0Rm9jdXMgPSBvcHRpb25zLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxUb0ZvY3VzZWRPcHRpb25PblVwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmb2N1c2VkT3B0aW9uOiBvcHRpb25zW25leHRGb2N1c10sXG4gICAgICBmb2N1c2VkVmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICB0aGlzLmFubm91bmNlQXJpYUxpdmVDb250ZXh0KHtcbiAgICAgIGV2ZW50OiAnbWVudScsXG4gICAgICBjb250ZXh0OiB7XG4gICAgICAgIGlzRGlzYWJsZWQ6IGlzT3B0aW9uRGlzYWJsZWQob3B0aW9uc1tuZXh0Rm9jdXNdKVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBHZXR0ZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBfcHJvdG8uZ2V0VGhlbWUgPSBmdW5jdGlvbiBnZXRUaGVtZSgpIHtcbiAgICAvLyBVc2UgdGhlIGRlZmF1bHQgdGhlbWUgaWYgdGhlcmUgYXJlIG5vIGN1c3RvbWl6YXRpb25zLlxuICAgIGlmICghdGhpcy5wcm9wcy50aGVtZSkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRUaGVtZTtcbiAgICB9IC8vIElmIHRoZSB0aGVtZSBwcm9wIGlzIGEgZnVuY3Rpb24sIGFzc3VtZSB0aGUgZnVuY3Rpb25cbiAgICAvLyBrbm93cyBob3cgdG8gbWVyZ2UgdGhlIHBhc3NlZC1pbiBkZWZhdWx0IHRoZW1lIHdpdGhcbiAgICAvLyBpdHMgb3duIG1vZGlmaWNhdGlvbnMuXG5cblxuICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy50aGVtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMudGhlbWUoZGVmYXVsdFRoZW1lKTtcbiAgICB9IC8vIE90aGVyd2lzZSwgaWYgYSBwbGFpbiB0aGVtZSBvYmplY3Qgd2FzIHBhc3NlZCBpbixcbiAgICAvLyBvdmVybGF5IGl0IHdpdGggdGhlIGRlZmF1bHQgdGhlbWUuXG5cblxuICAgIHJldHVybiBfZXh0ZW5kcyQ0KHt9LCBkZWZhdWx0VGhlbWUsIHRoaXMucHJvcHMudGhlbWUpO1xuICB9O1xuXG4gIF9wcm90by5nZXRDb21tb25Qcm9wcyA9IGZ1bmN0aW9uIGdldENvbW1vblByb3BzKCkge1xuICAgIHZhciBjbGVhclZhbHVlID0gdGhpcy5jbGVhclZhbHVlLFxuICAgICAgICBnZXRTdHlsZXMgPSB0aGlzLmdldFN0eWxlcyxcbiAgICAgICAgc2V0VmFsdWUgPSB0aGlzLnNldFZhbHVlLFxuICAgICAgICBzZWxlY3RPcHRpb24gPSB0aGlzLnNlbGVjdE9wdGlvbixcbiAgICAgICAgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjbGFzc05hbWVQcmVmaXggPSBwcm9wcy5jbGFzc05hbWVQcmVmaXgsXG4gICAgICAgIGlzTXVsdGkgPSBwcm9wcy5pc011bHRpLFxuICAgICAgICBpc1J0bCA9IHByb3BzLmlzUnRsLFxuICAgICAgICBvcHRpb25zID0gcHJvcHMub3B0aW9ucztcbiAgICB2YXIgc2VsZWN0VmFsdWUgPSB0aGlzLnN0YXRlLnNlbGVjdFZhbHVlO1xuICAgIHZhciBoYXNWYWx1ZSA9IHRoaXMuaGFzVmFsdWUoKTtcblxuICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdFZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgY3ggPSBjbGFzc05hbWVzLmJpbmQobnVsbCwgY2xhc3NOYW1lUHJlZml4KTtcbiAgICByZXR1cm4ge1xuICAgICAgY3g6IGN4LFxuICAgICAgY2xlYXJWYWx1ZTogY2xlYXJWYWx1ZSxcbiAgICAgIGdldFN0eWxlczogZ2V0U3R5bGVzLFxuICAgICAgZ2V0VmFsdWU6IGdldFZhbHVlLFxuICAgICAgaGFzVmFsdWU6IGhhc1ZhbHVlLFxuICAgICAgaXNNdWx0aTogaXNNdWx0aSxcbiAgICAgIGlzUnRsOiBpc1J0bCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBzZWxlY3RPcHRpb246IHNlbGVjdE9wdGlvbixcbiAgICAgIHNldFZhbHVlOiBzZXRWYWx1ZSxcbiAgICAgIHNlbGVjdFByb3BzOiBwcm9wcyxcbiAgICAgIHRoZW1lOiB0aGlzLmdldFRoZW1lKClcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXROZXh0Rm9jdXNlZFZhbHVlID0gZnVuY3Rpb24gZ2V0TmV4dEZvY3VzZWRWYWx1ZShuZXh0U2VsZWN0VmFsdWUpIHtcbiAgICBpZiAodGhpcy5jbGVhckZvY3VzVmFsdWVPblVwZGF0ZSkge1xuICAgICAgdGhpcy5jbGVhckZvY3VzVmFsdWVPblVwZGF0ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHN0YXRlNiA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGZvY3VzZWRWYWx1ZSA9IF90aGlzJHN0YXRlNi5mb2N1c2VkVmFsdWUsXG4gICAgICAgIGxhc3RTZWxlY3RWYWx1ZSA9IF90aGlzJHN0YXRlNi5zZWxlY3RWYWx1ZTtcbiAgICB2YXIgbGFzdEZvY3VzZWRJbmRleCA9IGxhc3RTZWxlY3RWYWx1ZS5pbmRleE9mKGZvY3VzZWRWYWx1ZSk7XG5cbiAgICBpZiAobGFzdEZvY3VzZWRJbmRleCA+IC0xKSB7XG4gICAgICB2YXIgbmV4dEZvY3VzZWRJbmRleCA9IG5leHRTZWxlY3RWYWx1ZS5pbmRleE9mKGZvY3VzZWRWYWx1ZSk7XG5cbiAgICAgIGlmIChuZXh0Rm9jdXNlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgLy8gdGhlIGZvY3VzZWQgdmFsdWUgaXMgc3RpbGwgaW4gdGhlIHNlbGVjdFZhbHVlLCByZXR1cm4gaXRcbiAgICAgICAgcmV0dXJuIGZvY3VzZWRWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdEZvY3VzZWRJbmRleCA8IG5leHRTZWxlY3RWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gdGhlIGZvY3VzZWRWYWx1ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgbmV4dCBzZWxlY3RWYWx1ZSBhcnJheSBieVxuICAgICAgICAvLyByZWZlcmVuY2UsIHNvIHJldHVybiB0aGUgbmV3IHZhbHVlIGF0IHRoZSBzYW1lIGluZGV4XG4gICAgICAgIHJldHVybiBuZXh0U2VsZWN0VmFsdWVbbGFzdEZvY3VzZWRJbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmdldE5leHRGb2N1c2VkT3B0aW9uID0gZnVuY3Rpb24gZ2V0TmV4dEZvY3VzZWRPcHRpb24ob3B0aW9ucykge1xuICAgIHZhciBsYXN0Rm9jdXNlZE9wdGlvbiA9IHRoaXMuc3RhdGUuZm9jdXNlZE9wdGlvbjtcbiAgICByZXR1cm4gbGFzdEZvY3VzZWRPcHRpb24gJiYgb3B0aW9ucy5pbmRleE9mKGxhc3RGb2N1c2VkT3B0aW9uKSA+IC0xID8gbGFzdEZvY3VzZWRPcHRpb24gOiBvcHRpb25zWzBdO1xuICB9O1xuXG4gIF9wcm90by5oYXNWYWx1ZSA9IGZ1bmN0aW9uIGhhc1ZhbHVlKCkge1xuICAgIHZhciBzZWxlY3RWYWx1ZSA9IHRoaXMuc3RhdGUuc2VsZWN0VmFsdWU7XG4gICAgcmV0dXJuIHNlbGVjdFZhbHVlLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgX3Byb3RvLmhhc09wdGlvbnMgPSBmdW5jdGlvbiBoYXNPcHRpb25zKCkge1xuICAgIHJldHVybiAhIXRoaXMuc3RhdGUubWVudU9wdGlvbnMucmVuZGVyLmxlbmd0aDtcbiAgfTtcblxuICBfcHJvdG8uY291bnRPcHRpb25zID0gZnVuY3Rpb24gY291bnRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm1lbnVPcHRpb25zLmZvY3VzYWJsZS5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLmlzQ2xlYXJhYmxlID0gZnVuY3Rpb24gaXNDbGVhcmFibGUoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzMTIgPSB0aGlzLnByb3BzLFxuICAgICAgICBpc0NsZWFyYWJsZSA9IF90aGlzJHByb3BzMTIuaXNDbGVhcmFibGUsXG4gICAgICAgIGlzTXVsdGkgPSBfdGhpcyRwcm9wczEyLmlzTXVsdGk7IC8vIHNpbmdsZSBzZWxlY3QsIGJ5IGRlZmF1bHQsIElTIE5PVCBjbGVhcmFibGVcbiAgICAvLyBtdWx0aSBzZWxlY3QsIGJ5IGRlZmF1bHQsIElTIGNsZWFyYWJsZVxuXG4gICAgaWYgKGlzQ2xlYXJhYmxlID09PSB1bmRlZmluZWQpIHJldHVybiBpc011bHRpO1xuICAgIHJldHVybiBpc0NsZWFyYWJsZTtcbiAgfTtcblxuICBfcHJvdG8uaXNPcHRpb25EaXNhYmxlZCA9IGZ1bmN0aW9uIGlzT3B0aW9uRGlzYWJsZWQob3B0aW9uLCBzZWxlY3RWYWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wcm9wcy5pc09wdGlvbkRpc2FibGVkID09PSAnZnVuY3Rpb24nID8gdGhpcy5wcm9wcy5pc09wdGlvbkRpc2FibGVkKG9wdGlvbiwgc2VsZWN0VmFsdWUpIDogZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmlzT3B0aW9uU2VsZWN0ZWQgPSBmdW5jdGlvbiBpc09wdGlvblNlbGVjdGVkKG9wdGlvbiwgc2VsZWN0VmFsdWUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGlmIChzZWxlY3RWYWx1ZS5pbmRleE9mKG9wdGlvbikgPiAtMSkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuaXNPcHRpb25TZWxlY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaXNPcHRpb25TZWxlY3RlZChvcHRpb24sIHNlbGVjdFZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgY2FuZGlkYXRlID0gdGhpcy5nZXRPcHRpb25WYWx1ZShvcHRpb24pO1xuICAgIHJldHVybiBzZWxlY3RWYWx1ZS5zb21lKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLmdldE9wdGlvblZhbHVlKGkpID09PSBjYW5kaWRhdGU7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmZpbHRlck9wdGlvbiA9IGZ1bmN0aW9uIGZpbHRlck9wdGlvbihvcHRpb24sIGlucHV0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5maWx0ZXJPcHRpb24gPyB0aGlzLnByb3BzLmZpbHRlck9wdGlvbihvcHRpb24sIGlucHV0VmFsdWUpIDogdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0T3B0aW9uTGFiZWwgPSBmdW5jdGlvbiBmb3JtYXRPcHRpb25MYWJlbChkYXRhLCBjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLmZvcm1hdE9wdGlvbkxhYmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaW5wdXRWYWx1ZSA9IHRoaXMucHJvcHMuaW5wdXRWYWx1ZTtcbiAgICAgIHZhciBzZWxlY3RWYWx1ZSA9IHRoaXMuc3RhdGUuc2VsZWN0VmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5mb3JtYXRPcHRpb25MYWJlbChkYXRhLCB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgIHNlbGVjdFZhbHVlOiBzZWxlY3RWYWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbkxhYmVsKGRhdGEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0R3JvdXBMYWJlbCA9IGZ1bmN0aW9uIGZvcm1hdEdyb3VwTGFiZWwoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmZvcm1hdEdyb3VwTGFiZWwoZGF0YSk7XG4gIH0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIE1vdXNlIEhhbmRsZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICA7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIENvbXBvc2l0aW9uIEhhbmRsZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBfcHJvdG8uc3RhcnRMaXN0ZW5pbmdDb21wb3NpdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuaW5nQ29tcG9zaXRpb24oKSB7XG4gICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCB0aGlzLm9uQ29tcG9zaXRpb25TdGFydCwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCB0aGlzLm9uQ29tcG9zaXRpb25FbmQsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnN0b3BMaXN0ZW5pbmdDb21wb3NpdGlvbiA9IGZ1bmN0aW9uIHN0b3BMaXN0ZW5pbmdDb21wb3NpdGlvbigpIHtcbiAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIHRoaXMub25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgdGhpcy5vbkNvbXBvc2l0aW9uRW5kKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRvdWNoIEhhbmRsZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBfcHJvdG8uc3RhcnRMaXN0ZW5pbmdUb1RvdWNoID0gZnVuY3Rpb24gc3RhcnRMaXN0ZW5pbmdUb1RvdWNoKCkge1xuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zdG9wTGlzdGVuaW5nVG9Ub3VjaCA9IGZ1bmN0aW9uIHN0b3BMaXN0ZW5pbmdUb1RvdWNoKCkge1xuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCk7XG4gICAgfVxuICB9O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBSZW5kZXJlcnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIF9wcm90by5jb25zdHJ1Y3RBcmlhTGl2ZU1lc3NhZ2UgPSBmdW5jdGlvbiBjb25zdHJ1Y3RBcmlhTGl2ZU1lc3NhZ2UoKSB7XG4gICAgdmFyIF90aGlzJHN0YXRlNyA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGFyaWFMaXZlQ29udGV4dCA9IF90aGlzJHN0YXRlNy5hcmlhTGl2ZUNvbnRleHQsXG4gICAgICAgIHNlbGVjdFZhbHVlID0gX3RoaXMkc3RhdGU3LnNlbGVjdFZhbHVlLFxuICAgICAgICBmb2N1c2VkVmFsdWUgPSBfdGhpcyRzdGF0ZTcuZm9jdXNlZFZhbHVlLFxuICAgICAgICBmb2N1c2VkT3B0aW9uID0gX3RoaXMkc3RhdGU3LmZvY3VzZWRPcHRpb247XG4gICAgdmFyIF90aGlzJHByb3BzMTMgPSB0aGlzLnByb3BzLFxuICAgICAgICBvcHRpb25zID0gX3RoaXMkcHJvcHMxMy5vcHRpb25zLFxuICAgICAgICBtZW51SXNPcGVuID0gX3RoaXMkcHJvcHMxMy5tZW51SXNPcGVuLFxuICAgICAgICBpbnB1dFZhbHVlID0gX3RoaXMkcHJvcHMxMy5pbnB1dFZhbHVlLFxuICAgICAgICBzY3JlZW5SZWFkZXJTdGF0dXMgPSBfdGhpcyRwcm9wczEzLnNjcmVlblJlYWRlclN0YXR1czsgLy8gQW4gYXJpYSBsaXZlIG1lc3NhZ2UgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50bHkgZm9jdXNlZCB2YWx1ZSBpbiB0aGUgc2VsZWN0LlxuXG4gICAgdmFyIGZvY3VzZWRWYWx1ZU1zZyA9IGZvY3VzZWRWYWx1ZSA/IHZhbHVlRm9jdXNBcmlhTWVzc2FnZSh7XG4gICAgICBmb2N1c2VkVmFsdWU6IGZvY3VzZWRWYWx1ZSxcbiAgICAgIGdldE9wdGlvbkxhYmVsOiB0aGlzLmdldE9wdGlvbkxhYmVsLFxuICAgICAgc2VsZWN0VmFsdWU6IHNlbGVjdFZhbHVlXG4gICAgfSkgOiAnJzsgLy8gQW4gYXJpYSBsaXZlIG1lc3NhZ2UgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBvcHRpb24gaW4gdGhlIHNlbGVjdC5cblxuICAgIHZhciBmb2N1c2VkT3B0aW9uTXNnID0gZm9jdXNlZE9wdGlvbiAmJiBtZW51SXNPcGVuID8gb3B0aW9uRm9jdXNBcmlhTWVzc2FnZSh7XG4gICAgICBmb2N1c2VkT3B0aW9uOiBmb2N1c2VkT3B0aW9uLFxuICAgICAgZ2V0T3B0aW9uTGFiZWw6IHRoaXMuZ2V0T3B0aW9uTGFiZWwsXG4gICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSkgOiAnJzsgLy8gQW4gYXJpYSBsaXZlIG1lc3NhZ2UgcmVwcmVzZW50aW5nIHRoZSBzZXQgb2YgZm9jdXNhYmxlIHJlc3VsdHMgYW5kIGN1cnJlbnQgc2VhcmNodGVybS9pbnB1dHZhbHVlLlxuXG4gICAgdmFyIHJlc3VsdHNNc2cgPSByZXN1bHRzQXJpYU1lc3NhZ2Uoe1xuICAgICAgaW5wdXRWYWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgIHNjcmVlblJlYWRlck1lc3NhZ2U6IHNjcmVlblJlYWRlclN0YXR1cyh7XG4gICAgICAgIGNvdW50OiB0aGlzLmNvdW50T3B0aW9ucygpXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBmb2N1c2VkVmFsdWVNc2cgKyBcIiBcIiArIGZvY3VzZWRPcHRpb25Nc2cgKyBcIiBcIiArIHJlc3VsdHNNc2cgKyBcIiBcIiArIGFyaWFMaXZlQ29udGV4dDtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVySW5wdXQgPSBmdW5jdGlvbiByZW5kZXJJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMxNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIGlzRGlzYWJsZWQgPSBfdGhpcyRwcm9wczE0LmlzRGlzYWJsZWQsXG4gICAgICAgIGlzU2VhcmNoYWJsZSA9IF90aGlzJHByb3BzMTQuaXNTZWFyY2hhYmxlLFxuICAgICAgICBpbnB1dElkID0gX3RoaXMkcHJvcHMxNC5pbnB1dElkLFxuICAgICAgICBpbnB1dFZhbHVlID0gX3RoaXMkcHJvcHMxNC5pbnB1dFZhbHVlLFxuICAgICAgICB0YWJJbmRleCA9IF90aGlzJHByb3BzMTQudGFiSW5kZXg7XG4gICAgdmFyIElucHV0ID0gdGhpcy5jb21wb25lbnRzLklucHV0O1xuICAgIHZhciBpbnB1dElzSGlkZGVuID0gdGhpcy5zdGF0ZS5pbnB1dElzSGlkZGVuO1xuICAgIHZhciBpZCA9IGlucHV0SWQgfHwgdGhpcy5nZXRFbGVtZW50SWQoJ2lucHV0Jyk7IC8vIGFyaWEgYXR0cmlidXRlcyBtYWtlcyB0aGUgSlNYIFwibm9pc3lcIiwgc2VwYXJhdGVkIGZvciBjbGFyaXR5XG5cbiAgICB2YXIgYXJpYUF0dHJpYnV0ZXMgPSB7XG4gICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCcsXG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMucHJvcHNbJ2FyaWEtbGFiZWwnXSxcbiAgICAgICdhcmlhLWxhYmVsbGVkYnknOiB0aGlzLnByb3BzWydhcmlhLWxhYmVsbGVkYnknXVxuICAgIH07XG5cbiAgICBpZiAoIWlzU2VhcmNoYWJsZSkge1xuICAgICAgLy8gdXNlIGEgZHVtbXkgaW5wdXQgdG8gbWFpbnRhaW4gZm9jdXMvYmx1ciBmdW5jdGlvbmFsaXR5XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEdW1teUlucHV0LCBfZXh0ZW5kcyQ0KHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBpbm5lclJlZjogdGhpcy5nZXRJbnB1dFJlZixcbiAgICAgICAgb25CbHVyOiB0aGlzLm9uSW5wdXRCbHVyLFxuICAgICAgICBvbkNoYW5nZTogbm9vcCxcbiAgICAgICAgb25Gb2N1czogdGhpcy5vbklucHV0Rm9jdXMsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgfSwgYXJpYUF0dHJpYnV0ZXMpKTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkY29tbW9uUHJvcHMgPSB0aGlzLmNvbW1vblByb3BzLFxuICAgICAgICBjeCA9IF90aGlzJGNvbW1vblByb3BzLmN4LFxuICAgICAgICB0aGVtZSA9IF90aGlzJGNvbW1vblByb3BzLnRoZW1lLFxuICAgICAgICBzZWxlY3RQcm9wcyA9IF90aGlzJGNvbW1vblByb3BzLnNlbGVjdFByb3BzO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KElucHV0LCBfZXh0ZW5kcyQ0KHtcbiAgICAgIGF1dG9DYXBpdGFsaXplOiBcIm5vbmVcIixcbiAgICAgIGF1dG9Db21wbGV0ZTogXCJvZmZcIixcbiAgICAgIGF1dG9Db3JyZWN0OiBcIm9mZlwiLFxuICAgICAgY3g6IGN4LFxuICAgICAgZ2V0U3R5bGVzOiB0aGlzLmdldFN0eWxlcyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlubmVyUmVmOiB0aGlzLmdldElucHV0UmVmLFxuICAgICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgIGlzSGlkZGVuOiBpbnB1dElzSGlkZGVuLFxuICAgICAgb25CbHVyOiB0aGlzLm9uSW5wdXRCbHVyLFxuICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgICBvbkZvY3VzOiB0aGlzLm9uSW5wdXRGb2N1cyxcbiAgICAgIHNlbGVjdFByb3BzOiBzZWxlY3RQcm9wcyxcbiAgICAgIHNwZWxsQ2hlY2s6IFwiZmFsc2VcIixcbiAgICAgIHRhYkluZGV4OiB0YWJJbmRleCxcbiAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICB9LCBhcmlhQXR0cmlidXRlcykpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJQbGFjZWhvbGRlck9yVmFsdWUgPSBmdW5jdGlvbiByZW5kZXJQbGFjZWhvbGRlck9yVmFsdWUoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cyxcbiAgICAgICAgTXVsdGlWYWx1ZSA9IF90aGlzJGNvbXBvbmVudHMuTXVsdGlWYWx1ZSxcbiAgICAgICAgTXVsdGlWYWx1ZUNvbnRhaW5lciA9IF90aGlzJGNvbXBvbmVudHMuTXVsdGlWYWx1ZUNvbnRhaW5lcixcbiAgICAgICAgTXVsdGlWYWx1ZUxhYmVsID0gX3RoaXMkY29tcG9uZW50cy5NdWx0aVZhbHVlTGFiZWwsXG4gICAgICAgIE11bHRpVmFsdWVSZW1vdmUgPSBfdGhpcyRjb21wb25lbnRzLk11bHRpVmFsdWVSZW1vdmUsXG4gICAgICAgIFNpbmdsZVZhbHVlID0gX3RoaXMkY29tcG9uZW50cy5TaW5nbGVWYWx1ZSxcbiAgICAgICAgUGxhY2Vob2xkZXIgPSBfdGhpcyRjb21wb25lbnRzLlBsYWNlaG9sZGVyO1xuICAgIHZhciBjb21tb25Qcm9wcyA9IHRoaXMuY29tbW9uUHJvcHM7XG4gICAgdmFyIF90aGlzJHByb3BzMTUgPSB0aGlzLnByb3BzLFxuICAgICAgICBjb250cm9sU2hvdWxkUmVuZGVyVmFsdWUgPSBfdGhpcyRwcm9wczE1LmNvbnRyb2xTaG91bGRSZW5kZXJWYWx1ZSxcbiAgICAgICAgaXNEaXNhYmxlZCA9IF90aGlzJHByb3BzMTUuaXNEaXNhYmxlZCxcbiAgICAgICAgaXNNdWx0aSA9IF90aGlzJHByb3BzMTUuaXNNdWx0aSxcbiAgICAgICAgaW5wdXRWYWx1ZSA9IF90aGlzJHByb3BzMTUuaW5wdXRWYWx1ZSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBfdGhpcyRwcm9wczE1LnBsYWNlaG9sZGVyO1xuICAgIHZhciBfdGhpcyRzdGF0ZTggPSB0aGlzLnN0YXRlLFxuICAgICAgICBzZWxlY3RWYWx1ZSA9IF90aGlzJHN0YXRlOC5zZWxlY3RWYWx1ZSxcbiAgICAgICAgZm9jdXNlZFZhbHVlID0gX3RoaXMkc3RhdGU4LmZvY3VzZWRWYWx1ZSxcbiAgICAgICAgaXNGb2N1c2VkID0gX3RoaXMkc3RhdGU4LmlzRm9jdXNlZDtcblxuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpIHx8ICFjb250cm9sU2hvdWxkUmVuZGVyVmFsdWUpIHtcbiAgICAgIHJldHVybiBpbnB1dFZhbHVlID8gbnVsbCA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGxhY2Vob2xkZXIsIF9leHRlbmRzJDQoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICAgIGtleTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICBpc0ZvY3VzZWQ6IGlzRm9jdXNlZFxuICAgICAgfSksIHBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgdmFyIHNlbGVjdFZhbHVlcyA9IHNlbGVjdFZhbHVlLm1hcChmdW5jdGlvbiAob3B0LCBpbmRleCkge1xuICAgICAgICB2YXIgaXNPcHRpb25Gb2N1c2VkID0gb3B0ID09PSBmb2N1c2VkVmFsdWU7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE11bHRpVmFsdWUsIF9leHRlbmRzJDQoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgQ29udGFpbmVyOiBNdWx0aVZhbHVlQ29udGFpbmVyLFxuICAgICAgICAgICAgTGFiZWw6IE11bHRpVmFsdWVMYWJlbCxcbiAgICAgICAgICAgIFJlbW92ZTogTXVsdGlWYWx1ZVJlbW92ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNGb2N1c2VkOiBpc09wdGlvbkZvY3VzZWQsXG4gICAgICAgICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgICBrZXk6IF90aGlzNC5nZXRPcHRpb25WYWx1ZShvcHQpLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICByZW1vdmVQcm9wczoge1xuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5yZW1vdmVWYWx1ZShvcHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uVG91Y2hFbmQ6IGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQucmVtb3ZlVmFsdWUob3B0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhOiBvcHRcbiAgICAgICAgfSksIF90aGlzNC5mb3JtYXRPcHRpb25MYWJlbChvcHQsICd2YWx1ZScpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlbGVjdFZhbHVlcztcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHNpbmdsZVZhbHVlID0gc2VsZWN0VmFsdWVbMF07XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2luZ2xlVmFsdWUsIF9leHRlbmRzJDQoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICBkYXRhOiBzaW5nbGVWYWx1ZSxcbiAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWRcbiAgICB9KSwgdGhpcy5mb3JtYXRPcHRpb25MYWJlbChzaW5nbGVWYWx1ZSwgJ3ZhbHVlJykpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJDbGVhckluZGljYXRvciA9IGZ1bmN0aW9uIHJlbmRlckNsZWFySW5kaWNhdG9yKCkge1xuICAgIHZhciBDbGVhckluZGljYXRvciA9IHRoaXMuY29tcG9uZW50cy5DbGVhckluZGljYXRvcjtcbiAgICB2YXIgY29tbW9uUHJvcHMgPSB0aGlzLmNvbW1vblByb3BzO1xuICAgIHZhciBfdGhpcyRwcm9wczE2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgaXNEaXNhYmxlZCA9IF90aGlzJHByb3BzMTYuaXNEaXNhYmxlZCxcbiAgICAgICAgaXNMb2FkaW5nID0gX3RoaXMkcHJvcHMxNi5pc0xvYWRpbmc7XG4gICAgdmFyIGlzRm9jdXNlZCA9IHRoaXMuc3RhdGUuaXNGb2N1c2VkO1xuXG4gICAgaWYgKCF0aGlzLmlzQ2xlYXJhYmxlKCkgfHwgIUNsZWFySW5kaWNhdG9yIHx8IGlzRGlzYWJsZWQgfHwgIXRoaXMuaGFzVmFsdWUoKSB8fCBpc0xvYWRpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbm5lclByb3BzID0ge1xuICAgICAgb25Nb3VzZURvd246IHRoaXMub25DbGVhckluZGljYXRvck1vdXNlRG93bixcbiAgICAgIG9uVG91Y2hFbmQ6IHRoaXMub25DbGVhckluZGljYXRvclRvdWNoRW5kLFxuICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnXG4gICAgfTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDbGVhckluZGljYXRvciwgX2V4dGVuZHMkNCh7fSwgY29tbW9uUHJvcHMsIHtcbiAgICAgIGlubmVyUHJvcHM6IGlubmVyUHJvcHMsXG4gICAgICBpc0ZvY3VzZWQ6IGlzRm9jdXNlZFxuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyTG9hZGluZ0luZGljYXRvciA9IGZ1bmN0aW9uIHJlbmRlckxvYWRpbmdJbmRpY2F0b3IoKSB7XG4gICAgdmFyIExvYWRpbmdJbmRpY2F0b3IgPSB0aGlzLmNvbXBvbmVudHMuTG9hZGluZ0luZGljYXRvcjtcbiAgICB2YXIgY29tbW9uUHJvcHMgPSB0aGlzLmNvbW1vblByb3BzO1xuICAgIHZhciBfdGhpcyRwcm9wczE3ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgaXNEaXNhYmxlZCA9IF90aGlzJHByb3BzMTcuaXNEaXNhYmxlZCxcbiAgICAgICAgaXNMb2FkaW5nID0gX3RoaXMkcHJvcHMxNy5pc0xvYWRpbmc7XG4gICAgdmFyIGlzRm9jdXNlZCA9IHRoaXMuc3RhdGUuaXNGb2N1c2VkO1xuICAgIGlmICghTG9hZGluZ0luZGljYXRvciB8fCAhaXNMb2FkaW5nKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgaW5uZXJQcm9wcyA9IHtcbiAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJ1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTG9hZGluZ0luZGljYXRvciwgX2V4dGVuZHMkNCh7fSwgY29tbW9uUHJvcHMsIHtcbiAgICAgIGlubmVyUHJvcHM6IGlubmVyUHJvcHMsXG4gICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgaXNGb2N1c2VkOiBpc0ZvY3VzZWRcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlckluZGljYXRvclNlcGFyYXRvciA9IGZ1bmN0aW9uIHJlbmRlckluZGljYXRvclNlcGFyYXRvcigpIHtcbiAgICB2YXIgX3RoaXMkY29tcG9uZW50czIgPSB0aGlzLmNvbXBvbmVudHMsXG4gICAgICAgIERyb3Bkb3duSW5kaWNhdG9yID0gX3RoaXMkY29tcG9uZW50czIuRHJvcGRvd25JbmRpY2F0b3IsXG4gICAgICAgIEluZGljYXRvclNlcGFyYXRvciA9IF90aGlzJGNvbXBvbmVudHMyLkluZGljYXRvclNlcGFyYXRvcjsgLy8gc2VwYXJhdG9yIGRvZXNuJ3QgbWFrZSBzZW5zZSB3aXRob3V0IHRoZSBkcm9wZG93biBpbmRpY2F0b3JcblxuICAgIGlmICghRHJvcGRvd25JbmRpY2F0b3IgfHwgIUluZGljYXRvclNlcGFyYXRvcikgcmV0dXJuIG51bGw7XG4gICAgdmFyIGNvbW1vblByb3BzID0gdGhpcy5jb21tb25Qcm9wcztcbiAgICB2YXIgaXNEaXNhYmxlZCA9IHRoaXMucHJvcHMuaXNEaXNhYmxlZDtcbiAgICB2YXIgaXNGb2N1c2VkID0gdGhpcy5zdGF0ZS5pc0ZvY3VzZWQ7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5kaWNhdG9yU2VwYXJhdG9yLCBfZXh0ZW5kcyQ0KHt9LCBjb21tb25Qcm9wcywge1xuICAgICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgIGlzRm9jdXNlZDogaXNGb2N1c2VkXG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJEcm9wZG93bkluZGljYXRvciA9IGZ1bmN0aW9uIHJlbmRlckRyb3Bkb3duSW5kaWNhdG9yKCkge1xuICAgIHZhciBEcm9wZG93bkluZGljYXRvciA9IHRoaXMuY29tcG9uZW50cy5Ecm9wZG93bkluZGljYXRvcjtcbiAgICBpZiAoIURyb3Bkb3duSW5kaWNhdG9yKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgY29tbW9uUHJvcHMgPSB0aGlzLmNvbW1vblByb3BzO1xuICAgIHZhciBpc0Rpc2FibGVkID0gdGhpcy5wcm9wcy5pc0Rpc2FibGVkO1xuICAgIHZhciBpc0ZvY3VzZWQgPSB0aGlzLnN0YXRlLmlzRm9jdXNlZDtcbiAgICB2YXIgaW5uZXJQcm9wcyA9IHtcbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLm9uRHJvcGRvd25JbmRpY2F0b3JNb3VzZURvd24sXG4gICAgICBvblRvdWNoRW5kOiB0aGlzLm9uRHJvcGRvd25JbmRpY2F0b3JUb3VjaEVuZCxcbiAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJ1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25JbmRpY2F0b3IsIF9leHRlbmRzJDQoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICBpbm5lclByb3BzOiBpbm5lclByb3BzLFxuICAgICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgIGlzRm9jdXNlZDogaXNGb2N1c2VkXG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJNZW51ID0gZnVuY3Rpb24gcmVuZGVyTWVudSgpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciBfdGhpcyRjb21wb25lbnRzMyA9IHRoaXMuY29tcG9uZW50cyxcbiAgICAgICAgR3JvdXAgPSBfdGhpcyRjb21wb25lbnRzMy5Hcm91cCxcbiAgICAgICAgR3JvdXBIZWFkaW5nID0gX3RoaXMkY29tcG9uZW50czMuR3JvdXBIZWFkaW5nLFxuICAgICAgICBNZW51ID0gX3RoaXMkY29tcG9uZW50czMuTWVudSxcbiAgICAgICAgTWVudUxpc3QgPSBfdGhpcyRjb21wb25lbnRzMy5NZW51TGlzdCxcbiAgICAgICAgTWVudVBvcnRhbCA9IF90aGlzJGNvbXBvbmVudHMzLk1lbnVQb3J0YWwsXG4gICAgICAgIExvYWRpbmdNZXNzYWdlID0gX3RoaXMkY29tcG9uZW50czMuTG9hZGluZ01lc3NhZ2UsXG4gICAgICAgIE5vT3B0aW9uc01lc3NhZ2UgPSBfdGhpcyRjb21wb25lbnRzMy5Ob09wdGlvbnNNZXNzYWdlLFxuICAgICAgICBPcHRpb24gPSBfdGhpcyRjb21wb25lbnRzMy5PcHRpb247XG4gICAgdmFyIGNvbW1vblByb3BzID0gdGhpcy5jb21tb25Qcm9wcztcbiAgICB2YXIgX3RoaXMkc3RhdGU5ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgZm9jdXNlZE9wdGlvbiA9IF90aGlzJHN0YXRlOS5mb2N1c2VkT3B0aW9uLFxuICAgICAgICBtZW51T3B0aW9ucyA9IF90aGlzJHN0YXRlOS5tZW51T3B0aW9ucztcbiAgICB2YXIgX3RoaXMkcHJvcHMxOCA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNhcHR1cmVNZW51U2Nyb2xsID0gX3RoaXMkcHJvcHMxOC5jYXB0dXJlTWVudVNjcm9sbCxcbiAgICAgICAgaW5wdXRWYWx1ZSA9IF90aGlzJHByb3BzMTguaW5wdXRWYWx1ZSxcbiAgICAgICAgaXNMb2FkaW5nID0gX3RoaXMkcHJvcHMxOC5pc0xvYWRpbmcsXG4gICAgICAgIGxvYWRpbmdNZXNzYWdlID0gX3RoaXMkcHJvcHMxOC5sb2FkaW5nTWVzc2FnZSxcbiAgICAgICAgbWluTWVudUhlaWdodCA9IF90aGlzJHByb3BzMTgubWluTWVudUhlaWdodCxcbiAgICAgICAgbWF4TWVudUhlaWdodCA9IF90aGlzJHByb3BzMTgubWF4TWVudUhlaWdodCxcbiAgICAgICAgbWVudUlzT3BlbiA9IF90aGlzJHByb3BzMTgubWVudUlzT3BlbixcbiAgICAgICAgbWVudVBsYWNlbWVudCA9IF90aGlzJHByb3BzMTgubWVudVBsYWNlbWVudCxcbiAgICAgICAgbWVudVBvc2l0aW9uID0gX3RoaXMkcHJvcHMxOC5tZW51UG9zaXRpb24sXG4gICAgICAgIG1lbnVQb3J0YWxUYXJnZXQgPSBfdGhpcyRwcm9wczE4Lm1lbnVQb3J0YWxUYXJnZXQsXG4gICAgICAgIG1lbnVTaG91bGRCbG9ja1Njcm9sbCA9IF90aGlzJHByb3BzMTgubWVudVNob3VsZEJsb2NrU2Nyb2xsLFxuICAgICAgICBtZW51U2hvdWxkU2Nyb2xsSW50b1ZpZXcgPSBfdGhpcyRwcm9wczE4Lm1lbnVTaG91bGRTY3JvbGxJbnRvVmlldyxcbiAgICAgICAgbm9PcHRpb25zTWVzc2FnZSA9IF90aGlzJHByb3BzMTgubm9PcHRpb25zTWVzc2FnZSxcbiAgICAgICAgb25NZW51U2Nyb2xsVG9Ub3AgPSBfdGhpcyRwcm9wczE4Lm9uTWVudVNjcm9sbFRvVG9wLFxuICAgICAgICBvbk1lbnVTY3JvbGxUb0JvdHRvbSA9IF90aGlzJHByb3BzMTgub25NZW51U2Nyb2xsVG9Cb3R0b207XG4gICAgaWYgKCFtZW51SXNPcGVuKSByZXR1cm4gbnVsbDsgLy8gVE9ETzogSW50ZXJuYWwgT3B0aW9uIFR5cGUgaGVyZVxuXG4gICAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihwcm9wcykge1xuICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlLCB0aGUgbWVudSBvcHRpb25zIGluIHN0YXRlIGFyZW4ndCBjaGFuZ2VkIHdoZW4gdGhlXG4gICAgICAvLyBmb2N1c2VkIG9wdGlvbiBjaGFuZ2VzIHNvIHdlIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHByb3BzIGJhc2VkIG9uIHRoYXRcbiAgICAgIHZhciBpc0ZvY3VzZWQgPSBmb2N1c2VkT3B0aW9uID09PSBwcm9wcy5kYXRhO1xuICAgICAgcHJvcHMuaW5uZXJSZWYgPSBpc0ZvY3VzZWQgPyBfdGhpczUuZ2V0Rm9jdXNlZE9wdGlvblJlZiA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE9wdGlvbiwgX2V4dGVuZHMkNCh7fSwgY29tbW9uUHJvcHMsIHByb3BzLCB7XG4gICAgICAgIGlzRm9jdXNlZDogaXNGb2N1c2VkXG4gICAgICB9KSwgX3RoaXM1LmZvcm1hdE9wdGlvbkxhYmVsKHByb3BzLmRhdGEsICdtZW51JykpO1xuICAgIH07XG5cbiAgICB2YXIgbWVudVVJO1xuXG4gICAgaWYgKHRoaXMuaGFzT3B0aW9ucygpKSB7XG4gICAgICBtZW51VUkgPSBtZW51T3B0aW9ucy5yZW5kZXIubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGl0ZW0udHlwZSxcbiAgICAgICAgICAgICAgZ3JvdXAgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSQyKGl0ZW0sIFtcInR5cGVcIl0pO1xuXG4gICAgICAgICAgdmFyIGhlYWRpbmdJZCA9IGl0ZW0ua2V5ICsgXCItaGVhZGluZ1wiO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEdyb3VwLCBfZXh0ZW5kcyQ0KHt9LCBjb21tb25Qcm9wcywgZ3JvdXAsIHtcbiAgICAgICAgICAgIEhlYWRpbmc6IEdyb3VwSGVhZGluZyxcbiAgICAgICAgICAgIGhlYWRpbmdQcm9wczoge1xuICAgICAgICAgICAgICBpZDogaGVhZGluZ0lkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFiZWw6IF90aGlzNS5mb3JtYXRHcm91cExhYmVsKGl0ZW0uZGF0YSlcbiAgICAgICAgICB9KSwgaXRlbS5vcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyKG9wdGlvbik7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzTG9hZGluZykge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBsb2FkaW5nTWVzc2FnZSh7XG4gICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgbWVudVVJID0gUmVhY3QuY3JlYXRlRWxlbWVudChMb2FkaW5nTWVzc2FnZSwgY29tbW9uUHJvcHMsIG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX21lc3NhZ2UgPSBub09wdGlvbnNNZXNzYWdlKHtcbiAgICAgICAgaW5wdXRWYWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChfbWVzc2FnZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICBtZW51VUkgPSBSZWFjdC5jcmVhdGVFbGVtZW50KE5vT3B0aW9uc01lc3NhZ2UsIGNvbW1vblByb3BzLCBfbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdmFyIG1lbnVQbGFjZW1lbnRQcm9wcyA9IHtcbiAgICAgIG1pbk1lbnVIZWlnaHQ6IG1pbk1lbnVIZWlnaHQsXG4gICAgICBtYXhNZW51SGVpZ2h0OiBtYXhNZW51SGVpZ2h0LFxuICAgICAgbWVudVBsYWNlbWVudDogbWVudVBsYWNlbWVudCxcbiAgICAgIG1lbnVQb3NpdGlvbjogbWVudVBvc2l0aW9uLFxuICAgICAgbWVudVNob3VsZFNjcm9sbEludG9WaWV3OiBtZW51U2hvdWxkU2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xuICAgIHZhciBtZW51RWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVudVBsYWNlciwgX2V4dGVuZHMkNCh7fSwgY29tbW9uUHJvcHMsIG1lbnVQbGFjZW1lbnRQcm9wcyksIGZ1bmN0aW9uIChfcmVmOCkge1xuICAgICAgdmFyIHJlZiA9IF9yZWY4LnJlZixcbiAgICAgICAgICBfcmVmOCRwbGFjZXJQcm9wcyA9IF9yZWY4LnBsYWNlclByb3BzLFxuICAgICAgICAgIHBsYWNlbWVudCA9IF9yZWY4JHBsYWNlclByb3BzLnBsYWNlbWVudCxcbiAgICAgICAgICBtYXhIZWlnaHQgPSBfcmVmOCRwbGFjZXJQcm9wcy5tYXhIZWlnaHQ7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNZW51LCBfZXh0ZW5kcyQ0KHt9LCBjb21tb25Qcm9wcywgbWVudVBsYWNlbWVudFByb3BzLCB7XG4gICAgICAgIGlubmVyUmVmOiByZWYsXG4gICAgICAgIGlubmVyUHJvcHM6IHtcbiAgICAgICAgICBvbk1vdXNlRG93bjogX3RoaXM1Lm9uTWVudU1vdXNlRG93bixcbiAgICAgICAgICBvbk1vdXNlTW92ZTogX3RoaXM1Lm9uTWVudU1vdXNlTW92ZVxuICAgICAgICB9LFxuICAgICAgICBpc0xvYWRpbmc6IGlzTG9hZGluZyxcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFNjcm9sbENhcHRvclN3aXRjaCwge1xuICAgICAgICBpc0VuYWJsZWQ6IGNhcHR1cmVNZW51U2Nyb2xsLFxuICAgICAgICBvblRvcEFycml2ZTogb25NZW51U2Nyb2xsVG9Ub3AsXG4gICAgICAgIG9uQm90dG9tQXJyaXZlOiBvbk1lbnVTY3JvbGxUb0JvdHRvbVxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChTY3JvbGxCbG9jaywge1xuICAgICAgICBpc0VuYWJsZWQ6IG1lbnVTaG91bGRCbG9ja1Njcm9sbFxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChNZW51TGlzdCwgX2V4dGVuZHMkNCh7fSwgY29tbW9uUHJvcHMsIHtcbiAgICAgICAgaW5uZXJSZWY6IF90aGlzNS5nZXRNZW51TGlzdFJlZixcbiAgICAgICAgaXNMb2FkaW5nOiBpc0xvYWRpbmcsXG4gICAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0XG4gICAgICB9KSwgbWVudVVJKSkpKTtcbiAgICB9KTsgLy8gcG9zaXRpb25pbmcgYmVoYXZpb3VyIGlzIGFsbW9zdCBpZGVudGljYWwgZm9yIHBvcnRhbGxlZCBhbmQgZml4ZWQsXG4gICAgLy8gc28gd2UgdXNlIHRoZSBzYW1lIGNvbXBvbmVudC4gdGhlIGFjdHVhbCBwb3J0YWxsaW5nIGxvZ2ljIGlzIGZvcmtlZFxuICAgIC8vIHdpdGhpbiB0aGUgY29tcG9uZW50IGJhc2VkIG9uIGBtZW51UG9zaXRpb25gXG5cbiAgICByZXR1cm4gbWVudVBvcnRhbFRhcmdldCB8fCBtZW51UG9zaXRpb24gPT09ICdmaXhlZCcgPyBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbnVQb3J0YWwsIF9leHRlbmRzJDQoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICBhcHBlbmRUbzogbWVudVBvcnRhbFRhcmdldCxcbiAgICAgIGNvbnRyb2xFbGVtZW50OiB0aGlzLmNvbnRyb2xSZWYsXG4gICAgICBtZW51UGxhY2VtZW50OiBtZW51UGxhY2VtZW50LFxuICAgICAgbWVudVBvc2l0aW9uOiBtZW51UG9zaXRpb25cbiAgICB9KSwgbWVudUVsZW1lbnQpIDogbWVudUVsZW1lbnQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlckZvcm1GaWVsZCA9IGZ1bmN0aW9uIHJlbmRlckZvcm1GaWVsZCgpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciBfdGhpcyRwcm9wczE5ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZGVsaW1pdGVyID0gX3RoaXMkcHJvcHMxOS5kZWxpbWl0ZXIsXG4gICAgICAgIGlzRGlzYWJsZWQgPSBfdGhpcyRwcm9wczE5LmlzRGlzYWJsZWQsXG4gICAgICAgIGlzTXVsdGkgPSBfdGhpcyRwcm9wczE5LmlzTXVsdGksXG4gICAgICAgIG5hbWUgPSBfdGhpcyRwcm9wczE5Lm5hbWU7XG4gICAgdmFyIHNlbGVjdFZhbHVlID0gdGhpcy5zdGF0ZS5zZWxlY3RWYWx1ZTtcbiAgICBpZiAoIW5hbWUgfHwgaXNEaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgaWYgKGlzTXVsdGkpIHtcbiAgICAgIGlmIChkZWxpbWl0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc2VsZWN0VmFsdWUubWFwKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM2LmdldE9wdGlvblZhbHVlKG9wdCk7XG4gICAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB0eXBlOiBcImhpZGRlblwiLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHNlbGVjdFZhbHVlLmxlbmd0aCA+IDAgPyBzZWxlY3RWYWx1ZS5tYXAoZnVuY3Rpb24gKG9wdCwgaSkge1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAga2V5OiBcImktXCIgKyBpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3RoaXM2LmdldE9wdGlvblZhbHVlKG9wdClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdHlwZTogXCJoaWRkZW5cIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgaW5wdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3ZhbHVlMiA9IHNlbGVjdFZhbHVlWzBdID8gdGhpcy5nZXRPcHRpb25WYWx1ZShzZWxlY3RWYWx1ZVswXSkgOiAnJztcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IFwiaGlkZGVuXCIsXG4gICAgICAgIHZhbHVlOiBfdmFsdWUyXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlckxpdmVSZWdpb24gPSBmdW5jdGlvbiByZW5kZXJMaXZlUmVnaW9uKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc0ZvY3VzZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEExMXlUZXh0LCB7XG4gICAgICBcImFyaWEtbGl2ZVwiOiBcInBvbGl0ZVwiXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwge1xuICAgICAgaWQ6IFwiYXJpYS1zZWxlY3Rpb24tZXZlbnRcIlxuICAgIH0sIFwiXFx4QTBcIiwgdGhpcy5zdGF0ZS5hcmlhTGl2ZVNlbGVjdGlvbiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgIGlkOiBcImFyaWEtY29udGV4dFwiXG4gICAgfSwgXCJcXHhBMFwiLCB0aGlzLmNvbnN0cnVjdEFyaWFMaXZlTWVzc2FnZSgpKSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkY29tcG9uZW50czQgPSB0aGlzLmNvbXBvbmVudHMsXG4gICAgICAgIENvbnRyb2wgPSBfdGhpcyRjb21wb25lbnRzNC5Db250cm9sLFxuICAgICAgICBJbmRpY2F0b3JzQ29udGFpbmVyID0gX3RoaXMkY29tcG9uZW50czQuSW5kaWNhdG9yc0NvbnRhaW5lcixcbiAgICAgICAgU2VsZWN0Q29udGFpbmVyID0gX3RoaXMkY29tcG9uZW50czQuU2VsZWN0Q29udGFpbmVyLFxuICAgICAgICBWYWx1ZUNvbnRhaW5lciA9IF90aGlzJGNvbXBvbmVudHM0LlZhbHVlQ29udGFpbmVyO1xuICAgIHZhciBfdGhpcyRwcm9wczIwID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMyMC5jbGFzc05hbWUsXG4gICAgICAgIGlkID0gX3RoaXMkcHJvcHMyMC5pZCxcbiAgICAgICAgaXNEaXNhYmxlZCA9IF90aGlzJHByb3BzMjAuaXNEaXNhYmxlZCxcbiAgICAgICAgbWVudUlzT3BlbiA9IF90aGlzJHByb3BzMjAubWVudUlzT3BlbjtcbiAgICB2YXIgaXNGb2N1c2VkID0gdGhpcy5zdGF0ZS5pc0ZvY3VzZWQ7XG4gICAgdmFyIGNvbW1vblByb3BzID0gdGhpcy5jb21tb25Qcm9wcyA9IHRoaXMuZ2V0Q29tbW9uUHJvcHMoKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3RDb250YWluZXIsIF9leHRlbmRzJDQoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIGlubmVyUHJvcHM6IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBvbktleURvd246IHRoaXMub25LZXlEb3duXG4gICAgICB9LFxuICAgICAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgIGlzRm9jdXNlZDogaXNGb2N1c2VkXG4gICAgfSksIHRoaXMucmVuZGVyTGl2ZVJlZ2lvbigpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRyb2wsIF9leHRlbmRzJDQoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICBpbm5lclJlZjogdGhpcy5nZXRDb250cm9sUmVmLFxuICAgICAgaW5uZXJQcm9wczoge1xuICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5vbkNvbnRyb2xNb3VzZURvd24sXG4gICAgICAgIG9uVG91Y2hFbmQ6IHRoaXMub25Db250cm9sVG91Y2hFbmRcbiAgICAgIH0sXG4gICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgaXNGb2N1c2VkOiBpc0ZvY3VzZWQsXG4gICAgICBtZW51SXNPcGVuOiBtZW51SXNPcGVuXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVmFsdWVDb250YWluZXIsIF9leHRlbmRzJDQoe30sIGNvbW1vblByb3BzLCB7XG4gICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkXG4gICAgfSksIHRoaXMucmVuZGVyUGxhY2Vob2xkZXJPclZhbHVlKCksIHRoaXMucmVuZGVySW5wdXQoKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5kaWNhdG9yc0NvbnRhaW5lciwgX2V4dGVuZHMkNCh7fSwgY29tbW9uUHJvcHMsIHtcbiAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWRcbiAgICB9KSwgdGhpcy5yZW5kZXJDbGVhckluZGljYXRvcigpLCB0aGlzLnJlbmRlckxvYWRpbmdJbmRpY2F0b3IoKSwgdGhpcy5yZW5kZXJJbmRpY2F0b3JTZXBhcmF0b3IoKSwgdGhpcy5yZW5kZXJEcm9wZG93bkluZGljYXRvcigpKSksIHRoaXMucmVuZGVyTWVudSgpLCB0aGlzLnJlbmRlckZvcm1GaWVsZCgpKTtcbiAgfTtcblxuICByZXR1cm4gU2VsZWN0O1xufShDb21wb25lbnQpO1xuXG5TZWxlY3QuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5leHBvcnQgeyBTZWxlY3QgYXMgUywgZGVmYXVsdFRoZW1lIGFzIGEsIGNyZWF0ZUZpbHRlciBhcyBjLCBkZWZhdWx0UHJvcHMgYXMgZCwgbWVyZ2VTdHlsZXMgYXMgbSB9O1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMsIENsYXNzTmFtZXMgfSBmcm9tICdAZW1vdGlvbi9jb3JlJztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZyBhcyBnZXRCb3VuZGluZ0NsaWVudE9iaiwgYSBhcyBnZXRTY3JvbGxQYXJlbnQsIGIgYXMgZ2V0U2Nyb2xsVG9wLCBjIGFzIGFuaW1hdGVkU2Nyb2xsVG8sIHMgYXMgc2Nyb2xsVG8gfSBmcm9tICcuL3V0aWxzLTA2YjBkNWE0LmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCBfY3NzIGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgQXV0b3NpemVJbnB1dCBmcm9tICdyZWFjdC1pbnB1dC1hdXRvc2l6ZSc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuZnVuY3Rpb24gZ2V0TWVudVBsYWNlbWVudChfcmVmKSB7XG4gIHZhciBtYXhIZWlnaHQgPSBfcmVmLm1heEhlaWdodCxcbiAgICAgIG1lbnVFbCA9IF9yZWYubWVudUVsLFxuICAgICAgbWluSGVpZ2h0ID0gX3JlZi5taW5IZWlnaHQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudCxcbiAgICAgIHNob3VsZFNjcm9sbCA9IF9yZWYuc2hvdWxkU2Nyb2xsLFxuICAgICAgaXNGaXhlZFBvc2l0aW9uID0gX3JlZi5pc0ZpeGVkUG9zaXRpb24sXG4gICAgICB0aGVtZSA9IF9yZWYudGhlbWU7XG4gIHZhciBzcGFjaW5nID0gdGhlbWUuc3BhY2luZztcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChtZW51RWwpO1xuICB2YXIgZGVmYXVsdFN0YXRlID0ge1xuICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHRcbiAgfTsgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmcsIHJldHVybiBkZWZhdWx0IHN0YXRlXG5cbiAgaWYgKCFtZW51RWwgfHwgIW1lbnVFbC5vZmZzZXRQYXJlbnQpIHJldHVybiBkZWZhdWx0U3RhdGU7IC8vIHdlIGNhbid0IHRydXN0IGBzY3JvbGxQYXJlbnQuc2Nyb2xsSGVpZ2h0YCAtLT4gaXQgbWF5IGluY3JlYXNlIHdoZW5cbiAgLy8gdGhlIG1lbnUgaXMgcmVuZGVyZWRcblxuICB2YXIgX3Njcm9sbFBhcmVudCRnZXRCb3VuID0gc2Nyb2xsUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgc2Nyb2xsSGVpZ2h0ID0gX3Njcm9sbFBhcmVudCRnZXRCb3VuLmhlaWdodDtcblxuICB2YXIgX21lbnVFbCRnZXRCb3VuZGluZ0NsID0gbWVudUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgbWVudUJvdHRvbSA9IF9tZW51RWwkZ2V0Qm91bmRpbmdDbC5ib3R0b20sXG4gICAgICBtZW51SGVpZ2h0ID0gX21lbnVFbCRnZXRCb3VuZGluZ0NsLmhlaWdodCxcbiAgICAgIG1lbnVUb3AgPSBfbWVudUVsJGdldEJvdW5kaW5nQ2wudG9wO1xuXG4gIHZhciBfbWVudUVsJG9mZnNldFBhcmVudCQgPSBtZW51RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29udGFpbmVyVG9wID0gX21lbnVFbCRvZmZzZXRQYXJlbnQkLnRvcDtcblxuICB2YXIgdmlld0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbFRvcChzY3JvbGxQYXJlbnQpO1xuICB2YXIgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShtZW51RWwpLm1hcmdpbkJvdHRvbSwgMTApO1xuICB2YXIgbWFyZ2luVG9wID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShtZW51RWwpLm1hcmdpblRvcCwgMTApO1xuICB2YXIgdmlld1NwYWNlQWJvdmUgPSBjb250YWluZXJUb3AgLSBtYXJnaW5Ub3A7XG4gIHZhciB2aWV3U3BhY2VCZWxvdyA9IHZpZXdIZWlnaHQgLSBtZW51VG9wO1xuICB2YXIgc2Nyb2xsU3BhY2VBYm92ZSA9IHZpZXdTcGFjZUFib3ZlICsgc2Nyb2xsVG9wO1xuICB2YXIgc2Nyb2xsU3BhY2VCZWxvdyA9IHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCAtIG1lbnVUb3A7XG4gIHZhciBzY3JvbGxEb3duID0gbWVudUJvdHRvbSAtIHZpZXdIZWlnaHQgKyBzY3JvbGxUb3AgKyBtYXJnaW5Cb3R0b207XG4gIHZhciBzY3JvbGxVcCA9IHNjcm9sbFRvcCArIG1lbnVUb3AgLSBtYXJnaW5Ub3A7XG4gIHZhciBzY3JvbGxEdXJhdGlvbiA9IDE2MDtcblxuICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgIGNhc2UgJ2F1dG8nOlxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAvLyAxOiB0aGUgbWVudSB3aWxsIGZpdCwgZG8gbm90aGluZ1xuICAgICAgaWYgKHZpZXdTcGFjZUJlbG93ID49IG1lbnVIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9IC8vIDI6IHRoZSBtZW51IHdpbGwgZml0LCBpZiBzY3JvbGxlZFxuXG5cbiAgICAgIGlmIChzY3JvbGxTcGFjZUJlbG93ID49IG1lbnVIZWlnaHQgJiYgIWlzRml4ZWRQb3NpdGlvbikge1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICAgICAgYW5pbWF0ZWRTY3JvbGxUbyhzY3JvbGxQYXJlbnQsIHNjcm9sbERvd24sIHNjcm9sbER1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodFxuICAgICAgICB9O1xuICAgICAgfSAvLyAzOiB0aGUgbWVudSB3aWxsIGZpdCwgaWYgY29uc3RyYWluZWRcblxuXG4gICAgICBpZiAoIWlzRml4ZWRQb3NpdGlvbiAmJiBzY3JvbGxTcGFjZUJlbG93ID49IG1pbkhlaWdodCB8fCBpc0ZpeGVkUG9zaXRpb24gJiYgdmlld1NwYWNlQmVsb3cgPj0gbWluSGVpZ2h0KSB7XG4gICAgICAgIGlmIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgICBhbmltYXRlZFNjcm9sbFRvKHNjcm9sbFBhcmVudCwgc2Nyb2xsRG93biwgc2Nyb2xsRHVyYXRpb24pO1xuICAgICAgICB9IC8vIHdlIHdhbnQgdG8gcHJvdmlkZSBhcyBtdWNoIG9mIHRoZSBtZW51IGFzIHBvc3NpYmxlIHRvIHRoZSB1c2VyLFxuICAgICAgICAvLyBzbyBnaXZlIHRoZW0gd2hhdGV2ZXIgaXMgYXZhaWxhYmxlIGJlbG93IHJhdGhlciB0aGFuIHRoZSBtaW5IZWlnaHQuXG5cblxuICAgICAgICB2YXIgY29uc3RyYWluZWRIZWlnaHQgPSBpc0ZpeGVkUG9zaXRpb24gPyB2aWV3U3BhY2VCZWxvdyAtIG1hcmdpbkJvdHRvbSA6IHNjcm9sbFNwYWNlQmVsb3cgLSBtYXJnaW5Cb3R0b207XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgICAgICBtYXhIZWlnaHQ6IGNvbnN0cmFpbmVkSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9IC8vIDQuIEZvcmtlZCBiZXZpb3VyIHdoZW4gdGhlcmUgaXNuJ3QgZW5vdWdoIHNwYWNlIGJlbG93XG4gICAgICAvLyBBVVRPOiBmbGlwIHRoZSBtZW51LCByZW5kZXIgYWJvdmVcblxuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAnYXV0bycgfHwgaXNGaXhlZFBvc2l0aW9uKSB7XG4gICAgICAgIC8vIG1heSBuZWVkIHRvIGJlIGNvbnN0cmFpbmVkIGFmdGVyIGZsaXBwaW5nXG4gICAgICAgIHZhciBfY29uc3RyYWluZWRIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgIHZhciBzcGFjZUFib3ZlID0gaXNGaXhlZFBvc2l0aW9uID8gdmlld1NwYWNlQWJvdmUgOiBzY3JvbGxTcGFjZUFib3ZlO1xuXG4gICAgICAgIGlmIChzcGFjZUFib3ZlID49IG1pbkhlaWdodCkge1xuICAgICAgICAgIF9jb25zdHJhaW5lZEhlaWdodCA9IE1hdGgubWluKHNwYWNlQWJvdmUgLSBtYXJnaW5Cb3R0b20gLSBzcGFjaW5nLmNvbnRyb2xIZWlnaHQsIG1heEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICAgICAgbWF4SGVpZ2h0OiBfY29uc3RyYWluZWRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gQk9UVE9NOiBhbGxvdyBicm93c2VyIHRvIGluY3JlYXNlIHNjcm9sbGFibGUgYXJlYSBhbmQgaW1tZWRpYXRlbHkgc2V0IHNjcm9sbFxuXG5cbiAgICAgIGlmIChwbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgICAgIHNjcm9sbFRvKHNjcm9sbFBhcmVudCwgc2Nyb2xsRG93bik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvcCc6XG4gICAgICAvLyAxOiB0aGUgbWVudSB3aWxsIGZpdCwgZG8gbm90aGluZ1xuICAgICAgaWYgKHZpZXdTcGFjZUFib3ZlID49IG1lbnVIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9IC8vIDI6IHRoZSBtZW51IHdpbGwgZml0LCBpZiBzY3JvbGxlZFxuXG5cbiAgICAgIGlmIChzY3JvbGxTcGFjZUFib3ZlID49IG1lbnVIZWlnaHQgJiYgIWlzRml4ZWRQb3NpdGlvbikge1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICAgICAgYW5pbWF0ZWRTY3JvbGxUbyhzY3JvbGxQYXJlbnQsIHNjcm9sbFVwLCBzY3JvbGxEdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICAgICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gMzogdGhlIG1lbnUgd2lsbCBmaXQsIGlmIGNvbnN0cmFpbmVkXG5cblxuICAgICAgaWYgKCFpc0ZpeGVkUG9zaXRpb24gJiYgc2Nyb2xsU3BhY2VBYm92ZSA+PSBtaW5IZWlnaHQgfHwgaXNGaXhlZFBvc2l0aW9uICYmIHZpZXdTcGFjZUFib3ZlID49IG1pbkhlaWdodCkge1xuICAgICAgICB2YXIgX2NvbnN0cmFpbmVkSGVpZ2h0MiA9IG1heEhlaWdodDsgLy8gd2Ugd2FudCB0byBwcm92aWRlIGFzIG11Y2ggb2YgdGhlIG1lbnUgYXMgcG9zc2libGUgdG8gdGhlIHVzZXIsXG4gICAgICAgIC8vIHNvIGdpdmUgdGhlbSB3aGF0ZXZlciBpcyBhdmFpbGFibGUgYmVsb3cgcmF0aGVyIHRoYW4gdGhlIG1pbkhlaWdodC5cblxuICAgICAgICBpZiAoIWlzRml4ZWRQb3NpdGlvbiAmJiBzY3JvbGxTcGFjZUFib3ZlID49IG1pbkhlaWdodCB8fCBpc0ZpeGVkUG9zaXRpb24gJiYgdmlld1NwYWNlQWJvdmUgPj0gbWluSGVpZ2h0KSB7XG4gICAgICAgICAgX2NvbnN0cmFpbmVkSGVpZ2h0MiA9IGlzRml4ZWRQb3NpdGlvbiA/IHZpZXdTcGFjZUFib3ZlIC0gbWFyZ2luVG9wIDogc2Nyb2xsU3BhY2VBYm92ZSAtIG1hcmdpblRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgICBhbmltYXRlZFNjcm9sbFRvKHNjcm9sbFBhcmVudCwgc2Nyb2xsVXAsIHNjcm9sbER1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICAgICAgICBtYXhIZWlnaHQ6IF9jb25zdHJhaW5lZEhlaWdodDJcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gNC4gbm90IGVub3VnaCBzcGFjZSwgdGhlIGJyb3dzZXIgV0lMTCBOT1QgaW5jcmVhc2Ugc2Nyb2xsYWJsZSBhcmVhIHdoZW5cbiAgICAgIC8vIGFic29sdXRlbHkgcG9zaXRpb25lZCBlbGVtZW50IHJlbmRlcmVkIGFib3ZlIHRoZSB2aWV3cG9ydCAob25seSBiZWxvdykuXG4gICAgICAvLyBGbGlwIHRoZSBtZW51LCByZW5kZXIgYmVsb3dcblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodFxuICAgICAgfTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBsYWNlbWVudCBwcm92aWRlZCBcXFwiXCIgKyBwbGFjZW1lbnQgKyBcIlxcXCIuXCIpO1xuICB9IC8vIGZ1bGZpbCBjb250cmFjdCB3aXRoIGZsb3c6IGltcGxpY2l0IHJldHVybiB2YWx1ZSBvZiB1bmRlZmluZWRcblxuXG4gIHJldHVybiBkZWZhdWx0U3RhdGU7XG59IC8vIE1lbnUgQ29tcG9uZW50XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gYWxpZ25Ub0NvbnRyb2wocGxhY2VtZW50KSB7XG4gIHZhciBwbGFjZW1lbnRUb0NTU1Byb3AgPSB7XG4gICAgYm90dG9tOiAndG9wJyxcbiAgICB0b3A6ICdib3R0b20nXG4gIH07XG4gIHJldHVybiBwbGFjZW1lbnQgPyBwbGFjZW1lbnRUb0NTU1Byb3BbcGxhY2VtZW50XSA6ICdib3R0b20nO1xufVxuXG52YXIgY29lcmNlUGxhY2VtZW50ID0gZnVuY3Rpb24gY29lcmNlUGxhY2VtZW50KHApIHtcbiAgcmV0dXJuIHAgPT09ICdhdXRvJyA/ICdib3R0b20nIDogcDtcbn07XG5cbnZhciBtZW51Q1NTID0gZnVuY3Rpb24gbWVudUNTUyhfcmVmMikge1xuICB2YXIgX3JlZjM7XG5cbiAgdmFyIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIF9yZWYyJHRoZW1lID0gX3JlZjIudGhlbWUsXG4gICAgICBib3JkZXJSYWRpdXMgPSBfcmVmMiR0aGVtZS5ib3JkZXJSYWRpdXMsXG4gICAgICBzcGFjaW5nID0gX3JlZjIkdGhlbWUuc3BhY2luZyxcbiAgICAgIGNvbG9ycyA9IF9yZWYyJHRoZW1lLmNvbG9ycztcbiAgcmV0dXJuIF9yZWYzID0ge1xuICAgIGxhYmVsOiAnbWVudSdcbiAgfSwgX3JlZjNbYWxpZ25Ub0NvbnRyb2wocGxhY2VtZW50KV0gPSAnMTAwJScsIF9yZWYzLmJhY2tncm91bmRDb2xvciA9IGNvbG9ycy5uZXV0cmFsMCwgX3JlZjMuYm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzLCBfcmVmMy5ib3hTaGFkb3cgPSAnMCAwIDAgMXB4IGhzbGEoMCwgMCUsIDAlLCAwLjEpLCAwIDRweCAxMXB4IGhzbGEoMCwgMCUsIDAlLCAwLjEpJywgX3JlZjMubWFyZ2luQm90dG9tID0gc3BhY2luZy5tZW51R3V0dGVyLCBfcmVmMy5tYXJnaW5Ub3AgPSBzcGFjaW5nLm1lbnVHdXR0ZXIsIF9yZWYzLnBvc2l0aW9uID0gJ2Fic29sdXRlJywgX3JlZjMud2lkdGggPSAnMTAwJScsIF9yZWYzLnpJbmRleCA9IDEsIF9yZWYzO1xufTsgLy8gTk9URTogaW50ZXJuYWwgb25seVxuXG52YXIgTWVudVBsYWNlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShNZW51UGxhY2VyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZW51UGxhY2VyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbC5hcHBseShfQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF4SGVpZ2h0OiBfdGhpcy5wcm9wcy5tYXhNZW51SGVpZ2h0LFxuICAgICAgcGxhY2VtZW50OiBudWxsXG4gICAgfTtcblxuICAgIF90aGlzLmdldFBsYWNlbWVudCA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG1pbk1lbnVIZWlnaHQgPSBfdGhpcyRwcm9wcy5taW5NZW51SGVpZ2h0LFxuICAgICAgICAgIG1heE1lbnVIZWlnaHQgPSBfdGhpcyRwcm9wcy5tYXhNZW51SGVpZ2h0LFxuICAgICAgICAgIG1lbnVQbGFjZW1lbnQgPSBfdGhpcyRwcm9wcy5tZW51UGxhY2VtZW50LFxuICAgICAgICAgIG1lbnVQb3NpdGlvbiA9IF90aGlzJHByb3BzLm1lbnVQb3NpdGlvbixcbiAgICAgICAgICBtZW51U2hvdWxkU2Nyb2xsSW50b1ZpZXcgPSBfdGhpcyRwcm9wcy5tZW51U2hvdWxkU2Nyb2xsSW50b1ZpZXcsXG4gICAgICAgICAgdGhlbWUgPSBfdGhpcyRwcm9wcy50aGVtZTtcbiAgICAgIHZhciBnZXRQb3J0YWxQbGFjZW1lbnQgPSBfdGhpcy5jb250ZXh0LmdldFBvcnRhbFBsYWNlbWVudDtcbiAgICAgIGlmICghcmVmKSByZXR1cm47IC8vIERPIE5PVCBzY3JvbGwgaWYgcG9zaXRpb24gaXMgZml4ZWRcblxuICAgICAgdmFyIGlzRml4ZWRQb3NpdGlvbiA9IG1lbnVQb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbiAgICAgIHZhciBzaG91bGRTY3JvbGwgPSBtZW51U2hvdWxkU2Nyb2xsSW50b1ZpZXcgJiYgIWlzRml4ZWRQb3NpdGlvbjtcbiAgICAgIHZhciBzdGF0ZSA9IGdldE1lbnVQbGFjZW1lbnQoe1xuICAgICAgICBtYXhIZWlnaHQ6IG1heE1lbnVIZWlnaHQsXG4gICAgICAgIG1lbnVFbDogcmVmLFxuICAgICAgICBtaW5IZWlnaHQ6IG1pbk1lbnVIZWlnaHQsXG4gICAgICAgIHBsYWNlbWVudDogbWVudVBsYWNlbWVudCxcbiAgICAgICAgc2hvdWxkU2Nyb2xsOiBzaG91bGRTY3JvbGwsXG4gICAgICAgIGlzRml4ZWRQb3NpdGlvbjogaXNGaXhlZFBvc2l0aW9uLFxuICAgICAgICB0aGVtZTogdGhlbWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGdldFBvcnRhbFBsYWNlbWVudCkgZ2V0UG9ydGFsUGxhY2VtZW50KHN0YXRlKTtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRVcGRhdGVkUHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWVudVBsYWNlbWVudCA9IF90aGlzLnByb3BzLm1lbnVQbGFjZW1lbnQ7XG4gICAgICB2YXIgcGxhY2VtZW50ID0gX3RoaXMuc3RhdGUucGxhY2VtZW50IHx8IGNvZXJjZVBsYWNlbWVudChtZW51UGxhY2VtZW50KTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgX3RoaXMucHJvcHMsIHtcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIG1heEhlaWdodDogX3RoaXMuc3RhdGUubWF4SGVpZ2h0XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1lbnVQbGFjZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4oe1xuICAgICAgcmVmOiB0aGlzLmdldFBsYWNlbWVudCxcbiAgICAgIHBsYWNlclByb3BzOiB0aGlzLmdldFVwZGF0ZWRQcm9wcygpXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVQbGFjZXI7XG59KENvbXBvbmVudCk7XG5NZW51UGxhY2VyLmNvbnRleHRUeXBlcyA9IHtcbiAgZ2V0UG9ydGFsUGxhY2VtZW50OiBQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIE1lbnUgPSBmdW5jdGlvbiBNZW51KHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3ggPSBwcm9wcy5jeCxcbiAgICAgIGdldFN0eWxlcyA9IHByb3BzLmdldFN0eWxlcyxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBpbm5lclByb3BzID0gcHJvcHMuaW5uZXJQcm9wcztcbiAgcmV0dXJuIGpzeChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY3NzOiBnZXRTdHlsZXMoJ21lbnUnLCBwcm9wcyksXG4gICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICBtZW51OiB0cnVlXG4gICAgfSwgY2xhc3NOYW1lKVxuICB9LCBpbm5lclByb3BzLCB7XG4gICAgcmVmOiBpbm5lclJlZlxuICB9KSwgY2hpbGRyZW4pO1xufTtcbi8vIE1lbnUgTGlzdFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnZhciBtZW51TGlzdENTUyA9IGZ1bmN0aW9uIG1lbnVMaXN0Q1NTKF9yZWY0KSB7XG4gIHZhciBtYXhIZWlnaHQgPSBfcmVmNC5tYXhIZWlnaHQsXG4gICAgICBiYXNlVW5pdCA9IF9yZWY0LnRoZW1lLnNwYWNpbmcuYmFzZVVuaXQ7XG4gIHJldHVybiB7XG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsXG4gICAgb3ZlcmZsb3dZOiAnYXV0bycsXG4gICAgcGFkZGluZ0JvdHRvbTogYmFzZVVuaXQsXG4gICAgcGFkZGluZ1RvcDogYmFzZVVuaXQsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgLy8gcmVxdWlyZWQgZm9yIG9mZnNldFtIZWlnaHQsIFRvcF0gPiBrZXlib2FyZCBzY3JvbGxcbiAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJ1xuICB9O1xufTtcbnZhciBNZW51TGlzdCA9IGZ1bmN0aW9uIE1lbnVMaXN0KHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3ggPSBwcm9wcy5jeCxcbiAgICAgIGdldFN0eWxlcyA9IHByb3BzLmdldFN0eWxlcyxcbiAgICAgIGlzTXVsdGkgPSBwcm9wcy5pc011bHRpLFxuICAgICAgaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZjtcbiAgcmV0dXJuIGpzeChcImRpdlwiLCB7XG4gICAgY3NzOiBnZXRTdHlsZXMoJ21lbnVMaXN0JywgcHJvcHMpLFxuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgJ21lbnUtbGlzdCc6IHRydWUsXG4gICAgICAnbWVudS1saXN0LS1pcy1tdWx0aSc6IGlzTXVsdGlcbiAgICB9LCBjbGFzc05hbWUpLFxuICAgIHJlZjogaW5uZXJSZWZcbiAgfSwgY2hpbGRyZW4pO1xufTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNZW51IE5vdGljZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgbm90aWNlQ1NTID0gZnVuY3Rpb24gbm90aWNlQ1NTKF9yZWY1KSB7XG4gIHZhciBfcmVmNSR0aGVtZSA9IF9yZWY1LnRoZW1lLFxuICAgICAgYmFzZVVuaXQgPSBfcmVmNSR0aGVtZS5zcGFjaW5nLmJhc2VVbml0LFxuICAgICAgY29sb3JzID0gX3JlZjUkdGhlbWUuY29sb3JzO1xuICByZXR1cm4ge1xuICAgIGNvbG9yOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMiArIFwicHggXCIgKyBiYXNlVW5pdCAqIDMgKyBcInB4XCIsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJ1xuICB9O1xufTtcblxudmFyIG5vT3B0aW9uc01lc3NhZ2VDU1MgPSBub3RpY2VDU1M7XG52YXIgbG9hZGluZ01lc3NhZ2VDU1MgPSBub3RpY2VDU1M7XG52YXIgTm9PcHRpb25zTWVzc2FnZSA9IGZ1bmN0aW9uIE5vT3B0aW9uc01lc3NhZ2UocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjeCA9IHByb3BzLmN4LFxuICAgICAgZ2V0U3R5bGVzID0gcHJvcHMuZ2V0U3R5bGVzLFxuICAgICAgaW5uZXJQcm9wcyA9IHByb3BzLmlubmVyUHJvcHM7XG4gIHJldHVybiBqc3goXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIGNzczogZ2V0U3R5bGVzKCdub09wdGlvbnNNZXNzYWdlJywgcHJvcHMpLFxuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgJ21lbnUtbm90aWNlJzogdHJ1ZSxcbiAgICAgICdtZW51LW5vdGljZS0tbm8tb3B0aW9ucyc6IHRydWVcbiAgICB9LCBjbGFzc05hbWUpXG4gIH0sIGlubmVyUHJvcHMpLCBjaGlsZHJlbik7XG59O1xuTm9PcHRpb25zTWVzc2FnZS5kZWZhdWx0UHJvcHMgPSB7XG4gIGNoaWxkcmVuOiAnTm8gb3B0aW9ucydcbn07XG52YXIgTG9hZGluZ01lc3NhZ2UgPSBmdW5jdGlvbiBMb2FkaW5nTWVzc2FnZShwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGN4ID0gcHJvcHMuY3gsXG4gICAgICBnZXRTdHlsZXMgPSBwcm9wcy5nZXRTdHlsZXMsXG4gICAgICBpbm5lclByb3BzID0gcHJvcHMuaW5uZXJQcm9wcztcbiAgcmV0dXJuIGpzeChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY3NzOiBnZXRTdHlsZXMoJ2xvYWRpbmdNZXNzYWdlJywgcHJvcHMpLFxuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgJ21lbnUtbm90aWNlJzogdHJ1ZSxcbiAgICAgICdtZW51LW5vdGljZS0tbG9hZGluZyc6IHRydWVcbiAgICB9LCBjbGFzc05hbWUpXG4gIH0sIGlubmVyUHJvcHMpLCBjaGlsZHJlbik7XG59O1xuTG9hZGluZ01lc3NhZ2UuZGVmYXVsdFByb3BzID0ge1xuICBjaGlsZHJlbjogJ0xvYWRpbmcuLi4nXG59OyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1lbnUgUG9ydGFsXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudmFyIG1lbnVQb3J0YWxDU1MgPSBmdW5jdGlvbiBtZW51UG9ydGFsQ1NTKF9yZWY2KSB7XG4gIHZhciByZWN0ID0gX3JlZjYucmVjdCxcbiAgICAgIG9mZnNldCA9IF9yZWY2Lm9mZnNldCxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjYucG9zaXRpb247XG4gIHJldHVybiB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICB0b3A6IG9mZnNldCxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICB6SW5kZXg6IDFcbiAgfTtcbn07XG52YXIgTWVudVBvcnRhbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudDIpIHtcbiAgX2luaGVyaXRzTG9vc2UoTWVudVBvcnRhbCwgX0NvbXBvbmVudDIpO1xuXG4gIGZ1bmN0aW9uIE1lbnVQb3J0YWwoKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIF90aGlzMiA9IF9Db21wb25lbnQyLmNhbGwuYXBwbHkoX0NvbXBvbmVudDIsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMyLnN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiBudWxsXG4gICAgfTtcblxuICAgIF90aGlzMi5nZXRQb3J0YWxQbGFjZW1lbnQgPSBmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgIHZhciBwbGFjZW1lbnQgPSBfcmVmNy5wbGFjZW1lbnQ7XG4gICAgICB2YXIgaW5pdGlhbFBsYWNlbWVudCA9IGNvZXJjZVBsYWNlbWVudChfdGhpczIucHJvcHMubWVudVBsYWNlbWVudCk7IC8vIGF2b2lkIHJlLXJlbmRlcnMgaWYgdGhlIHBsYWNlbWVudCBoYXMgbm90IGNoYW5nZWRcblxuICAgICAgaWYgKHBsYWNlbWVudCAhPT0gaW5pdGlhbFBsYWNlbWVudCkge1xuICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBNZW51UG9ydGFsLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UG9ydGFsUGxhY2VtZW50OiB0aGlzLmdldFBvcnRhbFBsYWNlbWVudFxuICAgIH07XG4gIH0gLy8gY2FsbGJhY2sgZm9yIG9jY2Fzc2lvbnMgd2hlcmUgdGhlIG1lbnUgbXVzdCBcImZsaXBcIlxuICA7XG5cbiAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGFwcGVuZFRvID0gX3RoaXMkcHJvcHMyLmFwcGVuZFRvLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbixcbiAgICAgICAgY29udHJvbEVsZW1lbnQgPSBfdGhpcyRwcm9wczIuY29udHJvbEVsZW1lbnQsXG4gICAgICAgIG1lbnVQbGFjZW1lbnQgPSBfdGhpcyRwcm9wczIubWVudVBsYWNlbWVudCxcbiAgICAgICAgcG9zaXRpb24gPSBfdGhpcyRwcm9wczIubWVudVBvc2l0aW9uLFxuICAgICAgICBnZXRTdHlsZXMgPSBfdGhpcyRwcm9wczIuZ2V0U3R5bGVzO1xuICAgIHZhciBpc0ZpeGVkID0gcG9zaXRpb24gPT09ICdmaXhlZCc7IC8vIGJhaWwgZWFybHkgaWYgcmVxdWlyZWQgZWxlbWVudHMgYXJlbid0IHByZXNlbnRcblxuICAgIGlmICghYXBwZW5kVG8gJiYgIWlzRml4ZWQgfHwgIWNvbnRyb2xFbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcGxhY2VtZW50ID0gdGhpcy5zdGF0ZS5wbGFjZW1lbnQgfHwgY29lcmNlUGxhY2VtZW50KG1lbnVQbGFjZW1lbnQpO1xuICAgIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRPYmooY29udHJvbEVsZW1lbnQpO1xuICAgIHZhciBzY3JvbGxEaXN0YW5jZSA9IGlzRml4ZWQgPyAwIDogd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIHZhciBvZmZzZXQgPSByZWN0W3BsYWNlbWVudF0gKyBzY3JvbGxEaXN0YW5jZTtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgIHJlY3Q6IHJlY3RcbiAgICB9OyAvLyBzYW1lIHdyYXBwZXIgZWxlbWVudCB3aGV0aGVyIGZpeGVkIG9yIHBvcnRhbGxlZFxuXG4gICAgdmFyIG1lbnVXcmFwcGVyID0ganN4KFwiZGl2XCIsIHtcbiAgICAgIGNzczogZ2V0U3R5bGVzKCdtZW51UG9ydGFsJywgc3RhdGUpXG4gICAgfSwgY2hpbGRyZW4pO1xuICAgIHJldHVybiBhcHBlbmRUbyA/IGNyZWF0ZVBvcnRhbChtZW51V3JhcHBlciwgYXBwZW5kVG8pIDogbWVudVdyYXBwZXI7XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVQb3J0YWw7XG59KENvbXBvbmVudCk7XG5NZW51UG9ydGFsLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICBnZXRQb3J0YWxQbGFjZW1lbnQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIga2V5TGlzdCA9IE9iamVjdC5rZXlzO1xudmFyIGhhc1Byb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIC8vIGZhc3QtZGVlcC1lcXVhbCBpbmRleC5qcyAyLjAuMVxuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIHZhciBhcnJBID0gaXNBcnJheShhKSxcbiAgICAgICAgYXJyQiA9IGlzQXJyYXkoYiksXG4gICAgICAgIGksXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAga2V5O1xuXG4gICAgaWYgKGFyckEgJiYgYXJyQikge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhcnJBICE9IGFyckIpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZGF0ZUEgPSBhIGluc3RhbmNlb2YgRGF0ZSxcbiAgICAgICAgZGF0ZUIgPSBiIGluc3RhbmNlb2YgRGF0ZTtcbiAgICBpZiAoZGF0ZUEgIT0gZGF0ZUIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGF0ZUEgJiYgZGF0ZUIpIHJldHVybiBhLmdldFRpbWUoKSA9PSBiLmdldFRpbWUoKTtcbiAgICB2YXIgcmVnZXhwQSA9IGEgaW5zdGFuY2VvZiBSZWdFeHAsXG4gICAgICAgIHJlZ2V4cEIgPSBiIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIGlmIChyZWdleHBBICE9IHJlZ2V4cEIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocmVnZXhwQSAmJiByZWdleHBCKSByZXR1cm4gYS50b1N0cmluZygpID09IGIudG9TdHJpbmcoKTtcbiAgICB2YXIga2V5cyA9IGtleUxpc3QoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoICE9PSBrZXlMaXN0KGIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgaWYgKCFoYXNQcm9wLmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGVuZCBmYXN0LWRlZXAtZXF1YWxcbiAgICAvLyBDdXN0b20gaGFuZGxpbmcgZm9yIFJlYWN0XG5cblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSA9PT0gJ19vd25lcicgJiYgYS4kJHR5cGVvZikge1xuICAgICAgICAvLyBSZWFjdC1zcGVjaWZpYzogYXZvaWQgdHJhdmVyc2luZyBSZWFjdCBlbGVtZW50cycgX293bmVyLlxuICAgICAgICAvLyAgX293bmVyIGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgLy8gYW5kIGlzIG5vdCBuZWVkZWQgd2hlbiBjb21wYXJpbmcgdGhlIGFjdHVhbCBlbGVtZW50cyAoYW5kIG5vdCB0aGVpciBvd25lcnMpXG4gICAgICAgIC8vIC4kJHR5cGVvZiBhbmQgLl9zdG9yZSBvbiBqdXN0IHJlYXNvbmFibGUgbWFya2VycyBvZiBhIHJlYWN0IGVsZW1lbnRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbGwgb3RoZXIgcHJvcGVydGllcyBzaG91bGQgYmUgdHJhdmVyc2VkIGFzIHVzdWFsXG4gICAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBmYXN0LWRlZXAtZXF1YWwgaW5kZXguanMgMi4wLjFcblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufSAvLyBlbmQgZmFzdC1kZWVwLWVxdWFsXG5cblxuZnVuY3Rpb24gZXhwb3J0ZWRFcXVhbChhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVxdWFsKGEsIGIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3N0YWNrfHJlY3Vyc2lvbi9pKSkge1xuICAgICAgLy8gd2FybiBvbiBjaXJjdWxhciByZWZlcmVuY2VzLCBkb24ndCBjcmFzaFxuICAgICAgLy8gYnJvd3NlcnMgZ2l2ZSB0aGlzIGRpZmZlcmVudCBlcnJvcnMgbmFtZSBhbmQgbWVzc2FnZXM6XG4gICAgICAvLyBjaHJvbWUvc2FmYXJpOiBcIlJhbmdlRXJyb3JcIiwgXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiXG4gICAgICAvLyBmaXJlZm94OiBcIkludGVybmFsRXJyb3JcIiwgdG9vIG11Y2ggcmVjdXJzaW9uXCJcbiAgICAgIC8vIGVkZ2U6IFwiRXJyb3JcIiwgXCJPdXQgb2Ygc3RhY2sgc3BhY2VcIlxuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiByZWFjdC1mYXN0LWNvbXBhcmUgZG9lcyBub3QgaGFuZGxlIGNpcmN1bGFyIHJlZmVyZW5jZXMuJywgZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBzb21lIG90aGVyIGVycm9yLiB3ZSBzaG91bGQgZGVmaW5pdGVseSBrbm93IGFib3V0IHRoZXNlXG5cblxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDEoKSB7IF9leHRlbmRzJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG52YXIgY29udGFpbmVyQ1NTID0gZnVuY3Rpb24gY29udGFpbmVyQ1NTKF9yZWYpIHtcbiAgdmFyIGlzRGlzYWJsZWQgPSBfcmVmLmlzRGlzYWJsZWQsXG4gICAgICBpc1J0bCA9IF9yZWYuaXNSdGw7XG4gIHJldHVybiB7XG4gICAgbGFiZWw6ICdjb250YWluZXInLFxuICAgIGRpcmVjdGlvbjogaXNSdGwgPyAncnRsJyA6IG51bGwsXG4gICAgcG9pbnRlckV2ZW50czogaXNEaXNhYmxlZCA/ICdub25lJyA6IG51bGwsXG4gICAgLy8gY2FuY2VsIG1vdXNlIGV2ZW50cyB3aGVuIGRpc2FibGVkXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgfTtcbn07XG52YXIgU2VsZWN0Q29udGFpbmVyID0gZnVuY3Rpb24gU2VsZWN0Q29udGFpbmVyKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3ggPSBwcm9wcy5jeCxcbiAgICAgIGdldFN0eWxlcyA9IHByb3BzLmdldFN0eWxlcyxcbiAgICAgIGlubmVyUHJvcHMgPSBwcm9wcy5pbm5lclByb3BzLFxuICAgICAgaXNEaXNhYmxlZCA9IHByb3BzLmlzRGlzYWJsZWQsXG4gICAgICBpc1J0bCA9IHByb3BzLmlzUnRsO1xuICByZXR1cm4ganN4KFwiZGl2XCIsIF9leHRlbmRzJDEoe1xuICAgIGNzczogZ2V0U3R5bGVzKCdjb250YWluZXInLCBwcm9wcyksXG4gICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAnLS1pcy1kaXNhYmxlZCc6IGlzRGlzYWJsZWQsXG4gICAgICAnLS1pcy1ydGwnOiBpc1J0bFxuICAgIH0sIGNsYXNzTmFtZSlcbiAgfSwgaW5uZXJQcm9wcyksIGNoaWxkcmVuKTtcbn07IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVmFsdWUgQ29udGFpbmVyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudmFyIHZhbHVlQ29udGFpbmVyQ1NTID0gZnVuY3Rpb24gdmFsdWVDb250YWluZXJDU1MoX3JlZjIpIHtcbiAgdmFyIHNwYWNpbmcgPSBfcmVmMi50aGVtZS5zcGFjaW5nO1xuICByZXR1cm4ge1xuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBmbGV4OiAxLFxuICAgIGZsZXhXcmFwOiAnd3JhcCcsXG4gICAgcGFkZGluZzogc3BhY2luZy5iYXNlVW5pdCAvIDIgKyBcInB4IFwiICsgc3BhY2luZy5iYXNlVW5pdCAqIDIgKyBcInB4XCIsXG4gICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6ICd0b3VjaCcsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gIH07XG59O1xudmFyIFZhbHVlQ29udGFpbmVyID0gZnVuY3Rpb24gVmFsdWVDb250YWluZXIocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjeCA9IHByb3BzLmN4LFxuICAgICAgaXNNdWx0aSA9IHByb3BzLmlzTXVsdGksXG4gICAgICBnZXRTdHlsZXMgPSBwcm9wcy5nZXRTdHlsZXMsXG4gICAgICBoYXNWYWx1ZSA9IHByb3BzLmhhc1ZhbHVlO1xuICByZXR1cm4ganN4KFwiZGl2XCIsIHtcbiAgICBjc3M6IGdldFN0eWxlcygndmFsdWVDb250YWluZXInLCBwcm9wcyksXG4gICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAndmFsdWUtY29udGFpbmVyJzogdHJ1ZSxcbiAgICAgICd2YWx1ZS1jb250YWluZXItLWlzLW11bHRpJzogaXNNdWx0aSxcbiAgICAgICd2YWx1ZS1jb250YWluZXItLWhhcy12YWx1ZSc6IGhhc1ZhbHVlXG4gICAgfSwgY2xhc3NOYW1lKVxuICB9LCBjaGlsZHJlbik7XG59OyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEluZGljYXRvciBDb250YWluZXJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgaW5kaWNhdG9yc0NvbnRhaW5lckNTUyA9IGZ1bmN0aW9uIGluZGljYXRvcnNDb250YWluZXJDU1MoKSB7XG4gIHJldHVybiB7XG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhTaHJpbms6IDBcbiAgfTtcbn07XG52YXIgSW5kaWNhdG9yc0NvbnRhaW5lciA9IGZ1bmN0aW9uIEluZGljYXRvcnNDb250YWluZXIocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjeCA9IHByb3BzLmN4LFxuICAgICAgZ2V0U3R5bGVzID0gcHJvcHMuZ2V0U3R5bGVzO1xuICByZXR1cm4ganN4KFwiZGl2XCIsIHtcbiAgICBjc3M6IGdldFN0eWxlcygnaW5kaWNhdG9yc0NvbnRhaW5lcicsIHByb3BzKSxcbiAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgIGluZGljYXRvcnM6IHRydWVcbiAgICB9LCBjbGFzc05hbWUpXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbmZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdCgpIHtcbiAgdmFyIGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoW1wiXFxuICAwJSwgODAlLCAxMDAlIHsgb3BhY2l0eTogMDsgfVxcbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxcblwiXSk7XG5cbiAgX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2Uoc3RyaW5ncywgcmF3KSB7IGlmICghcmF3KSB7IHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7IH0gc3RyaW5ncy5yYXcgPSByYXc7IHJldHVybiBzdHJpbmdzOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDIoKSB7IF9leHRlbmRzJDIgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9yZWYyID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8ge1xuICBuYW1lOiBcIjE5YnFoMnJcIixcbiAgc3R5bGVzOiBcImRpc3BsYXk6aW5saW5lLWJsb2NrO2ZpbGw6Y3VycmVudENvbG9yO2xpbmUtaGVpZ2h0OjE7c3Ryb2tlOmN1cnJlbnRDb2xvcjtzdHJva2Utd2lkdGg6MDtcIlxufSA6IHtcbiAgbmFtZTogXCIxOWJxaDJyXCIsXG4gIHN0eWxlczogXCJkaXNwbGF5OmlubGluZS1ibG9jaztmaWxsOmN1cnJlbnRDb2xvcjtsaW5lLWhlaWdodDoxO3N0cm9rZTpjdXJyZW50Q29sb3I7c3Ryb2tlLXdpZHRoOjA7XCIsXG4gIG1hcDogXCIvKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbWx1WkdsallYUnZjbk11YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWtGQmEwSkpJaXdpWm1sc1pTSTZJbWx1WkdsallYUnZjbk11YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZMeUJBWm14dmQxeHVMeW9xSUVCcWMzZ2dhbk40SUNvdlhHNXBiWEJ2Y25RZ2V5QjBlWEJsSUU1dlpHVWdmU0JtY205dElDZHlaV0ZqZENjN1hHNXBiWEJ2Y25RZ2V5QnFjM2dzSUd0bGVXWnlZVzFsY3lCOUlHWnliMjBnSjBCbGJXOTBhVzl1TDJOdmNtVW5PMXh1WEc1cGJYQnZjblFnZEhsd1pTQjdJRU52YlcxdmJsQnliM0J6TENCVWFHVnRaU0I5SUdaeWIyMGdKeTR1TDNSNWNHVnpKenRjYmx4dUx5OGdQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5WEc0dkx5QkVjbTl3Wkc5M2JpQW1JRU5zWldGeUlFbGpiMjV6WEc0dkx5QTlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDFjYmx4dVkyOXVjM1FnVTNabklEMGdLSHNnYzJsNlpTd2dMaTR1Y0hKdmNITWdmVG9nZXlCemFYcGxPaUJ1ZFcxaVpYSWdmU2tnUFQ0Z0tGeHVJQ0E4YzNablhHNGdJQ0FnYUdWcFoyaDBQWHR6YVhwbGZWeHVJQ0FnSUhkcFpIUm9QWHR6YVhwbGZWeHVJQ0FnSUhacFpYZENiM2c5WENJd0lEQWdNakFnTWpCY0lseHVJQ0FnSUdGeWFXRXRhR2xrWkdWdVBWd2lkSEoxWlZ3aVhHNGdJQ0FnWm05amRYTmhZbXhsUFZ3aVptRnNjMlZjSWx4dUlDQWdJR056Y3oxN2UxeHVJQ0FnSUNBZ1pHbHpjR3hoZVRvZ0oybHViR2x1WlMxaWJHOWpheWNzWEc0Z0lDQWdJQ0JtYVd4c09pQW5ZM1Z5Y21WdWRFTnZiRzl5Snl4Y2JpQWdJQ0FnSUd4cGJtVklaV2xuYUhRNklERXNYRzRnSUNBZ0lDQnpkSEp2YTJVNklDZGpkWEp5Wlc1MFEyOXNiM0luTEZ4dUlDQWdJQ0FnYzNSeWIydGxWMmxrZEdnNklEQXNYRzRnSUNBZ2ZYMWNiaUFnSUNCN0xpNHVjSEp2Y0hOOVhHNGdJQzgrWEc0cE8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1EzSnZjM05KWTI5dUlEMGdLSEJ5YjNCek9pQmhibmtwSUQwK0lDaGNiaUFnUEZOMlp5QnphWHBsUFhzeU1IMGdleTR1TG5CeWIzQnpmVDVjYmlBZ0lDQThjR0YwYUNCa1BWd2lUVEUwTGpNME9DQXhOQzQ0TkRsakxUQXVORFk1SURBdU5EWTVMVEV1TWpJNUlEQXVORFk1TFRFdU5qazNJREJzTFRJdU5qVXhMVE11TURNd0xUSXVOalV4SURNdU1ESTVZeTB3TGpRMk9TQXdMalEyT1MweExqSXlPU0F3TGpRMk9TMHhMalk1TnlBd0xUQXVORFk1TFRBdU5EWTVMVEF1TkRZNUxURXVNakk1SURBdE1TNDJPVGRzTWk0M05UZ3RNeTR4TlMweUxqYzFPUzB6TGpFMU1tTXRNQzQwTmprdE1DNDBOamt0TUM0ME5qa3RNUzR5TWpnZ01DMHhMalk1TjNNeExqSXlPQzB3TGpRMk9TQXhMalk1TnlBd2JESXVOalV5SURNdU1ETXhJREl1TmpVeExUTXVNRE14WXpBdU5EWTVMVEF1TkRZNUlERXVNakk0TFRBdU5EWTVJREV1TmprM0lEQnpNQzQwTmprZ01TNHlNamtnTUNBeExqWTVOMnd0TWk0M05UZ2dNeTR4TlRJZ01pNDNOVGdnTXk0eE5XTXdMalEyT1NBd0xqUTJPU0F3TGpRMk9TQXhMakl5T1NBd0lERXVOams0ZWx3aUlDOCtYRzRnSUR3dlUzWm5QbHh1S1R0Y2JtVjRjRzl5ZENCamIyNXpkQ0JFYjNkdVEyaGxkbkp2YmlBOUlDaHdjbTl3Y3pvZ1lXNTVLU0E5UGlBb1hHNGdJRHhUZG1jZ2MybDZaVDE3TWpCOUlIc3VMaTV3Y205d2MzMCtYRzRnSUNBZ1BIQmhkR2dnWkQxY0lrMDBMalV4TmlBM0xqVTBPR013TGpRek5pMHdMalEwTmlBeExqQTBNeTB3TGpRNE1TQXhMalUzTmlBd2JETXVPVEE0SURNdU56UTNJRE11T1RBNExUTXVOelEzWXpBdU5UTXpMVEF1TkRneElERXVNVFF4TFRBdU5EUTJJREV1TlRjMElEQWdNQzQwTXpZZ01DNDBORFVnTUM0ME1EZ2dNUzR4T1RjZ01DQXhMall4TlMwd0xqUXdOaUF3TGpReE9DMDBMalk1TlNBMExqVXdNaTAwTGpZNU5TQTBMalV3TWkwd0xqSXhOeUF3TGpJeU15MHdMalV3TWlBd0xqTXpOUzB3TGpjNE55QXdMak16TlhNdE1DNDFOeTB3TGpFeE1pMHdMamM0T1Mwd0xqTXpOV013SURBdE5DNHlPRGN0TkM0d09EUXROQzQyT1RVdE5DNDFNREp6TFRBdU5ETTJMVEV1TVRjZ01DMHhMall4TlhwY0lpQXZQbHh1SUNBOEwxTjJaejVjYmlrN1hHNWNiaTh2SUQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBWeHVMeThnUkhKdmNHUnZkMjRnSmlCRGJHVmhjaUJDZFhSMGIyNXpYRzR2THlBOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMWNibHh1Wlhod2IzSjBJSFI1Y0dVZ1NXNWthV05oZEc5eVVISnZjSE1nUFNCRGIyMXRiMjVRY205d2N5QW1JSHRjYmlBZ0x5b3FJRlJvWlNCamFHbHNaSEpsYmlCMGJ5QmlaU0J5Wlc1a1pYSmxaQ0JwYm5OcFpHVWdkR2hsSUdsdVpHbGpZWFJ2Y2k0Z0tpOWNiaUFnWTJocGJHUnlaVzQ2SUU1dlpHVXNYRzRnSUM4cUtpQlFjbTl3Y3lCMGFHRjBJSGRwYkd3Z1ltVWdjR0Z6YzJWa0lHOXVJSFJ2SUhSb1pTQmphR2xzWkhKbGJpNGdLaTljYmlBZ2FXNXVaWEpRY205d2N6b2dZVzU1TEZ4dUlDQXZLaW9nVkdobElHWnZZM1Z6WldRZ2MzUmhkR1VnYjJZZ2RHaGxJSE5sYkdWamRDNGdLaTljYmlBZ2FYTkdiMk4xYzJWa09pQmliMjlzWldGdUxGeHVJQ0F2S2lvZ1YyaGxkR2hsY2lCMGFHVWdkR1Y0ZENCcGN5QnlhV2RvZENCMGJ5QnNaV1owSUNvdlhHNGdJR2x6VW5Sc09pQmliMjlzWldGdUxGeHVmVHRjYmx4dVkyOXVjM1FnWW1GelpVTlRVeUE5SUNoN1hHNGdJR2x6Um05amRYTmxaQ3hjYmlBZ2RHaGxiV1U2SUh0Y2JpQWdJQ0J6Y0dGamFXNW5PaUI3SUdKaGMyVlZibWwwSUgwc1hHNGdJQ0FnWTI5c2IzSnpMRnh1SUNCOUxGeHVmVG9nU1c1a2FXTmhkRzl5VUhKdmNITXBJRDArSUNoN1hHNGdJR3hoWW1Wc09pQW5hVzVrYVdOaGRHOXlRMjl1ZEdGcGJtVnlKeXhjYmlBZ1kyOXNiM0k2SUdselJtOWpkWE5sWkNBL0lHTnZiRzl5Y3k1dVpYVjBjbUZzTmpBZ09pQmpiMnh2Y25NdWJtVjFkSEpoYkRJd0xGeHVJQ0JrYVhOd2JHRjVPaUFuWm14bGVDY3NYRzRnSUhCaFpHUnBibWM2SUdKaGMyVlZibWwwSUNvZ01peGNiaUFnZEhKaGJuTnBkR2x2YmpvZ0oyTnZiRzl5SURFMU1HMXpKeXhjYmx4dUlDQW5PbWh2ZG1WeUp6b2dlMXh1SUNBZ0lHTnZiRzl5T2lCcGMwWnZZM1Z6WldRZ1B5QmpiMnh2Y25NdWJtVjFkSEpoYkRnd0lEb2dZMjlzYjNKekxtNWxkWFJ5WVd3ME1DeGNiaUFnZlN4Y2JuMHBPMXh1WEc1bGVIQnZjblFnWTI5dWMzUWdaSEp2Y0dSdmQyNUpibVJwWTJGMGIzSkRVMU1nUFNCaVlYTmxRMU5UTzF4dVpYaHdiM0owSUdOdmJuTjBJRVJ5YjNCa2IzZHVTVzVrYVdOaGRHOXlJRDBnS0hCeWIzQnpPaUJKYm1ScFkyRjBiM0pRY205d2N5a2dQVDRnZTF4dUlDQmpiMjV6ZENCN0lHTm9hV3hrY21WdUxDQmpiR0Z6YzA1aGJXVXNJR040TENCblpYUlRkSGxzWlhNc0lHbHVibVZ5VUhKdmNITWdmU0E5SUhCeWIzQnpPMXh1SUNCeVpYUjFjbTRnS0Z4dUlDQWdJRHhrYVhaY2JpQWdJQ0FnSUhzdUxpNXBibTVsY2xCeWIzQnpmVnh1SUNBZ0lDQWdZM056UFh0blpYUlRkSGxzWlhNb0oyUnliM0JrYjNkdVNXNWthV05oZEc5eUp5d2djSEp2Y0hNcGZWeHVJQ0FnSUNBZ1kyeGhjM05PWVcxbFBYdGplQ2hjYmlBZ0lDQWdJQ0FnZTF4dUlDQWdJQ0FnSUNBZ0lHbHVaR2xqWVhSdmNqb2dkSEoxWlN4Y2JpQWdJQ0FnSUNBZ0lDQW5aSEp2Y0dSdmQyNHRhVzVrYVdOaGRHOXlKem9nZEhKMVpTeGNiaUFnSUNBZ0lDQWdmU3hjYmlBZ0lDQWdJQ0FnWTJ4aGMzTk9ZVzFsWEc0Z0lDQWdJQ0FwZlZ4dUlDQWdJRDVjYmlBZ0lDQWdJSHRqYUdsc1pISmxiaUI4ZkNBOFJHOTNia05vWlhaeWIyNGdMejU5WEc0Z0lDQWdQQzlrYVhZK1hHNGdJQ2s3WEc1OU8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1kyeGxZWEpKYm1ScFkyRjBiM0pEVTFNZ1BTQmlZWE5sUTFOVE8xeHVaWGh3YjNKMElHTnZibk4wSUVOc1pXRnlTVzVrYVdOaGRHOXlJRDBnS0hCeWIzQnpPaUJKYm1ScFkyRjBiM0pRY205d2N5a2dQVDRnZTF4dUlDQmpiMjV6ZENCN0lHTm9hV3hrY21WdUxDQmpiR0Z6YzA1aGJXVXNJR040TENCblpYUlRkSGxzWlhNc0lHbHVibVZ5VUhKdmNITWdmU0E5SUhCeWIzQnpPMXh1SUNCeVpYUjFjbTRnS0Z4dUlDQWdJRHhrYVhaY2JpQWdJQ0FnSUhzdUxpNXBibTVsY2xCeWIzQnpmVnh1SUNBZ0lDQWdZM056UFh0blpYUlRkSGxzWlhNb0oyTnNaV0Z5U1c1a2FXTmhkRzl5Snl3Z2NISnZjSE1wZlZ4dUlDQWdJQ0FnWTJ4aGMzTk9ZVzFsUFh0amVDaGNiaUFnSUNBZ0lDQWdlMXh1SUNBZ0lDQWdJQ0FnSUdsdVpHbGpZWFJ2Y2pvZ2RISjFaU3hjYmlBZ0lDQWdJQ0FnSUNBblkyeGxZWEl0YVc1a2FXTmhkRzl5SnpvZ2RISjFaU3hjYmlBZ0lDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUNBZ1kyeGhjM05PWVcxbFhHNGdJQ0FnSUNBcGZWeHVJQ0FnSUQ1Y2JpQWdJQ0FnSUh0amFHbHNaSEpsYmlCOGZDQThRM0p2YzNOSlkyOXVJQzgrZlZ4dUlDQWdJRHd2WkdsMlBseHVJQ0FwTzF4dWZUdGNibHh1THk4Z1BUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlYRzR2THlCVFpYQmhjbUYwYjNKY2JpOHZJRDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFZ4dVhHNTBlWEJsSUZObGNHRnlZWFJ2Y2xOMFlYUmxJRDBnZXlCcGMwUnBjMkZpYkdWa09pQmliMjlzWldGdUlIMDdYRzVjYm1WNGNHOXlkQ0JqYjI1emRDQnBibVJwWTJGMGIzSlRaWEJoY21GMGIzSkRVMU1nUFNBb2UxeHVJQ0JwYzBScGMyRmliR1ZrTEZ4dUlDQjBhR1Z0WlRvZ2UxeHVJQ0FnSUhOd1lXTnBibWM2SUhzZ1ltRnpaVlZ1YVhRZ2ZTeGNiaUFnSUNCamIyeHZjbk1zWEc0Z0lIMHNYRzU5T2lCRGIyMXRiMjVRY205d2N5QW1JRk5sY0dGeVlYUnZjbE4wWVhSbEtTQTlQaUFvZTF4dUlDQnNZV0psYkRvZ0oybHVaR2xqWVhSdmNsTmxjR0Z5WVhSdmNpY3NYRzRnSUdGc2FXZHVVMlZzWmpvZ0ozTjBjbVYwWTJnbkxGeHVJQ0JpWVdOclozSnZkVzVrUTI5c2IzSTZJR2x6UkdsellXSnNaV1FnUHlCamIyeHZjbk11Ym1WMWRISmhiREV3SURvZ1kyOXNiM0p6TG01bGRYUnlZV3d5TUN4Y2JpQWdiV0Z5WjJsdVFtOTBkRzl0T2lCaVlYTmxWVzVwZENBcUlESXNYRzRnSUcxaGNtZHBibFJ2Y0RvZ1ltRnpaVlZ1YVhRZ0tpQXlMRnh1SUNCM2FXUjBhRG9nTVN4Y2JuMHBPMXh1WEc1bGVIQnZjblFnWTI5dWMzUWdTVzVrYVdOaGRHOXlVMlZ3WVhKaGRHOXlJRDBnS0hCeWIzQnpPaUJKYm1ScFkyRjBiM0pRY205d2N5a2dQVDRnZTF4dUlDQmpiMjV6ZENCN0lHTnNZWE56VG1GdFpTd2dZM2dzSUdkbGRGTjBlV3hsY3l3Z2FXNXVaWEpRY205d2N5QjlJRDBnY0hKdmNITTdYRzRnSUhKbGRIVnliaUFvWEc0Z0lDQWdQSE53WVc1Y2JpQWdJQ0FnSUhzdUxpNXBibTVsY2xCeWIzQnpmVnh1SUNBZ0lDQWdZM056UFh0blpYUlRkSGxzWlhNb0oybHVaR2xqWVhSdmNsTmxjR0Z5WVhSdmNpY3NJSEJ5YjNCektYMWNiaUFnSUNBZ0lHTnNZWE56VG1GdFpUMTdZM2dvZXlBbmFXNWthV05oZEc5eUxYTmxjR0Z5WVhSdmNpYzZJSFJ5ZFdVZ2ZTd2dZMnhoYzNOT1lXMWxLWDFjYmlBZ0lDQXZQbHh1SUNBcE8xeHVmVHRjYmx4dUx5OGdQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5WEc0dkx5Qk1iMkZrYVc1blhHNHZMeUE5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQxY2JseHVZMjl1YzNRZ2JHOWhaR2x1WjBSdmRFRnVhVzFoZEdsdmJuTWdQU0JyWlhsbWNtRnRaWE5nWEc0Z0lEQWxMQ0E0TUNVc0lERXdNQ1VnZXlCdmNHRmphWFI1T2lBd095QjlYRzRnSURRd0pTQjdJRzl3WVdOcGRIazZJREU3SUgxY2JtQTdYRzVjYm1WNGNHOXlkQ0JqYjI1emRDQnNiMkZrYVc1blNXNWthV05oZEc5eVExTlRJRDBnS0h0Y2JpQWdhWE5HYjJOMWMyVmtMRnh1SUNCemFYcGxMRnh1SUNCMGFHVnRaVG9nZTF4dUlDQWdJR052Ykc5eWN5eGNiaUFnSUNCemNHRmphVzVuT2lCN0lHSmhjMlZWYm1sMElIMHNYRzRnSUgwc1hHNTlPaUI3WEc0Z0lHbHpSbTlqZFhObFpEb2dZbTl2YkdWaGJpeGNiaUFnYzJsNlpUb2diblZ0WW1WeUxGeHVJQ0IwYUdWdFpUb2dWR2hsYldVc1hHNTlLU0E5UGlBb2UxeHVJQ0JzWVdKbGJEb2dKMnh2WVdScGJtZEpibVJwWTJGMGIzSW5MRnh1SUNCamIyeHZjam9nYVhOR2IyTjFjMlZrSUQ4Z1kyOXNiM0p6TG01bGRYUnlZV3cyTUNBNklHTnZiRzl5Y3k1dVpYVjBjbUZzTWpBc1hHNGdJR1JwYzNCc1lYazZJQ2RtYkdWNEp5eGNiaUFnY0dGa1pHbHVaem9nWW1GelpWVnVhWFFnS2lBeUxGeHVJQ0IwY21GdWMybDBhVzl1T2lBblkyOXNiM0lnTVRVd2JYTW5MRnh1SUNCaGJHbG5ibE5sYkdZNklDZGpaVzUwWlhJbkxGeHVJQ0JtYjI1MFUybDZaVG9nYzJsNlpTeGNiaUFnYkdsdVpVaGxhV2RvZERvZ01TeGNiaUFnYldGeVoybHVVbWxuYUhRNklITnBlbVVzWEc0Z0lIUmxlSFJCYkdsbmJqb2dKMk5sYm5SbGNpY3NYRzRnSUhabGNuUnBZMkZzUVd4cFoyNDZJQ2R0YVdSa2JHVW5MRnh1ZlNrN1hHNWNiblI1Y0dVZ1JHOTBVSEp2Y0hNZ1BTQjdJR1JsYkdGNU9pQnVkVzFpWlhJc0lHOW1abk5sZERvZ1ltOXZiR1ZoYmlCOU8xeHVZMjl1YzNRZ1RHOWhaR2x1WjBSdmRDQTlJQ2g3SUdSbGJHRjVMQ0J2Wm1aelpYUWdmVG9nUkc5MFVISnZjSE1wSUQwK0lDaGNiaUFnUEhOd1lXNWNiaUFnSUNCamMzTTllM3RjYmlBZ0lDQWdJR0Z1YVcxaGRHbHZiam9nWUNSN2JHOWhaR2x1WjBSdmRFRnVhVzFoZEdsdmJuTjlJREZ6SUdWaGMyVXRhVzR0YjNWMElDUjdaR1ZzWVhsOWJYTWdhVzVtYVc1cGRHVTdZQ3hjYmlBZ0lDQWdJR0poWTJ0bmNtOTFibVJEYjJ4dmNqb2dKMk4xY25KbGJuUkRiMnh2Y2ljc1hHNGdJQ0FnSUNCaWIzSmtaWEpTWVdScGRYTTZJQ2N4WlcwbkxGeHVJQ0FnSUNBZ1pHbHpjR3hoZVRvZ0oybHViR2x1WlMxaWJHOWpheWNzWEc0Z0lDQWdJQ0J0WVhKbmFXNU1aV1owT2lCdlptWnpaWFFnUHlBbk1XVnRKeUE2SUc1MWJHd3NYRzRnSUNBZ0lDQm9aV2xuYUhRNklDY3haVzBuTEZ4dUlDQWdJQ0FnZG1WeWRHbGpZV3hCYkdsbmJqb2dKM1J2Y0Njc1hHNGdJQ0FnSUNCM2FXUjBhRG9nSnpGbGJTY3NYRzRnSUNBZ2ZYMWNiaUFnTHo1Y2JpazdYRzVjYm1WNGNHOXlkQ0IwZVhCbElFeHZZV1JwYm1kSlkyOXVVSEp2Y0hNZ1BTQjdYRzRnSUM4cUtpQlFjbTl3Y3lCMGFHRjBJSGRwYkd3Z1ltVWdjR0Z6YzJWa0lHOXVJSFJ2SUhSb1pTQmphR2xzWkhKbGJpNGdLaTljYmlBZ2FXNXVaWEpRY205d2N6b2dZVzU1TEZ4dUlDQXZLaW9nVkdobElHWnZZM1Z6WldRZ2MzUmhkR1VnYjJZZ2RHaGxJSE5sYkdWamRDNGdLaTljYmlBZ2FYTkdiMk4xYzJWa09pQmliMjlzWldGdUxGeHVJQ0F2S2lvZ1YyaGxkR2hsY2lCMGFHVWdkR1Y0ZENCcGN5QnlhV2RvZENCMGJ5QnNaV1owSUNvdlhHNGdJR2x6VW5Sc09pQmliMjlzWldGdUxGeHVmU0FtSUVOdmJXMXZibEJ5YjNCeklDWWdlMXh1SUNBZ0lDOHFLaUJUWlhRZ2MybDZaU0J2WmlCMGFHVWdZMjl1ZEdGcGJtVnlMaUFxTDF4dUlDQWdJSE5wZW1VNklHNTFiV0psY2l4Y2JpQWdmVHRjYm1WNGNHOXlkQ0JqYjI1emRDQk1iMkZrYVc1blNXNWthV05oZEc5eUlEMGdLSEJ5YjNCek9pQk1iMkZrYVc1blNXTnZibEJ5YjNCektTQTlQaUI3WEc0Z0lHTnZibk4wSUhzZ1kyeGhjM05PWVcxbExDQmplQ3dnWjJWMFUzUjViR1Z6TENCcGJtNWxjbEJ5YjNCekxDQnBjMUowYkNCOUlEMGdjSEp2Y0hNN1hHNWNiaUFnY21WMGRYSnVJQ2hjYmlBZ0lDQThaR2wyWEc0Z0lDQWdJQ0I3TGk0dWFXNXVaWEpRY205d2MzMWNiaUFnSUNBZ0lHTnpjejE3WjJWMFUzUjViR1Z6S0Nkc2IyRmthVzVuU1c1a2FXTmhkRzl5Snl3Z2NISnZjSE1wZlZ4dUlDQWdJQ0FnWTJ4aGMzTk9ZVzFsUFh0amVDaGNiaUFnSUNBZ0lDQWdlMXh1SUNBZ0lDQWdJQ0FnSUdsdVpHbGpZWFJ2Y2pvZ2RISjFaU3hjYmlBZ0lDQWdJQ0FnSUNBbmJHOWhaR2x1WnkxcGJtUnBZMkYwYjNJbk9pQjBjblZsTEZ4dUlDQWdJQ0FnSUNCOUxGeHVJQ0FnSUNBZ0lDQmpiR0Z6YzA1aGJXVmNiaUFnSUNBZ0lDbDlYRzRnSUNBZ1BseHVJQ0FnSUNBZ1BFeHZZV1JwYm1kRWIzUWdaR1ZzWVhrOWV6QjlJRzltWm5ObGREMTdhWE5TZEd4OUlDOCtYRzRnSUNBZ0lDQThURzloWkdsdVowUnZkQ0JrWld4aGVUMTdNVFl3ZlNCdlptWnpaWFFnTHo1Y2JpQWdJQ0FnSUR4TWIyRmthVzVuUkc5MElHUmxiR0Y1UFhzek1qQjlJRzltWm5ObGREMTdJV2x6VW5Sc2ZTQXZQbHh1SUNBZ0lEd3ZaR2wyUGx4dUlDQXBPMXh1ZlR0Y2JreHZZV1JwYm1kSmJtUnBZMkYwYjNJdVpHVm1ZWFZzZEZCeWIzQnpJRDBnZXlCemFYcGxPaUEwSUgwN1hHNGlYWDA9ICovXCJcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRHJvcGRvd24gJiBDbGVhciBJY29uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG52YXIgU3ZnID0gZnVuY3Rpb24gU3ZnKF9yZWYpIHtcbiAgdmFyIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcInNpemVcIl0pO1xuXG4gIHJldHVybiBqc3goXCJzdmdcIiwgX2V4dGVuZHMkMih7XG4gICAgaGVpZ2h0OiBzaXplLFxuICAgIHdpZHRoOiBzaXplLFxuICAgIHZpZXdCb3g6IFwiMCAwIDIwIDIwXCIsXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICBmb2N1c2FibGU6IFwiZmFsc2VcIixcbiAgICBjc3M6IF9yZWYyXG4gIH0sIHByb3BzKSk7XG59O1xuXG52YXIgQ3Jvc3NJY29uID0gZnVuY3Rpb24gQ3Jvc3NJY29uKHByb3BzKSB7XG4gIHJldHVybiBqc3goU3ZnLCBfZXh0ZW5kcyQyKHtcbiAgICBzaXplOiAyMFxuICB9LCBwcm9wcyksIGpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiXG4gIH0pKTtcbn07XG52YXIgRG93bkNoZXZyb24gPSBmdW5jdGlvbiBEb3duQ2hldnJvbihwcm9wcykge1xuICByZXR1cm4ganN4KFN2ZywgX2V4dGVuZHMkMih7XG4gICAgc2l6ZTogMjBcbiAgfSwgcHJvcHMpLCBqc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk00LjUxNiA3LjU0OGMwLjQzNi0wLjQ0NiAxLjA0My0wLjQ4MSAxLjU3NiAwbDMuOTA4IDMuNzQ3IDMuOTA4LTMuNzQ3YzAuNTMzLTAuNDgxIDEuMTQxLTAuNDQ2IDEuNTc0IDAgMC40MzYgMC40NDUgMC40MDggMS4xOTcgMCAxLjYxNS0wLjQwNiAwLjQxOC00LjY5NSA0LjUwMi00LjY5NSA0LjUwMi0wLjIxNyAwLjIyMy0wLjUwMiAwLjMzNS0wLjc4NyAwLjMzNXMtMC41Ny0wLjExMi0wLjc4OS0wLjMzNWMwIDAtNC4yODctNC4wODQtNC42OTUtNC41MDJzLTAuNDM2LTEuMTcgMC0xLjYxNXpcIlxuICB9KSk7XG59OyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnZhciBiYXNlQ1NTID0gZnVuY3Rpb24gYmFzZUNTUyhfcmVmMykge1xuICB2YXIgaXNGb2N1c2VkID0gX3JlZjMuaXNGb2N1c2VkLFxuICAgICAgX3JlZjMkdGhlbWUgPSBfcmVmMy50aGVtZSxcbiAgICAgIGJhc2VVbml0ID0gX3JlZjMkdGhlbWUuc3BhY2luZy5iYXNlVW5pdCxcbiAgICAgIGNvbG9ycyA9IF9yZWYzJHRoZW1lLmNvbG9ycztcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgICAnOmhvdmVyJzoge1xuICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwXG4gICAgfVxuICB9O1xufTtcblxudmFyIGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbnZhciBEcm9wZG93bkluZGljYXRvciA9IGZ1bmN0aW9uIERyb3Bkb3duSW5kaWNhdG9yKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3ggPSBwcm9wcy5jeCxcbiAgICAgIGdldFN0eWxlcyA9IHByb3BzLmdldFN0eWxlcyxcbiAgICAgIGlubmVyUHJvcHMgPSBwcm9wcy5pbm5lclByb3BzO1xuICByZXR1cm4ganN4KFwiZGl2XCIsIF9leHRlbmRzJDIoe30sIGlubmVyUHJvcHMsIHtcbiAgICBjc3M6IGdldFN0eWxlcygnZHJvcGRvd25JbmRpY2F0b3InLCBwcm9wcyksXG4gICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAnZHJvcGRvd24taW5kaWNhdG9yJzogdHJ1ZVxuICAgIH0sIGNsYXNzTmFtZSlcbiAgfSksIGNoaWxkcmVuIHx8IGpzeChEb3duQ2hldnJvbiwgbnVsbCkpO1xufTtcbnZhciBjbGVhckluZGljYXRvckNTUyA9IGJhc2VDU1M7XG52YXIgQ2xlYXJJbmRpY2F0b3IgPSBmdW5jdGlvbiBDbGVhckluZGljYXRvcihwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGN4ID0gcHJvcHMuY3gsXG4gICAgICBnZXRTdHlsZXMgPSBwcm9wcy5nZXRTdHlsZXMsXG4gICAgICBpbm5lclByb3BzID0gcHJvcHMuaW5uZXJQcm9wcztcbiAgcmV0dXJuIGpzeChcImRpdlwiLCBfZXh0ZW5kcyQyKHt9LCBpbm5lclByb3BzLCB7XG4gICAgY3NzOiBnZXRTdHlsZXMoJ2NsZWFySW5kaWNhdG9yJywgcHJvcHMpLFxuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWVcbiAgICB9LCBjbGFzc05hbWUpXG4gIH0pLCBjaGlsZHJlbiB8fCBqc3goQ3Jvc3NJY29uLCBudWxsKSk7XG59OyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNlcGFyYXRvclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnZhciBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSBmdW5jdGlvbiBpbmRpY2F0b3JTZXBhcmF0b3JDU1MoX3JlZjQpIHtcbiAgdmFyIGlzRGlzYWJsZWQgPSBfcmVmNC5pc0Rpc2FibGVkLFxuICAgICAgX3JlZjQkdGhlbWUgPSBfcmVmNC50aGVtZSxcbiAgICAgIGJhc2VVbml0ID0gX3JlZjQkdGhlbWUuc3BhY2luZy5iYXNlVW5pdCxcbiAgICAgIGNvbG9ycyA9IF9yZWY0JHRoZW1lLmNvbG9ycztcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogJ2luZGljYXRvclNlcGFyYXRvcicsXG4gICAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgbWFyZ2luQm90dG9tOiBiYXNlVW5pdCAqIDIsXG4gICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgd2lkdGg6IDFcbiAgfTtcbn07XG52YXIgSW5kaWNhdG9yU2VwYXJhdG9yID0gZnVuY3Rpb24gSW5kaWNhdG9yU2VwYXJhdG9yKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjeCA9IHByb3BzLmN4LFxuICAgICAgZ2V0U3R5bGVzID0gcHJvcHMuZ2V0U3R5bGVzLFxuICAgICAgaW5uZXJQcm9wcyA9IHByb3BzLmlubmVyUHJvcHM7XG4gIHJldHVybiBqc3goXCJzcGFuXCIsIF9leHRlbmRzJDIoe30sIGlubmVyUHJvcHMsIHtcbiAgICBjc3M6IGdldFN0eWxlcygnaW5kaWNhdG9yU2VwYXJhdG9yJywgcHJvcHMpLFxuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgJ2luZGljYXRvci1zZXBhcmF0b3InOiB0cnVlXG4gICAgfSwgY2xhc3NOYW1lKVxuICB9KSk7XG59OyAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXMoX3RlbXBsYXRlT2JqZWN0KCkpO1xudmFyIGxvYWRpbmdJbmRpY2F0b3JDU1MgPSBmdW5jdGlvbiBsb2FkaW5nSW5kaWNhdG9yQ1NTKF9yZWY1KSB7XG4gIHZhciBpc0ZvY3VzZWQgPSBfcmVmNS5pc0ZvY3VzZWQsXG4gICAgICBzaXplID0gX3JlZjUuc2l6ZSxcbiAgICAgIF9yZWY1JHRoZW1lID0gX3JlZjUudGhlbWUsXG4gICAgICBjb2xvcnMgPSBfcmVmNSR0aGVtZS5jb2xvcnMsXG4gICAgICBiYXNlVW5pdCA9IF9yZWY1JHRoZW1lLnNwYWNpbmcuYmFzZVVuaXQ7XG4gIHJldHVybiB7XG4gICAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICAgIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gICAgZm9udFNpemU6IHNpemUsXG4gICAgbGluZUhlaWdodDogMSxcbiAgICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gIH07XG59O1xuXG52YXIgTG9hZGluZ0RvdCA9IGZ1bmN0aW9uIExvYWRpbmdEb3QoX3JlZjYpIHtcbiAgdmFyIGRlbGF5ID0gX3JlZjYuZGVsYXksXG4gICAgICBvZmZzZXQgPSBfcmVmNi5vZmZzZXQ7XG4gIHJldHVybiBqc3goXCJzcGFuXCIsIHtcbiAgICBjc3M6XG4gICAgLyojX19QVVJFX18qL1xuICAgIF9jc3Moe1xuICAgICAgYW5pbWF0aW9uOiBsb2FkaW5nRG90QW5pbWF0aW9ucyArIFwiIDFzIGVhc2UtaW4tb3V0IFwiICsgZGVsYXkgKyBcIm1zIGluZmluaXRlO1wiLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogbnVsbCxcbiAgICAgIGhlaWdodDogJzFlbScsXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICAgIHdpZHRoOiAnMWVtJ1xuICAgIH0sIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IFwiXCIgOiBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltbHVaR2xqWVhSdmNuTXVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJa0ZCYzB4Sklpd2labWxzWlNJNkltbHVaR2xqWVhSdmNuTXVhbk1pTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJdkx5QkFabXh2ZDF4dUx5b3FJRUJxYzNnZ2FuTjRJQ292WEc1cGJYQnZjblFnZXlCMGVYQmxJRTV2WkdVZ2ZTQm1jbTl0SUNkeVpXRmpkQ2M3WEc1cGJYQnZjblFnZXlCcWMzZ3NJR3RsZVdaeVlXMWxjeUI5SUdaeWIyMGdKMEJsYlc5MGFXOXVMMk52Y21Vbk8xeHVYRzVwYlhCdmNuUWdkSGx3WlNCN0lFTnZiVzF2YmxCeWIzQnpMQ0JVYUdWdFpTQjlJR1p5YjIwZ0p5NHVMM1I1Y0dWekp6dGNibHh1THk4Z1BUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlYRzR2THlCRWNtOXdaRzkzYmlBbUlFTnNaV0Z5SUVsamIyNXpYRzR2THlBOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMWNibHh1WTI5dWMzUWdVM1puSUQwZ0tIc2djMmw2WlN3Z0xpNHVjSEp2Y0hNZ2ZUb2dleUJ6YVhwbE9pQnVkVzFpWlhJZ2ZTa2dQVDRnS0Z4dUlDQThjM1puWEc0Z0lDQWdhR1ZwWjJoMFBYdHphWHBsZlZ4dUlDQWdJSGRwWkhSb1BYdHphWHBsZlZ4dUlDQWdJSFpwWlhkQ2IzZzlYQ0l3SURBZ01qQWdNakJjSWx4dUlDQWdJR0Z5YVdFdGFHbGtaR1Z1UFZ3aWRISjFaVndpWEc0Z0lDQWdabTlqZFhOaFlteGxQVndpWm1Gc2MyVmNJbHh1SUNBZ0lHTnpjejE3ZTF4dUlDQWdJQ0FnWkdsemNHeGhlVG9nSjJsdWJHbHVaUzFpYkc5amF5Y3NYRzRnSUNBZ0lDQm1hV3hzT2lBblkzVnljbVZ1ZEVOdmJHOXlKeXhjYmlBZ0lDQWdJR3hwYm1WSVpXbG5hSFE2SURFc1hHNGdJQ0FnSUNCemRISnZhMlU2SUNkamRYSnlaVzUwUTI5c2IzSW5MRnh1SUNBZ0lDQWdjM1J5YjJ0bFYybGtkR2c2SURBc1hHNGdJQ0FnZlgxY2JpQWdJQ0I3TGk0dWNISnZjSE45WEc0Z0lDOCtYRzRwTzF4dVhHNWxlSEJ2Y25RZ1kyOXVjM1FnUTNKdmMzTkpZMjl1SUQwZ0tIQnliM0J6T2lCaGJua3BJRDArSUNoY2JpQWdQRk4yWnlCemFYcGxQWHN5TUgwZ2V5NHVMbkJ5YjNCemZUNWNiaUFnSUNBOGNHRjBhQ0JrUFZ3aVRURTBMak0wT0NBeE5DNDRORGxqTFRBdU5EWTVJREF1TkRZNUxURXVNakk1SURBdU5EWTVMVEV1TmprM0lEQnNMVEl1TmpVeExUTXVNRE13TFRJdU5qVXhJRE11TURJNVl5MHdMalEyT1NBd0xqUTJPUzB4TGpJeU9TQXdMalEyT1MweExqWTVOeUF3TFRBdU5EWTVMVEF1TkRZNUxUQXVORFk1TFRFdU1qSTVJREF0TVM0Mk9UZHNNaTQzTlRndE15NHhOUzB5TGpjMU9TMHpMakUxTW1NdE1DNDBOamt0TUM0ME5qa3RNQzQwTmprdE1TNHlNamdnTUMweExqWTVOM014TGpJeU9DMHdMalEyT1NBeExqWTVOeUF3YkRJdU5qVXlJRE11TURNeElESXVOalV4TFRNdU1ETXhZekF1TkRZNUxUQXVORFk1SURFdU1qSTRMVEF1TkRZNUlERXVOamszSURCek1DNDBOamtnTVM0eU1qa2dNQ0F4TGpZNU4yd3RNaTQzTlRnZ015NHhOVElnTWk0M05UZ2dNeTR4TldNd0xqUTJPU0F3TGpRMk9TQXdMalEyT1NBeExqSXlPU0F3SURFdU5qazRlbHdpSUM4K1hHNGdJRHd2VTNablBseHVLVHRjYm1WNGNHOXlkQ0JqYjI1emRDQkViM2R1UTJobGRuSnZiaUE5SUNod2NtOXdjem9nWVc1NUtTQTlQaUFvWEc0Z0lEeFRkbWNnYzJsNlpUMTdNakI5SUhzdUxpNXdjbTl3YzMwK1hHNGdJQ0FnUEhCaGRHZ2daRDFjSWswMExqVXhOaUEzTGpVME9HTXdMalF6Tmkwd0xqUTBOaUF4TGpBME15MHdMalE0TVNBeExqVTNOaUF3YkRNdU9UQTRJRE11TnpRM0lETXVPVEE0TFRNdU56UTNZekF1TlRNekxUQXVORGd4SURFdU1UUXhMVEF1TkRRMklERXVOVGMwSURBZ01DNDBNellnTUM0ME5EVWdNQzQwTURnZ01TNHhPVGNnTUNBeExqWXhOUzB3TGpRd05pQXdMalF4T0MwMExqWTVOU0EwTGpVd01pMDBMalk1TlNBMExqVXdNaTB3TGpJeE55QXdMakl5TXkwd0xqVXdNaUF3TGpNek5TMHdMamM0TnlBd0xqTXpOWE10TUM0MU55MHdMakV4TWkwd0xqYzRPUzB3TGpNek5XTXdJREF0TkM0eU9EY3ROQzR3T0RRdE5DNDJPVFV0TkM0MU1ESnpMVEF1TkRNMkxURXVNVGNnTUMweExqWXhOWHBjSWlBdlBseHVJQ0E4TDFOMlp6NWNiaWs3WEc1Y2JpOHZJRDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFZ4dUx5OGdSSEp2Y0dSdmQyNGdKaUJEYkdWaGNpQkNkWFIwYjI1elhHNHZMeUE5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQxY2JseHVaWGh3YjNKMElIUjVjR1VnU1c1a2FXTmhkRzl5VUhKdmNITWdQU0JEYjIxdGIyNVFjbTl3Y3lBbUlIdGNiaUFnTHlvcUlGUm9aU0JqYUdsc1pISmxiaUIwYnlCaVpTQnlaVzVrWlhKbFpDQnBibk5wWkdVZ2RHaGxJR2x1WkdsallYUnZjaTRnS2k5Y2JpQWdZMmhwYkdSeVpXNDZJRTV2WkdVc1hHNGdJQzhxS2lCUWNtOXdjeUIwYUdGMElIZHBiR3dnWW1VZ2NHRnpjMlZrSUc5dUlIUnZJSFJvWlNCamFHbHNaSEpsYmk0Z0tpOWNiaUFnYVc1dVpYSlFjbTl3Y3pvZ1lXNTVMRnh1SUNBdktpb2dWR2hsSUdadlkzVnpaV1FnYzNSaGRHVWdiMllnZEdobElITmxiR1ZqZEM0Z0tpOWNiaUFnYVhOR2IyTjFjMlZrT2lCaWIyOXNaV0Z1TEZ4dUlDQXZLaW9nVjJobGRHaGxjaUIwYUdVZ2RHVjRkQ0JwY3lCeWFXZG9kQ0IwYnlCc1pXWjBJQ292WEc0Z0lHbHpVblJzT2lCaWIyOXNaV0Z1TEZ4dWZUdGNibHh1WTI5dWMzUWdZbUZ6WlVOVFV5QTlJQ2g3WEc0Z0lHbHpSbTlqZFhObFpDeGNiaUFnZEdobGJXVTZJSHRjYmlBZ0lDQnpjR0ZqYVc1bk9pQjdJR0poYzJWVmJtbDBJSDBzWEc0Z0lDQWdZMjlzYjNKekxGeHVJQ0I5TEZ4dWZUb2dTVzVrYVdOaGRHOXlVSEp2Y0hNcElEMCtJQ2g3WEc0Z0lHeGhZbVZzT2lBbmFXNWthV05oZEc5eVEyOXVkR0ZwYm1WeUp5eGNiaUFnWTI5c2IzSTZJR2x6Um05amRYTmxaQ0EvSUdOdmJHOXljeTV1WlhWMGNtRnNOakFnT2lCamIyeHZjbk11Ym1WMWRISmhiREl3TEZ4dUlDQmthWE53YkdGNU9pQW5abXhsZUNjc1hHNGdJSEJoWkdScGJtYzZJR0poYzJWVmJtbDBJQ29nTWl4Y2JpQWdkSEpoYm5OcGRHbHZiam9nSjJOdmJHOXlJREUxTUcxekp5eGNibHh1SUNBbk9taHZkbVZ5SnpvZ2UxeHVJQ0FnSUdOdmJHOXlPaUJwYzBadlkzVnpaV1FnUHlCamIyeHZjbk11Ym1WMWRISmhiRGd3SURvZ1kyOXNiM0p6TG01bGRYUnlZV3cwTUN4Y2JpQWdmU3hjYm4wcE8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1pISnZjR1J2ZDI1SmJtUnBZMkYwYjNKRFUxTWdQU0JpWVhObFExTlRPMXh1Wlhod2IzSjBJR052Ym5OMElFUnliM0JrYjNkdVNXNWthV05oZEc5eUlEMGdLSEJ5YjNCek9pQkpibVJwWTJGMGIzSlFjbTl3Y3lrZ1BUNGdlMXh1SUNCamIyNXpkQ0I3SUdOb2FXeGtjbVZ1TENCamJHRnpjMDVoYldVc0lHTjRMQ0JuWlhSVGRIbHNaWE1zSUdsdWJtVnlVSEp2Y0hNZ2ZTQTlJSEJ5YjNCek8xeHVJQ0J5WlhSMWNtNGdLRnh1SUNBZ0lEeGthWFpjYmlBZ0lDQWdJSHN1TGk1cGJtNWxjbEJ5YjNCemZWeHVJQ0FnSUNBZ1kzTnpQWHRuWlhSVGRIbHNaWE1vSjJSeWIzQmtiM2R1U1c1a2FXTmhkRzl5Snl3Z2NISnZjSE1wZlZ4dUlDQWdJQ0FnWTJ4aGMzTk9ZVzFsUFh0amVDaGNiaUFnSUNBZ0lDQWdlMXh1SUNBZ0lDQWdJQ0FnSUdsdVpHbGpZWFJ2Y2pvZ2RISjFaU3hjYmlBZ0lDQWdJQ0FnSUNBblpISnZjR1J2ZDI0dGFXNWthV05oZEc5eUp6b2dkSEoxWlN4Y2JpQWdJQ0FnSUNBZ2ZTeGNiaUFnSUNBZ0lDQWdZMnhoYzNOT1lXMWxYRzRnSUNBZ0lDQXBmVnh1SUNBZ0lENWNiaUFnSUNBZ0lIdGphR2xzWkhKbGJpQjhmQ0E4Ukc5M2JrTm9aWFp5YjI0Z0x6NTlYRzRnSUNBZ1BDOWthWFkrWEc0Z0lDazdYRzU5TzF4dVhHNWxlSEJ2Y25RZ1kyOXVjM1FnWTJ4bFlYSkpibVJwWTJGMGIzSkRVMU1nUFNCaVlYTmxRMU5UTzF4dVpYaHdiM0owSUdOdmJuTjBJRU5zWldGeVNXNWthV05oZEc5eUlEMGdLSEJ5YjNCek9pQkpibVJwWTJGMGIzSlFjbTl3Y3lrZ1BUNGdlMXh1SUNCamIyNXpkQ0I3SUdOb2FXeGtjbVZ1TENCamJHRnpjMDVoYldVc0lHTjRMQ0JuWlhSVGRIbHNaWE1zSUdsdWJtVnlVSEp2Y0hNZ2ZTQTlJSEJ5YjNCek8xeHVJQ0J5WlhSMWNtNGdLRnh1SUNBZ0lEeGthWFpjYmlBZ0lDQWdJSHN1TGk1cGJtNWxjbEJ5YjNCemZWeHVJQ0FnSUNBZ1kzTnpQWHRuWlhSVGRIbHNaWE1vSjJOc1pXRnlTVzVrYVdOaGRHOXlKeXdnY0hKdmNITXBmVnh1SUNBZ0lDQWdZMnhoYzNOT1lXMWxQWHRqZUNoY2JpQWdJQ0FnSUNBZ2UxeHVJQ0FnSUNBZ0lDQWdJR2x1WkdsallYUnZjam9nZEhKMVpTeGNiaUFnSUNBZ0lDQWdJQ0FuWTJ4bFlYSXRhVzVrYVdOaGRHOXlKem9nZEhKMVpTeGNiaUFnSUNBZ0lDQWdmU3hjYmlBZ0lDQWdJQ0FnWTJ4aGMzTk9ZVzFsWEc0Z0lDQWdJQ0FwZlZ4dUlDQWdJRDVjYmlBZ0lDQWdJSHRqYUdsc1pISmxiaUI4ZkNBOFEzSnZjM05KWTI5dUlDOCtmVnh1SUNBZ0lEd3ZaR2wyUGx4dUlDQXBPMXh1ZlR0Y2JseHVMeThnUFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVhHNHZMeUJUWlhCaGNtRjBiM0pjYmk4dklEMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVnh1WEc1MGVYQmxJRk5sY0dGeVlYUnZjbE4wWVhSbElEMGdleUJwYzBScGMyRmliR1ZrT2lCaWIyOXNaV0Z1SUgwN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCcGJtUnBZMkYwYjNKVFpYQmhjbUYwYjNKRFUxTWdQU0FvZTF4dUlDQnBjMFJwYzJGaWJHVmtMRnh1SUNCMGFHVnRaVG9nZTF4dUlDQWdJSE53WVdOcGJtYzZJSHNnWW1GelpWVnVhWFFnZlN4Y2JpQWdJQ0JqYjJ4dmNuTXNYRzRnSUgwc1hHNTlPaUJEYjIxdGIyNVFjbTl3Y3lBbUlGTmxjR0Z5WVhSdmNsTjBZWFJsS1NBOVBpQW9lMXh1SUNCc1lXSmxiRG9nSjJsdVpHbGpZWFJ2Y2xObGNHRnlZWFJ2Y2ljc1hHNGdJR0ZzYVdkdVUyVnNaam9nSjNOMGNtVjBZMmduTEZ4dUlDQmlZV05yWjNKdmRXNWtRMjlzYjNJNklHbHpSR2x6WVdKc1pXUWdQeUJqYjJ4dmNuTXVibVYxZEhKaGJERXdJRG9nWTI5c2IzSnpMbTVsZFhSeVlXd3lNQ3hjYmlBZ2JXRnlaMmx1UW05MGRHOXRPaUJpWVhObFZXNXBkQ0FxSURJc1hHNGdJRzFoY21kcGJsUnZjRG9nWW1GelpWVnVhWFFnS2lBeUxGeHVJQ0IzYVdSMGFEb2dNU3hjYm4wcE8xeHVYRzVsZUhCdmNuUWdZMjl1YzNRZ1NXNWthV05oZEc5eVUyVndZWEpoZEc5eUlEMGdLSEJ5YjNCek9pQkpibVJwWTJGMGIzSlFjbTl3Y3lrZ1BUNGdlMXh1SUNCamIyNXpkQ0I3SUdOc1lYTnpUbUZ0WlN3Z1kzZ3NJR2RsZEZOMGVXeGxjeXdnYVc1dVpYSlFjbTl3Y3lCOUlEMGdjSEp2Y0hNN1hHNGdJSEpsZEhWeWJpQW9YRzRnSUNBZ1BITndZVzVjYmlBZ0lDQWdJSHN1TGk1cGJtNWxjbEJ5YjNCemZWeHVJQ0FnSUNBZ1kzTnpQWHRuWlhSVGRIbHNaWE1vSjJsdVpHbGpZWFJ2Y2xObGNHRnlZWFJ2Y2ljc0lIQnliM0J6S1gxY2JpQWdJQ0FnSUdOc1lYTnpUbUZ0WlQxN1kzZ29leUFuYVc1a2FXTmhkRzl5TFhObGNHRnlZWFJ2Y2ljNklIUnlkV1VnZlN3Z1kyeGhjM05PWVcxbEtYMWNiaUFnSUNBdlBseHVJQ0FwTzF4dWZUdGNibHh1THk4Z1BUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlYRzR2THlCTWIyRmthVzVuWEc0dkx5QTlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDFjYmx4dVkyOXVjM1FnYkc5aFpHbHVaMFJ2ZEVGdWFXMWhkR2x2Ym5NZ1BTQnJaWGxtY21GdFpYTmdYRzRnSURBbExDQTRNQ1VzSURFd01DVWdleUJ2Y0dGamFYUjVPaUF3T3lCOVhHNGdJRFF3SlNCN0lHOXdZV05wZEhrNklERTdJSDFjYm1BN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCc2IyRmthVzVuU1c1a2FXTmhkRzl5UTFOVElEMGdLSHRjYmlBZ2FYTkdiMk4xYzJWa0xGeHVJQ0J6YVhwbExGeHVJQ0IwYUdWdFpUb2dlMXh1SUNBZ0lHTnZiRzl5Y3l4Y2JpQWdJQ0J6Y0dGamFXNW5PaUI3SUdKaGMyVlZibWwwSUgwc1hHNGdJSDBzWEc1OU9pQjdYRzRnSUdselJtOWpkWE5sWkRvZ1ltOXZiR1ZoYml4Y2JpQWdjMmw2WlRvZ2JuVnRZbVZ5TEZ4dUlDQjBhR1Z0WlRvZ1ZHaGxiV1VzWEc1OUtTQTlQaUFvZTF4dUlDQnNZV0psYkRvZ0oyeHZZV1JwYm1kSmJtUnBZMkYwYjNJbkxGeHVJQ0JqYjJ4dmNqb2dhWE5HYjJOMWMyVmtJRDhnWTI5c2IzSnpMbTVsZFhSeVlXdzJNQ0E2SUdOdmJHOXljeTV1WlhWMGNtRnNNakFzWEc0Z0lHUnBjM0JzWVhrNklDZG1iR1Y0Snl4Y2JpQWdjR0ZrWkdsdVp6b2dZbUZ6WlZWdWFYUWdLaUF5TEZ4dUlDQjBjbUZ1YzJsMGFXOXVPaUFuWTI5c2IzSWdNVFV3YlhNbkxGeHVJQ0JoYkdsbmJsTmxiR1k2SUNkalpXNTBaWEluTEZ4dUlDQm1iMjUwVTJsNlpUb2djMmw2WlN4Y2JpQWdiR2x1WlVobGFXZG9kRG9nTVN4Y2JpQWdiV0Z5WjJsdVVtbG5hSFE2SUhOcGVtVXNYRzRnSUhSbGVIUkJiR2xuYmpvZ0oyTmxiblJsY2ljc1hHNGdJSFpsY25ScFkyRnNRV3hwWjI0NklDZHRhV1JrYkdVbkxGeHVmU2s3WEc1Y2JuUjVjR1VnUkc5MFVISnZjSE1nUFNCN0lHUmxiR0Y1T2lCdWRXMWlaWElzSUc5bVpuTmxkRG9nWW05dmJHVmhiaUI5TzF4dVkyOXVjM1FnVEc5aFpHbHVaMFJ2ZENBOUlDaDdJR1JsYkdGNUxDQnZabVp6WlhRZ2ZUb2dSRzkwVUhKdmNITXBJRDArSUNoY2JpQWdQSE53WVc1Y2JpQWdJQ0JqYzNNOWUzdGNiaUFnSUNBZ0lHRnVhVzFoZEdsdmJqb2dZQ1I3Ykc5aFpHbHVaMFJ2ZEVGdWFXMWhkR2x2Ym5OOUlERnpJR1ZoYzJVdGFXNHRiM1YwSUNSN1pHVnNZWGw5YlhNZ2FXNW1hVzVwZEdVN1lDeGNiaUFnSUNBZ0lHSmhZMnRuY205MWJtUkRiMnh2Y2pvZ0oyTjFjbkpsYm5SRGIyeHZjaWNzWEc0Z0lDQWdJQ0JpYjNKa1pYSlNZV1JwZFhNNklDY3haVzBuTEZ4dUlDQWdJQ0FnWkdsemNHeGhlVG9nSjJsdWJHbHVaUzFpYkc5amF5Y3NYRzRnSUNBZ0lDQnRZWEpuYVc1TVpXWjBPaUJ2Wm1aelpYUWdQeUFuTVdWdEp5QTZJRzUxYkd3c1hHNGdJQ0FnSUNCb1pXbG5hSFE2SUNjeFpXMG5MRnh1SUNBZ0lDQWdkbVZ5ZEdsallXeEJiR2xuYmpvZ0ozUnZjQ2NzWEc0Z0lDQWdJQ0IzYVdSMGFEb2dKekZsYlNjc1hHNGdJQ0FnZlgxY2JpQWdMejVjYmlrN1hHNWNibVY0Y0c5eWRDQjBlWEJsSUV4dllXUnBibWRKWTI5dVVISnZjSE1nUFNCN1hHNGdJQzhxS2lCUWNtOXdjeUIwYUdGMElIZHBiR3dnWW1VZ2NHRnpjMlZrSUc5dUlIUnZJSFJvWlNCamFHbHNaSEpsYmk0Z0tpOWNiaUFnYVc1dVpYSlFjbTl3Y3pvZ1lXNTVMRnh1SUNBdktpb2dWR2hsSUdadlkzVnpaV1FnYzNSaGRHVWdiMllnZEdobElITmxiR1ZqZEM0Z0tpOWNiaUFnYVhOR2IyTjFjMlZrT2lCaWIyOXNaV0Z1TEZ4dUlDQXZLaW9nVjJobGRHaGxjaUIwYUdVZ2RHVjRkQ0JwY3lCeWFXZG9kQ0IwYnlCc1pXWjBJQ292WEc0Z0lHbHpVblJzT2lCaWIyOXNaV0Z1TEZ4dWZTQW1JRU52YlcxdmJsQnliM0J6SUNZZ2UxeHVJQ0FnSUM4cUtpQlRaWFFnYzJsNlpTQnZaaUIwYUdVZ1kyOXVkR0ZwYm1WeUxpQXFMMXh1SUNBZ0lITnBlbVU2SUc1MWJXSmxjaXhjYmlBZ2ZUdGNibVY0Y0c5eWRDQmpiMjV6ZENCTWIyRmthVzVuU1c1a2FXTmhkRzl5SUQwZ0tIQnliM0J6T2lCTWIyRmthVzVuU1dOdmJsQnliM0J6S1NBOVBpQjdYRzRnSUdOdmJuTjBJSHNnWTJ4aGMzTk9ZVzFsTENCamVDd2daMlYwVTNSNWJHVnpMQ0JwYm01bGNsQnliM0J6TENCcGMxSjBiQ0I5SUQwZ2NISnZjSE03WEc1Y2JpQWdjbVYwZFhKdUlDaGNiaUFnSUNBOFpHbDJYRzRnSUNBZ0lDQjdMaTR1YVc1dVpYSlFjbTl3YzMxY2JpQWdJQ0FnSUdOemN6MTdaMlYwVTNSNWJHVnpLQ2RzYjJGa2FXNW5TVzVrYVdOaGRHOXlKeXdnY0hKdmNITXBmVnh1SUNBZ0lDQWdZMnhoYzNOT1lXMWxQWHRqZUNoY2JpQWdJQ0FnSUNBZ2UxeHVJQ0FnSUNBZ0lDQWdJR2x1WkdsallYUnZjam9nZEhKMVpTeGNiaUFnSUNBZ0lDQWdJQ0FuYkc5aFpHbHVaeTFwYm1ScFkyRjBiM0luT2lCMGNuVmxMRnh1SUNBZ0lDQWdJQ0I5TEZ4dUlDQWdJQ0FnSUNCamJHRnpjMDVoYldWY2JpQWdJQ0FnSUNsOVhHNGdJQ0FnUGx4dUlDQWdJQ0FnUEV4dllXUnBibWRFYjNRZ1pHVnNZWGs5ZXpCOUlHOW1abk5sZEQxN2FYTlNkR3g5SUM4K1hHNGdJQ0FnSUNBOFRHOWhaR2x1WjBSdmRDQmtaV3hoZVQxN01UWXdmU0J2Wm1aelpYUWdMejVjYmlBZ0lDQWdJRHhNYjJGa2FXNW5SRzkwSUdSbGJHRjVQWHN6TWpCOUlHOW1abk5sZEQxN0lXbHpVblJzZlNBdlBseHVJQ0FnSUR3dlpHbDJQbHh1SUNBcE8xeHVmVHRjYmt4dllXUnBibWRKYm1ScFkyRjBiM0l1WkdWbVlYVnNkRkJ5YjNCeklEMGdleUJ6YVhwbE9pQTBJSDA3WEc0aVhYMD0gKi9cIilcbiAgfSk7XG59O1xuXG52YXIgTG9hZGluZ0luZGljYXRvciA9IGZ1bmN0aW9uIExvYWRpbmdJbmRpY2F0b3IocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGN4ID0gcHJvcHMuY3gsXG4gICAgICBnZXRTdHlsZXMgPSBwcm9wcy5nZXRTdHlsZXMsXG4gICAgICBpbm5lclByb3BzID0gcHJvcHMuaW5uZXJQcm9wcyxcbiAgICAgIGlzUnRsID0gcHJvcHMuaXNSdGw7XG4gIHJldHVybiBqc3goXCJkaXZcIiwgX2V4dGVuZHMkMih7fSwgaW5uZXJQcm9wcywge1xuICAgIGNzczogZ2V0U3R5bGVzKCdsb2FkaW5nSW5kaWNhdG9yJywgcHJvcHMpLFxuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZVxuICAgIH0sIGNsYXNzTmFtZSlcbiAgfSksIGpzeChMb2FkaW5nRG90LCB7XG4gICAgZGVsYXk6IDAsXG4gICAgb2Zmc2V0OiBpc1J0bFxuICB9KSwganN4KExvYWRpbmdEb3QsIHtcbiAgICBkZWxheTogMTYwLFxuICAgIG9mZnNldDogdHJ1ZVxuICB9KSwganN4KExvYWRpbmdEb3QsIHtcbiAgICBkZWxheTogMzIwLFxuICAgIG9mZnNldDogIWlzUnRsXG4gIH0pKTtcbn07XG5Mb2FkaW5nSW5kaWNhdG9yLmRlZmF1bHRQcm9wcyA9IHtcbiAgc2l6ZTogNFxufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMkMygpIHsgX2V4dGVuZHMkMyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcyQzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbnZhciBjc3MgPSBmdW5jdGlvbiBjc3MoX3JlZikge1xuICB2YXIgaXNEaXNhYmxlZCA9IF9yZWYuaXNEaXNhYmxlZCxcbiAgICAgIGlzRm9jdXNlZCA9IF9yZWYuaXNGb2N1c2VkLFxuICAgICAgX3JlZiR0aGVtZSA9IF9yZWYudGhlbWUsXG4gICAgICBjb2xvcnMgPSBfcmVmJHRoZW1lLmNvbG9ycyxcbiAgICAgIGJvcmRlclJhZGl1cyA9IF9yZWYkdGhlbWUuYm9yZGVyUmFkaXVzLFxuICAgICAgc3BhY2luZyA9IF9yZWYkdGhlbWUuc3BhY2luZztcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogJ2NvbnRyb2wnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsNSA6IGNvbG9ycy5uZXV0cmFsMCxcbiAgICBib3JkZXJDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBpc0ZvY3VzZWQgPyBjb2xvcnMucHJpbWFyeSA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgYm94U2hhZG93OiBpc0ZvY3VzZWQgPyBcIjAgMCAwIDFweCBcIiArIGNvbG9ycy5wcmltYXJ5IDogbnVsbCxcbiAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgZmxleFdyYXA6ICd3cmFwJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgIG1pbkhlaWdodDogc3BhY2luZy5jb250cm9sSGVpZ2h0LFxuICAgIG91dGxpbmU6ICcwICFpbXBvcnRhbnQnLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHRyYW5zaXRpb246ICdhbGwgMTAwbXMnLFxuICAgICcmOmhvdmVyJzoge1xuICAgICAgYm9yZGVyQ29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5wcmltYXJ5IDogY29sb3JzLm5ldXRyYWwzMFxuICAgIH1cbiAgfTtcbn07XG5cbnZhciBDb250cm9sID0gZnVuY3Rpb24gQ29udHJvbChwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGN4ID0gcHJvcHMuY3gsXG4gICAgICBnZXRTdHlsZXMgPSBwcm9wcy5nZXRTdHlsZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBpc0Rpc2FibGVkID0gcHJvcHMuaXNEaXNhYmxlZCxcbiAgICAgIGlzRm9jdXNlZCA9IHByb3BzLmlzRm9jdXNlZCxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBpbm5lclByb3BzID0gcHJvcHMuaW5uZXJQcm9wcyxcbiAgICAgIG1lbnVJc09wZW4gPSBwcm9wcy5tZW51SXNPcGVuO1xuICByZXR1cm4ganN4KFwiZGl2XCIsIF9leHRlbmRzJDMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY3NzOiBnZXRTdHlsZXMoJ2NvbnRyb2wnLCBwcm9wcyksXG4gICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICBjb250cm9sOiB0cnVlLFxuICAgICAgJ2NvbnRyb2wtLWlzLWRpc2FibGVkJzogaXNEaXNhYmxlZCxcbiAgICAgICdjb250cm9sLS1pcy1mb2N1c2VkJzogaXNGb2N1c2VkLFxuICAgICAgJ2NvbnRyb2wtLW1lbnUtaXMtb3Blbic6IG1lbnVJc09wZW5cbiAgICB9LCBjbGFzc05hbWUpXG4gIH0sIGlubmVyUHJvcHMpLCBjaGlsZHJlbik7XG59O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSQxKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMkNCgpIHsgX2V4dGVuZHMkNCA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcyQ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbnZhciBncm91cENTUyA9IGZ1bmN0aW9uIGdyb3VwQ1NTKF9yZWYpIHtcbiAgdmFyIHNwYWNpbmcgPSBfcmVmLnRoZW1lLnNwYWNpbmc7XG4gIHJldHVybiB7XG4gICAgcGFkZGluZ0JvdHRvbTogc3BhY2luZy5iYXNlVW5pdCAqIDIsXG4gICAgcGFkZGluZ1RvcDogc3BhY2luZy5iYXNlVW5pdCAqIDJcbiAgfTtcbn07XG5cbnZhciBHcm91cCA9IGZ1bmN0aW9uIEdyb3VwKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3ggPSBwcm9wcy5jeCxcbiAgICAgIGdldFN0eWxlcyA9IHByb3BzLmdldFN0eWxlcyxcbiAgICAgIEhlYWRpbmcgPSBwcm9wcy5IZWFkaW5nLFxuICAgICAgaGVhZGluZ1Byb3BzID0gcHJvcHMuaGVhZGluZ1Byb3BzLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIHRoZW1lID0gcHJvcHMudGhlbWUsXG4gICAgICBzZWxlY3RQcm9wcyA9IHByb3BzLnNlbGVjdFByb3BzO1xuICByZXR1cm4ganN4KFwiZGl2XCIsIHtcbiAgICBjc3M6IGdldFN0eWxlcygnZ3JvdXAnLCBwcm9wcyksXG4gICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICBncm91cDogdHJ1ZVxuICAgIH0sIGNsYXNzTmFtZSlcbiAgfSwganN4KEhlYWRpbmcsIF9leHRlbmRzJDQoe30sIGhlYWRpbmdQcm9wcywge1xuICAgIHNlbGVjdFByb3BzOiBzZWxlY3RQcm9wcyxcbiAgICB0aGVtZTogdGhlbWUsXG4gICAgZ2V0U3R5bGVzOiBnZXRTdHlsZXMsXG4gICAgY3g6IGN4XG4gIH0pLCBsYWJlbCksIGpzeChcImRpdlwiLCBudWxsLCBjaGlsZHJlbikpO1xufTtcblxudmFyIGdyb3VwSGVhZGluZ0NTUyA9IGZ1bmN0aW9uIGdyb3VwSGVhZGluZ0NTUyhfcmVmMikge1xuICB2YXIgc3BhY2luZyA9IF9yZWYyLnRoZW1lLnNwYWNpbmc7XG4gIHJldHVybiB7XG4gICAgbGFiZWw6ICdncm91cCcsXG4gICAgY29sb3I6ICcjOTk5JyxcbiAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgIGZvbnRTaXplOiAnNzUlJyxcbiAgICBmb250V2VpZ2h0OiAnNTAwJyxcbiAgICBtYXJnaW5Cb3R0b206ICcwLjI1ZW0nLFxuICAgIHBhZGRpbmdMZWZ0OiBzcGFjaW5nLmJhc2VVbml0ICogMyxcbiAgICBwYWRkaW5nUmlnaHQ6IHNwYWNpbmcuYmFzZVVuaXQgKiAzLFxuICAgIHRleHRUcmFuc2Zvcm06ICd1cHBlcmNhc2UnXG4gIH07XG59O1xudmFyIEdyb3VwSGVhZGluZyA9IGZ1bmN0aW9uIEdyb3VwSGVhZGluZyhwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3ggPSBwcm9wcy5jeCxcbiAgICAgIGdldFN0eWxlcyA9IHByb3BzLmdldFN0eWxlcyxcbiAgICAgIHRoZW1lID0gcHJvcHMudGhlbWUsXG4gICAgICBzZWxlY3RQcm9wcyA9IHByb3BzLnNlbGVjdFByb3BzLFxuICAgICAgY2xlYW5Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJDEocHJvcHMsIFtcImNsYXNzTmFtZVwiLCBcImN4XCIsIFwiZ2V0U3R5bGVzXCIsIFwidGhlbWVcIiwgXCJzZWxlY3RQcm9wc1wiXSk7XG5cbiAgcmV0dXJuIGpzeChcImRpdlwiLCBfZXh0ZW5kcyQ0KHtcbiAgICBjc3M6IGdldFN0eWxlcygnZ3JvdXBIZWFkaW5nJywgX2V4dGVuZHMkNCh7XG4gICAgICB0aGVtZTogdGhlbWVcbiAgICB9LCBjbGVhblByb3BzKSksXG4gICAgY2xhc3NOYW1lOiBjeCh7XG4gICAgICAnZ3JvdXAtaGVhZGluZyc6IHRydWVcbiAgICB9LCBjbGFzc05hbWUpXG4gIH0sIGNsZWFuUHJvcHMpKTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDUoKSB7IF9leHRlbmRzJDUgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMkNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJDIoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIGlucHV0Q1NTID0gZnVuY3Rpb24gaW5wdXRDU1MoX3JlZikge1xuICB2YXIgaXNEaXNhYmxlZCA9IF9yZWYuaXNEaXNhYmxlZCxcbiAgICAgIF9yZWYkdGhlbWUgPSBfcmVmLnRoZW1lLFxuICAgICAgc3BhY2luZyA9IF9yZWYkdGhlbWUuc3BhY2luZyxcbiAgICAgIGNvbG9ycyA9IF9yZWYkdGhlbWUuY29sb3JzO1xuICByZXR1cm4ge1xuICAgIG1hcmdpbjogc3BhY2luZy5iYXNlVW5pdCAvIDIsXG4gICAgcGFkZGluZ0JvdHRvbTogc3BhY2luZy5iYXNlVW5pdCAvIDIsXG4gICAgcGFkZGluZ1RvcDogc3BhY2luZy5iYXNlVW5pdCAvIDIsXG4gICAgdmlzaWJpbGl0eTogaXNEaXNhYmxlZCA/ICdoaWRkZW4nIDogJ3Zpc2libGUnLFxuICAgIGNvbG9yOiBjb2xvcnMubmV1dHJhbDgwXG4gIH07XG59O1xuXG52YXIgaW5wdXRTdHlsZSA9IGZ1bmN0aW9uIGlucHV0U3R5bGUoaXNIaWRkZW4pIHtcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogJ2lucHV0JyxcbiAgICBiYWNrZ3JvdW5kOiAwLFxuICAgIGJvcmRlcjogMCxcbiAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgIG9wYWNpdHk6IGlzSGlkZGVuID8gMCA6IDEsXG4gICAgb3V0bGluZTogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIGNvbG9yOiAnaW5oZXJpdCdcbiAgfTtcbn07XG5cbnZhciBJbnB1dCA9IGZ1bmN0aW9uIElucHV0KF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBjeCA9IF9yZWYyLmN4LFxuICAgICAgZ2V0U3R5bGVzID0gX3JlZjIuZ2V0U3R5bGVzLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGlzSGlkZGVuID0gX3JlZjIuaXNIaWRkZW4sXG4gICAgICBpc0Rpc2FibGVkID0gX3JlZjIuaXNEaXNhYmxlZCxcbiAgICAgIHRoZW1lID0gX3JlZjIudGhlbWUsXG4gICAgICBzZWxlY3RQcm9wcyA9IF9yZWYyLnNlbGVjdFByb3BzLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSQyKF9yZWYyLCBbXCJjbGFzc05hbWVcIiwgXCJjeFwiLCBcImdldFN0eWxlc1wiLCBcImlubmVyUmVmXCIsIFwiaXNIaWRkZW5cIiwgXCJpc0Rpc2FibGVkXCIsIFwidGhlbWVcIiwgXCJzZWxlY3RQcm9wc1wiXSk7XG5cbiAgcmV0dXJuIGpzeChcImRpdlwiLCB7XG4gICAgY3NzOiBnZXRTdHlsZXMoJ2lucHV0JywgX2V4dGVuZHMkNSh7XG4gICAgICB0aGVtZTogdGhlbWVcbiAgICB9LCBwcm9wcykpXG4gIH0sIGpzeChBdXRvc2l6ZUlucHV0LCBfZXh0ZW5kcyQ1KHtcbiAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgIGlucHV0OiB0cnVlXG4gICAgfSwgY2xhc3NOYW1lKSxcbiAgICBpbnB1dFJlZjogaW5uZXJSZWYsXG4gICAgaW5wdXRTdHlsZTogaW5wdXRTdHlsZShpc0hpZGRlbiksXG4gICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWRcbiAgfSwgcHJvcHMpKSk7XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcyQ2KCkgeyBfZXh0ZW5kcyQ2ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzJDYuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxudmFyIG11bHRpVmFsdWVDU1MgPSBmdW5jdGlvbiBtdWx0aVZhbHVlQ1NTKF9yZWYpIHtcbiAgdmFyIF9yZWYkdGhlbWUgPSBfcmVmLnRoZW1lLFxuICAgICAgc3BhY2luZyA9IF9yZWYkdGhlbWUuc3BhY2luZyxcbiAgICAgIGJvcmRlclJhZGl1cyA9IF9yZWYkdGhlbWUuYm9yZGVyUmFkaXVzLFxuICAgICAgY29sb3JzID0gX3JlZiR0aGVtZS5jb2xvcnM7XG4gIHJldHVybiB7XG4gICAgbGFiZWw6ICdtdWx0aVZhbHVlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5uZXV0cmFsMTAsXG4gICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMgLyAyLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBtYXJnaW46IHNwYWNpbmcuYmFzZVVuaXQgLyAyLFxuICAgIG1pbldpZHRoOiAwIC8vIHJlc29sdmVzIGZsZXgvdGV4dC1vdmVyZmxvdyBidWdcblxuICB9O1xufTtcbnZhciBtdWx0aVZhbHVlTGFiZWxDU1MgPSBmdW5jdGlvbiBtdWx0aVZhbHVlTGFiZWxDU1MoX3JlZjIpIHtcbiAgdmFyIF9yZWYyJHRoZW1lID0gX3JlZjIudGhlbWUsXG4gICAgICBib3JkZXJSYWRpdXMgPSBfcmVmMiR0aGVtZS5ib3JkZXJSYWRpdXMsXG4gICAgICBjb2xvcnMgPSBfcmVmMiR0aGVtZS5jb2xvcnMsXG4gICAgICBjcm9wV2l0aEVsbGlwc2lzID0gX3JlZjIuY3JvcFdpdGhFbGxpcHNpcztcbiAgcmV0dXJuIHtcbiAgICBib3JkZXJSYWRpdXM6IGJvcmRlclJhZGl1cyAvIDIsXG4gICAgY29sb3I6IGNvbG9ycy5uZXV0cmFsODAsXG4gICAgZm9udFNpemU6ICc4NSUnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwYWRkaW5nOiAzLFxuICAgIHBhZGRpbmdMZWZ0OiA2LFxuICAgIHRleHRPdmVyZmxvdzogY3JvcFdpdGhFbGxpcHNpcyA/ICdlbGxpcHNpcycgOiBudWxsLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gIH07XG59O1xudmFyIG11bHRpVmFsdWVSZW1vdmVDU1MgPSBmdW5jdGlvbiBtdWx0aVZhbHVlUmVtb3ZlQ1NTKF9yZWYzKSB7XG4gIHZhciBfcmVmMyR0aGVtZSA9IF9yZWYzLnRoZW1lLFxuICAgICAgc3BhY2luZyA9IF9yZWYzJHRoZW1lLnNwYWNpbmcsXG4gICAgICBib3JkZXJSYWRpdXMgPSBfcmVmMyR0aGVtZS5ib3JkZXJSYWRpdXMsXG4gICAgICBjb2xvcnMgPSBfcmVmMyR0aGVtZS5jb2xvcnMsXG4gICAgICBpc0ZvY3VzZWQgPSBfcmVmMy5pc0ZvY3VzZWQ7XG4gIHJldHVybiB7XG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMgLyAyLFxuICAgIGJhY2tncm91bmRDb2xvcjogaXNGb2N1c2VkICYmIGNvbG9ycy5kYW5nZXJMaWdodCxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgcGFkZGluZ0xlZnQ6IHNwYWNpbmcuYmFzZVVuaXQsXG4gICAgcGFkZGluZ1JpZ2h0OiBzcGFjaW5nLmJhc2VVbml0LFxuICAgICc6aG92ZXInOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5kYW5nZXJMaWdodCxcbiAgICAgIGNvbG9yOiBjb2xvcnMuZGFuZ2VyXG4gICAgfVxuICB9O1xufTtcbnZhciBNdWx0aVZhbHVlR2VuZXJpYyA9IGZ1bmN0aW9uIE11bHRpVmFsdWVHZW5lcmljKF9yZWY0KSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWY0LmNoaWxkcmVuLFxuICAgICAgaW5uZXJQcm9wcyA9IF9yZWY0LmlubmVyUHJvcHM7XG4gIHJldHVybiBqc3goXCJkaXZcIiwgaW5uZXJQcm9wcywgY2hpbGRyZW4pO1xufTtcbnZhciBNdWx0aVZhbHVlQ29udGFpbmVyID0gTXVsdGlWYWx1ZUdlbmVyaWM7XG52YXIgTXVsdGlWYWx1ZUxhYmVsID0gTXVsdGlWYWx1ZUdlbmVyaWM7XG5mdW5jdGlvbiBNdWx0aVZhbHVlUmVtb3ZlKF9yZWY1KSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWY1LmNoaWxkcmVuLFxuICAgICAgaW5uZXJQcm9wcyA9IF9yZWY1LmlubmVyUHJvcHM7XG4gIHJldHVybiBqc3goXCJkaXZcIiwgaW5uZXJQcm9wcywgY2hpbGRyZW4gfHwganN4KENyb3NzSWNvbiwge1xuICAgIHNpemU6IDE0XG4gIH0pKTtcbn1cblxudmFyIE11bHRpVmFsdWUgPSBmdW5jdGlvbiBNdWx0aVZhbHVlKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY29tcG9uZW50cyA9IHByb3BzLmNvbXBvbmVudHMsXG4gICAgICBjeCA9IHByb3BzLmN4LFxuICAgICAgZGF0YSA9IHByb3BzLmRhdGEsXG4gICAgICBnZXRTdHlsZXMgPSBwcm9wcy5nZXRTdHlsZXMsXG4gICAgICBpbm5lclByb3BzID0gcHJvcHMuaW5uZXJQcm9wcyxcbiAgICAgIGlzRGlzYWJsZWQgPSBwcm9wcy5pc0Rpc2FibGVkLFxuICAgICAgcmVtb3ZlUHJvcHMgPSBwcm9wcy5yZW1vdmVQcm9wcyxcbiAgICAgIHNlbGVjdFByb3BzID0gcHJvcHMuc2VsZWN0UHJvcHM7XG4gIHZhciBDb250YWluZXIgPSBjb21wb25lbnRzLkNvbnRhaW5lcixcbiAgICAgIExhYmVsID0gY29tcG9uZW50cy5MYWJlbCxcbiAgICAgIFJlbW92ZSA9IGNvbXBvbmVudHMuUmVtb3ZlO1xuICByZXR1cm4ganN4KENsYXNzTmFtZXMsIG51bGwsIGZ1bmN0aW9uIChfcmVmNikge1xuICAgIHZhciBjc3MgPSBfcmVmNi5jc3MsXG4gICAgICAgIGVtb3Rpb25DeCA9IF9yZWY2LmN4O1xuICAgIHJldHVybiBqc3goQ29udGFpbmVyLCB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgaW5uZXJQcm9wczogX2V4dGVuZHMkNih7fSwgaW5uZXJQcm9wcywge1xuICAgICAgICBjbGFzc05hbWU6IGVtb3Rpb25DeChjc3MoZ2V0U3R5bGVzKCdtdWx0aVZhbHVlJywgcHJvcHMpKSwgY3goe1xuICAgICAgICAgICdtdWx0aS12YWx1ZSc6IHRydWUsXG4gICAgICAgICAgJ211bHRpLXZhbHVlLS1pcy1kaXNhYmxlZCc6IGlzRGlzYWJsZWRcbiAgICAgICAgfSwgY2xhc3NOYW1lKSlcbiAgICAgIH0pLFxuICAgICAgc2VsZWN0UHJvcHM6IHNlbGVjdFByb3BzXG4gICAgfSwganN4KExhYmVsLCB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgaW5uZXJQcm9wczoge1xuICAgICAgICBjbGFzc05hbWU6IGVtb3Rpb25DeChjc3MoZ2V0U3R5bGVzKCdtdWx0aVZhbHVlTGFiZWwnLCBwcm9wcykpLCBjeCh7XG4gICAgICAgICAgJ211bHRpLXZhbHVlX19sYWJlbCc6IHRydWVcbiAgICAgICAgfSwgY2xhc3NOYW1lKSlcbiAgICAgIH0sXG4gICAgICBzZWxlY3RQcm9wczogc2VsZWN0UHJvcHNcbiAgICB9LCBjaGlsZHJlbiksIGpzeChSZW1vdmUsIHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBpbm5lclByb3BzOiBfZXh0ZW5kcyQ2KHtcbiAgICAgICAgY2xhc3NOYW1lOiBlbW90aW9uQ3goY3NzKGdldFN0eWxlcygnbXVsdGlWYWx1ZVJlbW92ZScsIHByb3BzKSksIGN4KHtcbiAgICAgICAgICAnbXVsdGktdmFsdWVfX3JlbW92ZSc6IHRydWVcbiAgICAgICAgfSwgY2xhc3NOYW1lKSlcbiAgICAgIH0sIHJlbW92ZVByb3BzKSxcbiAgICAgIHNlbGVjdFByb3BzOiBzZWxlY3RQcm9wc1xuICAgIH0pKTtcbiAgfSk7XG59O1xuXG5NdWx0aVZhbHVlLmRlZmF1bHRQcm9wcyA9IHtcbiAgY3JvcFdpdGhFbGxpcHNpczogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMkNygpIHsgX2V4dGVuZHMkNyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcyQ3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbnZhciBvcHRpb25DU1MgPSBmdW5jdGlvbiBvcHRpb25DU1MoX3JlZikge1xuICB2YXIgaXNEaXNhYmxlZCA9IF9yZWYuaXNEaXNhYmxlZCxcbiAgICAgIGlzRm9jdXNlZCA9IF9yZWYuaXNGb2N1c2VkLFxuICAgICAgaXNTZWxlY3RlZCA9IF9yZWYuaXNTZWxlY3RlZCxcbiAgICAgIF9yZWYkdGhlbWUgPSBfcmVmLnRoZW1lLFxuICAgICAgc3BhY2luZyA9IF9yZWYkdGhlbWUuc3BhY2luZyxcbiAgICAgIGNvbG9ycyA9IF9yZWYkdGhlbWUuY29sb3JzO1xuICByZXR1cm4ge1xuICAgIGxhYmVsOiAnb3B0aW9uJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGlzU2VsZWN0ZWQgPyBjb2xvcnMucHJpbWFyeSA6IGlzRm9jdXNlZCA/IGNvbG9ycy5wcmltYXJ5MjUgOiAndHJhbnNwYXJlbnQnLFxuICAgIGNvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwyMCA6IGlzU2VsZWN0ZWQgPyBjb2xvcnMubmV1dHJhbDAgOiAnaW5oZXJpdCcsXG4gICAgY3Vyc29yOiAnZGVmYXVsdCcsXG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgIHBhZGRpbmc6IHNwYWNpbmcuYmFzZVVuaXQgKiAyICsgXCJweCBcIiArIHNwYWNpbmcuYmFzZVVuaXQgKiAzICsgXCJweFwiLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLCAwLCAwLCAwKScsXG4gICAgLy8gcHJvdmlkZSBzb21lIGFmZm9yZGFuY2Ugb24gdG91Y2ggZGV2aWNlc1xuICAgICc6YWN0aXZlJzoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAhaXNEaXNhYmxlZCAmJiAoaXNTZWxlY3RlZCA/IGNvbG9ycy5wcmltYXJ5IDogY29sb3JzLnByaW1hcnk1MClcbiAgICB9XG4gIH07XG59O1xuXG52YXIgT3B0aW9uID0gZnVuY3Rpb24gT3B0aW9uKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3ggPSBwcm9wcy5jeCxcbiAgICAgIGdldFN0eWxlcyA9IHByb3BzLmdldFN0eWxlcyxcbiAgICAgIGlzRGlzYWJsZWQgPSBwcm9wcy5pc0Rpc2FibGVkLFxuICAgICAgaXNGb2N1c2VkID0gcHJvcHMuaXNGb2N1c2VkLFxuICAgICAgaXNTZWxlY3RlZCA9IHByb3BzLmlzU2VsZWN0ZWQsXG4gICAgICBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgaW5uZXJQcm9wcyA9IHByb3BzLmlubmVyUHJvcHM7XG4gIHJldHVybiBqc3goXCJkaXZcIiwgX2V4dGVuZHMkNyh7XG4gICAgY3NzOiBnZXRTdHlsZXMoJ29wdGlvbicsIHByb3BzKSxcbiAgICBjbGFzc05hbWU6IGN4KHtcbiAgICAgIG9wdGlvbjogdHJ1ZSxcbiAgICAgICdvcHRpb24tLWlzLWRpc2FibGVkJzogaXNEaXNhYmxlZCxcbiAgICAgICdvcHRpb24tLWlzLWZvY3VzZWQnOiBpc0ZvY3VzZWQsXG4gICAgICAnb3B0aW9uLS1pcy1zZWxlY3RlZCc6IGlzU2VsZWN0ZWRcbiAgICB9LCBjbGFzc05hbWUpLFxuICAgIHJlZjogaW5uZXJSZWZcbiAgfSwgaW5uZXJQcm9wcyksIGNoaWxkcmVuKTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDgoKSB7IF9leHRlbmRzJDggPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMkOC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG52YXIgcGxhY2Vob2xkZXJDU1MgPSBmdW5jdGlvbiBwbGFjZWhvbGRlckNTUyhfcmVmKSB7XG4gIHZhciBfcmVmJHRoZW1lID0gX3JlZi50aGVtZSxcbiAgICAgIHNwYWNpbmcgPSBfcmVmJHRoZW1lLnNwYWNpbmcsXG4gICAgICBjb2xvcnMgPSBfcmVmJHRoZW1lLmNvbG9ycztcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogJ3BsYWNlaG9sZGVyJyxcbiAgICBjb2xvcjogY29sb3JzLm5ldXRyYWw1MCxcbiAgICBtYXJnaW5MZWZ0OiBzcGFjaW5nLmJhc2VVbml0IC8gMixcbiAgICBtYXJnaW5SaWdodDogc3BhY2luZy5iYXNlVW5pdCAvIDIsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAnNTAlJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJ1xuICB9O1xufTtcblxudmFyIFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gUGxhY2Vob2xkZXIocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjeCA9IHByb3BzLmN4LFxuICAgICAgZ2V0U3R5bGVzID0gcHJvcHMuZ2V0U3R5bGVzLFxuICAgICAgaW5uZXJQcm9wcyA9IHByb3BzLmlubmVyUHJvcHM7XG4gIHJldHVybiBqc3goXCJkaXZcIiwgX2V4dGVuZHMkOCh7XG4gICAgY3NzOiBnZXRTdHlsZXMoJ3BsYWNlaG9sZGVyJywgcHJvcHMpLFxuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgcGxhY2Vob2xkZXI6IHRydWVcbiAgICB9LCBjbGFzc05hbWUpXG4gIH0sIGlubmVyUHJvcHMpLCBjaGlsZHJlbik7XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcyQ5KCkgeyBfZXh0ZW5kcyQ5ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzJDkuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxudmFyIGNzcyQxID0gZnVuY3Rpb24gY3NzKF9yZWYpIHtcbiAgdmFyIGlzRGlzYWJsZWQgPSBfcmVmLmlzRGlzYWJsZWQsXG4gICAgICBfcmVmJHRoZW1lID0gX3JlZi50aGVtZSxcbiAgICAgIHNwYWNpbmcgPSBfcmVmJHRoZW1lLnNwYWNpbmcsXG4gICAgICBjb2xvcnMgPSBfcmVmJHRoZW1lLmNvbG9ycztcbiAgcmV0dXJuIHtcbiAgICBsYWJlbDogJ3NpbmdsZVZhbHVlJyxcbiAgICBjb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsNDAgOiBjb2xvcnMubmV1dHJhbDgwLFxuICAgIG1hcmdpbkxlZnQ6IHNwYWNpbmcuYmFzZVVuaXQgLyAyLFxuICAgIG1hcmdpblJpZ2h0OiBzcGFjaW5nLmJhc2VVbml0IC8gMixcbiAgICBtYXhXaWR0aDogXCJjYWxjKDEwMCUgLSBcIiArIHNwYWNpbmcuYmFzZVVuaXQgKiAyICsgXCJweClcIixcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIHRvcDogJzUwJScsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKSdcbiAgfTtcbn07XG5cbnZhciBTaW5nbGVWYWx1ZSA9IGZ1bmN0aW9uIFNpbmdsZVZhbHVlKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3ggPSBwcm9wcy5jeCxcbiAgICAgIGdldFN0eWxlcyA9IHByb3BzLmdldFN0eWxlcyxcbiAgICAgIGlzRGlzYWJsZWQgPSBwcm9wcy5pc0Rpc2FibGVkLFxuICAgICAgaW5uZXJQcm9wcyA9IHByb3BzLmlubmVyUHJvcHM7XG4gIHJldHVybiBqc3goXCJkaXZcIiwgX2V4dGVuZHMkOSh7XG4gICAgY3NzOiBnZXRTdHlsZXMoJ3NpbmdsZVZhbHVlJywgcHJvcHMpLFxuICAgIGNsYXNzTmFtZTogY3goe1xuICAgICAgJ3NpbmdsZS12YWx1ZSc6IHRydWUsXG4gICAgICAnc2luZ2xlLXZhbHVlLS1pcy1kaXNhYmxlZCc6IGlzRGlzYWJsZWRcbiAgICB9LCBjbGFzc05hbWUpXG4gIH0sIGlubmVyUHJvcHMpLCBjaGlsZHJlbik7XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcyRhKCkgeyBfZXh0ZW5kcyRhID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzJGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxudmFyIGNvbXBvbmVudHMgPSB7XG4gIENsZWFySW5kaWNhdG9yOiBDbGVhckluZGljYXRvcixcbiAgQ29udHJvbDogQ29udHJvbCxcbiAgRHJvcGRvd25JbmRpY2F0b3I6IERyb3Bkb3duSW5kaWNhdG9yLFxuICBEb3duQ2hldnJvbjogRG93bkNoZXZyb24sXG4gIENyb3NzSWNvbjogQ3Jvc3NJY29uLFxuICBHcm91cDogR3JvdXAsXG4gIEdyb3VwSGVhZGluZzogR3JvdXBIZWFkaW5nLFxuICBJbmRpY2F0b3JzQ29udGFpbmVyOiBJbmRpY2F0b3JzQ29udGFpbmVyLFxuICBJbmRpY2F0b3JTZXBhcmF0b3I6IEluZGljYXRvclNlcGFyYXRvcixcbiAgSW5wdXQ6IElucHV0LFxuICBMb2FkaW5nSW5kaWNhdG9yOiBMb2FkaW5nSW5kaWNhdG9yLFxuICBNZW51OiBNZW51LFxuICBNZW51TGlzdDogTWVudUxpc3QsXG4gIE1lbnVQb3J0YWw6IE1lbnVQb3J0YWwsXG4gIExvYWRpbmdNZXNzYWdlOiBMb2FkaW5nTWVzc2FnZSxcbiAgTm9PcHRpb25zTWVzc2FnZTogTm9PcHRpb25zTWVzc2FnZSxcbiAgTXVsdGlWYWx1ZTogTXVsdGlWYWx1ZSxcbiAgTXVsdGlWYWx1ZUNvbnRhaW5lcjogTXVsdGlWYWx1ZUNvbnRhaW5lcixcbiAgTXVsdGlWYWx1ZUxhYmVsOiBNdWx0aVZhbHVlTGFiZWwsXG4gIE11bHRpVmFsdWVSZW1vdmU6IE11bHRpVmFsdWVSZW1vdmUsXG4gIE9wdGlvbjogT3B0aW9uLFxuICBQbGFjZWhvbGRlcjogUGxhY2Vob2xkZXIsXG4gIFNlbGVjdENvbnRhaW5lcjogU2VsZWN0Q29udGFpbmVyLFxuICBTaW5nbGVWYWx1ZTogU2luZ2xlVmFsdWUsXG4gIFZhbHVlQ29udGFpbmVyOiBWYWx1ZUNvbnRhaW5lclxufTtcbnZhciBkZWZhdWx0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIGRlZmF1bHRDb21wb25lbnRzKHByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyRhKHt9LCBjb21wb25lbnRzLCBwcm9wcy5jb21wb25lbnRzKTtcbn07XG5cbmV4cG9ydCB7IE1lbnVQbGFjZXIgYXMgTSwgY29udGFpbmVyQ1NTIGFzIGEsIGNzcyBhcyBiLCBjbGVhckluZGljYXRvckNTUyBhcyBjLCBkcm9wZG93bkluZGljYXRvckNTUyBhcyBkLCBncm91cEhlYWRpbmdDU1MgYXMgZSwgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTIGFzIGYsIGdyb3VwQ1NTIGFzIGcsIGlucHV0Q1NTIGFzIGgsIGluZGljYXRvcnNDb250YWluZXJDU1MgYXMgaSwgbG9hZGluZ01lc3NhZ2VDU1MgYXMgaiwgbWVudUxpc3RDU1MgYXMgaywgbG9hZGluZ0luZGljYXRvckNTUyBhcyBsLCBtZW51Q1NTIGFzIG0sIG1lbnVQb3J0YWxDU1MgYXMgbiwgbXVsdGlWYWx1ZUNTUyBhcyBvLCBtdWx0aVZhbHVlTGFiZWxDU1MgYXMgcCwgbXVsdGlWYWx1ZVJlbW92ZUNTUyBhcyBxLCBub09wdGlvbnNNZXNzYWdlQ1NTIGFzIHIsIG9wdGlvbkNTUyBhcyBzLCBwbGFjZWhvbGRlckNTUyBhcyB0LCBjc3MkMSBhcyB1LCB2YWx1ZUNvbnRhaW5lckNTUyBhcyB2LCBkZWZhdWx0Q29tcG9uZW50cyBhcyB3LCBleHBvcnRlZEVxdWFsIGFzIHgsIGNvbXBvbmVudHMgYXMgeSB9O1xuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtZW1vaXplT25lIGZyb20gJ21lbW9pemUtb25lJztcbmltcG9ydCB7IENhY2hlUHJvdmlkZXIgfSBmcm9tICdAZW1vdGlvbi9jb3JlJztcbmltcG9ydCAncmVhY3QtZG9tJztcbmltcG9ydCAncHJvcC10eXBlcyc7XG5pbXBvcnQgJy4vdXRpbHMtMDZiMGQ1YTQuYnJvd3Nlci5lc20uanMnO1xuZXhwb3J0IHsgeSBhcyBjb21wb25lbnRzIH0gZnJvbSAnLi9pbmRleC00MzIyYzBlZC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBTIGFzIFNlbGVjdCB9IGZyb20gJy4vU2VsZWN0LTlmZGI4Y2QwLmJyb3dzZXIuZXNtLmpzJztcbmV4cG9ydCB7IGMgYXMgY3JlYXRlRmlsdGVyLCBhIGFzIGRlZmF1bHRUaGVtZSwgbSBhcyBtZXJnZVN0eWxlcyB9IGZyb20gJy4vU2VsZWN0LTlmZGI4Y2QwLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCAnQGVtb3Rpb24vY3NzJztcbmltcG9ydCAncmVhY3QtaW5wdXQtYXV0b3NpemUnO1xuaW1wb3J0IHsgbSBhcyBtYW5hZ2VTdGF0ZSB9IGZyb20gJy4vc3RhdGVNYW5hZ2VyLTA0ZjczNGEyLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCBjcmVhdGVDYWNoZSBmcm9tICdAZW1vdGlvbi9jYWNoZSc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTm9uY2VQcm92aWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShOb25jZVByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBOb25jZVByb3ZpZGVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5jcmVhdGVFbW90aW9uQ2FjaGUgPSBmdW5jdGlvbiAobm9uY2UpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDYWNoZSh7XG4gICAgICAgIG5vbmNlOiBub25jZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZUVtb3Rpb25DYWNoZSA9IG1lbW9pemVPbmUoX3RoaXMuY3JlYXRlRW1vdGlvbkNhY2hlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTm9uY2VQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgZW1vdGlvbkNhY2hlID0gdGhpcy5jcmVhdGVFbW90aW9uQ2FjaGUodGhpcy5wcm9wcy5ub25jZSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FjaGVQcm92aWRlciwge1xuICAgICAgdmFsdWU6IGVtb3Rpb25DYWNoZVxuICAgIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBOb25jZVByb3ZpZGVyO1xufShDb21wb25lbnQpO1xuXG52YXIgaW5kZXggPSBtYW5hZ2VTdGF0ZShTZWxlY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbmV4cG9ydCB7IE5vbmNlUHJvdmlkZXIgfTtcbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBkZWZhdWx0SW5wdXRWYWx1ZTogJycsXG4gIGRlZmF1bHRNZW51SXNPcGVuOiBmYWxzZSxcbiAgZGVmYXVsdFZhbHVlOiBudWxsXG59O1xuXG52YXIgbWFuYWdlU3RhdGUgPSBmdW5jdGlvbiBtYW5hZ2VTdGF0ZShTZWxlY3RDb21wb25lbnQpIHtcbiAgdmFyIF9jbGFzcywgX3RlbXA7XG5cbiAgcmV0dXJuIF90ZW1wID0gX2NsYXNzID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFN0YXRlTWFuYWdlciwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBTdGF0ZU1hbmFnZXIoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbC5hcHBseShfQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuc2VsZWN0ID0gdm9pZCAwO1xuICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgIGlucHV0VmFsdWU6IF90aGlzLnByb3BzLmlucHV0VmFsdWUgIT09IHVuZGVmaW5lZCA/IF90aGlzLnByb3BzLmlucHV0VmFsdWUgOiBfdGhpcy5wcm9wcy5kZWZhdWx0SW5wdXRWYWx1ZSxcbiAgICAgICAgbWVudUlzT3BlbjogX3RoaXMucHJvcHMubWVudUlzT3BlbiAhPT0gdW5kZWZpbmVkID8gX3RoaXMucHJvcHMubWVudUlzT3BlbiA6IF90aGlzLnByb3BzLmRlZmF1bHRNZW51SXNPcGVuLFxuICAgICAgICB2YWx1ZTogX3RoaXMucHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCA/IF90aGlzLnByb3BzLnZhbHVlIDogX3RoaXMucHJvcHMuZGVmYXVsdFZhbHVlXG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSwgYWN0aW9uTWV0YSkge1xuICAgICAgICBfdGhpcy5jYWxsUHJvcCgnb25DaGFuZ2UnLCB2YWx1ZSwgYWN0aW9uTWV0YSk7XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLm9uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUsIGFjdGlvbk1ldGEpIHtcbiAgICAgICAgLy8gVE9ETzogZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBhbGxvdyB0aGUgcHJvcCB0byByZXR1cm4gYSBuZXdcbiAgICAgICAgLy8gdmFsdWUsIGJ1dCBub3cgaW5wdXRWYWx1ZSBpcyBhIGNvbnRyb2xsYWJsZSBwcm9wIHdlIHByb2JhYmx5IHNob3VsZG4ndFxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5jYWxsUHJvcCgnb25JbnB1dENoYW5nZScsIHZhbHVlLCBhY3Rpb25NZXRhKTtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaW5wdXRWYWx1ZTogbmV3VmFsdWUgIT09IHVuZGVmaW5lZCA/IG5ld1ZhbHVlIDogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5vbk1lbnVPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5jYWxsUHJvcCgnb25NZW51T3BlbicpO1xuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBtZW51SXNPcGVuOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMub25NZW51Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNhbGxQcm9wKCdvbk1lbnVDbG9zZScpO1xuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBtZW51SXNPcGVuOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gU3RhdGVNYW5hZ2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgdGhpcy5zZWxlY3QuZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmJsdXIgPSBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgdGhpcy5zZWxlY3QuYmx1cigpO1xuICAgIH0gLy8gRklYTUU6IHVudHlwZWQgZmxvdyBjb2RlLCByZXR1cm4gYW55XG4gICAgO1xuXG4gICAgX3Byb3RvLmdldFByb3AgPSBmdW5jdGlvbiBnZXRQcm9wKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpcy5wcm9wc1trZXldIDogdGhpcy5zdGF0ZVtrZXldO1xuICAgIH0gLy8gRklYTUU6IHVudHlwZWQgZmxvdyBjb2RlLCByZXR1cm4gYW55XG4gICAgO1xuXG4gICAgX3Byb3RvLmNhbGxQcm9wID0gZnVuY3Rpb24gY2FsbFByb3AobmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKF90aGlzJHByb3BzID0gdGhpcy5wcm9wcylbbmFtZV0uYXBwbHkoX3RoaXMkcHJvcHMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRlZmF1bHRJbnB1dFZhbHVlID0gX3RoaXMkcHJvcHMyLmRlZmF1bHRJbnB1dFZhbHVlLFxuICAgICAgICAgIGRlZmF1bHRNZW51SXNPcGVuID0gX3RoaXMkcHJvcHMyLmRlZmF1bHRNZW51SXNPcGVuLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IF90aGlzJHByb3BzMi5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczIsIFtcImRlZmF1bHRJbnB1dFZhbHVlXCIsIFwiZGVmYXVsdE1lbnVJc09wZW5cIiwgXCJkZWZhdWx0VmFsdWVcIl0pO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3RDb21wb25lbnQsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmKSB7XG4gICAgICAgICAgX3RoaXMyLnNlbGVjdCA9IF9yZWY7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0VmFsdWU6IHRoaXMuZ2V0UHJvcCgnaW5wdXRWYWx1ZScpLFxuICAgICAgICBtZW51SXNPcGVuOiB0aGlzLmdldFByb3AoJ21lbnVJc09wZW4nKSxcbiAgICAgICAgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2UsXG4gICAgICAgIG9uSW5wdXRDaGFuZ2U6IHRoaXMub25JbnB1dENoYW5nZSxcbiAgICAgICAgb25NZW51Q2xvc2U6IHRoaXMub25NZW51Q2xvc2UsXG4gICAgICAgIG9uTWVudU9wZW46IHRoaXMub25NZW51T3BlbixcbiAgICAgICAgdmFsdWU6IHRoaXMuZ2V0UHJvcCgndmFsdWUnKVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3RhdGVNYW5hZ2VyO1xuICB9KENvbXBvbmVudCksIF9jbGFzcy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMsIF90ZW1wO1xufTtcblxuZXhwb3J0IHsgbWFuYWdlU3RhdGUgYXMgbSB9O1xuIiwiLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBOTyBPUFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbi8vIENsYXNzIE5hbWUgUHJlZml4ZXJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgY29tcG9uZW50IHN0YXRlIGZvciBzdHlsaW5nIHdpdGggY2xhc3MgbmFtZXMuXG5cbiBFeHBlY3RzIGFuIGFycmF5IG9mIHN0cmluZ3MgT1IgYSBzdHJpbmcvb2JqZWN0IHBhaXI6XG4gLSBjbGFzc05hbWUoWydjb21wJywgJ2NvbXAtYXJnJywgJ2NvbXAtYXJnLTInXSlcbiAgIEByZXR1cm5zICdyZWFjdC1zZWxlY3RfX2NvbXAgcmVhY3Qtc2VsZWN0X19jb21wLWFyZyByZWFjdC1zZWxlY3RfX2NvbXAtYXJnLTInXG4gLSBjbGFzc05hbWUoJ2NvbXAnLCB7IHNvbWU6IHRydWUsIHN0YXRlOiBmYWxzZSB9KVxuICAgQHJldHVybnMgJ3JlYWN0LXNlbGVjdF9fY29tcCByZWFjdC1zZWxlY3RfX2NvbXAtLXNvbWUnXG4qL1xuXG5mdW5jdGlvbiBhcHBseVByZWZpeFRvTmFtZShwcmVmaXgsIG5hbWUpIHtcbiAgaWYgKCFuYW1lKSB7XG4gICAgcmV0dXJuIHByZWZpeDtcbiAgfSBlbHNlIGlmIChuYW1lWzBdID09PSAnLScpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgbmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ19fJyArIG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xhc3NOYW1lcyhwcmVmaXgsIHN0YXRlLCBjbGFzc05hbWUpIHtcbiAgdmFyIGFyciA9IFtjbGFzc05hbWVdO1xuXG4gIGlmIChzdGF0ZSAmJiBwcmVmaXgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHN0YXRlW2tleV0pIHtcbiAgICAgICAgYXJyLnB1c2goXCJcIiArIGFwcGx5UHJlZml4VG9OYW1lKHByZWZpeCwga2V5KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaTtcbiAgfSkubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIFN0cmluZyhpKS50cmltKCk7XG4gIH0pLmpvaW4oJyAnKTtcbn0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDbGVhbiBWYWx1ZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnZhciBjbGVhblZhbHVlID0gZnVuY3Rpb24gY2xlYW5WYWx1ZSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZS5maWx0ZXIoQm9vbGVhbik7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSByZXR1cm4gW3ZhbHVlXTtcbiAgcmV0dXJuIFtdO1xufTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIYW5kbGUgSW5wdXQgQ2hhbmdlXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gaGFuZGxlSW5wdXRDaGFuZ2UoaW5wdXRWYWx1ZSwgYWN0aW9uTWV0YSwgb25JbnB1dENoYW5nZSkge1xuICBpZiAob25JbnB1dENoYW5nZSkge1xuICAgIHZhciBuZXdWYWx1ZSA9IG9uSW5wdXRDaGFuZ2UoaW5wdXRWYWx1ZSwgYWN0aW9uTWV0YSk7XG4gICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBuZXdWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dFZhbHVlO1xufSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNjcm9sbCBIZWxwZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gaXNEb2N1bWVudEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHksIHdpbmRvd10uaW5kZXhPZihlbCkgPiAtMTtcbn0gLy8gTm9ybWFsaXplZCBTY3JvbGwgVG9wXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKGVsKSB7XG4gIGlmIChpc0RvY3VtZW50RWxlbWVudChlbCkpIHtcbiAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIGVsLnNjcm9sbFRvcDtcbn1cbmZ1bmN0aW9uIHNjcm9sbFRvKGVsLCB0b3ApIHtcbiAgLy8gd2l0aCBhIHNjcm9sbCBkaXN0YW5jZSwgd2UgcGVyZm9ybSBzY3JvbGwgb24gdGhlIGVsZW1lbnRcbiAgaWYgKGlzRG9jdW1lbnRFbGVtZW50KGVsKSkge1xuICAgIHdpbmRvdy5zY3JvbGxUbygwLCB0b3ApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsLnNjcm9sbFRvcCA9IHRvcDtcbn0gLy8gR2V0IFNjcm9sbCBQYXJlbnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgZXhjbHVkZVN0YXRpY1BhcmVudCA9IHN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xuICB2YXIgb3ZlcmZsb3dSeCA9IC8oYXV0b3xzY3JvbGwpLztcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyAvLyBzdWNrIGl0LCBmbG93Li4uXG5cbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSByZXR1cm4gZG9jRWw7XG5cbiAgZm9yICh2YXIgcGFyZW50ID0gZWxlbWVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7KSB7XG4gICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XG5cbiAgICBpZiAoZXhjbHVkZVN0YXRpY1BhcmVudCAmJiBzdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChvdmVyZmxvd1J4LnRlc3Qoc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1kgKyBzdHlsZS5vdmVyZmxvd1gpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb2NFbDtcbn0gLy8gQW5pbWF0ZWQgU2Nyb2xsIFRvXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gIEBwYXJhbSB0OiB0aW1lIChlbGFwc2VkKVxuICBAcGFyYW0gYjogaW5pdGlhbCB2YWx1ZVxuICBAcGFyYW0gYzogYW1vdW50IG9mIGNoYW5nZVxuICBAcGFyYW0gZDogZHVyYXRpb25cbiovXG5cbmZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICsgMSkgKyBiO1xufVxuXG5mdW5jdGlvbiBhbmltYXRlZFNjcm9sbFRvKGVsZW1lbnQsIHRvLCBkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICBkdXJhdGlvbiA9IDIwMDtcbiAgfVxuXG4gIGlmIChjYWxsYmFjayA9PT0gdm9pZCAwKSB7XG4gICAgY2FsbGJhY2sgPSBub29wO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gZ2V0U2Nyb2xsVG9wKGVsZW1lbnQpO1xuICB2YXIgY2hhbmdlID0gdG8gLSBzdGFydDtcbiAgdmFyIGluY3JlbWVudCA9IDEwO1xuICB2YXIgY3VycmVudFRpbWUgPSAwO1xuXG4gIGZ1bmN0aW9uIGFuaW1hdGVTY3JvbGwoKSB7XG4gICAgY3VycmVudFRpbWUgKz0gaW5jcmVtZW50O1xuICAgIHZhciB2YWwgPSBlYXNlT3V0Q3ViaWMoY3VycmVudFRpbWUsIHN0YXJ0LCBjaGFuZ2UsIGR1cmF0aW9uKTtcbiAgICBzY3JvbGxUbyhlbGVtZW50LCB2YWwpO1xuXG4gICAgaWYgKGN1cnJlbnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZVNjcm9sbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGFuaW1hdGVTY3JvbGwoKTtcbn0gLy8gU2Nyb2xsIEludG8gVmlld1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KG1lbnVFbCwgZm9jdXNlZEVsKSB7XG4gIHZhciBtZW51UmVjdCA9IG1lbnVFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGZvY3VzZWRSZWN0ID0gZm9jdXNlZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgb3ZlclNjcm9sbCA9IGZvY3VzZWRFbC5vZmZzZXRIZWlnaHQgLyAzO1xuXG4gIGlmIChmb2N1c2VkUmVjdC5ib3R0b20gKyBvdmVyU2Nyb2xsID4gbWVudVJlY3QuYm90dG9tKSB7XG4gICAgc2Nyb2xsVG8obWVudUVsLCBNYXRoLm1pbihmb2N1c2VkRWwub2Zmc2V0VG9wICsgZm9jdXNlZEVsLmNsaWVudEhlaWdodCAtIG1lbnVFbC5vZmZzZXRIZWlnaHQgKyBvdmVyU2Nyb2xsLCBtZW51RWwuc2Nyb2xsSGVpZ2h0KSk7XG4gIH0gZWxzZSBpZiAoZm9jdXNlZFJlY3QudG9wIC0gb3ZlclNjcm9sbCA8IG1lbnVSZWN0LnRvcCkge1xuICAgIHNjcm9sbFRvKG1lbnVFbCwgTWF0aC5tYXgoZm9jdXNlZEVsLm9mZnNldFRvcCAtIG92ZXJTY3JvbGwsIDApKTtcbiAgfVxufSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEdldCBib3VuZGluZyBjbGllbnQgb2JqZWN0XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGNhbm5vdCBnZXQga2V5cyB1c2luZyBhcnJheSBub3RhdGlvbiB3aXRoIERPTVJlY3RcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRPYmooZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICByaWdodDogcmVjdC5yaWdodCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LndpZHRoXG4gIH07XG59XG4vLyBUb3VjaCBDYXBhYmlsaXR5IERldGVjdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gaXNUb3VjaENhcGFibGUoKSB7XG4gIHRyeSB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ1RvdWNoRXZlbnQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1vYmlsZSBEZXZpY2UgRGV0ZWN0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBpc01vYmlsZURldmljZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCB7IGdldFNjcm9sbFBhcmVudCBhcyBhLCBnZXRTY3JvbGxUb3AgYXMgYiwgYW5pbWF0ZWRTY3JvbGxUbyBhcyBjLCBpc01vYmlsZURldmljZSBhcyBkLCBjbGVhblZhbHVlIGFzIGUsIHNjcm9sbEludG9WaWV3IGFzIGYsIGdldEJvdW5kaW5nQ2xpZW50T2JqIGFzIGcsIGNsYXNzTmFtZXMgYXMgaCwgaXNUb3VjaENhcGFibGUgYXMgaSwgaXNEb2N1bWVudEVsZW1lbnQgYXMgaiwgaGFuZGxlSW5wdXRDaGFuZ2UgYXMgaywgbm9vcCBhcyBuLCBzY3JvbGxUbyBhcyBzIH07XG4iLCJcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKXtyZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycil8fF9pdGVyYWJsZVRvQXJyYXkoYXJyKXx8X25vbkl0ZXJhYmxlU3ByZWFkKCk7fWZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTt9ZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpfHxPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcik9PT1cIltvYmplY3QgQXJndW1lbnRzXVwiKXJldHVybiBBcnJheS5mcm9tKGl0ZXIpO31mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKXtpZihBcnJheS5pc0FycmF5KGFycikpe2Zvcih2YXIgaT0wLGFycjI9bmV3IEFycmF5KGFyci5sZW5ndGgpO2k8YXJyLmxlbmd0aDtpKyspe2FycjJbaV09YXJyW2ldO31yZXR1cm4gYXJyMjt9fWZ1bmN0aW9uIF90eXBlb2Yob2JqKXtcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7aWYodHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVwic3ltYm9sXCIpe190eXBlb2Y9ZnVuY3Rpb24gX3R5cGVvZihvYmope3JldHVybiB0eXBlb2Ygb2JqO307fWVsc2V7X3R5cGVvZj1mdW5jdGlvbiBfdHlwZW9mKG9iail7cmV0dXJuIG9iaiYmdHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmb2JqLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZvYmohPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIG9iajt9O31yZXR1cm4gX3R5cGVvZihvYmopO30oZnVuY3Rpb24oZil7aWYoKHR5cGVvZiBleHBvcnRzPT09XCJ1bmRlZmluZWRcIj9cInVuZGVmaW5lZFwiOl90eXBlb2YoZXhwb3J0cykpPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKTt9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZik7fWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93O31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbDt9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZjt9ZWxzZXtnPXRoaXM7fWcuc2FuaXRpemVIdG1sPWYoKTt9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhO312YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cik7fSxwLHAuZXhwb3J0cyxyLGUsbix0KTt9cmV0dXJuIG5baV0uZXhwb3J0czt9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKXtvKHRbaV0pO31yZXR1cm4gbzt9cmV0dXJuIHI7fSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsndXNlIHN0cmljdCc7ZXhwb3J0cy5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ZXhwb3J0cy50b0J5dGVBcnJheT10b0J5dGVBcnJheTtleHBvcnRzLmZyb21CeXRlQXJyYXk9ZnJvbUJ5dGVBcnJheTt2YXIgbG9va3VwPVtdO3ZhciByZXZMb29rdXA9W107dmFyIEFycj10eXBlb2YgVWludDhBcnJheSE9PSd1bmRlZmluZWQnP1VpbnQ4QXJyYXk6QXJyYXk7dmFyIGNvZGU9J0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO2Zvcih2YXIgaT0wLGxlbj1jb2RlLmxlbmd0aDtpPGxlbjsrK2kpe2xvb2t1cFtpXT1jb2RlW2ldO3Jldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldPWk7fS8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV09NjI7cmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGI2NCl7dmFyIGxlbj1iNjQubGVuZ3RoO2lmKGxlbiU0PjApe3Rocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpO30vLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxudmFyIHZhbGlkTGVuPWI2NC5pbmRleE9mKCc9Jyk7aWYodmFsaWRMZW49PT0tMSl2YWxpZExlbj1sZW47dmFyIHBsYWNlSG9sZGVyc0xlbj12YWxpZExlbj09PWxlbj8wOjQtdmFsaWRMZW4lNDtyZXR1cm5bdmFsaWRMZW4scGxhY2VIb2xkZXJzTGVuXTt9Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoKGI2NCl7dmFyIGxlbnM9Z2V0TGVucyhiNjQpO3ZhciB2YWxpZExlbj1sZW5zWzBdO3ZhciBwbGFjZUhvbGRlcnNMZW49bGVuc1sxXTtyZXR1cm4odmFsaWRMZW4rcGxhY2VIb2xkZXJzTGVuKSozLzQtcGxhY2VIb2xkZXJzTGVuO31mdW5jdGlvbiBfYnl0ZUxlbmd0aChiNjQsdmFsaWRMZW4scGxhY2VIb2xkZXJzTGVuKXtyZXR1cm4odmFsaWRMZW4rcGxhY2VIb2xkZXJzTGVuKSozLzQtcGxhY2VIb2xkZXJzTGVuO31mdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpe3ZhciB0bXA7dmFyIGxlbnM9Z2V0TGVucyhiNjQpO3ZhciB2YWxpZExlbj1sZW5zWzBdO3ZhciBwbGFjZUhvbGRlcnNMZW49bGVuc1sxXTt2YXIgYXJyPW5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LHZhbGlkTGVuLHBsYWNlSG9sZGVyc0xlbikpO3ZhciBjdXJCeXRlPTA7Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xudmFyIGxlbj1wbGFjZUhvbGRlcnNMZW4+MD92YWxpZExlbi00OnZhbGlkTGVuO3ZhciBpO2ZvcihpPTA7aTxsZW47aSs9NCl7dG1wPXJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV08PDE4fHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKzEpXTw8MTJ8cmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkrMildPDw2fHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKzMpXTthcnJbY3VyQnl0ZSsrXT10bXA+PjE2JjB4RkY7YXJyW2N1ckJ5dGUrK109dG1wPj44JjB4RkY7YXJyW2N1ckJ5dGUrK109dG1wJjB4RkY7fWlmKHBsYWNlSG9sZGVyc0xlbj09PTIpe3RtcD1yZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldPDwyfHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKzEpXT4+NDthcnJbY3VyQnl0ZSsrXT10bXAmMHhGRjt9aWYocGxhY2VIb2xkZXJzTGVuPT09MSl7dG1wPXJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV08PDEwfHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKzEpXTw8NHxyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSsyKV0+PjI7YXJyW2N1ckJ5dGUrK109dG1wPj44JjB4RkY7YXJyW2N1ckJ5dGUrK109dG1wJjB4RkY7fXJldHVybiBhcnI7fWZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pe3JldHVybiBsb29rdXBbbnVtPj4xOCYweDNGXStsb29rdXBbbnVtPj4xMiYweDNGXStsb29rdXBbbnVtPj42JjB4M0ZdK2xvb2t1cFtudW0mMHgzRl07fWZ1bmN0aW9uIGVuY29kZUNodW5rKHVpbnQ4LHN0YXJ0LGVuZCl7dmFyIHRtcDt2YXIgb3V0cHV0PVtdO2Zvcih2YXIgaT1zdGFydDtpPGVuZDtpKz0zKXt0bXA9KHVpbnQ4W2ldPDwxNiYweEZGMDAwMCkrKHVpbnQ4W2krMV08PDgmMHhGRjAwKSsodWludDhbaSsyXSYweEZGKTtvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7fXJldHVybiBvdXRwdXQuam9pbignJyk7fWZ1bmN0aW9uIGZyb21CeXRlQXJyYXkodWludDgpe3ZhciB0bXA7dmFyIGxlbj11aW50OC5sZW5ndGg7dmFyIGV4dHJhQnl0ZXM9bGVuJTM7Ly8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbnZhciBwYXJ0cz1bXTt2YXIgbWF4Q2h1bmtMZW5ndGg9MTYzODM7Ly8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG4vLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5mb3IodmFyIGk9MCxsZW4yPWxlbi1leHRyYUJ5dGVzO2k8bGVuMjtpKz1tYXhDaHVua0xlbmd0aCl7cGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCxpLGkrbWF4Q2h1bmtMZW5ndGg+bGVuMj9sZW4yOmkrbWF4Q2h1bmtMZW5ndGgpKTt9Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuaWYoZXh0cmFCeXRlcz09PTEpe3RtcD11aW50OFtsZW4tMV07cGFydHMucHVzaChsb29rdXBbdG1wPj4yXStsb29rdXBbdG1wPDw0JjB4M0ZdKyc9PScpO31lbHNlIGlmKGV4dHJhQnl0ZXM9PT0yKXt0bXA9KHVpbnQ4W2xlbi0yXTw8OCkrdWludDhbbGVuLTFdO3BhcnRzLnB1c2gobG9va3VwW3RtcD4+MTBdK2xvb2t1cFt0bXA+PjQmMHgzRl0rbG9va3VwW3RtcDw8MiYweDNGXSsnPScpO31yZXR1cm4gcGFydHMuam9pbignJyk7fX0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe30se31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpey8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqLyAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqLyd1c2Ugc3RyaWN0Jzt2YXIgYmFzZTY0PXJlcXVpcmUoJ2Jhc2U2NC1qcycpO3ZhciBpZWVlNzU0PXJlcXVpcmUoJ2llZWU3NTQnKTt2YXIgY3VzdG9tSW5zcGVjdFN5bWJvbD10eXBlb2YgU3ltYm9sPT09J2Z1bmN0aW9uJyYmdHlwZW9mIFN5bWJvbFtcImZvclwiXT09PSdmdW5jdGlvbic/U3ltYm9sW1wiZm9yXCJdKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpOm51bGw7ZXhwb3J0cy5CdWZmZXI9QnVmZmVyO2V4cG9ydHMuU2xvd0J1ZmZlcj1TbG93QnVmZmVyO2V4cG9ydHMuSU5TUEVDVF9NQVhfQllURVM9NTA7dmFyIEtfTUFYX0xFTkdUSD0weDdmZmZmZmZmO2V4cG9ydHMua01heExlbmd0aD1LX01BWF9MRU5HVEg7LyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL0J1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUPXR5cGVkQXJyYXlTdXBwb3J0KCk7aWYoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgY29uc29sZS5lcnJvcj09PSdmdW5jdGlvbicpe2NvbnNvbGUuZXJyb3IoJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnKydgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LicpO31mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpey8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbnRyeXt2YXIgYXJyPW5ldyBVaW50OEFycmF5KDEpO3ZhciBwcm90bz17Zm9vOmZ1bmN0aW9uIGZvbygpe3JldHVybiA0Mjt9fTtPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihhcnIscHJvdG8pO3JldHVybiBhcnIuZm9vKCk9PT00Mjt9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlO319T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsJ3BhcmVudCcse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcjt9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsJ29mZnNldCcse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXQ7fX0pO2Z1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihsZW5ndGgpe2lmKGxlbmd0aD5LX01BWF9MRU5HVEgpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2xlbmd0aCsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyk7fS8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG52YXIgYnVmPW5ldyBVaW50OEFycmF5KGxlbmd0aCk7T2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gYnVmO30vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovZnVuY3Rpb24gQnVmZmVyKGFyZyxlbmNvZGluZ09yT2Zmc2V0LGxlbmd0aCl7Ly8gQ29tbW9uIGNhc2UuXG5pZih0eXBlb2YgYXJnPT09J251bWJlcicpe2lmKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0PT09J3N0cmluZycpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7fXJldHVybiBhbGxvY1Vuc2FmZShhcmcpO31yZXR1cm4gZnJvbShhcmcsZW5jb2RpbmdPck9mZnNldCxsZW5ndGgpO30vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYodHlwZW9mIFN5bWJvbCE9PSd1bmRlZmluZWQnJiZTeW1ib2wuc3BlY2llcyE9bnVsbCYmQnVmZmVyW1N5bWJvbC5zcGVjaWVzXT09PUJ1ZmZlcil7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcixTeW1ib2wuc3BlY2llcyx7dmFsdWU6bnVsbCxjb25maWd1cmFibGU6dHJ1ZSxlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOmZhbHNlfSk7fUJ1ZmZlci5wb29sU2l6ZT04MTkyOy8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGZyb20odmFsdWUsZW5jb2RpbmdPck9mZnNldCxsZW5ndGgpe2lmKHR5cGVvZiB2YWx1ZT09PSdzdHJpbmcnKXtyZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSxlbmNvZGluZ09yT2Zmc2V0KTt9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSl7cmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpO31pZih2YWx1ZT09bnVsbCl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJysnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJytfdHlwZW9mKHZhbHVlKSk7fWlmKGlzSW5zdGFuY2UodmFsdWUsQXJyYXlCdWZmZXIpfHx2YWx1ZSYmaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLGVuY29kaW5nT3JPZmZzZXQsbGVuZ3RoKTt9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09J3VuZGVmaW5lZCcmJihpc0luc3RhbmNlKHZhbHVlLFNoYXJlZEFycmF5QnVmZmVyKXx8dmFsdWUmJmlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsZW5jb2RpbmdPck9mZnNldCxsZW5ndGgpO31pZih0eXBlb2YgdmFsdWU9PT0nbnVtYmVyJyl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTt9dmFyIHZhbHVlT2Y9dmFsdWUudmFsdWVPZiYmdmFsdWUudmFsdWVPZigpO2lmKHZhbHVlT2YhPW51bGwmJnZhbHVlT2YhPT12YWx1ZSl7cmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsZW5jb2RpbmdPck9mZnNldCxsZW5ndGgpO312YXIgYj1mcm9tT2JqZWN0KHZhbHVlKTtpZihiKXJldHVybiBiO2lmKHR5cGVvZiBTeW1ib2whPT0ndW5kZWZpbmVkJyYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXT09PSdmdW5jdGlvbicpe3JldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSxlbmNvZGluZ09yT2Zmc2V0LGxlbmd0aCk7fXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcrJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcrX3R5cGVvZih2YWx1ZSkpO30vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovQnVmZmVyLmZyb209ZnVuY3Rpb24odmFsdWUsZW5jb2RpbmdPck9mZnNldCxsZW5ndGgpe3JldHVybiBmcm9tKHZhbHVlLGVuY29kaW5nT3JPZmZzZXQsbGVuZ3RoKTt9Oy8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSxVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcixVaW50OEFycmF5KTtmdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpe2lmKHR5cGVvZiBzaXplIT09J251bWJlcicpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKTt9ZWxzZSBpZihzaXplPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK3NpemUrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpO319ZnVuY3Rpb24gYWxsb2Moc2l6ZSxmaWxsLGVuY29kaW5nKXthc3NlcnRTaXplKHNpemUpO2lmKHNpemU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSk7fWlmKGZpbGwhPT11bmRlZmluZWQpey8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4vLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4vLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG5yZXR1cm4gdHlwZW9mIGVuY29kaW5nPT09J3N0cmluZyc/Y3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCxlbmNvZGluZyk6Y3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCk7fXJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSk7fS8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL0J1ZmZlci5hbGxvYz1mdW5jdGlvbihzaXplLGZpbGwsZW5jb2Rpbmcpe3JldHVybiBhbGxvYyhzaXplLGZpbGwsZW5jb2RpbmcpO307ZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSl7YXNzZXJ0U2l6ZShzaXplKTtyZXR1cm4gY3JlYXRlQnVmZmVyKHNpemU8MD8wOmNoZWNrZWQoc2l6ZSl8MCk7fS8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovQnVmZmVyLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKHNpemUpe3JldHVybiBhbGxvY1Vuc2FmZShzaXplKTt9Oy8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9CdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKHNpemUpe3JldHVybiBhbGxvY1Vuc2FmZShzaXplKTt9O2Z1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nLGVuY29kaW5nKXtpZih0eXBlb2YgZW5jb2RpbmchPT0nc3RyaW5nJ3x8ZW5jb2Rpbmc9PT0nJyl7ZW5jb2Rpbmc9J3V0ZjgnO31pZighQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnK2VuY29kaW5nKTt9dmFyIGxlbmd0aD1ieXRlTGVuZ3RoKHN0cmluZyxlbmNvZGluZyl8MDt2YXIgYnVmPWNyZWF0ZUJ1ZmZlcihsZW5ndGgpO3ZhciBhY3R1YWw9YnVmLndyaXRlKHN0cmluZyxlbmNvZGluZyk7aWYoYWN0dWFsIT09bGVuZ3RoKXsvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbi8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4vLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbmJ1Zj1idWYuc2xpY2UoMCxhY3R1YWwpO31yZXR1cm4gYnVmO31mdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5KXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDwwPzA6Y2hlY2tlZChhcnJheS5sZW5ndGgpfDA7dmFyIGJ1Zj1jcmVhdGVCdWZmZXIobGVuZ3RoKTtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKz0xKXtidWZbaV09YXJyYXlbaV0mMjU1O31yZXR1cm4gYnVmO31mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXksYnl0ZU9mZnNldCxsZW5ndGgpe2lmKGJ5dGVPZmZzZXQ8MHx8YXJyYXkuYnl0ZUxlbmd0aDxieXRlT2Zmc2V0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTt9aWYoYXJyYXkuYnl0ZUxlbmd0aDxieXRlT2Zmc2V0KyhsZW5ndGh8fDApKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTt9dmFyIGJ1ZjtpZihieXRlT2Zmc2V0PT09dW5kZWZpbmVkJiZsZW5ndGg9PT11bmRlZmluZWQpe2J1Zj1uZXcgVWludDhBcnJheShhcnJheSk7fWVsc2UgaWYobGVuZ3RoPT09dW5kZWZpbmVkKXtidWY9bmV3IFVpbnQ4QXJyYXkoYXJyYXksYnl0ZU9mZnNldCk7fWVsc2V7YnVmPW5ldyBVaW50OEFycmF5KGFycmF5LGJ5dGVPZmZzZXQsbGVuZ3RoKTt9Ly8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2Vcbk9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGJ1Zjt9ZnVuY3Rpb24gZnJvbU9iamVjdChvYmope2lmKEJ1ZmZlci5pc0J1ZmZlcihvYmopKXt2YXIgbGVuPWNoZWNrZWQob2JqLmxlbmd0aCl8MDt2YXIgYnVmPWNyZWF0ZUJ1ZmZlcihsZW4pO2lmKGJ1Zi5sZW5ndGg9PT0wKXtyZXR1cm4gYnVmO31vYmouY29weShidWYsMCwwLGxlbik7cmV0dXJuIGJ1Zjt9aWYob2JqLmxlbmd0aCE9PXVuZGVmaW5lZCl7aWYodHlwZW9mIG9iai5sZW5ndGghPT0nbnVtYmVyJ3x8bnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpe3JldHVybiBjcmVhdGVCdWZmZXIoMCk7fXJldHVybiBmcm9tQXJyYXlMaWtlKG9iaik7fWlmKG9iai50eXBlPT09J0J1ZmZlcicmJkFycmF5LmlzQXJyYXkob2JqLmRhdGEpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSk7fX1mdW5jdGlvbiBjaGVja2VkKGxlbmd0aCl7Ly8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4vLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbmlmKGxlbmd0aD49S19NQVhfTEVOR1RIKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnKydzaXplOiAweCcrS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSsnIGJ5dGVzJyk7fXJldHVybiBsZW5ndGh8MDt9ZnVuY3Rpb24gU2xvd0J1ZmZlcihsZW5ndGgpe2lmKCtsZW5ndGghPWxlbmd0aCl7Ly8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbmxlbmd0aD0wO31yZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpO31CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoYil7cmV0dXJuIGIhPW51bGwmJmIuX2lzQnVmZmVyPT09dHJ1ZSYmYiE9PUJ1ZmZlci5wcm90b3R5cGU7Ly8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn07QnVmZmVyLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShhLGIpe2lmKGlzSW5zdGFuY2UoYSxVaW50OEFycmF5KSlhPUJ1ZmZlci5mcm9tKGEsYS5vZmZzZXQsYS5ieXRlTGVuZ3RoKTtpZihpc0luc3RhbmNlKGIsVWludDhBcnJheSkpYj1CdWZmZXIuZnJvbShiLGIub2Zmc2V0LGIuYnl0ZUxlbmd0aCk7aWYoIUJ1ZmZlci5pc0J1ZmZlcihhKXx8IUJ1ZmZlci5pc0J1ZmZlcihiKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpO31pZihhPT09YilyZXR1cm4gMDt2YXIgeD1hLmxlbmd0aDt2YXIgeT1iLmxlbmd0aDtmb3IodmFyIGk9MCxsZW49TWF0aC5taW4oeCx5KTtpPGxlbjsrK2kpe2lmKGFbaV0hPT1iW2ldKXt4PWFbaV07eT1iW2ldO2JyZWFrO319aWYoeDx5KXJldHVybi0xO2lmKHk8eClyZXR1cm4gMTtyZXR1cm4gMDt9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZW5jb2Rpbmcpe3N3aXRjaChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpe2Nhc2UnaGV4JzpjYXNlJ3V0ZjgnOmNhc2UndXRmLTgnOmNhc2UnYXNjaWknOmNhc2UnbGF0aW4xJzpjYXNlJ2JpbmFyeSc6Y2FzZSdiYXNlNjQnOmNhc2UndWNzMic6Y2FzZSd1Y3MtMic6Y2FzZSd1dGYxNmxlJzpjYXNlJ3V0Zi0xNmxlJzpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZTt9fTtCdWZmZXIuY29uY2F0PWZ1bmN0aW9uIGNvbmNhdChsaXN0LGxlbmd0aCl7aWYoIUFycmF5LmlzQXJyYXkobGlzdCkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO31pZihsaXN0Lmxlbmd0aD09PTApe3JldHVybiBCdWZmZXIuYWxsb2MoMCk7fXZhciBpO2lmKGxlbmd0aD09PXVuZGVmaW5lZCl7bGVuZ3RoPTA7Zm9yKGk9MDtpPGxpc3QubGVuZ3RoOysraSl7bGVuZ3RoKz1saXN0W2ldLmxlbmd0aDt9fXZhciBidWZmZXI9QnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7dmFyIHBvcz0wO2ZvcihpPTA7aTxsaXN0Lmxlbmd0aDsrK2kpe3ZhciBidWY9bGlzdFtpXTtpZihpc0luc3RhbmNlKGJ1ZixVaW50OEFycmF5KSl7YnVmPUJ1ZmZlci5mcm9tKGJ1Zik7fWlmKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7fWJ1Zi5jb3B5KGJ1ZmZlcixwb3MpO3Bvcys9YnVmLmxlbmd0aDt9cmV0dXJuIGJ1ZmZlcjt9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nLGVuY29kaW5nKXtpZihCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSl7cmV0dXJuIHN0cmluZy5sZW5ndGg7fWlmKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpfHxpc0luc3RhbmNlKHN0cmluZyxBcnJheUJ1ZmZlcikpe3JldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDt9aWYodHlwZW9mIHN0cmluZyE9PSdzdHJpbmcnKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJysnUmVjZWl2ZWQgdHlwZSAnK190eXBlb2Yoc3RyaW5nKSk7fXZhciBsZW49c3RyaW5nLmxlbmd0aDt2YXIgbXVzdE1hdGNoPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighbXVzdE1hdGNoJiZsZW49PT0wKXJldHVybiAwOy8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxudmFyIGxvd2VyZWRDYXNlPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKGVuY29kaW5nKXtjYXNlJ2FzY2lpJzpjYXNlJ2xhdGluMSc6Y2FzZSdiaW5hcnknOnJldHVybiBsZW47Y2FzZSd1dGY4JzpjYXNlJ3V0Zi04JzpyZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7Y2FzZSd1Y3MyJzpjYXNlJ3Vjcy0yJzpjYXNlJ3V0ZjE2bGUnOmNhc2UndXRmLTE2bGUnOnJldHVybiBsZW4qMjtjYXNlJ2hleCc6cmV0dXJuIGxlbj4+PjE7Y2FzZSdiYXNlNjQnOnJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoO2RlZmF1bHQ6aWYobG93ZXJlZENhc2Upe3JldHVybiBtdXN0TWF0Y2g/LTE6dXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7Ly8gYXNzdW1lIHV0Zjhcbn1lbmNvZGluZz0oJycrZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7bG93ZXJlZENhc2U9dHJ1ZTt9fX1CdWZmZXIuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO2Z1bmN0aW9uIHNsb3dUb1N0cmluZyhlbmNvZGluZyxzdGFydCxlbmQpe3ZhciBsb3dlcmVkQ2FzZT1mYWxzZTsvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbi8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG4vLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbi8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbi8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4vLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbmlmKHN0YXJ0PT09dW5kZWZpbmVkfHxzdGFydDwwKXtzdGFydD0wO30vLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbmlmKHN0YXJ0PnRoaXMubGVuZ3RoKXtyZXR1cm4nJzt9aWYoZW5kPT09dW5kZWZpbmVkfHxlbmQ+dGhpcy5sZW5ndGgpe2VuZD10aGlzLmxlbmd0aDt9aWYoZW5kPD0wKXtyZXR1cm4nJzt9Ly8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbmVuZD4+Pj0wO3N0YXJ0Pj4+PTA7aWYoZW5kPD1zdGFydCl7cmV0dXJuJyc7fWlmKCFlbmNvZGluZyllbmNvZGluZz0ndXRmOCc7d2hpbGUodHJ1ZSl7c3dpdGNoKGVuY29kaW5nKXtjYXNlJ2hleCc6cmV0dXJuIGhleFNsaWNlKHRoaXMsc3RhcnQsZW5kKTtjYXNlJ3V0ZjgnOmNhc2UndXRmLTgnOnJldHVybiB1dGY4U2xpY2UodGhpcyxzdGFydCxlbmQpO2Nhc2UnYXNjaWknOnJldHVybiBhc2NpaVNsaWNlKHRoaXMsc3RhcnQsZW5kKTtjYXNlJ2xhdGluMSc6Y2FzZSdiaW5hcnknOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHN0YXJ0LGVuZCk7Y2FzZSdiYXNlNjQnOnJldHVybiBiYXNlNjRTbGljZSh0aGlzLHN0YXJ0LGVuZCk7Y2FzZSd1Y3MyJzpjYXNlJ3Vjcy0yJzpjYXNlJ3V0ZjE2bGUnOmNhc2UndXRmLTE2bGUnOnJldHVybiB1dGYxNmxlU2xpY2UodGhpcyxzdGFydCxlbmQpO2RlZmF1bHQ6aWYobG93ZXJlZENhc2UpdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJytlbmNvZGluZyk7ZW5jb2Rpbmc9KGVuY29kaW5nKycnKS50b0xvd2VyQ2FzZSgpO2xvd2VyZWRDYXNlPXRydWU7fX19Ly8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoYixuLG0pe3ZhciBpPWJbbl07YltuXT1iW21dO2JbbV09aTt9QnVmZmVyLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24gc3dhcDE2KCl7dmFyIGxlbj10aGlzLmxlbmd0aDtpZihsZW4lMiE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpO31mb3IodmFyIGk9MDtpPGxlbjtpKz0yKXtzd2FwKHRoaXMsaSxpKzEpO31yZXR1cm4gdGhpczt9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uIHN3YXAzMigpe3ZhciBsZW49dGhpcy5sZW5ndGg7aWYobGVuJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKTt9Zm9yKHZhciBpPTA7aTxsZW47aSs9NCl7c3dhcCh0aGlzLGksaSszKTtzd2FwKHRoaXMsaSsxLGkrMik7fXJldHVybiB0aGlzO307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGxlbj10aGlzLmxlbmd0aDtpZihsZW4lOCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpO31mb3IodmFyIGk9MDtpPGxlbjtpKz04KXtzd2FwKHRoaXMsaSxpKzcpO3N3YXAodGhpcyxpKzEsaSs2KTtzd2FwKHRoaXMsaSsyLGkrNSk7c3dhcCh0aGlzLGkrMyxpKzQpO31yZXR1cm4gdGhpczt9O0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXt2YXIgbGVuZ3RoPXRoaXMubGVuZ3RoO2lmKGxlbmd0aD09PTApcmV0dXJuJyc7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsbGVuZ3RoKTtyZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoYil7aWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyk7aWYodGhpcz09PWIpcmV0dXJuIHRydWU7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsYik9PT0wO307QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uIGluc3BlY3QoKXt2YXIgc3RyPScnO3ZhciBtYXg9ZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUztzdHI9dGhpcy50b1N0cmluZygnaGV4JywwLG1heCkucmVwbGFjZSgvKC57Mn0pL2csJyQxICcpLnRyaW0oKTtpZih0aGlzLmxlbmd0aD5tYXgpc3RyKz0nIC4uLiAnO3JldHVybic8QnVmZmVyICcrc3RyKyc+Jzt9O2lmKGN1c3RvbUluc3BlY3RTeW1ib2wpe0J1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF09QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0O31CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZSh0YXJnZXQsc3RhcnQsZW5kLHRoaXNTdGFydCx0aGlzRW5kKXtpZihpc0luc3RhbmNlKHRhcmdldCxVaW50OEFycmF5KSl7dGFyZ2V0PUJ1ZmZlci5mcm9tKHRhcmdldCx0YXJnZXQub2Zmc2V0LHRhcmdldC5ieXRlTGVuZ3RoKTt9aWYoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnKydSZWNlaXZlZCB0eXBlICcrX3R5cGVvZih0YXJnZXQpKTt9aWYoc3RhcnQ9PT11bmRlZmluZWQpe3N0YXJ0PTA7fWlmKGVuZD09PXVuZGVmaW5lZCl7ZW5kPXRhcmdldD90YXJnZXQubGVuZ3RoOjA7fWlmKHRoaXNTdGFydD09PXVuZGVmaW5lZCl7dGhpc1N0YXJ0PTA7fWlmKHRoaXNFbmQ9PT11bmRlZmluZWQpe3RoaXNFbmQ9dGhpcy5sZW5ndGg7fWlmKHN0YXJ0PDB8fGVuZD50YXJnZXQubGVuZ3RofHx0aGlzU3RhcnQ8MHx8dGhpc0VuZD50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpO31pZih0aGlzU3RhcnQ+PXRoaXNFbmQmJnN0YXJ0Pj1lbmQpe3JldHVybiAwO31pZih0aGlzU3RhcnQ+PXRoaXNFbmQpe3JldHVybi0xO31pZihzdGFydD49ZW5kKXtyZXR1cm4gMTt9c3RhcnQ+Pj49MDtlbmQ+Pj49MDt0aGlzU3RhcnQ+Pj49MDt0aGlzRW5kPj4+PTA7aWYodGhpcz09PXRhcmdldClyZXR1cm4gMDt2YXIgeD10aGlzRW5kLXRoaXNTdGFydDt2YXIgeT1lbmQtc3RhcnQ7dmFyIGxlbj1NYXRoLm1pbih4LHkpO3ZhciB0aGlzQ29weT10aGlzLnNsaWNlKHRoaXNTdGFydCx0aGlzRW5kKTt2YXIgdGFyZ2V0Q29weT10YXJnZXQuc2xpY2Uoc3RhcnQsZW5kKTtmb3IodmFyIGk9MDtpPGxlbjsrK2kpe2lmKHRoaXNDb3B5W2ldIT09dGFyZ2V0Q29weVtpXSl7eD10aGlzQ29weVtpXTt5PXRhcmdldENvcHlbaV07YnJlYWs7fX1pZih4PHkpcmV0dXJuLTE7aWYoeTx4KXJldHVybiAxO3JldHVybiAwO307Ly8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihidWZmZXIsdmFsLGJ5dGVPZmZzZXQsZW5jb2RpbmcsZGlyKXsvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbmlmKGJ1ZmZlci5sZW5ndGg9PT0wKXJldHVybi0xOy8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG5pZih0eXBlb2YgYnl0ZU9mZnNldD09PSdzdHJpbmcnKXtlbmNvZGluZz1ieXRlT2Zmc2V0O2J5dGVPZmZzZXQ9MDt9ZWxzZSBpZihieXRlT2Zmc2V0PjB4N2ZmZmZmZmYpe2J5dGVPZmZzZXQ9MHg3ZmZmZmZmZjt9ZWxzZSBpZihieXRlT2Zmc2V0PC0weDgwMDAwMDAwKXtieXRlT2Zmc2V0PS0weDgwMDAwMDAwO31ieXRlT2Zmc2V0PStieXRlT2Zmc2V0Oy8vIENvZXJjZSB0byBOdW1iZXIuXG5pZihudW1iZXJJc05hTihieXRlT2Zmc2V0KSl7Ly8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG5ieXRlT2Zmc2V0PWRpcj8wOmJ1ZmZlci5sZW5ndGgtMTt9Ly8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbmlmKGJ5dGVPZmZzZXQ8MClieXRlT2Zmc2V0PWJ1ZmZlci5sZW5ndGgrYnl0ZU9mZnNldDtpZihieXRlT2Zmc2V0Pj1idWZmZXIubGVuZ3RoKXtpZihkaXIpcmV0dXJuLTE7ZWxzZSBieXRlT2Zmc2V0PWJ1ZmZlci5sZW5ndGgtMTt9ZWxzZSBpZihieXRlT2Zmc2V0PDApe2lmKGRpcilieXRlT2Zmc2V0PTA7ZWxzZSByZXR1cm4tMTt9Ly8gTm9ybWFsaXplIHZhbFxuaWYodHlwZW9mIHZhbD09PSdzdHJpbmcnKXt2YWw9QnVmZmVyLmZyb20odmFsLGVuY29kaW5nKTt9Ly8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbmlmKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKXsvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG5pZih2YWwubGVuZ3RoPT09MCl7cmV0dXJuLTE7fXJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLHZhbCxieXRlT2Zmc2V0LGVuY29kaW5nLGRpcik7fWVsc2UgaWYodHlwZW9mIHZhbD09PSdudW1iZXInKXt2YWw9dmFsJjB4RkY7Ly8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuaWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT0nZnVuY3Rpb24nKXtpZihkaXIpe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLHZhbCxieXRlT2Zmc2V0KTt9ZWxzZXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsdmFsLGJ5dGVPZmZzZXQpO319cmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsW3ZhbF0sYnl0ZU9mZnNldCxlbmNvZGluZyxkaXIpO310aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKTt9ZnVuY3Rpb24gYXJyYXlJbmRleE9mKGFycix2YWwsYnl0ZU9mZnNldCxlbmNvZGluZyxkaXIpe3ZhciBpbmRleFNpemU9MTt2YXIgYXJyTGVuZ3RoPWFyci5sZW5ndGg7dmFyIHZhbExlbmd0aD12YWwubGVuZ3RoO2lmKGVuY29kaW5nIT09dW5kZWZpbmVkKXtlbmNvZGluZz1TdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7aWYoZW5jb2Rpbmc9PT0ndWNzMid8fGVuY29kaW5nPT09J3Vjcy0yJ3x8ZW5jb2Rpbmc9PT0ndXRmMTZsZSd8fGVuY29kaW5nPT09J3V0Zi0xNmxlJyl7aWYoYXJyLmxlbmd0aDwyfHx2YWwubGVuZ3RoPDIpe3JldHVybi0xO31pbmRleFNpemU9MjthcnJMZW5ndGgvPTI7dmFsTGVuZ3RoLz0yO2J5dGVPZmZzZXQvPTI7fX1mdW5jdGlvbiByZWFkKGJ1ZixpKXtpZihpbmRleFNpemU9PT0xKXtyZXR1cm4gYnVmW2ldO31lbHNle3JldHVybiBidWYucmVhZFVJbnQxNkJFKGkqaW5kZXhTaXplKTt9fXZhciBpO2lmKGRpcil7dmFyIGZvdW5kSW5kZXg9LTE7Zm9yKGk9Ynl0ZU9mZnNldDtpPGFyckxlbmd0aDtpKyspe2lmKHJlYWQoYXJyLGkpPT09cmVhZCh2YWwsZm91bmRJbmRleD09PS0xPzA6aS1mb3VuZEluZGV4KSl7aWYoZm91bmRJbmRleD09PS0xKWZvdW5kSW5kZXg9aTtpZihpLWZvdW5kSW5kZXgrMT09PXZhbExlbmd0aClyZXR1cm4gZm91bmRJbmRleCppbmRleFNpemU7fWVsc2V7aWYoZm91bmRJbmRleCE9PS0xKWktPWktZm91bmRJbmRleDtmb3VuZEluZGV4PS0xO319fWVsc2V7aWYoYnl0ZU9mZnNldCt2YWxMZW5ndGg+YXJyTGVuZ3RoKWJ5dGVPZmZzZXQ9YXJyTGVuZ3RoLXZhbExlbmd0aDtmb3IoaT1ieXRlT2Zmc2V0O2k+PTA7aS0tKXt2YXIgZm91bmQ9dHJ1ZTtmb3IodmFyIGo9MDtqPHZhbExlbmd0aDtqKyspe2lmKHJlYWQoYXJyLGkraikhPT1yZWFkKHZhbCxqKSl7Zm91bmQ9ZmFsc2U7YnJlYWs7fX1pZihmb3VuZClyZXR1cm4gaTt9fXJldHVybi0xO31CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uIGluY2x1ZGVzKHZhbCxieXRlT2Zmc2V0LGVuY29kaW5nKXtyZXR1cm4gdGhpcy5pbmRleE9mKHZhbCxieXRlT2Zmc2V0LGVuY29kaW5nKSE9PS0xO307QnVmZmVyLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uIGluZGV4T2YodmFsLGJ5dGVPZmZzZXQsZW5jb2Rpbmcpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLHZhbCxieXRlT2Zmc2V0LGVuY29kaW5nLHRydWUpO307QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZih2YWwsYnl0ZU9mZnNldCxlbmNvZGluZyl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsdmFsLGJ5dGVPZmZzZXQsZW5jb2RpbmcsZmFsc2UpO307ZnVuY3Rpb24gaGV4V3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXtvZmZzZXQ9TnVtYmVyKG9mZnNldCl8fDA7dmFyIHJlbWFpbmluZz1idWYubGVuZ3RoLW9mZnNldDtpZighbGVuZ3RoKXtsZW5ndGg9cmVtYWluaW5nO31lbHNle2xlbmd0aD1OdW1iZXIobGVuZ3RoKTtpZihsZW5ndGg+cmVtYWluaW5nKXtsZW5ndGg9cmVtYWluaW5nO319dmFyIHN0ckxlbj1zdHJpbmcubGVuZ3RoO2lmKGxlbmd0aD5zdHJMZW4vMil7bGVuZ3RoPXN0ckxlbi8yO31mb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe3ZhciBwYXJzZWQ9cGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpKjIsMiksMTYpO2lmKG51bWJlcklzTmFOKHBhcnNlZCkpcmV0dXJuIGk7YnVmW29mZnNldCtpXT1wYXJzZWQ7fXJldHVybiBpO31mdW5jdGlvbiB1dGY4V3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsYnVmLmxlbmd0aC1vZmZzZXQpLGJ1ZixvZmZzZXQsbGVuZ3RoKTt9ZnVuY3Rpb24gYXNjaWlXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe3JldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLGJ1ZixvZmZzZXQsbGVuZ3RoKTt9ZnVuY3Rpb24gbGF0aW4xV3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXtyZXR1cm4gYXNjaWlXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpO31mdW5jdGlvbiBiYXNlNjRXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe3JldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSxidWYsb2Zmc2V0LGxlbmd0aCk7fWZ1bmN0aW9uIHVjczJXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe3JldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyxidWYubGVuZ3RoLW9mZnNldCksYnVmLG9mZnNldCxsZW5ndGgpO31CdWZmZXIucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uIHdyaXRlKHN0cmluZyxvZmZzZXQsbGVuZ3RoLGVuY29kaW5nKXsvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuaWYob2Zmc2V0PT09dW5kZWZpbmVkKXtlbmNvZGluZz0ndXRmOCc7bGVuZ3RoPXRoaXMubGVuZ3RoO29mZnNldD0wOy8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxufWVsc2UgaWYobGVuZ3RoPT09dW5kZWZpbmVkJiZ0eXBlb2Ygb2Zmc2V0PT09J3N0cmluZycpe2VuY29kaW5nPW9mZnNldDtsZW5ndGg9dGhpcy5sZW5ndGg7b2Zmc2V0PTA7Ly8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbn1lbHNlIGlmKGlzRmluaXRlKG9mZnNldCkpe29mZnNldD1vZmZzZXQ+Pj4wO2lmKGlzRmluaXRlKGxlbmd0aCkpe2xlbmd0aD1sZW5ndGg+Pj4wO2lmKGVuY29kaW5nPT09dW5kZWZpbmVkKWVuY29kaW5nPSd1dGY4Jzt9ZWxzZXtlbmNvZGluZz1sZW5ndGg7bGVuZ3RoPXVuZGVmaW5lZDt9fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCcpO312YXIgcmVtYWluaW5nPXRoaXMubGVuZ3RoLW9mZnNldDtpZihsZW5ndGg9PT11bmRlZmluZWR8fGxlbmd0aD5yZW1haW5pbmcpbGVuZ3RoPXJlbWFpbmluZztpZihzdHJpbmcubGVuZ3RoPjAmJihsZW5ndGg8MHx8b2Zmc2V0PDApfHxvZmZzZXQ+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpO31pZighZW5jb2RpbmcpZW5jb2Rpbmc9J3V0ZjgnO3ZhciBsb3dlcmVkQ2FzZT1mYWxzZTtmb3IoOzspe3N3aXRjaChlbmNvZGluZyl7Y2FzZSdoZXgnOnJldHVybiBoZXhXcml0ZSh0aGlzLHN0cmluZyxvZmZzZXQsbGVuZ3RoKTtjYXNlJ3V0ZjgnOmNhc2UndXRmLTgnOnJldHVybiB1dGY4V3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7Y2FzZSdhc2NpaSc6cmV0dXJuIGFzY2lpV3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7Y2FzZSdsYXRpbjEnOmNhc2UnYmluYXJ5JzpyZXR1cm4gbGF0aW4xV3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7Y2FzZSdiYXNlNjQnOi8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG5yZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7Y2FzZSd1Y3MyJzpjYXNlJ3Vjcy0yJzpjYXNlJ3V0ZjE2bGUnOmNhc2UndXRmLTE2bGUnOnJldHVybiB1Y3MyV3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7ZGVmYXVsdDppZihsb3dlcmVkQ2FzZSl0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnK2VuY29kaW5nKTtlbmNvZGluZz0oJycrZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7bG93ZXJlZENhc2U9dHJ1ZTt9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6J0J1ZmZlcicsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9O307ZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLHN0YXJ0LGVuZCl7aWYoc3RhcnQ9PT0wJiZlbmQ9PT1idWYubGVuZ3RoKXtyZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKTt9ZWxzZXtyZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LGVuZCkpO319ZnVuY3Rpb24gdXRmOFNsaWNlKGJ1ZixzdGFydCxlbmQpe2VuZD1NYXRoLm1pbihidWYubGVuZ3RoLGVuZCk7dmFyIHJlcz1bXTt2YXIgaT1zdGFydDt3aGlsZShpPGVuZCl7dmFyIGZpcnN0Qnl0ZT1idWZbaV07dmFyIGNvZGVQb2ludD1udWxsO3ZhciBieXRlc1BlclNlcXVlbmNlPWZpcnN0Qnl0ZT4weEVGPzQ6Zmlyc3RCeXRlPjB4REY/MzpmaXJzdEJ5dGU+MHhCRj8yOjE7aWYoaStieXRlc1BlclNlcXVlbmNlPD1lbmQpe3ZhciBzZWNvbmRCeXRlLHRoaXJkQnl0ZSxmb3VydGhCeXRlLHRlbXBDb2RlUG9pbnQ7c3dpdGNoKGJ5dGVzUGVyU2VxdWVuY2Upe2Nhc2UgMTppZihmaXJzdEJ5dGU8MHg4MCl7Y29kZVBvaW50PWZpcnN0Qnl0ZTt9YnJlYWs7Y2FzZSAyOnNlY29uZEJ5dGU9YnVmW2krMV07aWYoKHNlY29uZEJ5dGUmMHhDMCk9PT0weDgwKXt0ZW1wQ29kZVBvaW50PShmaXJzdEJ5dGUmMHgxRik8PDB4NnxzZWNvbmRCeXRlJjB4M0Y7aWYodGVtcENvZGVQb2ludD4weDdGKXtjb2RlUG9pbnQ9dGVtcENvZGVQb2ludDt9fWJyZWFrO2Nhc2UgMzpzZWNvbmRCeXRlPWJ1ZltpKzFdO3RoaXJkQnl0ZT1idWZbaSsyXTtpZigoc2Vjb25kQnl0ZSYweEMwKT09PTB4ODAmJih0aGlyZEJ5dGUmMHhDMCk9PT0weDgwKXt0ZW1wQ29kZVBvaW50PShmaXJzdEJ5dGUmMHhGKTw8MHhDfChzZWNvbmRCeXRlJjB4M0YpPDwweDZ8dGhpcmRCeXRlJjB4M0Y7aWYodGVtcENvZGVQb2ludD4weDdGRiYmKHRlbXBDb2RlUG9pbnQ8MHhEODAwfHx0ZW1wQ29kZVBvaW50PjB4REZGRikpe2NvZGVQb2ludD10ZW1wQ29kZVBvaW50O319YnJlYWs7Y2FzZSA0OnNlY29uZEJ5dGU9YnVmW2krMV07dGhpcmRCeXRlPWJ1ZltpKzJdO2ZvdXJ0aEJ5dGU9YnVmW2krM107aWYoKHNlY29uZEJ5dGUmMHhDMCk9PT0weDgwJiYodGhpcmRCeXRlJjB4QzApPT09MHg4MCYmKGZvdXJ0aEJ5dGUmMHhDMCk9PT0weDgwKXt0ZW1wQ29kZVBvaW50PShmaXJzdEJ5dGUmMHhGKTw8MHgxMnwoc2Vjb25kQnl0ZSYweDNGKTw8MHhDfCh0aGlyZEJ5dGUmMHgzRik8PDB4Nnxmb3VydGhCeXRlJjB4M0Y7aWYodGVtcENvZGVQb2ludD4weEZGRkYmJnRlbXBDb2RlUG9pbnQ8MHgxMTAwMDApe2NvZGVQb2ludD10ZW1wQ29kZVBvaW50O319fX1pZihjb2RlUG9pbnQ9PT1udWxsKXsvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4vLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG5jb2RlUG9pbnQ9MHhGRkZEO2J5dGVzUGVyU2VxdWVuY2U9MTt9ZWxzZSBpZihjb2RlUG9pbnQ+MHhGRkZGKXsvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuY29kZVBvaW50LT0weDEwMDAwO3Jlcy5wdXNoKGNvZGVQb2ludD4+PjEwJjB4M0ZGfDB4RDgwMCk7Y29kZVBvaW50PTB4REMwMHxjb2RlUG9pbnQmMHgzRkY7fXJlcy5wdXNoKGNvZGVQb2ludCk7aSs9Ynl0ZXNQZXJTZXF1ZW5jZTt9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpO30vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSD0weDEwMDA7ZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGNvZGVQb2ludHMpe3ZhciBsZW49Y29kZVBvaW50cy5sZW5ndGg7aWYobGVuPD1NQVhfQVJHVU1FTlRTX0xFTkdUSCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGNvZGVQb2ludHMpOy8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbn0vLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG52YXIgcmVzPScnO3ZhciBpPTA7d2hpbGUoaTxsZW4pe3Jlcys9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsY29kZVBvaW50cy5zbGljZShpLGkrPU1BWF9BUkdVTUVOVFNfTEVOR1RIKSk7fXJldHVybiByZXM7fWZ1bmN0aW9uIGFzY2lpU2xpY2UoYnVmLHN0YXJ0LGVuZCl7dmFyIHJldD0nJztlbmQ9TWF0aC5taW4oYnVmLmxlbmd0aCxlbmQpO2Zvcih2YXIgaT1zdGFydDtpPGVuZDsrK2kpe3JldCs9U3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0mMHg3Rik7fXJldHVybiByZXQ7fWZ1bmN0aW9uIGxhdGluMVNsaWNlKGJ1ZixzdGFydCxlbmQpe3ZhciByZXQ9Jyc7ZW5kPU1hdGgubWluKGJ1Zi5sZW5ndGgsZW5kKTtmb3IodmFyIGk9c3RhcnQ7aTxlbmQ7KytpKXtyZXQrPVN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTt9cmV0dXJuIHJldDt9ZnVuY3Rpb24gaGV4U2xpY2UoYnVmLHN0YXJ0LGVuZCl7dmFyIGxlbj1idWYubGVuZ3RoO2lmKCFzdGFydHx8c3RhcnQ8MClzdGFydD0wO2lmKCFlbmR8fGVuZDwwfHxlbmQ+bGVuKWVuZD1sZW47dmFyIG91dD0nJztmb3IodmFyIGk9c3RhcnQ7aTxlbmQ7KytpKXtvdXQrPWhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXTt9cmV0dXJuIG91dDt9ZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGJ1ZixzdGFydCxlbmQpe3ZhciBieXRlcz1idWYuc2xpY2Uoc3RhcnQsZW5kKTt2YXIgcmVzPScnO2Zvcih2YXIgaT0wO2k8Ynl0ZXMubGVuZ3RoO2krPTIpe3Jlcys9U3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXStieXRlc1tpKzFdKjI1Nik7fXJldHVybiByZXM7fUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2Uoc3RhcnQsZW5kKXt2YXIgbGVuPXRoaXMubGVuZ3RoO3N0YXJ0PX5+c3RhcnQ7ZW5kPWVuZD09PXVuZGVmaW5lZD9sZW46fn5lbmQ7aWYoc3RhcnQ8MCl7c3RhcnQrPWxlbjtpZihzdGFydDwwKXN0YXJ0PTA7fWVsc2UgaWYoc3RhcnQ+bGVuKXtzdGFydD1sZW47fWlmKGVuZDwwKXtlbmQrPWxlbjtpZihlbmQ8MCllbmQ9MDt9ZWxzZSBpZihlbmQ+bGVuKXtlbmQ9bGVuO31pZihlbmQ8c3RhcnQpZW5kPXN0YXJ0O3ZhciBuZXdCdWY9dGhpcy5zdWJhcnJheShzdGFydCxlbmQpOy8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG5PYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBuZXdCdWY7fTsvKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9mdW5jdGlvbiBjaGVja09mZnNldChvZmZzZXQsZXh0LGxlbmd0aCl7aWYob2Zmc2V0JTEhPT0wfHxvZmZzZXQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50Jyk7aWYob2Zmc2V0K2V4dD5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTt9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uIHJlYWRVSW50TEUob2Zmc2V0LGJ5dGVMZW5ndGgsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2J5dGVMZW5ndGg9Ynl0ZUxlbmd0aD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCxieXRlTGVuZ3RoLHRoaXMubGVuZ3RoKTt2YXIgdmFsPXRoaXNbb2Zmc2V0XTt2YXIgbXVsPTE7dmFyIGk9MDt3aGlsZSgrK2k8Ynl0ZUxlbmd0aCYmKG11bCo9MHgxMDApKXt2YWwrPXRoaXNbb2Zmc2V0K2ldKm11bDt9cmV0dXJuIHZhbDt9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbiByZWFkVUludEJFKG9mZnNldCxieXRlTGVuZ3RoLG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtieXRlTGVuZ3RoPWJ5dGVMZW5ndGg+Pj4wO2lmKCFub0Fzc2VydCl7Y2hlY2tPZmZzZXQob2Zmc2V0LGJ5dGVMZW5ndGgsdGhpcy5sZW5ndGgpO312YXIgdmFsPXRoaXNbb2Zmc2V0Ky0tYnl0ZUxlbmd0aF07dmFyIG11bD0xO3doaWxlKGJ5dGVMZW5ndGg+MCYmKG11bCo9MHgxMDApKXt2YWwrPXRoaXNbb2Zmc2V0Ky0tYnl0ZUxlbmd0aF0qbXVsO31yZXR1cm4gdmFsO307QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24gcmVhZFVJbnQ4KG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tvZmZzZXRdO307QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tvZmZzZXRdfHRoaXNbb2Zmc2V0KzFdPDw4O307QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tvZmZzZXRdPDw4fHRoaXNbb2Zmc2V0KzFdO307QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCw0LHRoaXMubGVuZ3RoKTtyZXR1cm4odGhpc1tvZmZzZXRdfHRoaXNbb2Zmc2V0KzFdPDw4fHRoaXNbb2Zmc2V0KzJdPDwxNikrdGhpc1tvZmZzZXQrM10qMHgxMDAwMDAwO307QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24gcmVhZFVJbnQzMkJFKG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tvZmZzZXRdKjB4MTAwMDAwMCsodGhpc1tvZmZzZXQrMV08PDE2fHRoaXNbb2Zmc2V0KzJdPDw4fHRoaXNbb2Zmc2V0KzNdKTt9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uIHJlYWRJbnRMRShvZmZzZXQsYnl0ZUxlbmd0aCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7Ynl0ZUxlbmd0aD1ieXRlTGVuZ3RoPj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LGJ5dGVMZW5ndGgsdGhpcy5sZW5ndGgpO3ZhciB2YWw9dGhpc1tvZmZzZXRdO3ZhciBtdWw9MTt2YXIgaT0wO3doaWxlKCsraTxieXRlTGVuZ3RoJiYobXVsKj0weDEwMCkpe3ZhbCs9dGhpc1tvZmZzZXQraV0qbXVsO31tdWwqPTB4ODA7aWYodmFsPj1tdWwpdmFsLT1NYXRoLnBvdygyLDgqYnl0ZUxlbmd0aCk7cmV0dXJuIHZhbDt9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uIHJlYWRJbnRCRShvZmZzZXQsYnl0ZUxlbmd0aCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7Ynl0ZUxlbmd0aD1ieXRlTGVuZ3RoPj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LGJ5dGVMZW5ndGgsdGhpcy5sZW5ndGgpO3ZhciBpPWJ5dGVMZW5ndGg7dmFyIG11bD0xO3ZhciB2YWw9dGhpc1tvZmZzZXQrLS1pXTt3aGlsZShpPjAmJihtdWwqPTB4MTAwKSl7dmFsKz10aGlzW29mZnNldCstLWldKm11bDt9bXVsKj0weDgwO2lmKHZhbD49bXVsKXZhbC09TWF0aC5wb3coMiw4KmJ5dGVMZW5ndGgpO3JldHVybiB2YWw7fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uIHJlYWRJbnQ4KG9mZnNldCxub0Fzc2VydCl7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrT2Zmc2V0KG9mZnNldCwxLHRoaXMubGVuZ3RoKTtpZighKHRoaXNbb2Zmc2V0XSYweDgwKSlyZXR1cm4gdGhpc1tvZmZzZXRdO3JldHVybigweGZmLXRoaXNbb2Zmc2V0XSsxKSotMTt9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24gcmVhZEludDE2TEUob2Zmc2V0LG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LDIsdGhpcy5sZW5ndGgpO3ZhciB2YWw9dGhpc1tvZmZzZXRdfHRoaXNbb2Zmc2V0KzFdPDw4O3JldHVybiB2YWwmMHg4MDAwP3ZhbHwweEZGRkYwMDAwOnZhbDt9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24gcmVhZEludDE2QkUob2Zmc2V0LG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LDIsdGhpcy5sZW5ndGgpO3ZhciB2YWw9dGhpc1tvZmZzZXQrMV18dGhpc1tvZmZzZXRdPDw4O3JldHVybiB2YWwmMHg4MDAwP3ZhbHwweEZGRkYwMDAwOnZhbDt9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24gcmVhZEludDMyTEUob2Zmc2V0LG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW29mZnNldF18dGhpc1tvZmZzZXQrMV08PDh8dGhpc1tvZmZzZXQrMl08PDE2fHRoaXNbb2Zmc2V0KzNdPDwyNDt9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW29mZnNldF08PDI0fHRoaXNbb2Zmc2V0KzFdPDwxNnx0aGlzW29mZnNldCsyXTw8OHx0aGlzW29mZnNldCszXTt9O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24gcmVhZEZsb2F0TEUob2Zmc2V0LG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LDQsdGhpcy5sZW5ndGgpO3JldHVybiBpZWVlNzU0LnJlYWQodGhpcyxvZmZzZXQsdHJ1ZSwyMyw0KTt9O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24gcmVhZEZsb2F0QkUob2Zmc2V0LG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LDQsdGhpcy5sZW5ndGgpO3JldHVybiBpZWVlNzU0LnJlYWQodGhpcyxvZmZzZXQsZmFsc2UsMjMsNCk7fTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUob2Zmc2V0LG5vQXNzZXJ0KXtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tPZmZzZXQob2Zmc2V0LDgsdGhpcy5sZW5ndGgpO3JldHVybiBpZWVlNzU0LnJlYWQodGhpcyxvZmZzZXQsdHJ1ZSw1Miw4KTt9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uIHJlYWREb3VibGVCRShvZmZzZXQsbm9Bc3NlcnQpe29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja09mZnNldChvZmZzZXQsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLG9mZnNldCxmYWxzZSw1Miw4KTt9O2Z1bmN0aW9uIGNoZWNrSW50KGJ1Zix2YWx1ZSxvZmZzZXQsZXh0LG1heCxtaW4pe2lmKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZih2YWx1ZT5tYXh8fHZhbHVlPG1pbil0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZihvZmZzZXQrZXh0PmJ1Zi5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO31CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLG9mZnNldCxieXRlTGVuZ3RoLG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7Ynl0ZUxlbmd0aD1ieXRlTGVuZ3RoPj4+MDtpZighbm9Bc3NlcnQpe3ZhciBtYXhCeXRlcz1NYXRoLnBvdygyLDgqYnl0ZUxlbmd0aCktMTtjaGVja0ludCh0aGlzLHZhbHVlLG9mZnNldCxieXRlTGVuZ3RoLG1heEJ5dGVzLDApO312YXIgbXVsPTE7dmFyIGk9MDt0aGlzW29mZnNldF09dmFsdWUmMHhGRjt3aGlsZSgrK2k8Ynl0ZUxlbmd0aCYmKG11bCo9MHgxMDApKXt0aGlzW29mZnNldCtpXT12YWx1ZS9tdWwmMHhGRjt9cmV0dXJuIG9mZnNldCtieXRlTGVuZ3RoO307QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRSh2YWx1ZSxvZmZzZXQsYnl0ZUxlbmd0aCxub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2J5dGVMZW5ndGg9Ynl0ZUxlbmd0aD4+PjA7aWYoIW5vQXNzZXJ0KXt2YXIgbWF4Qnl0ZXM9TWF0aC5wb3coMiw4KmJ5dGVMZW5ndGgpLTE7Y2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsYnl0ZUxlbmd0aCxtYXhCeXRlcywwKTt9dmFyIGk9Ynl0ZUxlbmd0aC0xO3ZhciBtdWw9MTt0aGlzW29mZnNldCtpXT12YWx1ZSYweEZGO3doaWxlKC0taT49MCYmKG11bCo9MHgxMDApKXt0aGlzW29mZnNldCtpXT12YWx1ZS9tdWwmMHhGRjt9cmV0dXJuIG9mZnNldCtieXRlTGVuZ3RoO307QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uIHdyaXRlVUludDgodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LDEsMHhmZiwwKTt0aGlzW29mZnNldF09dmFsdWUmMHhmZjtyZXR1cm4gb2Zmc2V0KzE7fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsMiwweGZmZmYsMCk7dGhpc1tvZmZzZXRdPXZhbHVlJjB4ZmY7dGhpc1tvZmZzZXQrMV09dmFsdWU+Pj44O3JldHVybiBvZmZzZXQrMjt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja0ludCh0aGlzLHZhbHVlLG9mZnNldCwyLDB4ZmZmZiwwKTt0aGlzW29mZnNldF09dmFsdWU+Pj44O3RoaXNbb2Zmc2V0KzFdPXZhbHVlJjB4ZmY7cmV0dXJuIG9mZnNldCsyO307QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlVUludDMyTEUodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXt2YWx1ZT0rdmFsdWU7b2Zmc2V0PW9mZnNldD4+PjA7aWYoIW5vQXNzZXJ0KWNoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LDQsMHhmZmZmZmZmZiwwKTt0aGlzW29mZnNldCszXT12YWx1ZT4+PjI0O3RoaXNbb2Zmc2V0KzJdPXZhbHVlPj4+MTY7dGhpc1tvZmZzZXQrMV09dmFsdWU+Pj44O3RoaXNbb2Zmc2V0XT12YWx1ZSYweGZmO3JldHVybiBvZmZzZXQrNDt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkJFKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja0ludCh0aGlzLHZhbHVlLG9mZnNldCw0LDB4ZmZmZmZmZmYsMCk7dGhpc1tvZmZzZXRdPXZhbHVlPj4+MjQ7dGhpc1tvZmZzZXQrMV09dmFsdWU+Pj4xNjt0aGlzW29mZnNldCsyXT12YWx1ZT4+Pjg7dGhpc1tvZmZzZXQrM109dmFsdWUmMHhmZjtyZXR1cm4gb2Zmc2V0KzQ7fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24gd3JpdGVJbnRMRSh2YWx1ZSxvZmZzZXQsYnl0ZUxlbmd0aCxub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCl7dmFyIGxpbWl0PU1hdGgucG93KDIsOCpieXRlTGVuZ3RoLTEpO2NoZWNrSW50KHRoaXMsdmFsdWUsb2Zmc2V0LGJ5dGVMZW5ndGgsbGltaXQtMSwtbGltaXQpO312YXIgaT0wO3ZhciBtdWw9MTt2YXIgc3ViPTA7dGhpc1tvZmZzZXRdPXZhbHVlJjB4RkY7d2hpbGUoKytpPGJ5dGVMZW5ndGgmJihtdWwqPTB4MTAwKSl7aWYodmFsdWU8MCYmc3ViPT09MCYmdGhpc1tvZmZzZXQraS0xXSE9PTApe3N1Yj0xO310aGlzW29mZnNldCtpXT0odmFsdWUvbXVsPj4wKS1zdWImMHhGRjt9cmV0dXJuIG9mZnNldCtieXRlTGVuZ3RoO307QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUodmFsdWUsb2Zmc2V0LGJ5dGVMZW5ndGgsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpe3ZhciBsaW1pdD1NYXRoLnBvdygyLDgqYnl0ZUxlbmd0aC0xKTtjaGVja0ludCh0aGlzLHZhbHVlLG9mZnNldCxieXRlTGVuZ3RoLGxpbWl0LTEsLWxpbWl0KTt9dmFyIGk9Ynl0ZUxlbmd0aC0xO3ZhciBtdWw9MTt2YXIgc3ViPTA7dGhpc1tvZmZzZXQraV09dmFsdWUmMHhGRjt3aGlsZSgtLWk+PTAmJihtdWwqPTB4MTAwKSl7aWYodmFsdWU8MCYmc3ViPT09MCYmdGhpc1tvZmZzZXQraSsxXSE9PTApe3N1Yj0xO310aGlzW29mZnNldCtpXT0odmFsdWUvbXVsPj4wKS1zdWImMHhGRjt9cmV0dXJuIG9mZnNldCtieXRlTGVuZ3RoO307QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24gd3JpdGVJbnQ4KHZhbHVlLG9mZnNldCxub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCljaGVja0ludCh0aGlzLHZhbHVlLG9mZnNldCwxLDB4N2YsLTB4ODApO2lmKHZhbHVlPDApdmFsdWU9MHhmZit2YWx1ZSsxO3RoaXNbb2Zmc2V0XT12YWx1ZSYweGZmO3JldHVybiBvZmZzZXQrMTt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlSW50MTZMRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsMiwweDdmZmYsLTB4ODAwMCk7dGhpc1tvZmZzZXRdPXZhbHVlJjB4ZmY7dGhpc1tvZmZzZXQrMV09dmFsdWU+Pj44O3JldHVybiBvZmZzZXQrMjt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlSW50MTZCRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsMiwweDdmZmYsLTB4ODAwMCk7dGhpc1tvZmZzZXRdPXZhbHVlPj4+ODt0aGlzW29mZnNldCsxXT12YWx1ZSYweGZmO3JldHVybiBvZmZzZXQrMjt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsNCwweDdmZmZmZmZmLC0weDgwMDAwMDAwKTt0aGlzW29mZnNldF09dmFsdWUmMHhmZjt0aGlzW29mZnNldCsxXT12YWx1ZT4+Pjg7dGhpc1tvZmZzZXQrMl09dmFsdWU+Pj4xNjt0aGlzW29mZnNldCszXT12YWx1ZT4+PjI0O3JldHVybiBvZmZzZXQrNDt9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpY2hlY2tJbnQodGhpcyx2YWx1ZSxvZmZzZXQsNCwweDdmZmZmZmZmLC0weDgwMDAwMDAwKTtpZih2YWx1ZTwwKXZhbHVlPTB4ZmZmZmZmZmYrdmFsdWUrMTt0aGlzW29mZnNldF09dmFsdWU+Pj4yNDt0aGlzW29mZnNldCsxXT12YWx1ZT4+PjE2O3RoaXNbb2Zmc2V0KzJdPXZhbHVlPj4+ODt0aGlzW29mZnNldCszXT12YWx1ZSYweGZmO3JldHVybiBvZmZzZXQrNDt9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChidWYsdmFsdWUsb2Zmc2V0LGV4dCxtYXgsbWluKXtpZihvZmZzZXQrZXh0PmJ1Zi5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO2lmKG9mZnNldDwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTt9ZnVuY3Rpb24gd3JpdGVGbG9hdChidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7dmFsdWU9K3ZhbHVlO29mZnNldD1vZmZzZXQ+Pj4wO2lmKCFub0Fzc2VydCl7Y2hlY2tJRUVFNzU0KGJ1Zix2YWx1ZSxvZmZzZXQsNCwzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KTt9aWVlZTc1NC53cml0ZShidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbiwyMyw0KTtyZXR1cm4gb2Zmc2V0KzQ7fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRSh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsdmFsdWUsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpO307QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyx2YWx1ZSxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpO307ZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe3ZhbHVlPSt2YWx1ZTtvZmZzZXQ9b2Zmc2V0Pj4+MDtpZighbm9Bc3NlcnQpe2NoZWNrSUVFRTc1NChidWYsdmFsdWUsb2Zmc2V0LDgsMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KTt9aWVlZTc1NC53cml0ZShidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbiw1Miw4KTtyZXR1cm4gb2Zmc2V0Kzg7fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbiB3cml0ZURvdWJsZUxFKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsdmFsdWUsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpO307QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyx2YWx1ZSxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpO307Ly8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uIGNvcHkodGFyZ2V0LHRhcmdldFN0YXJ0LHN0YXJ0LGVuZCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpO2lmKCFzdGFydClzdGFydD0wO2lmKCFlbmQmJmVuZCE9PTApZW5kPXRoaXMubGVuZ3RoO2lmKHRhcmdldFN0YXJ0Pj10YXJnZXQubGVuZ3RoKXRhcmdldFN0YXJ0PXRhcmdldC5sZW5ndGg7aWYoIXRhcmdldFN0YXJ0KXRhcmdldFN0YXJ0PTA7aWYoZW5kPjAmJmVuZDxzdGFydCllbmQ9c3RhcnQ7Ly8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG5pZihlbmQ9PT1zdGFydClyZXR1cm4gMDtpZih0YXJnZXQubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwOy8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbmlmKHRhcmdldFN0YXJ0PDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJyk7fWlmKHN0YXJ0PDB8fHN0YXJ0Pj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7aWYoZW5kPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJyk7Ly8gQXJlIHdlIG9vYj9cbmlmKGVuZD50aGlzLmxlbmd0aCllbmQ9dGhpcy5sZW5ndGg7aWYodGFyZ2V0Lmxlbmd0aC10YXJnZXRTdGFydDxlbmQtc3RhcnQpe2VuZD10YXJnZXQubGVuZ3RoLXRhcmdldFN0YXJ0K3N0YXJ0O312YXIgbGVuPWVuZC1zdGFydDtpZih0aGlzPT09dGFyZ2V0JiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09PSdmdW5jdGlvbicpey8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbnRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCxzdGFydCxlbmQpO31lbHNlIGlmKHRoaXM9PT10YXJnZXQmJnN0YXJ0PHRhcmdldFN0YXJ0JiZ0YXJnZXRTdGFydDxlbmQpey8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuZm9yKHZhciBpPWxlbi0xO2k+PTA7LS1pKXt0YXJnZXRbaSt0YXJnZXRTdGFydF09dGhpc1tpK3N0YXJ0XTt9fWVsc2V7VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodGFyZ2V0LHRoaXMuc3ViYXJyYXkoc3RhcnQsZW5kKSx0YXJnZXRTdGFydCk7fXJldHVybiBsZW47fTsvLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbiBmaWxsKHZhbCxzdGFydCxlbmQsZW5jb2Rpbmcpey8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG5pZih0eXBlb2YgdmFsPT09J3N0cmluZycpe2lmKHR5cGVvZiBzdGFydD09PSdzdHJpbmcnKXtlbmNvZGluZz1zdGFydDtzdGFydD0wO2VuZD10aGlzLmxlbmd0aDt9ZWxzZSBpZih0eXBlb2YgZW5kPT09J3N0cmluZycpe2VuY29kaW5nPWVuZDtlbmQ9dGhpcy5sZW5ndGg7fWlmKGVuY29kaW5nIT09dW5kZWZpbmVkJiZ0eXBlb2YgZW5jb2RpbmchPT0nc3RyaW5nJyl7dGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpO31pZih0eXBlb2YgZW5jb2Rpbmc9PT0nc3RyaW5nJyYmIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJytlbmNvZGluZyk7fWlmKHZhbC5sZW5ndGg9PT0xKXt2YXIgY29kZT12YWwuY2hhckNvZGVBdCgwKTtpZihlbmNvZGluZz09PSd1dGY4JyYmY29kZTwxMjh8fGVuY29kaW5nPT09J2xhdGluMScpey8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG52YWw9Y29kZTt9fX1lbHNlIGlmKHR5cGVvZiB2YWw9PT0nbnVtYmVyJyl7dmFsPXZhbCYyNTU7fWVsc2UgaWYodHlwZW9mIHZhbD09PSdib29sZWFuJyl7dmFsPU51bWJlcih2YWwpO30vLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbmlmKHN0YXJ0PDB8fHRoaXMubGVuZ3RoPHN0YXJ0fHx0aGlzLmxlbmd0aDxlbmQpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKTt9aWYoZW5kPD1zdGFydCl7cmV0dXJuIHRoaXM7fXN0YXJ0PXN0YXJ0Pj4+MDtlbmQ9ZW5kPT09dW5kZWZpbmVkP3RoaXMubGVuZ3RoOmVuZD4+PjA7aWYoIXZhbCl2YWw9MDt2YXIgaTtpZih0eXBlb2YgdmFsPT09J251bWJlcicpe2ZvcihpPXN0YXJ0O2k8ZW5kOysraSl7dGhpc1tpXT12YWw7fX1lbHNle3ZhciBieXRlcz1CdWZmZXIuaXNCdWZmZXIodmFsKT92YWw6QnVmZmVyLmZyb20odmFsLGVuY29kaW5nKTt2YXIgbGVuPWJ5dGVzLmxlbmd0aDtpZihsZW49PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK3ZhbCsnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyk7fWZvcihpPTA7aTxlbmQtc3RhcnQ7KytpKXt0aGlzW2krc3RhcnRdPWJ5dGVzW2klbGVuXTt9fXJldHVybiB0aGlzO307Ly8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxudmFyIElOVkFMSURfQkFTRTY0X1JFPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gYmFzZTY0Y2xlYW4oc3RyKXsvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG5zdHI9c3RyLnNwbGl0KCc9JylbMF07Ly8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG5zdHI9c3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCcnKTsvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG5pZihzdHIubGVuZ3RoPDIpcmV0dXJuJyc7Ly8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG53aGlsZShzdHIubGVuZ3RoJTQhPT0wKXtzdHI9c3RyKyc9Jzt9cmV0dXJuIHN0cjt9ZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyaW5nLHVuaXRzKXt1bml0cz11bml0c3x8SW5maW5pdHk7dmFyIGNvZGVQb2ludDt2YXIgbGVuZ3RoPXN0cmluZy5sZW5ndGg7dmFyIGxlYWRTdXJyb2dhdGU9bnVsbDt2YXIgYnl0ZXM9W107Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXtjb2RlUG9pbnQ9c3RyaW5nLmNoYXJDb2RlQXQoaSk7Ly8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuaWYoY29kZVBvaW50PjB4RDdGRiYmY29kZVBvaW50PDB4RTAwMCl7Ly8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbmlmKCFsZWFkU3Vycm9nYXRlKXsvLyBubyBsZWFkIHlldFxuaWYoY29kZVBvaW50PjB4REJGRil7Ly8gdW5leHBlY3RlZCB0cmFpbFxuaWYoKHVuaXRzLT0zKT4tMSlieXRlcy5wdXNoKDB4RUYsMHhCRiwweEJEKTtjb250aW51ZTt9ZWxzZSBpZihpKzE9PT1sZW5ndGgpey8vIHVucGFpcmVkIGxlYWRcbmlmKCh1bml0cy09Myk+LTEpYnl0ZXMucHVzaCgweEVGLDB4QkYsMHhCRCk7Y29udGludWU7fS8vIHZhbGlkIGxlYWRcbmxlYWRTdXJyb2dhdGU9Y29kZVBvaW50O2NvbnRpbnVlO30vLyAyIGxlYWRzIGluIGEgcm93XG5pZihjb2RlUG9pbnQ8MHhEQzAwKXtpZigodW5pdHMtPTMpPi0xKWJ5dGVzLnB1c2goMHhFRiwweEJGLDB4QkQpO2xlYWRTdXJyb2dhdGU9Y29kZVBvaW50O2NvbnRpbnVlO30vLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuY29kZVBvaW50PShsZWFkU3Vycm9nYXRlLTB4RDgwMDw8MTB8Y29kZVBvaW50LTB4REMwMCkrMHgxMDAwMDt9ZWxzZSBpZihsZWFkU3Vycm9nYXRlKXsvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG5pZigodW5pdHMtPTMpPi0xKWJ5dGVzLnB1c2goMHhFRiwweEJGLDB4QkQpO31sZWFkU3Vycm9nYXRlPW51bGw7Ly8gZW5jb2RlIHV0ZjhcbmlmKGNvZGVQb2ludDwweDgwKXtpZigodW5pdHMtPTEpPDApYnJlYWs7Ynl0ZXMucHVzaChjb2RlUG9pbnQpO31lbHNlIGlmKGNvZGVQb2ludDwweDgwMCl7aWYoKHVuaXRzLT0yKTwwKWJyZWFrO2J5dGVzLnB1c2goY29kZVBvaW50Pj4weDZ8MHhDMCxjb2RlUG9pbnQmMHgzRnwweDgwKTt9ZWxzZSBpZihjb2RlUG9pbnQ8MHgxMDAwMCl7aWYoKHVuaXRzLT0zKTwwKWJyZWFrO2J5dGVzLnB1c2goY29kZVBvaW50Pj4weEN8MHhFMCxjb2RlUG9pbnQ+PjB4NiYweDNGfDB4ODAsY29kZVBvaW50JjB4M0Z8MHg4MCk7fWVsc2UgaWYoY29kZVBvaW50PDB4MTEwMDAwKXtpZigodW5pdHMtPTQpPDApYnJlYWs7Ynl0ZXMucHVzaChjb2RlUG9pbnQ+PjB4MTJ8MHhGMCxjb2RlUG9pbnQ+PjB4QyYweDNGfDB4ODAsY29kZVBvaW50Pj4weDYmMHgzRnwweDgwLGNvZGVQb2ludCYweDNGfDB4ODApO31lbHNle3Rocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50Jyk7fX1yZXR1cm4gYnl0ZXM7fWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhzdHIpe3ZhciBieXRlQXJyYXk9W107Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7Ly8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG5ieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSYweEZGKTt9cmV0dXJuIGJ5dGVBcnJheTt9ZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoc3RyLHVuaXRzKXt2YXIgYyxoaSxsbzt2YXIgYnl0ZUFycmF5PVtdO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe2lmKCh1bml0cy09Mik8MClicmVhaztjPXN0ci5jaGFyQ29kZUF0KGkpO2hpPWM+Pjg7bG89YyUyNTY7Ynl0ZUFycmF5LnB1c2gobG8pO2J5dGVBcnJheS5wdXNoKGhpKTt9cmV0dXJuIGJ5dGVBcnJheTt9ZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhzdHIpe3JldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSk7fWZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLGRzdCxvZmZzZXQsbGVuZ3RoKXtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe2lmKGkrb2Zmc2V0Pj1kc3QubGVuZ3RofHxpPj1zcmMubGVuZ3RoKWJyZWFrO2RzdFtpK29mZnNldF09c3JjW2ldO31yZXR1cm4gaTt9Ly8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlKG9iaix0eXBlKXtyZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZXx8b2JqIT1udWxsJiZvYmouY29uc3RydWN0b3IhPW51bGwmJm9iai5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZvYmouY29uc3RydWN0b3IubmFtZT09PXR5cGUubmFtZTt9ZnVuY3Rpb24gbnVtYmVySXNOYU4ob2JqKXsvLyBGb3IgSUUxMSBzdXBwb3J0XG5yZXR1cm4gb2JqIT09b2JqOy8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59Ly8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxudmFyIGhleFNsaWNlTG9va3VwVGFibGU9ZnVuY3Rpb24oKXt2YXIgYWxwaGFiZXQ9JzAxMjM0NTY3ODlhYmNkZWYnO3ZhciB0YWJsZT1uZXcgQXJyYXkoMjU2KTtmb3IodmFyIGk9MDtpPDE2OysraSl7dmFyIGkxNj1pKjE2O2Zvcih2YXIgaj0wO2o8MTY7KytqKXt0YWJsZVtpMTYral09YWxwaGFiZXRbaV0rYWxwaGFiZXRbal07fX1yZXR1cm4gdGFibGU7fSgpO30pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcik7fSx7XCJiYXNlNjQtanNcIjoxLFwiYnVmZmVyXCI6MyxcImllZWU3NTRcIjozMn1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPXtcImVsZW1lbnROYW1lc1wiOntcImFsdGdseXBoXCI6XCJhbHRHbHlwaFwiLFwiYWx0Z2x5cGhkZWZcIjpcImFsdEdseXBoRGVmXCIsXCJhbHRnbHlwaGl0ZW1cIjpcImFsdEdseXBoSXRlbVwiLFwiYW5pbWF0ZWNvbG9yXCI6XCJhbmltYXRlQ29sb3JcIixcImFuaW1hdGVtb3Rpb25cIjpcImFuaW1hdGVNb3Rpb25cIixcImFuaW1hdGV0cmFuc2Zvcm1cIjpcImFuaW1hdGVUcmFuc2Zvcm1cIixcImNsaXBwYXRoXCI6XCJjbGlwUGF0aFwiLFwiZmVibGVuZFwiOlwiZmVCbGVuZFwiLFwiZmVjb2xvcm1hdHJpeFwiOlwiZmVDb2xvck1hdHJpeFwiLFwiZmVjb21wb25lbnR0cmFuc2ZlclwiOlwiZmVDb21wb25lbnRUcmFuc2ZlclwiLFwiZmVjb21wb3NpdGVcIjpcImZlQ29tcG9zaXRlXCIsXCJmZWNvbnZvbHZlbWF0cml4XCI6XCJmZUNvbnZvbHZlTWF0cml4XCIsXCJmZWRpZmZ1c2VsaWdodGluZ1wiOlwiZmVEaWZmdXNlTGlnaHRpbmdcIixcImZlZGlzcGxhY2VtZW50bWFwXCI6XCJmZURpc3BsYWNlbWVudE1hcFwiLFwiZmVkaXN0YW50bGlnaHRcIjpcImZlRGlzdGFudExpZ2h0XCIsXCJmZWRyb3BzaGFkb3dcIjpcImZlRHJvcFNoYWRvd1wiLFwiZmVmbG9vZFwiOlwiZmVGbG9vZFwiLFwiZmVmdW5jYVwiOlwiZmVGdW5jQVwiLFwiZmVmdW5jYlwiOlwiZmVGdW5jQlwiLFwiZmVmdW5jZ1wiOlwiZmVGdW5jR1wiLFwiZmVmdW5jclwiOlwiZmVGdW5jUlwiLFwiZmVnYXVzc2lhbmJsdXJcIjpcImZlR2F1c3NpYW5CbHVyXCIsXCJmZWltYWdlXCI6XCJmZUltYWdlXCIsXCJmZW1lcmdlXCI6XCJmZU1lcmdlXCIsXCJmZW1lcmdlbm9kZVwiOlwiZmVNZXJnZU5vZGVcIixcImZlbW9ycGhvbG9neVwiOlwiZmVNb3JwaG9sb2d5XCIsXCJmZW9mZnNldFwiOlwiZmVPZmZzZXRcIixcImZlcG9pbnRsaWdodFwiOlwiZmVQb2ludExpZ2h0XCIsXCJmZXNwZWN1bGFybGlnaHRpbmdcIjpcImZlU3BlY3VsYXJMaWdodGluZ1wiLFwiZmVzcG90bGlnaHRcIjpcImZlU3BvdExpZ2h0XCIsXCJmZXRpbGVcIjpcImZlVGlsZVwiLFwiZmV0dXJidWxlbmNlXCI6XCJmZVR1cmJ1bGVuY2VcIixcImZvcmVpZ25vYmplY3RcIjpcImZvcmVpZ25PYmplY3RcIixcImdseXBocmVmXCI6XCJnbHlwaFJlZlwiLFwibGluZWFyZ3JhZGllbnRcIjpcImxpbmVhckdyYWRpZW50XCIsXCJyYWRpYWxncmFkaWVudFwiOlwicmFkaWFsR3JhZGllbnRcIixcInRleHRwYXRoXCI6XCJ0ZXh0UGF0aFwifSxcImF0dHJpYnV0ZU5hbWVzXCI6e1wiZGVmaW5pdGlvbnVybFwiOlwiZGVmaW5pdGlvblVSTFwiLFwiYXR0cmlidXRlbmFtZVwiOlwiYXR0cmlidXRlTmFtZVwiLFwiYXR0cmlidXRldHlwZVwiOlwiYXR0cmlidXRlVHlwZVwiLFwiYmFzZWZyZXF1ZW5jeVwiOlwiYmFzZUZyZXF1ZW5jeVwiLFwiYmFzZXByb2ZpbGVcIjpcImJhc2VQcm9maWxlXCIsXCJjYWxjbW9kZVwiOlwiY2FsY01vZGVcIixcImNsaXBwYXRodW5pdHNcIjpcImNsaXBQYXRoVW5pdHNcIixcImRpZmZ1c2Vjb25zdGFudFwiOlwiZGlmZnVzZUNvbnN0YW50XCIsXCJlZGdlbW9kZVwiOlwiZWRnZU1vZGVcIixcImZpbHRlcnVuaXRzXCI6XCJmaWx0ZXJVbml0c1wiLFwiZ2x5cGhyZWZcIjpcImdseXBoUmVmXCIsXCJncmFkaWVudHRyYW5zZm9ybVwiOlwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcImdyYWRpZW50dW5pdHNcIjpcImdyYWRpZW50VW5pdHNcIixcImtlcm5lbG1hdHJpeFwiOlwia2VybmVsTWF0cml4XCIsXCJrZXJuZWx1bml0bGVuZ3RoXCI6XCJrZXJuZWxVbml0TGVuZ3RoXCIsXCJrZXlwb2ludHNcIjpcImtleVBvaW50c1wiLFwia2V5c3BsaW5lc1wiOlwia2V5U3BsaW5lc1wiLFwia2V5dGltZXNcIjpcImtleVRpbWVzXCIsXCJsZW5ndGhhZGp1c3RcIjpcImxlbmd0aEFkanVzdFwiLFwibGltaXRpbmdjb25lYW5nbGVcIjpcImxpbWl0aW5nQ29uZUFuZ2xlXCIsXCJtYXJrZXJoZWlnaHRcIjpcIm1hcmtlckhlaWdodFwiLFwibWFya2VydW5pdHNcIjpcIm1hcmtlclVuaXRzXCIsXCJtYXJrZXJ3aWR0aFwiOlwibWFya2VyV2lkdGhcIixcIm1hc2tjb250ZW50dW5pdHNcIjpcIm1hc2tDb250ZW50VW5pdHNcIixcIm1hc2t1bml0c1wiOlwibWFza1VuaXRzXCIsXCJudW1vY3RhdmVzXCI6XCJudW1PY3RhdmVzXCIsXCJwYXRobGVuZ3RoXCI6XCJwYXRoTGVuZ3RoXCIsXCJwYXR0ZXJuY29udGVudHVuaXRzXCI6XCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXCJwYXR0ZXJudHJhbnNmb3JtXCI6XCJwYXR0ZXJuVHJhbnNmb3JtXCIsXCJwYXR0ZXJudW5pdHNcIjpcInBhdHRlcm5Vbml0c1wiLFwicG9pbnRzYXR4XCI6XCJwb2ludHNBdFhcIixcInBvaW50c2F0eVwiOlwicG9pbnRzQXRZXCIsXCJwb2ludHNhdHpcIjpcInBvaW50c0F0WlwiLFwicHJlc2VydmVhbHBoYVwiOlwicHJlc2VydmVBbHBoYVwiLFwicHJlc2VydmVhc3BlY3RyYXRpb1wiOlwicHJlc2VydmVBc3BlY3RSYXRpb1wiLFwicHJpbWl0aXZldW5pdHNcIjpcInByaW1pdGl2ZVVuaXRzXCIsXCJyZWZ4XCI6XCJyZWZYXCIsXCJyZWZ5XCI6XCJyZWZZXCIsXCJyZXBlYXRjb3VudFwiOlwicmVwZWF0Q291bnRcIixcInJlcGVhdGR1clwiOlwicmVwZWF0RHVyXCIsXCJyZXF1aXJlZGV4dGVuc2lvbnNcIjpcInJlcXVpcmVkRXh0ZW5zaW9uc1wiLFwicmVxdWlyZWRmZWF0dXJlc1wiOlwicmVxdWlyZWRGZWF0dXJlc1wiLFwic3BlY3VsYXJjb25zdGFudFwiOlwic3BlY3VsYXJDb25zdGFudFwiLFwic3BlY3VsYXJleHBvbmVudFwiOlwic3BlY3VsYXJFeHBvbmVudFwiLFwic3ByZWFkbWV0aG9kXCI6XCJzcHJlYWRNZXRob2RcIixcInN0YXJ0b2Zmc2V0XCI6XCJzdGFydE9mZnNldFwiLFwic3RkZGV2aWF0aW9uXCI6XCJzdGREZXZpYXRpb25cIixcInN0aXRjaHRpbGVzXCI6XCJzdGl0Y2hUaWxlc1wiLFwic3VyZmFjZXNjYWxlXCI6XCJzdXJmYWNlU2NhbGVcIixcInN5c3RlbWxhbmd1YWdlXCI6XCJzeXN0ZW1MYW5ndWFnZVwiLFwidGFibGV2YWx1ZXNcIjpcInRhYmxlVmFsdWVzXCIsXCJ0YXJnZXR4XCI6XCJ0YXJnZXRYXCIsXCJ0YXJnZXR5XCI6XCJ0YXJnZXRZXCIsXCJ0ZXh0bGVuZ3RoXCI6XCJ0ZXh0TGVuZ3RoXCIsXCJ2aWV3Ym94XCI6XCJ2aWV3Qm94XCIsXCJ2aWV3dGFyZ2V0XCI6XCJ2aWV3VGFyZ2V0XCIsXCJ4Y2hhbm5lbHNlbGVjdG9yXCI6XCJ4Q2hhbm5lbFNlbGVjdG9yXCIsXCJ5Y2hhbm5lbHNlbGVjdG9yXCI6XCJ5Q2hhbm5lbFNlbGVjdG9yXCIsXCJ6b29tYW5kcGFuXCI6XCJ6b29tQW5kUGFuXCJ9fTt9LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKlxuICBNb2R1bGUgZGVwZW5kZW5jaWVzXG4qL3ZhciBFbGVtZW50VHlwZT1yZXF1aXJlKCdkb21lbGVtZW50dHlwZScpO3ZhciBlbnRpdGllcz1yZXF1aXJlKCdlbnRpdGllcycpOy8qIG1peGVkLWNhc2UgU1ZHIGFuZCBNYXRoTUwgdGFncyAmIGF0dHJpYnV0ZXNcbiAgIHJlY29nbml6ZWQgYnkgdGhlIEhUTUwgcGFyc2VyLCBzZWVcbiAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNwYXJzaW5nLW1haW4taW5mb3JlaWduXG4qL3ZhciBmb3JlaWduTmFtZXM9cmVxdWlyZSgnLi9mb3JlaWduTmFtZXMuanNvbicpO2ZvcmVpZ25OYW1lcy5lbGVtZW50TmFtZXMuX19wcm90b19fPW51bGw7LyogdXNlIGFzIGEgc2ltcGxlIGRpY3Rpb25hcnkgKi9mb3JlaWduTmFtZXMuYXR0cmlidXRlTmFtZXMuX19wcm90b19fPW51bGw7dmFyIHVuZW5jb2RlZEVsZW1lbnRzPXtfX3Byb3RvX186bnVsbCxzdHlsZTp0cnVlLHNjcmlwdDp0cnVlLHhtcDp0cnVlLGlmcmFtZTp0cnVlLG5vZW1iZWQ6dHJ1ZSxub2ZyYW1lczp0cnVlLHBsYWludGV4dDp0cnVlLG5vc2NyaXB0OnRydWV9Oy8qXG4gIEZvcm1hdCBhdHRyaWJ1dGVzXG4qL2Z1bmN0aW9uIGZvcm1hdEF0dHJzKGF0dHJpYnV0ZXMsb3B0cyl7aWYoIWF0dHJpYnV0ZXMpcmV0dXJuO3ZhciBvdXRwdXQ9Jyc7dmFyIHZhbHVlOy8vIExvb3AgdGhyb3VnaCB0aGUgYXR0cmlidXRlc1xuZm9yKHZhciBrZXkgaW4gYXR0cmlidXRlcyl7dmFsdWU9YXR0cmlidXRlc1trZXldO2lmKG91dHB1dCl7b3V0cHV0Kz0nICc7fWlmKG9wdHMueG1sTW9kZT09PSdmb3JlaWduJyl7LyogZml4IHVwIG1peGVkLWNhc2UgYXR0cmlidXRlIG5hbWVzICova2V5PWZvcmVpZ25OYW1lcy5hdHRyaWJ1dGVOYW1lc1trZXldfHxrZXk7fW91dHB1dCs9a2V5O2lmKHZhbHVlIT09bnVsbCYmdmFsdWUhPT0nJ3x8b3B0cy54bWxNb2RlKXtvdXRwdXQrPSc9XCInKyhvcHRzLmRlY29kZUVudGl0aWVzP2VudGl0aWVzLmVuY29kZVhNTCh2YWx1ZSk6dmFsdWUucmVwbGFjZSgvXFxcIi9nLCcmcXVvdDsnKSkrJ1wiJzt9fXJldHVybiBvdXRwdXQ7fS8qXG4gIFNlbGYtZW5jbG9zaW5nIHRhZ3MgKHN0b2xlbiBmcm9tIG5vZGUtaHRtbHBhcnNlcilcbiovdmFyIHNpbmdsZVRhZz17X19wcm90b19fOm51bGwsYXJlYTp0cnVlLGJhc2U6dHJ1ZSxiYXNlZm9udDp0cnVlLGJyOnRydWUsY29sOnRydWUsY29tbWFuZDp0cnVlLGVtYmVkOnRydWUsZnJhbWU6dHJ1ZSxocjp0cnVlLGltZzp0cnVlLGlucHV0OnRydWUsaXNpbmRleDp0cnVlLGtleWdlbjp0cnVlLGxpbms6dHJ1ZSxtZXRhOnRydWUscGFyYW06dHJ1ZSxzb3VyY2U6dHJ1ZSx0cmFjazp0cnVlLHdicjp0cnVlfTt2YXIgcmVuZGVyPW1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGRvbSxvcHRzKXtpZighQXJyYXkuaXNBcnJheShkb20pJiYhZG9tLmNoZWVyaW8pZG9tPVtkb21dO29wdHM9b3B0c3x8e307dmFyIG91dHB1dD0nJztmb3IodmFyIGk9MDtpPGRvbS5sZW5ndGg7aSsrKXt2YXIgZWxlbT1kb21baV07aWYoZWxlbS50eXBlPT09J3Jvb3QnKW91dHB1dCs9cmVuZGVyKGVsZW0uY2hpbGRyZW4sb3B0cyk7ZWxzZSBpZihFbGVtZW50VHlwZS5pc1RhZyhlbGVtKSlvdXRwdXQrPXJlbmRlclRhZyhlbGVtLG9wdHMpO2Vsc2UgaWYoZWxlbS50eXBlPT09RWxlbWVudFR5cGUuRGlyZWN0aXZlKW91dHB1dCs9cmVuZGVyRGlyZWN0aXZlKGVsZW0pO2Vsc2UgaWYoZWxlbS50eXBlPT09RWxlbWVudFR5cGUuQ29tbWVudClvdXRwdXQrPXJlbmRlckNvbW1lbnQoZWxlbSk7ZWxzZSBpZihlbGVtLnR5cGU9PT1FbGVtZW50VHlwZS5DREFUQSlvdXRwdXQrPXJlbmRlckNkYXRhKGVsZW0pO2Vsc2Ugb3V0cHV0Kz1yZW5kZXJUZXh0KGVsZW0sb3B0cyk7fXJldHVybiBvdXRwdXQ7fTt2YXIgZm9yZWlnbk1vZGVJbnRlZ3JhdGlvblBvaW50cz1bJ21pJywnbW8nLCdtbicsJ21zJywnbXRleHQnLCdhbm5vdGF0aW9uLXhtbCcsJ2ZvcmVpZ25PYmplY3QnLCdkZXNjJywndGl0bGUnXTtmdW5jdGlvbiByZW5kZXJUYWcoZWxlbSxvcHRzKXsvLyBIYW5kbGUgU1ZHIC8gTWF0aE1MIGluIEhUTUxcbmlmKG9wdHMueG1sTW9kZT09PSdmb3JlaWduJyl7LyogZml4IHVwIG1peGVkLWNhc2UgZWxlbWVudCBuYW1lcyAqL2VsZW0ubmFtZT1mb3JlaWduTmFtZXMuZWxlbWVudE5hbWVzW2VsZW0ubmFtZV18fGVsZW0ubmFtZTsvKiBleGl0IGZvcmVpZ24gbW9kZSBhdCBpbnRlZ3JhdGlvbiBwb2ludHMgKi9pZihlbGVtLnBhcmVudCYmZm9yZWlnbk1vZGVJbnRlZ3JhdGlvblBvaW50cy5pbmRleE9mKGVsZW0ucGFyZW50Lm5hbWUpPj0wKW9wdHM9T2JqZWN0LmFzc2lnbih7fSxvcHRzLHt4bWxNb2RlOmZhbHNlfSk7fWlmKCFvcHRzLnhtbE1vZGUmJlsnc3ZnJywnbWF0aCddLmluZGV4T2YoZWxlbS5uYW1lKT49MCl7b3B0cz1PYmplY3QuYXNzaWduKHt9LG9wdHMse3htbE1vZGU6J2ZvcmVpZ24nfSk7fXZhciB0YWc9JzwnK2VsZW0ubmFtZTt2YXIgYXR0cmlicz1mb3JtYXRBdHRycyhlbGVtLmF0dHJpYnMsb3B0cyk7aWYoYXR0cmlicyl7dGFnKz0nICcrYXR0cmliczt9aWYob3B0cy54bWxNb2RlJiYoIWVsZW0uY2hpbGRyZW58fGVsZW0uY2hpbGRyZW4ubGVuZ3RoPT09MCkpe3RhZys9Jy8+Jzt9ZWxzZXt0YWcrPSc+JztpZihlbGVtLmNoaWxkcmVuKXt0YWcrPXJlbmRlcihlbGVtLmNoaWxkcmVuLG9wdHMpO31pZighc2luZ2xlVGFnW2VsZW0ubmFtZV18fG9wdHMueG1sTW9kZSl7dGFnKz0nPC8nK2VsZW0ubmFtZSsnPic7fX1yZXR1cm4gdGFnO31mdW5jdGlvbiByZW5kZXJEaXJlY3RpdmUoZWxlbSl7cmV0dXJuJzwnK2VsZW0uZGF0YSsnPic7fWZ1bmN0aW9uIHJlbmRlclRleHQoZWxlbSxvcHRzKXt2YXIgZGF0YT1lbGVtLmRhdGF8fCcnOy8vIGlmIGVudGl0aWVzIHdlcmVuJ3QgZGVjb2RlZCwgbm8gbmVlZCB0byBlbmNvZGUgdGhlbSBiYWNrXG5pZihvcHRzLmRlY29kZUVudGl0aWVzJiYhKGVsZW0ucGFyZW50JiZlbGVtLnBhcmVudC5uYW1lIGluIHVuZW5jb2RlZEVsZW1lbnRzKSl7ZGF0YT1lbnRpdGllcy5lbmNvZGVYTUwoZGF0YSk7fXJldHVybiBkYXRhO31mdW5jdGlvbiByZW5kZXJDZGF0YShlbGVtKXtyZXR1cm4nPCFbQ0RBVEFbJytlbGVtLmNoaWxkcmVuWzBdLmRhdGErJ11dPic7fWZ1bmN0aW9uIHJlbmRlckNvbW1lbnQoZWxlbSl7cmV0dXJuJzwhLS0nK2VsZW0uZGF0YSsnLS0+Jzt9fSx7XCIuL2ZvcmVpZ25OYW1lcy5qc29uXCI6NCxcImRvbWVsZW1lbnR0eXBlXCI6NixcImVudGl0aWVzXCI6MjB9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pOy8qKlxuICogVGVzdHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGEgdGFnIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gZWxlbSBFbGVtZW50IHRvIHRlc3RcbiAqL2Z1bmN0aW9uIGlzVGFnKGVsZW0pe3JldHVybiBlbGVtLnR5cGU9PT1cInRhZ1wiLyogVGFnICovfHxlbGVtLnR5cGU9PT1cInNjcmlwdFwiLyogU2NyaXB0ICovfHxlbGVtLnR5cGU9PT1cInN0eWxlXCIvKiBTdHlsZSAqLzt9ZXhwb3J0cy5pc1RhZz1pc1RhZzsvLyBFeHBvcnRzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuZXhwb3J0cy5UZXh0PVwidGV4dFwiLyogVGV4dCAqLzsvL1RleHRcbmV4cG9ydHMuRGlyZWN0aXZlPVwiZGlyZWN0aXZlXCIvKiBEaXJlY3RpdmUgKi87Ly88PyAuLi4gPz5cbmV4cG9ydHMuQ29tbWVudD1cImNvbW1lbnRcIi8qIENvbW1lbnQgKi87Ly88IS0tIC4uLiAtLT5cbmV4cG9ydHMuU2NyaXB0PVwic2NyaXB0XCIvKiBTY3JpcHQgKi87Ly88c2NyaXB0PiB0YWdzXG5leHBvcnRzLlN0eWxlPVwic3R5bGVcIi8qIFN0eWxlICovOy8vPHN0eWxlPiB0YWdzXG5leHBvcnRzLlRhZz1cInRhZ1wiLyogVGFnICovOy8vQW55IHRhZ1xuZXhwb3J0cy5DREFUQT1cImNkYXRhXCIvKiBDREFUQSAqLzsvLzwhW0NEQVRBWyAuLi4gXV0+XG5leHBvcnRzLkRvY3R5cGU9XCJkb2N0eXBlXCIvKiBEb2N0eXBlICovO30se31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIG5vZGVfMT1yZXF1aXJlKFwiLi9ub2RlXCIpO2V4cG9ydHMuTm9kZT1ub2RlXzEuTm9kZTtleHBvcnRzLkVsZW1lbnQ9bm9kZV8xLkVsZW1lbnQ7ZXhwb3J0cy5EYXRhTm9kZT1ub2RlXzEuRGF0YU5vZGU7ZXhwb3J0cy5Ob2RlV2l0aENoaWxkcmVuPW5vZGVfMS5Ob2RlV2l0aENoaWxkcmVuO3ZhciByZVdoaXRlc3BhY2U9L1xccysvZzsvLyBEZWZhdWx0IG9wdGlvbnNcbnZhciBkZWZhdWx0T3B0cz17bm9ybWFsaXplV2hpdGVzcGFjZTpmYWxzZSx3aXRoU3RhcnRJbmRpY2VzOmZhbHNlLHdpdGhFbmRJbmRpY2VzOmZhbHNlfTt2YXIgRG9tSGFuZGxlcj0vKiogQGNsYXNzICovZnVuY3Rpb24oKXsvKipcbiAgICAgKiBJbml0aWF0ZSBhIG5ldyBEb21IYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxlZCBvbmNlIHBhcnNpbmcgaGFzIGNvbXBsZXRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBTZXR0aW5ncyBmb3IgdGhlIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIGVsZW1lbnRDQiBDYWxsYmFjayB3aGVuZXZlciBhIHRhZyBpcyBjbG9zZWQuXG4gICAgICovZnVuY3Rpb24gRG9tSGFuZGxlcihjYWxsYmFjayxvcHRpb25zLGVsZW1lbnRDQil7LyoqIFRoZSBjb25zdHJ1Y3RlZCBET00gKi90aGlzLmRvbT1bXTsvKiogSW5kaWNhdGVkIHdoZXRoZXIgcGFyc2luZyBoYXMgYmVlbiBjb21wbGV0ZWQuICovdGhpcy5fZG9uZT1mYWxzZTsvKiogU3RhY2sgb2Ygb3BlbiB0YWdzLiAqL3RoaXMuX3RhZ1N0YWNrPVtdOy8qKiBBIGRhdGEgbm9kZSB0aGF0IGlzIHN0aWxsIGJlaW5nIHdyaXR0ZW4gdG8uICovdGhpcy5fbGFzdE5vZGU9bnVsbDsvKiogUmVmZXJlbmNlIHRvIHRoZSBwYXJzZXIgaW5zdGFuY2UuIFVzZWQgZm9yIGxvY2F0aW9uIGluZm9ybWF0aW9uLiAqL3RoaXMuX3BhcnNlcj1udWxsOy8vIE1ha2UgaXQgcG9zc2libGUgdG8gc2tpcCBhcmd1bWVudHMsIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuaWYodHlwZW9mIG9wdGlvbnM9PT1cImZ1bmN0aW9uXCIpe2VsZW1lbnRDQj1vcHRpb25zO29wdGlvbnM9ZGVmYXVsdE9wdHM7fWlmKF90eXBlb2YoY2FsbGJhY2spPT09XCJvYmplY3RcIil7b3B0aW9ucz1jYWxsYmFjaztjYWxsYmFjaz11bmRlZmluZWQ7fXRoaXMuX2NhbGxiYWNrPWNhbGxiYWNrfHxudWxsO3RoaXMuX29wdGlvbnM9b3B0aW9uc3x8ZGVmYXVsdE9wdHM7dGhpcy5fZWxlbWVudENCPWVsZW1lbnRDQnx8bnVsbDt9RG9tSGFuZGxlci5wcm90b3R5cGUub25wYXJzZXJpbml0PWZ1bmN0aW9uKHBhcnNlcil7dGhpcy5fcGFyc2VyPXBhcnNlcjt9Oy8vIFJlc2V0cyB0aGUgaGFuZGxlciBiYWNrIHRvIHN0YXJ0aW5nIHN0YXRlXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5kb209W107dGhpcy5fZG9uZT1mYWxzZTt0aGlzLl90YWdTdGFjaz1bXTt0aGlzLl9sYXN0Tm9kZT1udWxsO3RoaXMuX3BhcnNlcj10aGlzLl9wYXJzZXJ8fG51bGw7fTsvLyBTaWduYWxzIHRoZSBoYW5kbGVyIHRoYXQgcGFyc2luZyBpcyBkb25lXG5Eb21IYW5kbGVyLnByb3RvdHlwZS5vbmVuZD1mdW5jdGlvbigpe2lmKHRoaXMuX2RvbmUpcmV0dXJuO3RoaXMuX2RvbmU9dHJ1ZTt0aGlzLl9wYXJzZXI9bnVsbDt0aGlzLmhhbmRsZUNhbGxiYWNrKG51bGwpO307RG9tSGFuZGxlci5wcm90b3R5cGUub25lcnJvcj1mdW5jdGlvbihlcnJvcil7dGhpcy5oYW5kbGVDYWxsYmFjayhlcnJvcik7fTtEb21IYW5kbGVyLnByb3RvdHlwZS5vbmNsb3NldGFnPWZ1bmN0aW9uKCl7dGhpcy5fbGFzdE5vZGU9bnVsbDsvLyBJZih0aGlzLl90YWdTdGFjay5wb3AoKS5uYW1lICE9PSBuYW1lKSB0aGlzLmhhbmRsZUNhbGxiYWNrKEVycm9yKFwiVGFnbmFtZSBkaWRuJ3QgbWF0Y2ghXCIpKTtcbnZhciBlbGVtPXRoaXMuX3RhZ1N0YWNrLnBvcCgpO2lmKCFlbGVtfHwhdGhpcy5fcGFyc2VyKXtyZXR1cm47fWlmKHRoaXMuX29wdGlvbnMud2l0aEVuZEluZGljZXMpe2VsZW0uZW5kSW5kZXg9dGhpcy5fcGFyc2VyLmVuZEluZGV4O31pZih0aGlzLl9lbGVtZW50Q0IpdGhpcy5fZWxlbWVudENCKGVsZW0pO307RG9tSGFuZGxlci5wcm90b3R5cGUub25vcGVudGFnPWZ1bmN0aW9uKG5hbWUsYXR0cmlicyl7dmFyIGVsZW1lbnQ9bmV3IG5vZGVfMS5FbGVtZW50KG5hbWUsYXR0cmlicyk7dGhpcy5hZGROb2RlKGVsZW1lbnQpO3RoaXMuX3RhZ1N0YWNrLnB1c2goZWxlbWVudCk7fTtEb21IYW5kbGVyLnByb3RvdHlwZS5vbnRleHQ9ZnVuY3Rpb24oZGF0YSl7dmFyIG5vcm1hbGl6ZT10aGlzLl9vcHRpb25zLm5vcm1hbGl6ZVdoaXRlc3BhY2U7dmFyIF9sYXN0Tm9kZT10aGlzLl9sYXN0Tm9kZTtpZihfbGFzdE5vZGUmJl9sYXN0Tm9kZS50eXBlPT09XCJ0ZXh0XCIvKiBUZXh0ICovKXtpZihub3JtYWxpemUpe19sYXN0Tm9kZS5kYXRhPShfbGFzdE5vZGUuZGF0YStkYXRhKS5yZXBsYWNlKHJlV2hpdGVzcGFjZSxcIiBcIik7fWVsc2V7X2xhc3ROb2RlLmRhdGErPWRhdGE7fX1lbHNle2lmKG5vcm1hbGl6ZSl7ZGF0YT1kYXRhLnJlcGxhY2UocmVXaGl0ZXNwYWNlLFwiIFwiKTt9dmFyIG5vZGU9bmV3IG5vZGVfMS5EYXRhTm9kZShcInRleHRcIi8qIFRleHQgKi8sZGF0YSk7dGhpcy5hZGROb2RlKG5vZGUpO3RoaXMuX2xhc3ROb2RlPW5vZGU7fX07RG9tSGFuZGxlci5wcm90b3R5cGUub25jb21tZW50PWZ1bmN0aW9uKGRhdGEpe2lmKHRoaXMuX2xhc3ROb2RlJiZ0aGlzLl9sYXN0Tm9kZS50eXBlPT09XCJjb21tZW50XCIvKiBDb21tZW50ICovKXt0aGlzLl9sYXN0Tm9kZS5kYXRhKz1kYXRhO3JldHVybjt9dmFyIG5vZGU9bmV3IG5vZGVfMS5EYXRhTm9kZShcImNvbW1lbnRcIi8qIENvbW1lbnQgKi8sZGF0YSk7dGhpcy5hZGROb2RlKG5vZGUpO3RoaXMuX2xhc3ROb2RlPW5vZGU7fTtEb21IYW5kbGVyLnByb3RvdHlwZS5vbmNvbW1lbnRlbmQ9ZnVuY3Rpb24oKXt0aGlzLl9sYXN0Tm9kZT1udWxsO307RG9tSGFuZGxlci5wcm90b3R5cGUub25jZGF0YXN0YXJ0PWZ1bmN0aW9uKCl7dmFyIHRleHQ9bmV3IG5vZGVfMS5EYXRhTm9kZShcInRleHRcIi8qIFRleHQgKi8sXCJcIik7dmFyIG5vZGU9bmV3IG5vZGVfMS5Ob2RlV2l0aENoaWxkcmVuKFwiY2RhdGFcIi8qIENEQVRBICovLFt0ZXh0XSk7dGhpcy5hZGROb2RlKG5vZGUpO3RleHQucGFyZW50PW5vZGU7dGhpcy5fbGFzdE5vZGU9dGV4dDt9O0RvbUhhbmRsZXIucHJvdG90eXBlLm9uY2RhdGFlbmQ9ZnVuY3Rpb24oKXt0aGlzLl9sYXN0Tm9kZT1udWxsO307RG9tSGFuZGxlci5wcm90b3R5cGUub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb249ZnVuY3Rpb24obmFtZSxkYXRhKXt2YXIgbm9kZT1uZXcgbm9kZV8xLlByb2Nlc3NpbmdJbnN0cnVjdGlvbihuYW1lLGRhdGEpO3RoaXMuYWRkTm9kZShub2RlKTt9O0RvbUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUNhbGxiYWNrPWZ1bmN0aW9uKGVycm9yKXtpZih0eXBlb2YgdGhpcy5fY2FsbGJhY2s9PT1cImZ1bmN0aW9uXCIpe3RoaXMuX2NhbGxiYWNrKGVycm9yLHRoaXMuZG9tKTt9ZWxzZSBpZihlcnJvcil7dGhyb3cgZXJyb3I7fX07RG9tSGFuZGxlci5wcm90b3R5cGUuYWRkTm9kZT1mdW5jdGlvbihub2RlKXt2YXIgcGFyZW50PXRoaXMuX3RhZ1N0YWNrW3RoaXMuX3RhZ1N0YWNrLmxlbmd0aC0xXTt2YXIgc2libGluZ3M9cGFyZW50P3BhcmVudC5jaGlsZHJlbjp0aGlzLmRvbTt2YXIgcHJldmlvdXNTaWJsaW5nPXNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aC0xXTtpZih0aGlzLl9wYXJzZXIpe2lmKHRoaXMuX29wdGlvbnMud2l0aFN0YXJ0SW5kaWNlcyl7bm9kZS5zdGFydEluZGV4PXRoaXMuX3BhcnNlci5zdGFydEluZGV4O31pZih0aGlzLl9vcHRpb25zLndpdGhFbmRJbmRpY2VzKXtub2RlLmVuZEluZGV4PXRoaXMuX3BhcnNlci5lbmRJbmRleDt9fXNpYmxpbmdzLnB1c2gobm9kZSk7aWYocHJldmlvdXNTaWJsaW5nKXtub2RlLnByZXY9cHJldmlvdXNTaWJsaW5nO3ByZXZpb3VzU2libGluZy5uZXh0PW5vZGU7fWlmKHBhcmVudCl7bm9kZS5wYXJlbnQ9cGFyZW50O310aGlzLl9sYXN0Tm9kZT1udWxsO307RG9tSGFuZGxlci5wcm90b3R5cGUuYWRkRGF0YU5vZGU9ZnVuY3Rpb24obm9kZSl7dGhpcy5hZGROb2RlKG5vZGUpO3RoaXMuX2xhc3ROb2RlPW5vZGU7fTtyZXR1cm4gRG9tSGFuZGxlcjt9KCk7ZXhwb3J0cy5Eb21IYW5kbGVyPURvbUhhbmRsZXI7ZXhwb3J0c1tcImRlZmF1bHRcIl09RG9tSGFuZGxlcjt9LHtcIi4vbm9kZVwiOjh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgX19leHRlbmRzPXRoaXMmJnRoaXMuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciBfZXh0ZW5kU3RhdGljcz1mdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsYil7X2V4dGVuZFN0YXRpY3M9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGQsYil7ZC5fX3Byb3RvX189Yjt9fHxmdW5jdGlvbihkLGIpe2Zvcih2YXIgcCBpbiBiKXtpZihiLmhhc093blByb3BlcnR5KHApKWRbcF09YltwXTt9fTtyZXR1cm4gX2V4dGVuZFN0YXRpY3MoZCxiKTt9O3JldHVybiBmdW5jdGlvbihkLGIpe19leHRlbmRTdGF0aWNzKGQsYik7ZnVuY3Rpb24gX18oKXt0aGlzLmNvbnN0cnVjdG9yPWQ7fWQucHJvdG90eXBlPWI9PT1udWxsP09iamVjdC5jcmVhdGUoYik6KF9fLnByb3RvdHlwZT1iLnByb3RvdHlwZSxuZXcgX18oKSk7fTt9KCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgbm9kZVR5cGVzPW5ldyBNYXAoW1tcInRhZ1wiLyogVGFnICovLDFdLFtcInNjcmlwdFwiLyogU2NyaXB0ICovLDFdLFtcInN0eWxlXCIvKiBTdHlsZSAqLywxXSxbXCJkaXJlY3RpdmVcIi8qIERpcmVjdGl2ZSAqLywxXSxbXCJ0ZXh0XCIvKiBUZXh0ICovLDNdLFtcImNkYXRhXCIvKiBDREFUQSAqLyw0XSxbXCJjb21tZW50XCIvKiBDb21tZW50ICovLDhdXSk7Ly8gVGhpcyBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHRoZSBwcm90b3R5cGUgZm9yIE5vZGVzIHdoZW4gY3JlYXRpbmcgYVxuLy8gRE9NLUxldmVsLTEtY29tcGxpYW50IHN0cnVjdHVyZS5cbnZhciBOb2RlPS8qKiBAY2xhc3MgKi9mdW5jdGlvbigpey8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG5vZGUuXG4gICAgICovZnVuY3Rpb24gTm9kZSh0eXBlKXt0aGlzLnR5cGU9dHlwZTsvKiogUGFyZW50IG9mIHRoZSBub2RlICovdGhpcy5wYXJlbnQ9bnVsbDsvKiogUHJldmlvdXMgc2libGluZyAqL3RoaXMucHJldj1udWxsOy8qKiBOZXh0IHNpYmxpbmcgKi90aGlzLm5leHQ9bnVsbDsvKiogVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSBub2RlLiBSZXF1aXJlcyBgd2l0aFN0YXJ0SW5kaWNlc2Agb24gdGhlIGhhbmRsZXIgdG8gYmUgYHRydWUuICovdGhpcy5zdGFydEluZGV4PW51bGw7LyoqIFRoZSBlbmQgaW5kZXggb2YgdGhlIG5vZGUuIFJlcXVpcmVzIGB3aXRoRW5kSW5kaWNlc2Agb24gdGhlIGhhbmRsZXIgdG8gYmUgYHRydWUuICovdGhpcy5lbmRJbmRleD1udWxsO31PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsXCJub2RlVHlwZVwiLHsvLyBSZWFkLW9ubHkgYWxpYXNlc1xuZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiBub2RlVHlwZXMuZ2V0KHRoaXMudHlwZSl8fDE7fSxlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsXCJwYXJlbnROb2RlXCIsey8vIFJlYWQtd3JpdGUgYWxpYXNlcyBmb3IgcHJvcGVydGllc1xuZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLnBhcmVudHx8bnVsbDt9LHNldDpmdW5jdGlvbiBzZXQocGFyZW50KXt0aGlzLnBhcmVudD1wYXJlbnQ7fSxlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsXCJwcmV2aW91c1NpYmxpbmdcIix7Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLnByZXZ8fG51bGw7fSxzZXQ6ZnVuY3Rpb24gc2V0KHByZXYpe3RoaXMucHJldj1wcmV2O30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLFwibmV4dFNpYmxpbmdcIix7Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLm5leHR8fG51bGw7fSxzZXQ6ZnVuY3Rpb24gc2V0KG5leHQpe3RoaXMubmV4dD1uZXh0O30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIE5vZGU7fSgpO2V4cG9ydHMuTm9kZT1Ob2RlO3ZhciBEYXRhTm9kZT0vKiogQGNsYXNzICovZnVuY3Rpb24oX3N1cGVyKXtfX2V4dGVuZHMoRGF0YU5vZGUsX3N1cGVyKTsvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBub2RlXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGNvbnRlbnQgb2YgdGhlIGRhdGEgbm9kZVxuICAgICAqL2Z1bmN0aW9uIERhdGFOb2RlKHR5cGUsZGF0YSl7dmFyIF90aGlzPV9zdXBlci5jYWxsKHRoaXMsdHlwZSl8fHRoaXM7X3RoaXMuZGF0YT1kYXRhO3JldHVybiBfdGhpczt9T2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSxcIm5vZGVWYWx1ZVwiLHtnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuZGF0YTt9LHNldDpmdW5jdGlvbiBzZXQoZGF0YSl7dGhpcy5kYXRhPWRhdGE7fSxlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9KTtyZXR1cm4gRGF0YU5vZGU7fShOb2RlKTtleHBvcnRzLkRhdGFOb2RlPURhdGFOb2RlO3ZhciBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb249LyoqIEBjbGFzcyAqL2Z1bmN0aW9uKF9zdXBlcil7X19leHRlbmRzKFByb2Nlc3NpbmdJbnN0cnVjdGlvbixfc3VwZXIpO2Z1bmN0aW9uIFByb2Nlc3NpbmdJbnN0cnVjdGlvbihuYW1lLGRhdGEpe3ZhciBfdGhpcz1fc3VwZXIuY2FsbCh0aGlzLFwiZGlyZWN0aXZlXCIvKiBEaXJlY3RpdmUgKi8sZGF0YSl8fHRoaXM7X3RoaXMubmFtZT1uYW1lO3JldHVybiBfdGhpczt9cmV0dXJuIFByb2Nlc3NpbmdJbnN0cnVjdGlvbjt9KERhdGFOb2RlKTtleHBvcnRzLlByb2Nlc3NpbmdJbnN0cnVjdGlvbj1Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb247dmFyIE5vZGVXaXRoQ2hpbGRyZW49LyoqIEBjbGFzcyAqL2Z1bmN0aW9uKF9zdXBlcil7X19leHRlbmRzKE5vZGVXaXRoQ2hpbGRyZW4sX3N1cGVyKTsvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIFR5cGUgb2YgdGhlIG5vZGUuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBub2RlLiBPbmx5IGNlcnRhaW4gbm9kZSB0eXBlcyBjYW4gaGF2ZSBjaGlsZHJlbi5cbiAgICAgKi9mdW5jdGlvbiBOb2RlV2l0aENoaWxkcmVuKHR5cGUsY2hpbGRyZW4pe3ZhciBfdGhpcz1fc3VwZXIuY2FsbCh0aGlzLHR5cGUpfHx0aGlzO190aGlzLmNoaWxkcmVuPWNoaWxkcmVuO3JldHVybiBfdGhpczt9T2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGVXaXRoQ2hpbGRyZW4ucHJvdG90eXBlLFwiZmlyc3RDaGlsZFwiLHsvLyBBbGlhc2VzXG5nZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuY2hpbGRyZW5bMF18fG51bGw7fSxlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZVdpdGhDaGlsZHJlbi5wcm90b3R5cGUsXCJsYXN0Q2hpbGRcIix7Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoLTFdfHxudWxsO30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGVXaXRoQ2hpbGRyZW4ucHJvdG90eXBlLFwiY2hpbGROb2Rlc1wiLHtnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuY2hpbGRyZW47fSxzZXQ6ZnVuY3Rpb24gc2V0KGNoaWxkcmVuKXt0aGlzLmNoaWxkcmVuPWNoaWxkcmVuO30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIE5vZGVXaXRoQ2hpbGRyZW47fShOb2RlKTtleHBvcnRzLk5vZGVXaXRoQ2hpbGRyZW49Tm9kZVdpdGhDaGlsZHJlbjt2YXIgRWxlbWVudD0vKiogQGNsYXNzICovZnVuY3Rpb24oX3N1cGVyKXtfX2V4dGVuZHMoRWxlbWVudCxfc3VwZXIpOy8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdGFnLCBlZy4gYGRpdmAsIGBzcGFuYFxuICAgICAqIEBwYXJhbSBhdHRyaWJzIE9iamVjdCBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lcyB0byBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICovZnVuY3Rpb24gRWxlbWVudChuYW1lLGF0dHJpYnMpe3ZhciBfdGhpcz1fc3VwZXIuY2FsbCh0aGlzLG5hbWU9PT1cInNjcmlwdFwiP1wic2NyaXB0XCIvKiBTY3JpcHQgKi86bmFtZT09PVwic3R5bGVcIj9cInN0eWxlXCIvKiBTdHlsZSAqLzpcInRhZ1wiLyogVGFnICovLFtdKXx8dGhpcztfdGhpcy5uYW1lPW5hbWU7X3RoaXMuYXR0cmlicz1hdHRyaWJzO190aGlzLmF0dHJpYnM9YXR0cmlicztyZXR1cm4gX3RoaXM7fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbGVtZW50LnByb3RvdHlwZSxcInRhZ05hbWVcIix7Ly8gRE9NIExldmVsIDEgYWxpYXNlc1xuZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLm5hbWU7fSxzZXQ6ZnVuY3Rpb24gc2V0KG5hbWUpe3RoaXMubmFtZT1uYW1lO30sZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfSk7cmV0dXJuIEVsZW1lbnQ7fShOb2RlV2l0aENoaWxkcmVuKTtleHBvcnRzLkVsZW1lbnQ9RWxlbWVudDt9LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciB0YWd0eXBlc18xPXJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpOy8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygbm9kZXMsIHJlbW92ZSBhbnkgbWVtYmVyIHRoYXQgaXMgY29udGFpbmVkIGJ5IGFub3RoZXIuXG4gKlxuICogQHBhcmFtIG5vZGVzIOKAlCBOb2RlcyB0byBmaWx0ZXIuXG4gKi9mdW5jdGlvbiByZW1vdmVTdWJzZXRzKG5vZGVzKXt2YXIgaWR4PW5vZGVzLmxlbmd0aDsvLyBDaGVjayBpZiBlYWNoIG5vZGUgKG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzKSBpcyBhbHJlYWR5IGNvbnRhaW5lZCBpbiB0aGVcbi8vIGFycmF5Llxud2hpbGUoLS1pZHg+PTApe3ZhciBub2RlPW5vZGVzW2lkeF07Ly8gUmVtb3ZlIHRoZSBub2RlIGlmIGl0IGlzIG5vdCB1bmlxdWUuXG4vLyBXZSBhcmUgZ29pbmcgdGhyb3VnaCB0aGUgYXJyYXkgZnJvbSB0aGUgZW5kLCBzbyB3ZSBvbmx5XG4vLyBoYXZlIHRvIGNoZWNrIG5vZGVzIHRoYXQgcHJlY2VlZCB0aGUgbm9kZSB1bmRlciBjb25zaWRlcmF0aW9uIGluIHRoZSBhcnJheS5cbmlmKGlkeD4wJiZub2Rlcy5sYXN0SW5kZXhPZihub2RlLGlkeC0xKT49MCl7bm9kZXMuc3BsaWNlKGlkeCwxKTtjb250aW51ZTt9Zm9yKHZhciBhbmNlc3Rvcj1ub2RlLnBhcmVudDthbmNlc3RvcjthbmNlc3Rvcj1hbmNlc3Rvci5wYXJlbnQpe2lmKG5vZGVzLmluZGV4T2YoYW5jZXN0b3IpPi0xKXtub2Rlcy5zcGxpY2UoaWR4LDEpO2JyZWFrO319fXJldHVybiBub2Rlczt9ZXhwb3J0cy5yZW1vdmVTdWJzZXRzPXJlbW92ZVN1YnNldHM7LyoqKlxuICogQ29tcGFyZSB0aGUgcG9zaXRpb24gb2Ygb25lIG5vZGUgYWdhaW5zdCBhbm90aGVyIG5vZGUgaW4gYW55IG90aGVyIGRvY3VtZW50LlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhIGJpdG1hc2sgd2l0aCB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqXG4gKiBkb2N1bWVudCBvcmRlcjpcbiAqID4gVGhlcmUgaXMgYW4gb3JkZXJpbmcsIGRvY3VtZW50IG9yZGVyLCBkZWZpbmVkIG9uIGFsbCB0aGUgbm9kZXMgaW4gdGhlXG4gKiA+IGRvY3VtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gKiA+IFhNTCByZXByZXNlbnRhdGlvbiBvZiBlYWNoIG5vZGUgb2NjdXJzIGluIHRoZSBYTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gKiA+IGRvY3VtZW50IGFmdGVyIGV4cGFuc2lvbiBvZiBnZW5lcmFsIGVudGl0aWVzLiBUaHVzLCB0aGUgZG9jdW1lbnQgZWxlbWVudFxuICogPiBub2RlIHdpbGwgYmUgdGhlIGZpcnN0IG5vZGUuIEVsZW1lbnQgbm9kZXMgb2NjdXIgYmVmb3JlIHRoZWlyIGNoaWxkcmVuLlxuICogPiBUaHVzLCBkb2N1bWVudCBvcmRlciBvcmRlcnMgZWxlbWVudCBub2RlcyBpbiBvcmRlciBvZiB0aGUgb2NjdXJyZW5jZSBvZlxuICogPiB0aGVpciBzdGFydC10YWcgaW4gdGhlIFhNTCAoYWZ0ZXIgZXhwYW5zaW9uIG9mIGVudGl0aWVzKS4gVGhlIGF0dHJpYnV0ZVxuICogPiBub2RlcyBvZiBhbiBlbGVtZW50IG9jY3VyIGFmdGVyIHRoZSBlbGVtZW50IGFuZCBiZWZvcmUgaXRzIGNoaWxkcmVuLiBUaGVcbiAqID4gcmVsYXRpdmUgb3JkZXIgb2YgYXR0cmlidXRlIG5vZGVzIGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudC4vXG4gKlxuICogU291cmNlOlxuICogaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtQ29yZS9nbG9zc2FyeS5odG1sI2R0LWRvY3VtZW50LW9yZGVyXG4gKiBAYXJndW1lbnQgbm9kYUEgVGhlIGZpcnN0IG5vZGUgdG8gdXNlIGluIHRoZSBjb21wYXJpc29uXG4gKiBAYXJndW1lbnQgbm9kZUIgVGhlIHNlY29uZCBub2RlIHRvIHVzZSBpbiB0aGUgY29tcGFyaXNvblxuICpcbiAqIEByZXR1cm4gQSBiaXRtYXNrIGRlc2NyaWJpbmcgdGhlIGlucHV0IG5vZGVzJyByZWxhdGl2ZSBwb3NpdGlvbi5cbiAqXG4gKiAgICAgICAgU2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tbm9kZS1jb21wYXJlZG9jdW1lbnRwb3NpdGlvbiBmb3JcbiAqICAgICAgICBhIGRlc2NyaXB0aW9uIG9mIHRoZXNlIHZhbHVlcy5cbiAqL2Z1bmN0aW9uIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGVBLG5vZGVCKXt2YXIgYVBhcmVudHM9W107dmFyIGJQYXJlbnRzPVtdO2lmKG5vZGVBPT09bm9kZUIpe3JldHVybiAwO312YXIgY3VycmVudD10YWd0eXBlc18xLmhhc0NoaWxkcmVuKG5vZGVBKT9ub2RlQTpub2RlQS5wYXJlbnQ7d2hpbGUoY3VycmVudCl7YVBhcmVudHMudW5zaGlmdChjdXJyZW50KTtjdXJyZW50PWN1cnJlbnQucGFyZW50O31jdXJyZW50PXRhZ3R5cGVzXzEuaGFzQ2hpbGRyZW4obm9kZUIpP25vZGVCOm5vZGVCLnBhcmVudDt3aGlsZShjdXJyZW50KXtiUGFyZW50cy51bnNoaWZ0KGN1cnJlbnQpO2N1cnJlbnQ9Y3VycmVudC5wYXJlbnQ7fXZhciBpZHg9MDt3aGlsZShhUGFyZW50c1tpZHhdPT09YlBhcmVudHNbaWR4XSl7aWR4Kys7fWlmKGlkeD09PTApe3JldHVybiAxLyogRElTQ09OTkVDVEVEICovO312YXIgc2hhcmVkUGFyZW50PWFQYXJlbnRzW2lkeC0xXTt2YXIgc2libGluZ3M9c2hhcmVkUGFyZW50LmNoaWxkcmVuO3ZhciBhU2libGluZz1hUGFyZW50c1tpZHhdO3ZhciBiU2libGluZz1iUGFyZW50c1tpZHhdO2lmKHNpYmxpbmdzLmluZGV4T2YoYVNpYmxpbmcpPnNpYmxpbmdzLmluZGV4T2YoYlNpYmxpbmcpKXtpZihzaGFyZWRQYXJlbnQ9PT1ub2RlQil7cmV0dXJuIDQvKiBGT0xMT1dJTkcgKi98MTYvKiBDT05UQUlORURfQlkgKi87fXJldHVybiA0LyogRk9MTE9XSU5HICovO31lbHNle2lmKHNoYXJlZFBhcmVudD09PW5vZGVBKXtyZXR1cm4gMi8qIFBSRUNFRElORyAqL3w4LyogQ09OVEFJTlMgKi87fXJldHVybiAyLyogUFJFQ0VESU5HICovO319ZXhwb3J0cy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj1jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjsvKioqXG4gKiBTb3J0IGFuIGFycmF5IG9mIG5vZGVzIGJhc2VkIG9uIHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBhbmRcbiAqIHJlbW92ZSBhbnkgZHVwbGljYXRlIG5vZGVzLiBJZiB0aGUgYXJyYXkgY29udGFpbnMgbm9kZXMgdGhhdCBkbyBub3QgYmVsb25nXG4gKiB0byB0aGUgc2FtZSBkb2N1bWVudCwgc29ydCBvcmRlciBpcyB1bnNwZWNpZmllZC5cbiAqXG4gKiBAYXJndW1lbnQgbm9kZXMgQXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcmV0dXJucyBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBub2Rlcywgc29ydGVkIGluIGRvY3VtZW50IG9yZGVyXG4gKi9mdW5jdGlvbiB1bmlxdWVTb3J0KG5vZGVzKXtub2Rlcz1ub2Rlcy5maWx0ZXIoZnVuY3Rpb24obm9kZSxpLGFycil7cmV0dXJuIWFyci5pbmNsdWRlcyhub2RlLGkrMSk7fSk7bm9kZXMuc29ydChmdW5jdGlvbihhLGIpe3ZhciByZWxhdGl2ZT1jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhLGIpO2lmKHJlbGF0aXZlJjIvKiBQUkVDRURJTkcgKi8pe3JldHVybi0xO31lbHNlIGlmKHJlbGF0aXZlJjQvKiBGT0xMT1dJTkcgKi8pe3JldHVybiAxO31yZXR1cm4gMDt9KTtyZXR1cm4gbm9kZXM7fWV4cG9ydHMudW5pcXVlU29ydD11bmlxdWVTb3J0O30se1wiLi90YWd0eXBlc1wiOjE1fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9fZXhwb3J0KG0pe2Zvcih2YXIgcCBpbiBtKXtpZighZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSlleHBvcnRzW3BdPW1bcF07fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO19fZXhwb3J0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeVwiKSk7X19leHBvcnQocmVxdWlyZShcIi4vdHJhdmVyc2FsXCIpKTtfX2V4cG9ydChyZXF1aXJlKFwiLi9tYW5pcHVsYXRpb25cIikpO19fZXhwb3J0KHJlcXVpcmUoXCIuL3F1ZXJ5aW5nXCIpKTtfX2V4cG9ydChyZXF1aXJlKFwiLi9sZWdhY3lcIikpO19fZXhwb3J0KHJlcXVpcmUoXCIuL2hlbHBlcnNcIikpO19fZXhwb3J0KHJlcXVpcmUoXCIuL3RhZ3R5cGVzXCIpKTt9LHtcIi4vaGVscGVyc1wiOjksXCIuL2xlZ2FjeVwiOjExLFwiLi9tYW5pcHVsYXRpb25cIjoxMixcIi4vcXVlcnlpbmdcIjoxMyxcIi4vc3RyaW5naWZ5XCI6MTQsXCIuL3RhZ3R5cGVzXCI6MTUsXCIuL3RyYXZlcnNhbFwiOjE2fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIHF1ZXJ5aW5nXzE9cmVxdWlyZShcIi4vcXVlcnlpbmdcIik7dmFyIHRhZ3R5cGVzXzE9cmVxdWlyZShcIi4vdGFndHlwZXNcIik7ZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKXtyZXR1cm4gbm9kZS50eXBlPT09XCJ0ZXh0XCIvKiBUZXh0ICovO30vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlICovdmFyIENoZWNrcz17dGFnX25hbWU6ZnVuY3Rpb24gdGFnX25hbWUobmFtZSl7aWYodHlwZW9mIG5hbWU9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBmdW5jdGlvbihlbGVtKXtyZXR1cm4gdGFndHlwZXNfMS5pc1RhZyhlbGVtKSYmbmFtZShlbGVtLm5hbWUpO307fWVsc2UgaWYobmFtZT09PVwiKlwiKXtyZXR1cm4gdGFndHlwZXNfMS5pc1RhZzt9ZWxzZXtyZXR1cm4gZnVuY3Rpb24oZWxlbSl7cmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoZWxlbSkmJmVsZW0ubmFtZT09PW5hbWU7fTt9fSx0YWdfdHlwZTpmdW5jdGlvbiB0YWdfdHlwZSh0eXBlKXtpZih0eXBlb2YgdHlwZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe3JldHVybiB0eXBlKGVsZW0udHlwZSk7fTt9ZWxzZXtyZXR1cm4gZnVuY3Rpb24oZWxlbSl7cmV0dXJuIGVsZW0udHlwZT09PXR5cGU7fTt9fSx0YWdfY29udGFpbnM6ZnVuY3Rpb24gdGFnX2NvbnRhaW5zKGRhdGEpe2lmKHR5cGVvZiBkYXRhPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZnVuY3Rpb24oZWxlbSl7cmV0dXJuIGlzVGV4dE5vZGUoZWxlbSkmJmRhdGEoZWxlbS5kYXRhKTt9O31lbHNle3JldHVybiBmdW5jdGlvbihlbGVtKXtyZXR1cm4gaXNUZXh0Tm9kZShlbGVtKSYmZWxlbS5kYXRhPT09ZGF0YTt9O319fTsvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jYW1lbGNhc2UgKi9mdW5jdGlvbiBnZXRBdHRyaWJDaGVjayhhdHRyaWIsdmFsdWUpe2lmKHR5cGVvZiB2YWx1ZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe3JldHVybiB0YWd0eXBlc18xLmlzVGFnKGVsZW0pJiZ2YWx1ZShlbGVtLmF0dHJpYnNbYXR0cmliXSk7fTt9ZWxzZXtyZXR1cm4gZnVuY3Rpb24oZWxlbSl7cmV0dXJuIHRhZ3R5cGVzXzEuaXNUYWcoZWxlbSkmJmVsZW0uYXR0cmlic1thdHRyaWJdPT09dmFsdWU7fTt9fWZ1bmN0aW9uIGNvbWJpbmVGdW5jcyhhLGIpe3JldHVybiBmdW5jdGlvbihlbGVtKXtyZXR1cm4gYShlbGVtKXx8YihlbGVtKTt9O31mdW5jdGlvbiBjb21waWxlVGVzdChvcHRpb25zKXt2YXIgZnVuY3M9T2JqZWN0LmtleXMob3B0aW9ucykubWFwKGZ1bmN0aW9uKGtleSl7dmFyIHZhbHVlPW9wdGlvbnNba2V5XTsvLyBAdHMtaWdub3JlXG5yZXR1cm4ga2V5IGluIENoZWNrcz9DaGVja3Nba2V5XSh2YWx1ZSk6Z2V0QXR0cmliQ2hlY2soa2V5LHZhbHVlKTt9KTtyZXR1cm4gZnVuY3MubGVuZ3RoPT09MD9udWxsOmZ1bmNzLnJlZHVjZShjb21iaW5lRnVuY3MpO31mdW5jdGlvbiB0ZXN0RWxlbWVudChvcHRpb25zLGVsZW1lbnQpe3ZhciB0ZXN0PWNvbXBpbGVUZXN0KG9wdGlvbnMpO3JldHVybiB0ZXN0P3Rlc3QoZWxlbWVudCk6dHJ1ZTt9ZXhwb3J0cy50ZXN0RWxlbWVudD10ZXN0RWxlbWVudDtmdW5jdGlvbiBnZXRFbGVtZW50cyhvcHRpb25zLGVsZW1lbnQscmVjdXJzZSxsaW1pdCl7aWYobGltaXQ9PT12b2lkIDApe2xpbWl0PUluZmluaXR5O312YXIgdGVzdD1jb21waWxlVGVzdChvcHRpb25zKTtyZXR1cm4gdGVzdD9xdWVyeWluZ18xLmZpbHRlcih0ZXN0LGVsZW1lbnQscmVjdXJzZSxsaW1pdCk6W107fWV4cG9ydHMuZ2V0RWxlbWVudHM9Z2V0RWxlbWVudHM7ZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQsZWxlbWVudCxyZWN1cnNlKXtpZihyZWN1cnNlPT09dm9pZCAwKXtyZWN1cnNlPXRydWU7fWlmKCFBcnJheS5pc0FycmF5KGVsZW1lbnQpKWVsZW1lbnQ9W2VsZW1lbnRdO3JldHVybiBxdWVyeWluZ18xLmZpbmRPbmUoZ2V0QXR0cmliQ2hlY2soXCJpZFwiLGlkKSxlbGVtZW50LHJlY3Vyc2UpO31leHBvcnRzLmdldEVsZW1lbnRCeUlkPWdldEVsZW1lbnRCeUlkO2Z1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUsZWxlbWVudCxyZWN1cnNlLGxpbWl0KXtpZihsaW1pdD09PXZvaWQgMCl7bGltaXQ9SW5maW5pdHk7fXJldHVybiBxdWVyeWluZ18xLmZpbHRlcihDaGVja3MudGFnX25hbWUobmFtZSksZWxlbWVudCxyZWN1cnNlLGxpbWl0KTt9ZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnTmFtZT1nZXRFbGVtZW50c0J5VGFnTmFtZTtmdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnVHlwZSh0eXBlLGVsZW1lbnQscmVjdXJzZSxsaW1pdCl7aWYocmVjdXJzZT09PXZvaWQgMCl7cmVjdXJzZT10cnVlO31pZihsaW1pdD09PXZvaWQgMCl7bGltaXQ9SW5maW5pdHk7fXJldHVybiBxdWVyeWluZ18xLmZpbHRlcihDaGVja3MudGFnX3R5cGUodHlwZSksZWxlbWVudCxyZWN1cnNlLGxpbWl0KTt9ZXhwb3J0cy5nZXRFbGVtZW50c0J5VGFnVHlwZT1nZXRFbGVtZW50c0J5VGFnVHlwZTt9LHtcIi4vcXVlcnlpbmdcIjoxMyxcIi4vdGFndHlwZXNcIjoxNX1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pOy8qKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIGRvbVxuICpcbiAqIEBhcmd1bWVudCBlbGVtIFRoZSBlbGVtZW50IHRvIGJlIHJlbW92ZWRcbiAqL2Z1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWxlbSl7aWYoZWxlbS5wcmV2KWVsZW0ucHJldi5uZXh0PWVsZW0ubmV4dDtpZihlbGVtLm5leHQpZWxlbS5uZXh0LnByZXY9ZWxlbS5wcmV2O2lmKGVsZW0ucGFyZW50KXt2YXIgY2hpbGRzPWVsZW0ucGFyZW50LmNoaWxkcmVuO2NoaWxkcy5zcGxpY2UoY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pLDEpO319ZXhwb3J0cy5yZW1vdmVFbGVtZW50PXJlbW92ZUVsZW1lbnQ7LyoqKlxuICogUmVwbGFjZSBhbiBlbGVtZW50IGluIHRoZSBkb21cbiAqXG4gKiBAYXJndW1lbnQgZWxlbSBUaGUgZWxlbWVudCB0byBiZSByZXBsYWNlZFxuICogQGFyZ3VtZW50IHJlcGxhY2VtZW50IFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkXG4gKi9mdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtLHJlcGxhY2VtZW50KXt2YXIgcHJldj1yZXBsYWNlbWVudC5wcmV2PWVsZW0ucHJldjtpZihwcmV2KXtwcmV2Lm5leHQ9cmVwbGFjZW1lbnQ7fXZhciBuZXh0PXJlcGxhY2VtZW50Lm5leHQ9ZWxlbS5uZXh0O2lmKG5leHQpe25leHQucHJldj1yZXBsYWNlbWVudDt9dmFyIHBhcmVudD1yZXBsYWNlbWVudC5wYXJlbnQ9ZWxlbS5wYXJlbnQ7aWYocGFyZW50KXt2YXIgY2hpbGRzPXBhcmVudC5jaGlsZHJlbjtjaGlsZHNbY2hpbGRzLmxhc3RJbmRleE9mKGVsZW0pXT1yZXBsYWNlbWVudDt9fWV4cG9ydHMucmVwbGFjZUVsZW1lbnQ9cmVwbGFjZUVsZW1lbnQ7LyoqKlxuICogQXBwZW5kIGEgY2hpbGQgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBhcmd1bWVudCBlbGVtIFRoZSBlbGVtZW50IHRvIGFwcGVuZCB0b1xuICogQGFyZ3VtZW50IGNoaWxkIFRoZSBlbGVtZW50IHRvIGJlIGFkZGVkIGFzIGEgY2hpbGRcbiAqL2Z1bmN0aW9uIGFwcGVuZENoaWxkKGVsZW0sY2hpbGQpe2NoaWxkLnBhcmVudD1lbGVtO2lmKGVsZW0uY2hpbGRyZW4ucHVzaChjaGlsZCkhPT0xKXt2YXIgc2libGluZz1lbGVtLmNoaWxkcmVuW2VsZW0uY2hpbGRyZW4ubGVuZ3RoLTJdO3NpYmxpbmcubmV4dD1jaGlsZDtjaGlsZC5wcmV2PXNpYmxpbmc7Y2hpbGQubmV4dD1udWxsO319ZXhwb3J0cy5hcHBlbmRDaGlsZD1hcHBlbmRDaGlsZDsvKioqXG4gKiBBcHBlbmQgYW4gZWxlbWVudCBhZnRlciBhbm90aGVyXG4gKlxuICogQGFyZ3VtZW50IGVsZW0gVGhlIGVsZW1lbnQgdG8gYXBwZW5kIHRvXG4gKiBAYXJndW1lbnQgbmV4dCBUaGUgZWxlbWVudCBiZSBhZGRlZFxuICovZnVuY3Rpb24gYXBwZW5kKGVsZW0sbmV4dCl7dmFyIHBhcmVudD1lbGVtLnBhcmVudCxjdXJyTmV4dD1lbGVtLm5leHQ7bmV4dC5uZXh0PWN1cnJOZXh0O25leHQucHJldj1lbGVtO2VsZW0ubmV4dD1uZXh0O25leHQucGFyZW50PXBhcmVudDtpZihjdXJyTmV4dCl7Y3Vyck5leHQucHJldj1uZXh0O2lmKHBhcmVudCl7dmFyIGNoaWxkcz1wYXJlbnQuY2hpbGRyZW47Y2hpbGRzLnNwbGljZShjaGlsZHMubGFzdEluZGV4T2YoY3Vyck5leHQpLDAsbmV4dCk7fX1lbHNlIGlmKHBhcmVudCl7cGFyZW50LmNoaWxkcmVuLnB1c2gobmV4dCk7fX1leHBvcnRzLmFwcGVuZD1hcHBlbmQ7LyoqKlxuICogUHJlcGVuZCBhbiBlbGVtZW50IGJlZm9yZSBhbm90aGVyXG4gKlxuICogQGFyZ3VtZW50IGVsZW0gVGhlIGVsZW1lbnQgdG8gYXBwZW5kIHRvXG4gKiBAYXJndW1lbnQgcHJldiBUaGUgZWxlbWVudCBiZSBhZGRlZFxuICovZnVuY3Rpb24gcHJlcGVuZChlbGVtLHByZXYpe3ZhciBwYXJlbnQ9ZWxlbS5wYXJlbnQ7aWYocGFyZW50KXt2YXIgY2hpbGRzPXBhcmVudC5jaGlsZHJlbjtjaGlsZHMuc3BsaWNlKGNoaWxkcy5sYXN0SW5kZXhPZihlbGVtKSwwLHByZXYpO31pZihlbGVtLnByZXYpe2VsZW0ucHJldi5uZXh0PXByZXY7fXByZXYucGFyZW50PXBhcmVudDtwcmV2LnByZXY9ZWxlbS5wcmV2O3ByZXYubmV4dD1lbGVtO2VsZW0ucHJldj1wcmV2O31leHBvcnRzLnByZXBlbmQ9cHJlcGVuZDt9LHt9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgdGFndHlwZXNfMT1yZXF1aXJlKFwiLi90YWd0eXBlc1wiKTtmdW5jdGlvbiBmaWx0ZXIodGVzdCxlbGVtZW50LHJlY3Vyc2UsbGltaXQpe2lmKHJlY3Vyc2U9PT12b2lkIDApe3JlY3Vyc2U9dHJ1ZTt9aWYobGltaXQ9PT12b2lkIDApe2xpbWl0PUluZmluaXR5O31pZighQXJyYXkuaXNBcnJheShlbGVtZW50KSllbGVtZW50PVtlbGVtZW50XTtyZXR1cm4gZmluZCh0ZXN0LGVsZW1lbnQscmVjdXJzZSxsaW1pdCk7fWV4cG9ydHMuZmlsdGVyPWZpbHRlcjtmdW5jdGlvbiBmaW5kKHRlc3QsZWxlbXMscmVjdXJzZSxsaW1pdCl7dmFyIHJlc3VsdD1bXTtmb3IodmFyIGk9MDtpPGVsZW1zLmxlbmd0aDtpKyspe3ZhciBlbGVtPWVsZW1zW2ldO2lmKHRlc3QoZWxlbSkpe3Jlc3VsdC5wdXNoKGVsZW0pO2lmKC0tbGltaXQ8PTApYnJlYWs7fWlmKHJlY3Vyc2UmJnRhZ3R5cGVzXzEuaGFzQ2hpbGRyZW4oZWxlbSkmJmVsZW0uY2hpbGRyZW4ubGVuZ3RoPjApe3ZhciBjaGlsZHJlbj1maW5kKHRlc3QsZWxlbS5jaGlsZHJlbixyZWN1cnNlLGxpbWl0KTtyZXN1bHQ9cmVzdWx0LmNvbmNhdChjaGlsZHJlbik7bGltaXQtPWNoaWxkcmVuLmxlbmd0aDtpZihsaW1pdDw9MClicmVhazt9fXJldHVybiByZXN1bHQ7fWV4cG9ydHMuZmluZD1maW5kO2Z1bmN0aW9uIGZpbmRPbmVDaGlsZCh0ZXN0LGVsZW1zKXtmb3IodmFyIGk9MDtpPGVsZW1zLmxlbmd0aDtpKyspe2lmKHRlc3QoZWxlbXNbaV0pKXJldHVybiBlbGVtc1tpXTt9cmV0dXJuIG51bGw7fWV4cG9ydHMuZmluZE9uZUNoaWxkPWZpbmRPbmVDaGlsZDtmdW5jdGlvbiBmaW5kT25lKHRlc3QsZWxlbXMscmVjdXJzZSl7aWYocmVjdXJzZT09PXZvaWQgMCl7cmVjdXJzZT10cnVlO312YXIgZWxlbT1udWxsO2Zvcih2YXIgaT0wO2k8ZWxlbXMubGVuZ3RoJiYhZWxlbTtpKyspe3ZhciBjaGVja2VkPWVsZW1zW2ldO2lmKCF0YWd0eXBlc18xLmlzVGFnKGNoZWNrZWQpKXtjb250aW51ZTt9ZWxzZSBpZih0ZXN0KGNoZWNrZWQpKXtlbGVtPWNoZWNrZWQ7fWVsc2UgaWYocmVjdXJzZSYmY2hlY2tlZC5jaGlsZHJlbi5sZW5ndGg+MCl7ZWxlbT1maW5kT25lKHRlc3QsY2hlY2tlZC5jaGlsZHJlbik7fX1yZXR1cm4gZWxlbTt9ZXhwb3J0cy5maW5kT25lPWZpbmRPbmU7ZnVuY3Rpb24gZXhpc3RzT25lKHRlc3QsZWxlbXMpe2Zvcih2YXIgaT0wO2k8ZWxlbXMubGVuZ3RoO2krKyl7dmFyIGNoZWNrZWQ9ZWxlbXNbaV07aWYodGFndHlwZXNfMS5pc1RhZyhjaGVja2VkKSYmKHRlc3QoY2hlY2tlZCl8fGNoZWNrZWQuY2hpbGRyZW4ubGVuZ3RoPjAmJmV4aXN0c09uZSh0ZXN0LGNoZWNrZWQuY2hpbGRyZW4pKSl7cmV0dXJuIHRydWU7fX1yZXR1cm4gZmFsc2U7fWV4cG9ydHMuZXhpc3RzT25lPWV4aXN0c09uZTtmdW5jdGlvbiBmaW5kQWxsKHRlc3Qscm9vdEVsZW1zKXt2YXIgcmVzdWx0PVtdO3ZhciBzdGFjaz1yb290RWxlbXMuc2xpY2UoKTt3aGlsZShzdGFjay5sZW5ndGgpe3ZhciBlbGVtPXN0YWNrLnNoaWZ0KCk7aWYoIWVsZW18fCF0YWd0eXBlc18xLmlzVGFnKGVsZW0pKWNvbnRpbnVlO2lmKGVsZW0uY2hpbGRyZW4mJmVsZW0uY2hpbGRyZW4ubGVuZ3RoPjApe3N0YWNrLnVuc2hpZnQuYXBwbHkoc3RhY2ssZWxlbS5jaGlsZHJlbik7fWlmKHRlc3QoZWxlbSkpcmVzdWx0LnB1c2goZWxlbSk7fXJldHVybiByZXN1bHQ7fWV4cG9ydHMuZmluZEFsbD1maW5kQWxsO30se1wiLi90YWd0eXBlc1wiOjE1fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOntcImRlZmF1bHRcIjptb2R9O307T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgdGFndHlwZXNfMT1yZXF1aXJlKFwiLi90YWd0eXBlc1wiKTt2YXIgZG9tX3NlcmlhbGl6ZXJfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRvbS1zZXJpYWxpemVyXCIpKTtleHBvcnRzLmdldE91dGVySFRNTD1kb21fc2VyaWFsaXplcl8xW1wiZGVmYXVsdFwiXTtmdW5jdGlvbiBnZXRJbm5lckhUTUwobm9kZSxvcHRpb25zKXtyZXR1cm4gdGFndHlwZXNfMS5oYXNDaGlsZHJlbihub2RlKT9ub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihub2RlKXtyZXR1cm4gZXhwb3J0cy5nZXRPdXRlckhUTUwobm9kZSxvcHRpb25zKTt9KS5qb2luKFwiXCIpOlwiXCI7fWV4cG9ydHMuZ2V0SW5uZXJIVE1MPWdldElubmVySFRNTDtmdW5jdGlvbiBnZXRUZXh0KG5vZGUpe2lmKEFycmF5LmlzQXJyYXkobm9kZSkpcmV0dXJuIG5vZGUubWFwKGdldFRleHQpLmpvaW4oXCJcIik7aWYodGFndHlwZXNfMS5pc1RhZyhub2RlKSlyZXR1cm4gbm9kZS5uYW1lPT09XCJiclwiP1wiXFxuXCI6Z2V0VGV4dChub2RlLmNoaWxkcmVuKTtpZih0YWd0eXBlc18xLmlzQ0RBVEEobm9kZSkpcmV0dXJuIGdldFRleHQobm9kZS5jaGlsZHJlbik7aWYodGFndHlwZXNfMS5pc1RleHQobm9kZSkpcmV0dXJuIG5vZGUuZGF0YTtyZXR1cm5cIlwiO31leHBvcnRzLmdldFRleHQ9Z2V0VGV4dDt9LHtcIi4vdGFndHlwZXNcIjoxNSxcImRvbS1zZXJpYWxpemVyXCI6NX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBkb21lbGVtZW50dHlwZV8xPXJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKTtmdW5jdGlvbiBpc1RhZyhub2RlKXtyZXR1cm4gZG9tZWxlbWVudHR5cGVfMS5pc1RhZyhub2RlKTt9ZXhwb3J0cy5pc1RhZz1pc1RhZztmdW5jdGlvbiBpc0NEQVRBKG5vZGUpe3JldHVyblwiY2RhdGFcIi8qIENEQVRBICovPT09bm9kZS50eXBlO31leHBvcnRzLmlzQ0RBVEE9aXNDREFUQTtmdW5jdGlvbiBpc1RleHQobm9kZSl7cmV0dXJuIG5vZGUudHlwZT09PVwidGV4dFwiLyogVGV4dCAqLzt9ZXhwb3J0cy5pc1RleHQ9aXNUZXh0O2Z1bmN0aW9uIGlzQ29tbWVudChub2RlKXtyZXR1cm4gbm9kZS50eXBlPT09XCJjb21tZW50XCIvKiBDb21tZW50ICovO31leHBvcnRzLmlzQ29tbWVudD1pc0NvbW1lbnQ7ZnVuY3Rpb24gaGFzQ2hpbGRyZW4obm9kZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLFwiY2hpbGRyZW5cIik7fWV4cG9ydHMuaGFzQ2hpbGRyZW49aGFzQ2hpbGRyZW47fSx7XCJkb21lbGVtZW50dHlwZVwiOjZ9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtmdW5jdGlvbiBnZXRDaGlsZHJlbihlbGVtKXsvLyBAdHMtaWdub3JlXG5yZXR1cm4gZWxlbS5jaGlsZHJlbnx8bnVsbDt9ZXhwb3J0cy5nZXRDaGlsZHJlbj1nZXRDaGlsZHJlbjtmdW5jdGlvbiBnZXRQYXJlbnQoZWxlbSl7cmV0dXJuIGVsZW0ucGFyZW50fHxudWxsO31leHBvcnRzLmdldFBhcmVudD1nZXRQYXJlbnQ7ZnVuY3Rpb24gZ2V0U2libGluZ3MoZWxlbSl7dmFyIHBhcmVudD1nZXRQYXJlbnQoZWxlbSk7cmV0dXJuIHBhcmVudD9nZXRDaGlsZHJlbihwYXJlbnQpOltlbGVtXTt9ZXhwb3J0cy5nZXRTaWJsaW5ncz1nZXRTaWJsaW5ncztmdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShlbGVtLG5hbWUpe3JldHVybiBlbGVtLmF0dHJpYnMmJmVsZW0uYXR0cmlic1tuYW1lXTt9ZXhwb3J0cy5nZXRBdHRyaWJ1dGVWYWx1ZT1nZXRBdHRyaWJ1dGVWYWx1ZTtmdW5jdGlvbiBoYXNBdHRyaWIoZWxlbSxuYW1lKXtyZXR1cm4hIWdldEF0dHJpYnV0ZVZhbHVlKGVsZW0sbmFtZSk7fWV4cG9ydHMuaGFzQXR0cmliPWhhc0F0dHJpYjsvKioqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIHByb3BlcnR5IG9mIGFuIGVsZW1lbnRcbiAqXG4gKiBAYXJndW1lbnQgZWxlbSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIG5hbWUgZm9yXG4gKi9mdW5jdGlvbiBnZXROYW1lKGVsZW0pe3JldHVybiBlbGVtLm5hbWU7fWV4cG9ydHMuZ2V0TmFtZT1nZXROYW1lO30se31dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgX19pbXBvcnREZWZhdWx0PXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihtb2Qpe3JldHVybiBtb2QmJm1vZC5fX2VzTW9kdWxlP21vZDp7XCJkZWZhdWx0XCI6bW9kfTt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIGVudGl0aWVzX2pzb25fMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy9lbnRpdGllcy5qc29uXCIpKTt2YXIgbGVnYWN5X2pzb25fMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFwcy9sZWdhY3kuanNvblwiKSk7dmFyIHhtbF9qc29uXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hcHMveG1sLmpzb25cIikpO3ZhciBkZWNvZGVfY29kZXBvaW50XzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2RlY29kZV9jb2RlcG9pbnRcIikpO2V4cG9ydHMuZGVjb2RlWE1MPWdldFN0cmljdERlY29kZXIoeG1sX2pzb25fMVtcImRlZmF1bHRcIl0pO2V4cG9ydHMuZGVjb2RlSFRNTFN0cmljdD1nZXRTdHJpY3REZWNvZGVyKGVudGl0aWVzX2pzb25fMVtcImRlZmF1bHRcIl0pO2Z1bmN0aW9uIGdldFN0cmljdERlY29kZXIobWFwKXt2YXIga2V5cz1PYmplY3Qua2V5cyhtYXApLmpvaW4oXCJ8XCIpO3ZhciByZXBsYWNlPWdldFJlcGxhY2VyKG1hcCk7a2V5cys9XCJ8I1t4WF1bXFxcXGRhLWZBLUZdK3wjXFxcXGQrXCI7dmFyIHJlPW5ldyBSZWdFeHAoXCImKD86XCIra2V5cytcIik7XCIsXCJnXCIpO3JldHVybiBmdW5jdGlvbihzdHIpe3JldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLHJlcGxhY2UpO307fXZhciBzb3J0ZXI9ZnVuY3Rpb24gc29ydGVyKGEsYil7cmV0dXJuIGE8Yj8xOi0xO307ZXhwb3J0cy5kZWNvZGVIVE1MPWZ1bmN0aW9uKCl7dmFyIGxlZ2FjeT1PYmplY3Qua2V5cyhsZWdhY3lfanNvbl8xW1wiZGVmYXVsdFwiXSkuc29ydChzb3J0ZXIpO3ZhciBrZXlzPU9iamVjdC5rZXlzKGVudGl0aWVzX2pzb25fMVtcImRlZmF1bHRcIl0pLnNvcnQoc29ydGVyKTtmb3IodmFyIGk9MCxqPTA7aTxrZXlzLmxlbmd0aDtpKyspe2lmKGxlZ2FjeVtqXT09PWtleXNbaV0pe2tleXNbaV0rPVwiOz9cIjtqKys7fWVsc2V7a2V5c1tpXSs9XCI7XCI7fX12YXIgcmU9bmV3IFJlZ0V4cChcIiYoPzpcIitrZXlzLmpvaW4oXCJ8XCIpK1wifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsXCJnXCIpO3ZhciByZXBsYWNlPWdldFJlcGxhY2VyKGVudGl0aWVzX2pzb25fMVtcImRlZmF1bHRcIl0pO2Z1bmN0aW9uIHJlcGxhY2VyKHN0cil7aWYoc3RyLnN1YnN0cigtMSkhPT1cIjtcIilzdHIrPVwiO1wiO3JldHVybiByZXBsYWNlKHN0cik7fS8vVE9ETyBjb25zaWRlciBjcmVhdGluZyBhIG1lcmdlZCBtYXBcbnJldHVybiBmdW5jdGlvbihzdHIpe3JldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLHJlcGxhY2VyKTt9O30oKTtmdW5jdGlvbiBnZXRSZXBsYWNlcihtYXApe3JldHVybiBmdW5jdGlvbiByZXBsYWNlKHN0cil7aWYoc3RyLmNoYXJBdCgxKT09PVwiI1wiKXtpZihzdHIuY2hhckF0KDIpPT09XCJYXCJ8fHN0ci5jaGFyQXQoMik9PT1cInhcIil7cmV0dXJuIGRlY29kZV9jb2RlcG9pbnRfMVtcImRlZmF1bHRcIl0ocGFyc2VJbnQoc3RyLnN1YnN0cigzKSwxNikpO31yZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xW1wiZGVmYXVsdFwiXShwYXJzZUludChzdHIuc3Vic3RyKDIpLDEwKSk7fXJldHVybiBtYXBbc3RyLnNsaWNlKDEsLTEpXTt9O319LHtcIi4vZGVjb2RlX2NvZGVwb2ludFwiOjE4LFwiLi9tYXBzL2VudGl0aWVzLmpzb25cIjoyMixcIi4vbWFwcy9sZWdhY3kuanNvblwiOjIzLFwiLi9tYXBzL3htbC5qc29uXCI6MjR9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIF9faW1wb3J0RGVmYXVsdD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24obW9kKXtyZXR1cm4gbW9kJiZtb2QuX19lc01vZHVsZT9tb2Q6e1wiZGVmYXVsdFwiOm1vZH07fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBkZWNvZGVfanNvbl8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2RlY29kZS5qc29uXCIpKTsvLyBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL2hlL2Jsb2IvbWFzdGVyL3NyYy9oZS5qcyNMOTQtTDExOVxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50KGNvZGVQb2ludCl7aWYoY29kZVBvaW50Pj0weGQ4MDAmJmNvZGVQb2ludDw9MHhkZmZmfHxjb2RlUG9pbnQ+MHgxMGZmZmYpe3JldHVyblwiXFx1RkZGRFwiO31pZihjb2RlUG9pbnQgaW4gZGVjb2RlX2pzb25fMVtcImRlZmF1bHRcIl0pey8vIEB0cy1pZ25vcmVcbmNvZGVQb2ludD1kZWNvZGVfanNvbl8xW1wiZGVmYXVsdFwiXVtjb2RlUG9pbnRdO312YXIgb3V0cHV0PVwiXCI7aWYoY29kZVBvaW50PjB4ZmZmZil7Y29kZVBvaW50LT0weDEwMDAwO291dHB1dCs9U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQ+Pj4xMCYweDNmZnwweGQ4MDApO2NvZGVQb2ludD0weGRjMDB8Y29kZVBvaW50JjB4M2ZmO31vdXRwdXQrPVN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtyZXR1cm4gb3V0cHV0O31leHBvcnRzW1wiZGVmYXVsdFwiXT1kZWNvZGVDb2RlUG9pbnQ7fSx7XCIuL21hcHMvZGVjb2RlLmpzb25cIjoyMX1dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgX19pbXBvcnREZWZhdWx0PXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihtb2Qpe3JldHVybiBtb2QmJm1vZC5fX2VzTW9kdWxlP21vZDp7XCJkZWZhdWx0XCI6bW9kfTt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIHhtbF9qc29uXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21hcHMveG1sLmpzb25cIikpO3ZhciBpbnZlcnNlWE1MPWdldEludmVyc2VPYmooeG1sX2pzb25fMVtcImRlZmF1bHRcIl0pO3ZhciB4bWxSZXBsYWNlcj1nZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZVhNTCk7ZXhwb3J0cy5lbmNvZGVYTUw9Z2V0SW52ZXJzZShpbnZlcnNlWE1MLHhtbFJlcGxhY2VyKTt2YXIgZW50aXRpZXNfanNvbl8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9tYXBzL2VudGl0aWVzLmpzb25cIikpO3ZhciBpbnZlcnNlSFRNTD1nZXRJbnZlcnNlT2JqKGVudGl0aWVzX2pzb25fMVtcImRlZmF1bHRcIl0pO3ZhciBodG1sUmVwbGFjZXI9Z2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VIVE1MKTtleHBvcnRzLmVuY29kZUhUTUw9Z2V0SW52ZXJzZShpbnZlcnNlSFRNTCxodG1sUmVwbGFjZXIpO2Z1bmN0aW9uIGdldEludmVyc2VPYmoob2JqKXtyZXR1cm4gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uKGludmVyc2UsbmFtZSl7aW52ZXJzZVtvYmpbbmFtZV1dPVwiJlwiK25hbWUrXCI7XCI7cmV0dXJuIGludmVyc2U7fSx7fSk7fWZ1bmN0aW9uIGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlKXt2YXIgc2luZ2xlPVtdO3ZhciBtdWx0aXBsZT1bXTtPYmplY3Qua2V5cyhpbnZlcnNlKS5mb3JFYWNoKGZ1bmN0aW9uKGspe3JldHVybiBrLmxlbmd0aD09PTE/Ly8gQWRkIHZhbHVlIHRvIHNpbmdsZSBhcnJheVxuc2luZ2xlLnB1c2goXCJcXFxcXCIrayk6Ly8gQWRkIHZhbHVlIHRvIG11bHRpcGxlIGFycmF5XG5tdWx0aXBsZS5wdXNoKGspO30pOy8vVE9ETyBhZGQgcmFuZ2VzXG5tdWx0aXBsZS51bnNoaWZ0KFwiW1wiK3NpbmdsZS5qb2luKFwiXCIpK1wiXVwiKTtyZXR1cm4gbmV3IFJlZ0V4cChtdWx0aXBsZS5qb2luKFwifFwiKSxcImdcIik7fXZhciByZU5vbkFTQ0lJPS9bXlxcMC1cXHg3Rl0vZzt2YXIgcmVBc3RyYWxTeW1ib2xzPS9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2c7ZnVuY3Rpb24gc2luZ2xlQ2hhclJlcGxhY2VyKGMpe3JldHVyblwiJiN4XCIrYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpK1wiO1wiO30vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBhc3RyYWxSZXBsYWNlcihjLF8pey8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG52YXIgaGlnaD1jLmNoYXJDb2RlQXQoMCk7dmFyIGxvdz1jLmNoYXJDb2RlQXQoMSk7dmFyIGNvZGVQb2ludD0oaGlnaC0weGQ4MDApKjB4NDAwK2xvdy0weGRjMDArMHgxMDAwMDtyZXR1cm5cIiYjeFwiK2NvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKStcIjtcIjt9ZnVuY3Rpb24gZ2V0SW52ZXJzZShpbnZlcnNlLHJlKXtyZXR1cm4gZnVuY3Rpb24oZGF0YSl7cmV0dXJuIGRhdGEucmVwbGFjZShyZSxmdW5jdGlvbihuYW1lKXtyZXR1cm4gaW52ZXJzZVtuYW1lXTt9KS5yZXBsYWNlKHJlQXN0cmFsU3ltYm9scyxhc3RyYWxSZXBsYWNlcikucmVwbGFjZShyZU5vbkFTQ0lJLHNpbmdsZUNoYXJSZXBsYWNlcik7fTt9dmFyIHJlWG1sQ2hhcnM9Z2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VYTUwpO2Z1bmN0aW9uIGVzY2FwZShkYXRhKXtyZXR1cm4gZGF0YS5yZXBsYWNlKHJlWG1sQ2hhcnMsc2luZ2xlQ2hhclJlcGxhY2VyKS5yZXBsYWNlKHJlQXN0cmFsU3ltYm9scyxhc3RyYWxSZXBsYWNlcikucmVwbGFjZShyZU5vbkFTQ0lJLHNpbmdsZUNoYXJSZXBsYWNlcik7fWV4cG9ydHMuZXNjYXBlPWVzY2FwZTt9LHtcIi4vbWFwcy9lbnRpdGllcy5qc29uXCI6MjIsXCIuL21hcHMveG1sLmpzb25cIjoyNH1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBkZWNvZGVfMT1yZXF1aXJlKFwiLi9kZWNvZGVcIik7dmFyIGVuY29kZV8xPXJlcXVpcmUoXCIuL2VuY29kZVwiKTtmdW5jdGlvbiBkZWNvZGUoZGF0YSxsZXZlbCl7cmV0dXJuKCFsZXZlbHx8bGV2ZWw8PTA/ZGVjb2RlXzEuZGVjb2RlWE1MOmRlY29kZV8xLmRlY29kZUhUTUwpKGRhdGEpO31leHBvcnRzLmRlY29kZT1kZWNvZGU7ZnVuY3Rpb24gZGVjb2RlU3RyaWN0KGRhdGEsbGV2ZWwpe3JldHVybighbGV2ZWx8fGxldmVsPD0wP2RlY29kZV8xLmRlY29kZVhNTDpkZWNvZGVfMS5kZWNvZGVIVE1MU3RyaWN0KShkYXRhKTt9ZXhwb3J0cy5kZWNvZGVTdHJpY3Q9ZGVjb2RlU3RyaWN0O2Z1bmN0aW9uIGVuY29kZShkYXRhLGxldmVsKXtyZXR1cm4oIWxldmVsfHxsZXZlbDw9MD9lbmNvZGVfMS5lbmNvZGVYTUw6ZW5jb2RlXzEuZW5jb2RlSFRNTCkoZGF0YSk7fWV4cG9ydHMuZW5jb2RlPWVuY29kZTt2YXIgZW5jb2RlXzI9cmVxdWlyZShcIi4vZW5jb2RlXCIpO2V4cG9ydHMuZW5jb2RlWE1MPWVuY29kZV8yLmVuY29kZVhNTDtleHBvcnRzLmVuY29kZUhUTUw9ZW5jb2RlXzIuZW5jb2RlSFRNTDtleHBvcnRzLmVzY2FwZT1lbmNvZGVfMi5lc2NhcGU7Ly8gTGVnYWN5IGFsaWFzZXNcbmV4cG9ydHMuZW5jb2RlSFRNTDQ9ZW5jb2RlXzIuZW5jb2RlSFRNTDtleHBvcnRzLmVuY29kZUhUTUw1PWVuY29kZV8yLmVuY29kZUhUTUw7dmFyIGRlY29kZV8yPXJlcXVpcmUoXCIuL2RlY29kZVwiKTtleHBvcnRzLmRlY29kZVhNTD1kZWNvZGVfMi5kZWNvZGVYTUw7ZXhwb3J0cy5kZWNvZGVIVE1MPWRlY29kZV8yLmRlY29kZUhUTUw7ZXhwb3J0cy5kZWNvZGVIVE1MU3RyaWN0PWRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7Ly8gTGVnYWN5IGFsaWFzZXNcbmV4cG9ydHMuZGVjb2RlSFRNTDQ9ZGVjb2RlXzIuZGVjb2RlSFRNTDtleHBvcnRzLmRlY29kZUhUTUw1PWRlY29kZV8yLmRlY29kZUhUTUw7ZXhwb3J0cy5kZWNvZGVIVE1MNFN0cmljdD1kZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0O2V4cG9ydHMuZGVjb2RlSFRNTDVTdHJpY3Q9ZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDtleHBvcnRzLmRlY29kZVhNTFN0cmljdD1kZWNvZGVfMi5kZWNvZGVYTUw7fSx7XCIuL2RlY29kZVwiOjE3LFwiLi9lbmNvZGVcIjoxOX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz17XCIwXCI6NjU1MzMsXCIxMjhcIjo4MzY0LFwiMTMwXCI6ODIxOCxcIjEzMVwiOjQwMixcIjEzMlwiOjgyMjIsXCIxMzNcIjo4MjMwLFwiMTM0XCI6ODIyNCxcIjEzNVwiOjgyMjUsXCIxMzZcIjo3MTAsXCIxMzdcIjo4MjQwLFwiMTM4XCI6MzUyLFwiMTM5XCI6ODI0OSxcIjE0MFwiOjMzOCxcIjE0MlwiOjM4MSxcIjE0NVwiOjgyMTYsXCIxNDZcIjo4MjE3LFwiMTQ3XCI6ODIyMCxcIjE0OFwiOjgyMjEsXCIxNDlcIjo4MjI2LFwiMTUwXCI6ODIxMSxcIjE1MVwiOjgyMTIsXCIxNTJcIjo3MzIsXCIxNTNcIjo4NDgyLFwiMTU0XCI6MzUzLFwiMTU1XCI6ODI1MCxcIjE1NlwiOjMzOSxcIjE1OFwiOjM4MixcIjE1OVwiOjM3Nn07fSx7fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPXtcIkFhY3V0ZVwiOlwiXFx4QzFcIixcImFhY3V0ZVwiOlwiXFx4RTFcIixcIkFicmV2ZVwiOlwiXFx1MDEwMlwiLFwiYWJyZXZlXCI6XCJcXHUwMTAzXCIsXCJhY1wiOlwiXFx1MjIzRVwiLFwiYWNkXCI6XCJcXHUyMjNGXCIsXCJhY0VcIjpcIlxcdTIyM0VcXHUwMzMzXCIsXCJBY2lyY1wiOlwiXFx4QzJcIixcImFjaXJjXCI6XCJcXHhFMlwiLFwiYWN1dGVcIjpcIlxceEI0XCIsXCJBY3lcIjpcIlxcdTA0MTBcIixcImFjeVwiOlwiXFx1MDQzMFwiLFwiQUVsaWdcIjpcIlxceEM2XCIsXCJhZWxpZ1wiOlwiXFx4RTZcIixcImFmXCI6XCJcXHUyMDYxXCIsXCJBZnJcIjpcIlxcdUQ4MzVcXHVERDA0XCIsXCJhZnJcIjpcIlxcdUQ4MzVcXHVERDFFXCIsXCJBZ3JhdmVcIjpcIlxceEMwXCIsXCJhZ3JhdmVcIjpcIlxceEUwXCIsXCJhbGVmc3ltXCI6XCJcXHUyMTM1XCIsXCJhbGVwaFwiOlwiXFx1MjEzNVwiLFwiQWxwaGFcIjpcIlxcdTAzOTFcIixcImFscGhhXCI6XCJcXHUwM0IxXCIsXCJBbWFjclwiOlwiXFx1MDEwMFwiLFwiYW1hY3JcIjpcIlxcdTAxMDFcIixcImFtYWxnXCI6XCJcXHUyQTNGXCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiYW5kYW5kXCI6XCJcXHUyQTU1XCIsXCJBbmRcIjpcIlxcdTJBNTNcIixcImFuZFwiOlwiXFx1MjIyN1wiLFwiYW5kZFwiOlwiXFx1MkE1Q1wiLFwiYW5kc2xvcGVcIjpcIlxcdTJBNThcIixcImFuZHZcIjpcIlxcdTJBNUFcIixcImFuZ1wiOlwiXFx1MjIyMFwiLFwiYW5nZVwiOlwiXFx1MjlBNFwiLFwiYW5nbGVcIjpcIlxcdTIyMjBcIixcImFuZ21zZGFhXCI6XCJcXHUyOUE4XCIsXCJhbmdtc2RhYlwiOlwiXFx1MjlBOVwiLFwiYW5nbXNkYWNcIjpcIlxcdTI5QUFcIixcImFuZ21zZGFkXCI6XCJcXHUyOUFCXCIsXCJhbmdtc2RhZVwiOlwiXFx1MjlBQ1wiLFwiYW5nbXNkYWZcIjpcIlxcdTI5QURcIixcImFuZ21zZGFnXCI6XCJcXHUyOUFFXCIsXCJhbmdtc2RhaFwiOlwiXFx1MjlBRlwiLFwiYW5nbXNkXCI6XCJcXHUyMjIxXCIsXCJhbmdydFwiOlwiXFx1MjIxRlwiLFwiYW5ncnR2YlwiOlwiXFx1MjJCRVwiLFwiYW5ncnR2YmRcIjpcIlxcdTI5OURcIixcImFuZ3NwaFwiOlwiXFx1MjIyMlwiLFwiYW5nc3RcIjpcIlxceEM1XCIsXCJhbmd6YXJyXCI6XCJcXHUyMzdDXCIsXCJBb2dvblwiOlwiXFx1MDEwNFwiLFwiYW9nb25cIjpcIlxcdTAxMDVcIixcIkFvcGZcIjpcIlxcdUQ4MzVcXHVERDM4XCIsXCJhb3BmXCI6XCJcXHVEODM1XFx1REQ1MlwiLFwiYXBhY2lyXCI6XCJcXHUyQTZGXCIsXCJhcFwiOlwiXFx1MjI0OFwiLFwiYXBFXCI6XCJcXHUyQTcwXCIsXCJhcGVcIjpcIlxcdTIyNEFcIixcImFwaWRcIjpcIlxcdTIyNEJcIixcImFwb3NcIjpcIidcIixcIkFwcGx5RnVuY3Rpb25cIjpcIlxcdTIwNjFcIixcImFwcHJveFwiOlwiXFx1MjI0OFwiLFwiYXBwcm94ZXFcIjpcIlxcdTIyNEFcIixcIkFyaW5nXCI6XCJcXHhDNVwiLFwiYXJpbmdcIjpcIlxceEU1XCIsXCJBc2NyXCI6XCJcXHVEODM1XFx1REM5Q1wiLFwiYXNjclwiOlwiXFx1RDgzNVxcdURDQjZcIixcIkFzc2lnblwiOlwiXFx1MjI1NFwiLFwiYXN0XCI6XCIqXCIsXCJhc3ltcFwiOlwiXFx1MjI0OFwiLFwiYXN5bXBlcVwiOlwiXFx1MjI0RFwiLFwiQXRpbGRlXCI6XCJcXHhDM1wiLFwiYXRpbGRlXCI6XCJcXHhFM1wiLFwiQXVtbFwiOlwiXFx4QzRcIixcImF1bWxcIjpcIlxceEU0XCIsXCJhd2NvbmludFwiOlwiXFx1MjIzM1wiLFwiYXdpbnRcIjpcIlxcdTJBMTFcIixcImJhY2tjb25nXCI6XCJcXHUyMjRDXCIsXCJiYWNrZXBzaWxvblwiOlwiXFx1MDNGNlwiLFwiYmFja3ByaW1lXCI6XCJcXHUyMDM1XCIsXCJiYWNrc2ltXCI6XCJcXHUyMjNEXCIsXCJiYWNrc2ltZXFcIjpcIlxcdTIyQ0RcIixcIkJhY2tzbGFzaFwiOlwiXFx1MjIxNlwiLFwiQmFydlwiOlwiXFx1MkFFN1wiLFwiYmFydmVlXCI6XCJcXHUyMkJEXCIsXCJiYXJ3ZWRcIjpcIlxcdTIzMDVcIixcIkJhcndlZFwiOlwiXFx1MjMwNlwiLFwiYmFyd2VkZ2VcIjpcIlxcdTIzMDVcIixcImJicmtcIjpcIlxcdTIzQjVcIixcImJicmt0YnJrXCI6XCJcXHUyM0I2XCIsXCJiY29uZ1wiOlwiXFx1MjI0Q1wiLFwiQmN5XCI6XCJcXHUwNDExXCIsXCJiY3lcIjpcIlxcdTA0MzFcIixcImJkcXVvXCI6XCJcXHUyMDFFXCIsXCJiZWNhdXNcIjpcIlxcdTIyMzVcIixcImJlY2F1c2VcIjpcIlxcdTIyMzVcIixcIkJlY2F1c2VcIjpcIlxcdTIyMzVcIixcImJlbXB0eXZcIjpcIlxcdTI5QjBcIixcImJlcHNpXCI6XCJcXHUwM0Y2XCIsXCJiZXJub3VcIjpcIlxcdTIxMkNcIixcIkJlcm5vdWxsaXNcIjpcIlxcdTIxMkNcIixcIkJldGFcIjpcIlxcdTAzOTJcIixcImJldGFcIjpcIlxcdTAzQjJcIixcImJldGhcIjpcIlxcdTIxMzZcIixcImJldHdlZW5cIjpcIlxcdTIyNkNcIixcIkJmclwiOlwiXFx1RDgzNVxcdUREMDVcIixcImJmclwiOlwiXFx1RDgzNVxcdUREMUZcIixcImJpZ2NhcFwiOlwiXFx1MjJDMlwiLFwiYmlnY2lyY1wiOlwiXFx1MjVFRlwiLFwiYmlnY3VwXCI6XCJcXHUyMkMzXCIsXCJiaWdvZG90XCI6XCJcXHUyQTAwXCIsXCJiaWdvcGx1c1wiOlwiXFx1MkEwMVwiLFwiYmlnb3RpbWVzXCI6XCJcXHUyQTAyXCIsXCJiaWdzcWN1cFwiOlwiXFx1MkEwNlwiLFwiYmlnc3RhclwiOlwiXFx1MjYwNVwiLFwiYmlndHJpYW5nbGVkb3duXCI6XCJcXHUyNUJEXCIsXCJiaWd0cmlhbmdsZXVwXCI6XCJcXHUyNUIzXCIsXCJiaWd1cGx1c1wiOlwiXFx1MkEwNFwiLFwiYmlndmVlXCI6XCJcXHUyMkMxXCIsXCJiaWd3ZWRnZVwiOlwiXFx1MjJDMFwiLFwiYmthcm93XCI6XCJcXHUyOTBEXCIsXCJibGFja2xvemVuZ2VcIjpcIlxcdTI5RUJcIixcImJsYWNrc3F1YXJlXCI6XCJcXHUyNUFBXCIsXCJibGFja3RyaWFuZ2xlXCI6XCJcXHUyNUI0XCIsXCJibGFja3RyaWFuZ2xlZG93blwiOlwiXFx1MjVCRVwiLFwiYmxhY2t0cmlhbmdsZWxlZnRcIjpcIlxcdTI1QzJcIixcImJsYWNrdHJpYW5nbGVyaWdodFwiOlwiXFx1MjVCOFwiLFwiYmxhbmtcIjpcIlxcdTI0MjNcIixcImJsazEyXCI6XCJcXHUyNTkyXCIsXCJibGsxNFwiOlwiXFx1MjU5MVwiLFwiYmxrMzRcIjpcIlxcdTI1OTNcIixcImJsb2NrXCI6XCJcXHUyNTg4XCIsXCJibmVcIjpcIj1cXHUyMEU1XCIsXCJibmVxdWl2XCI6XCJcXHUyMjYxXFx1MjBFNVwiLFwiYk5vdFwiOlwiXFx1MkFFRFwiLFwiYm5vdFwiOlwiXFx1MjMxMFwiLFwiQm9wZlwiOlwiXFx1RDgzNVxcdUREMzlcIixcImJvcGZcIjpcIlxcdUQ4MzVcXHVERDUzXCIsXCJib3RcIjpcIlxcdTIyQTVcIixcImJvdHRvbVwiOlwiXFx1MjJBNVwiLFwiYm93dGllXCI6XCJcXHUyMkM4XCIsXCJib3hib3hcIjpcIlxcdTI5QzlcIixcImJveGRsXCI6XCJcXHUyNTEwXCIsXCJib3hkTFwiOlwiXFx1MjU1NVwiLFwiYm94RGxcIjpcIlxcdTI1NTZcIixcImJveERMXCI6XCJcXHUyNTU3XCIsXCJib3hkclwiOlwiXFx1MjUwQ1wiLFwiYm94ZFJcIjpcIlxcdTI1NTJcIixcImJveERyXCI6XCJcXHUyNTUzXCIsXCJib3hEUlwiOlwiXFx1MjU1NFwiLFwiYm94aFwiOlwiXFx1MjUwMFwiLFwiYm94SFwiOlwiXFx1MjU1MFwiLFwiYm94aGRcIjpcIlxcdTI1MkNcIixcImJveEhkXCI6XCJcXHUyNTY0XCIsXCJib3hoRFwiOlwiXFx1MjU2NVwiLFwiYm94SERcIjpcIlxcdTI1NjZcIixcImJveGh1XCI6XCJcXHUyNTM0XCIsXCJib3hIdVwiOlwiXFx1MjU2N1wiLFwiYm94aFVcIjpcIlxcdTI1NjhcIixcImJveEhVXCI6XCJcXHUyNTY5XCIsXCJib3htaW51c1wiOlwiXFx1MjI5RlwiLFwiYm94cGx1c1wiOlwiXFx1MjI5RVwiLFwiYm94dGltZXNcIjpcIlxcdTIyQTBcIixcImJveHVsXCI6XCJcXHUyNTE4XCIsXCJib3h1TFwiOlwiXFx1MjU1QlwiLFwiYm94VWxcIjpcIlxcdTI1NUNcIixcImJveFVMXCI6XCJcXHUyNTVEXCIsXCJib3h1clwiOlwiXFx1MjUxNFwiLFwiYm94dVJcIjpcIlxcdTI1NThcIixcImJveFVyXCI6XCJcXHUyNTU5XCIsXCJib3hVUlwiOlwiXFx1MjU1QVwiLFwiYm94dlwiOlwiXFx1MjUwMlwiLFwiYm94VlwiOlwiXFx1MjU1MVwiLFwiYm94dmhcIjpcIlxcdTI1M0NcIixcImJveHZIXCI6XCJcXHUyNTZBXCIsXCJib3hWaFwiOlwiXFx1MjU2QlwiLFwiYm94VkhcIjpcIlxcdTI1NkNcIixcImJveHZsXCI6XCJcXHUyNTI0XCIsXCJib3h2TFwiOlwiXFx1MjU2MVwiLFwiYm94VmxcIjpcIlxcdTI1NjJcIixcImJveFZMXCI6XCJcXHUyNTYzXCIsXCJib3h2clwiOlwiXFx1MjUxQ1wiLFwiYm94dlJcIjpcIlxcdTI1NUVcIixcImJveFZyXCI6XCJcXHUyNTVGXCIsXCJib3hWUlwiOlwiXFx1MjU2MFwiLFwiYnByaW1lXCI6XCJcXHUyMDM1XCIsXCJicmV2ZVwiOlwiXFx1MDJEOFwiLFwiQnJldmVcIjpcIlxcdTAyRDhcIixcImJydmJhclwiOlwiXFx4QTZcIixcImJzY3JcIjpcIlxcdUQ4MzVcXHVEQ0I3XCIsXCJCc2NyXCI6XCJcXHUyMTJDXCIsXCJic2VtaVwiOlwiXFx1MjA0RlwiLFwiYnNpbVwiOlwiXFx1MjIzRFwiLFwiYnNpbWVcIjpcIlxcdTIyQ0RcIixcImJzb2xiXCI6XCJcXHUyOUM1XCIsXCJic29sXCI6XCJcXFxcXCIsXCJic29saHN1YlwiOlwiXFx1MjdDOFwiLFwiYnVsbFwiOlwiXFx1MjAyMlwiLFwiYnVsbGV0XCI6XCJcXHUyMDIyXCIsXCJidW1wXCI6XCJcXHUyMjRFXCIsXCJidW1wRVwiOlwiXFx1MkFBRVwiLFwiYnVtcGVcIjpcIlxcdTIyNEZcIixcIkJ1bXBlcVwiOlwiXFx1MjI0RVwiLFwiYnVtcGVxXCI6XCJcXHUyMjRGXCIsXCJDYWN1dGVcIjpcIlxcdTAxMDZcIixcImNhY3V0ZVwiOlwiXFx1MDEwN1wiLFwiY2FwYW5kXCI6XCJcXHUyQTQ0XCIsXCJjYXBicmN1cFwiOlwiXFx1MkE0OVwiLFwiY2FwY2FwXCI6XCJcXHUyQTRCXCIsXCJjYXBcIjpcIlxcdTIyMjlcIixcIkNhcFwiOlwiXFx1MjJEMlwiLFwiY2FwY3VwXCI6XCJcXHUyQTQ3XCIsXCJjYXBkb3RcIjpcIlxcdTJBNDBcIixcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6XCJcXHUyMTQ1XCIsXCJjYXBzXCI6XCJcXHUyMjI5XFx1RkUwMFwiLFwiY2FyZXRcIjpcIlxcdTIwNDFcIixcImNhcm9uXCI6XCJcXHUwMkM3XCIsXCJDYXlsZXlzXCI6XCJcXHUyMTJEXCIsXCJjY2Fwc1wiOlwiXFx1MkE0RFwiLFwiQ2Nhcm9uXCI6XCJcXHUwMTBDXCIsXCJjY2Fyb25cIjpcIlxcdTAxMERcIixcIkNjZWRpbFwiOlwiXFx4QzdcIixcImNjZWRpbFwiOlwiXFx4RTdcIixcIkNjaXJjXCI6XCJcXHUwMTA4XCIsXCJjY2lyY1wiOlwiXFx1MDEwOVwiLFwiQ2NvbmludFwiOlwiXFx1MjIzMFwiLFwiY2N1cHNcIjpcIlxcdTJBNENcIixcImNjdXBzc21cIjpcIlxcdTJBNTBcIixcIkNkb3RcIjpcIlxcdTAxMEFcIixcImNkb3RcIjpcIlxcdTAxMEJcIixcImNlZGlsXCI6XCJcXHhCOFwiLFwiQ2VkaWxsYVwiOlwiXFx4QjhcIixcImNlbXB0eXZcIjpcIlxcdTI5QjJcIixcImNlbnRcIjpcIlxceEEyXCIsXCJjZW50ZXJkb3RcIjpcIlxceEI3XCIsXCJDZW50ZXJEb3RcIjpcIlxceEI3XCIsXCJjZnJcIjpcIlxcdUQ4MzVcXHVERDIwXCIsXCJDZnJcIjpcIlxcdTIxMkRcIixcIkNIY3lcIjpcIlxcdTA0MjdcIixcImNoY3lcIjpcIlxcdTA0NDdcIixcImNoZWNrXCI6XCJcXHUyNzEzXCIsXCJjaGVja21hcmtcIjpcIlxcdTI3MTNcIixcIkNoaVwiOlwiXFx1MDNBN1wiLFwiY2hpXCI6XCJcXHUwM0M3XCIsXCJjaXJjXCI6XCJcXHUwMkM2XCIsXCJjaXJjZXFcIjpcIlxcdTIyNTdcIixcImNpcmNsZWFycm93bGVmdFwiOlwiXFx1MjFCQVwiLFwiY2lyY2xlYXJyb3dyaWdodFwiOlwiXFx1MjFCQlwiLFwiY2lyY2xlZGFzdFwiOlwiXFx1MjI5QlwiLFwiY2lyY2xlZGNpcmNcIjpcIlxcdTIyOUFcIixcImNpcmNsZWRkYXNoXCI6XCJcXHUyMjlEXCIsXCJDaXJjbGVEb3RcIjpcIlxcdTIyOTlcIixcImNpcmNsZWRSXCI6XCJcXHhBRVwiLFwiY2lyY2xlZFNcIjpcIlxcdTI0QzhcIixcIkNpcmNsZU1pbnVzXCI6XCJcXHUyMjk2XCIsXCJDaXJjbGVQbHVzXCI6XCJcXHUyMjk1XCIsXCJDaXJjbGVUaW1lc1wiOlwiXFx1MjI5N1wiLFwiY2lyXCI6XCJcXHUyNUNCXCIsXCJjaXJFXCI6XCJcXHUyOUMzXCIsXCJjaXJlXCI6XCJcXHUyMjU3XCIsXCJjaXJmbmludFwiOlwiXFx1MkExMFwiLFwiY2lybWlkXCI6XCJcXHUyQUVGXCIsXCJjaXJzY2lyXCI6XCJcXHUyOUMyXCIsXCJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMzJcIixcIkNsb3NlQ3VybHlEb3VibGVRdW90ZVwiOlwiXFx1MjAxRFwiLFwiQ2xvc2VDdXJseVF1b3RlXCI6XCJcXHUyMDE5XCIsXCJjbHVic1wiOlwiXFx1MjY2M1wiLFwiY2x1YnN1aXRcIjpcIlxcdTI2NjNcIixcImNvbG9uXCI6XCI6XCIsXCJDb2xvblwiOlwiXFx1MjIzN1wiLFwiQ29sb25lXCI6XCJcXHUyQTc0XCIsXCJjb2xvbmVcIjpcIlxcdTIyNTRcIixcImNvbG9uZXFcIjpcIlxcdTIyNTRcIixcImNvbW1hXCI6XCIsXCIsXCJjb21tYXRcIjpcIkBcIixcImNvbXBcIjpcIlxcdTIyMDFcIixcImNvbXBmblwiOlwiXFx1MjIxOFwiLFwiY29tcGxlbWVudFwiOlwiXFx1MjIwMVwiLFwiY29tcGxleGVzXCI6XCJcXHUyMTAyXCIsXCJjb25nXCI6XCJcXHUyMjQ1XCIsXCJjb25nZG90XCI6XCJcXHUyQTZEXCIsXCJDb25ncnVlbnRcIjpcIlxcdTIyNjFcIixcImNvbmludFwiOlwiXFx1MjIyRVwiLFwiQ29uaW50XCI6XCJcXHUyMjJGXCIsXCJDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMkVcIixcImNvcGZcIjpcIlxcdUQ4MzVcXHVERDU0XCIsXCJDb3BmXCI6XCJcXHUyMTAyXCIsXCJjb3Byb2RcIjpcIlxcdTIyMTBcIixcIkNvcHJvZHVjdFwiOlwiXFx1MjIxMFwiLFwiY29weVwiOlwiXFx4QTlcIixcIkNPUFlcIjpcIlxceEE5XCIsXCJjb3B5c3JcIjpcIlxcdTIxMTdcIixcIkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxcIjpcIlxcdTIyMzNcIixcImNyYXJyXCI6XCJcXHUyMUI1XCIsXCJjcm9zc1wiOlwiXFx1MjcxN1wiLFwiQ3Jvc3NcIjpcIlxcdTJBMkZcIixcIkNzY3JcIjpcIlxcdUQ4MzVcXHVEQzlFXCIsXCJjc2NyXCI6XCJcXHVEODM1XFx1RENCOFwiLFwiY3N1YlwiOlwiXFx1MkFDRlwiLFwiY3N1YmVcIjpcIlxcdTJBRDFcIixcImNzdXBcIjpcIlxcdTJBRDBcIixcImNzdXBlXCI6XCJcXHUyQUQyXCIsXCJjdGRvdFwiOlwiXFx1MjJFRlwiLFwiY3VkYXJybFwiOlwiXFx1MjkzOFwiLFwiY3VkYXJyclwiOlwiXFx1MjkzNVwiLFwiY3VlcHJcIjpcIlxcdTIyREVcIixcImN1ZXNjXCI6XCJcXHUyMkRGXCIsXCJjdWxhcnJcIjpcIlxcdTIxQjZcIixcImN1bGFycnBcIjpcIlxcdTI5M0RcIixcImN1cGJyY2FwXCI6XCJcXHUyQTQ4XCIsXCJjdXBjYXBcIjpcIlxcdTJBNDZcIixcIkN1cENhcFwiOlwiXFx1MjI0RFwiLFwiY3VwXCI6XCJcXHUyMjJBXCIsXCJDdXBcIjpcIlxcdTIyRDNcIixcImN1cGN1cFwiOlwiXFx1MkE0QVwiLFwiY3VwZG90XCI6XCJcXHUyMjhEXCIsXCJjdXBvclwiOlwiXFx1MkE0NVwiLFwiY3Vwc1wiOlwiXFx1MjIyQVxcdUZFMDBcIixcImN1cmFyclwiOlwiXFx1MjFCN1wiLFwiY3VyYXJybVwiOlwiXFx1MjkzQ1wiLFwiY3VybHllcXByZWNcIjpcIlxcdTIyREVcIixcImN1cmx5ZXFzdWNjXCI6XCJcXHUyMkRGXCIsXCJjdXJseXZlZVwiOlwiXFx1MjJDRVwiLFwiY3VybHl3ZWRnZVwiOlwiXFx1MjJDRlwiLFwiY3VycmVuXCI6XCJcXHhBNFwiLFwiY3VydmVhcnJvd2xlZnRcIjpcIlxcdTIxQjZcIixcImN1cnZlYXJyb3dyaWdodFwiOlwiXFx1MjFCN1wiLFwiY3V2ZWVcIjpcIlxcdTIyQ0VcIixcImN1d2VkXCI6XCJcXHUyMkNGXCIsXCJjd2NvbmludFwiOlwiXFx1MjIzMlwiLFwiY3dpbnRcIjpcIlxcdTIyMzFcIixcImN5bGN0eVwiOlwiXFx1MjMyRFwiLFwiZGFnZ2VyXCI6XCJcXHUyMDIwXCIsXCJEYWdnZXJcIjpcIlxcdTIwMjFcIixcImRhbGV0aFwiOlwiXFx1MjEzOFwiLFwiZGFyclwiOlwiXFx1MjE5M1wiLFwiRGFyclwiOlwiXFx1MjFBMVwiLFwiZEFyclwiOlwiXFx1MjFEM1wiLFwiZGFzaFwiOlwiXFx1MjAxMFwiLFwiRGFzaHZcIjpcIlxcdTJBRTRcIixcImRhc2h2XCI6XCJcXHUyMkEzXCIsXCJkYmthcm93XCI6XCJcXHUyOTBGXCIsXCJkYmxhY1wiOlwiXFx1MDJERFwiLFwiRGNhcm9uXCI6XCJcXHUwMTBFXCIsXCJkY2Fyb25cIjpcIlxcdTAxMEZcIixcIkRjeVwiOlwiXFx1MDQxNFwiLFwiZGN5XCI6XCJcXHUwNDM0XCIsXCJkZGFnZ2VyXCI6XCJcXHUyMDIxXCIsXCJkZGFyclwiOlwiXFx1MjFDQVwiLFwiRERcIjpcIlxcdTIxNDVcIixcImRkXCI6XCJcXHUyMTQ2XCIsXCJERG90cmFoZFwiOlwiXFx1MjkxMVwiLFwiZGRvdHNlcVwiOlwiXFx1MkE3N1wiLFwiZGVnXCI6XCJcXHhCMFwiLFwiRGVsXCI6XCJcXHUyMjA3XCIsXCJEZWx0YVwiOlwiXFx1MDM5NFwiLFwiZGVsdGFcIjpcIlxcdTAzQjRcIixcImRlbXB0eXZcIjpcIlxcdTI5QjFcIixcImRmaXNodFwiOlwiXFx1Mjk3RlwiLFwiRGZyXCI6XCJcXHVEODM1XFx1REQwN1wiLFwiZGZyXCI6XCJcXHVEODM1XFx1REQyMVwiLFwiZEhhclwiOlwiXFx1Mjk2NVwiLFwiZGhhcmxcIjpcIlxcdTIxQzNcIixcImRoYXJyXCI6XCJcXHUyMUMyXCIsXCJEaWFjcml0aWNhbEFjdXRlXCI6XCJcXHhCNFwiLFwiRGlhY3JpdGljYWxEb3RcIjpcIlxcdTAyRDlcIixcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjpcIlxcdTAyRERcIixcIkRpYWNyaXRpY2FsR3JhdmVcIjpcImBcIixcIkRpYWNyaXRpY2FsVGlsZGVcIjpcIlxcdTAyRENcIixcImRpYW1cIjpcIlxcdTIyQzRcIixcImRpYW1vbmRcIjpcIlxcdTIyQzRcIixcIkRpYW1vbmRcIjpcIlxcdTIyQzRcIixcImRpYW1vbmRzdWl0XCI6XCJcXHUyNjY2XCIsXCJkaWFtc1wiOlwiXFx1MjY2NlwiLFwiZGllXCI6XCJcXHhBOFwiLFwiRGlmZmVyZW50aWFsRFwiOlwiXFx1MjE0NlwiLFwiZGlnYW1tYVwiOlwiXFx1MDNERFwiLFwiZGlzaW5cIjpcIlxcdTIyRjJcIixcImRpdlwiOlwiXFx4RjdcIixcImRpdmlkZVwiOlwiXFx4RjdcIixcImRpdmlkZW9udGltZXNcIjpcIlxcdTIyQzdcIixcImRpdm9ueFwiOlwiXFx1MjJDN1wiLFwiREpjeVwiOlwiXFx1MDQwMlwiLFwiZGpjeVwiOlwiXFx1MDQ1MlwiLFwiZGxjb3JuXCI6XCJcXHUyMzFFXCIsXCJkbGNyb3BcIjpcIlxcdTIzMERcIixcImRvbGxhclwiOlwiJFwiLFwiRG9wZlwiOlwiXFx1RDgzNVxcdUREM0JcIixcImRvcGZcIjpcIlxcdUQ4MzVcXHVERDU1XCIsXCJEb3RcIjpcIlxceEE4XCIsXCJkb3RcIjpcIlxcdTAyRDlcIixcIkRvdERvdFwiOlwiXFx1MjBEQ1wiLFwiZG90ZXFcIjpcIlxcdTIyNTBcIixcImRvdGVxZG90XCI6XCJcXHUyMjUxXCIsXCJEb3RFcXVhbFwiOlwiXFx1MjI1MFwiLFwiZG90bWludXNcIjpcIlxcdTIyMzhcIixcImRvdHBsdXNcIjpcIlxcdTIyMTRcIixcImRvdHNxdWFyZVwiOlwiXFx1MjJBMVwiLFwiZG91YmxlYmFyd2VkZ2VcIjpcIlxcdTIzMDZcIixcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOlwiXFx1MjIyRlwiLFwiRG91YmxlRG90XCI6XCJcXHhBOFwiLFwiRG91YmxlRG93bkFycm93XCI6XCJcXHUyMUQzXCIsXCJEb3VibGVMZWZ0QXJyb3dcIjpcIlxcdTIxRDBcIixcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6XCJcXHUyMUQ0XCIsXCJEb3VibGVMZWZ0VGVlXCI6XCJcXHUyQUU0XCIsXCJEb3VibGVMb25nTGVmdEFycm93XCI6XCJcXHUyN0Y4XCIsXCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIlxcdTI3RkFcIixcIkRvdWJsZUxvbmdSaWdodEFycm93XCI6XCJcXHUyN0Y5XCIsXCJEb3VibGVSaWdodEFycm93XCI6XCJcXHUyMUQyXCIsXCJEb3VibGVSaWdodFRlZVwiOlwiXFx1MjJBOFwiLFwiRG91YmxlVXBBcnJvd1wiOlwiXFx1MjFEMVwiLFwiRG91YmxlVXBEb3duQXJyb3dcIjpcIlxcdTIxRDVcIixcIkRvdWJsZVZlcnRpY2FsQmFyXCI6XCJcXHUyMjI1XCIsXCJEb3duQXJyb3dCYXJcIjpcIlxcdTI5MTNcIixcImRvd25hcnJvd1wiOlwiXFx1MjE5M1wiLFwiRG93bkFycm93XCI6XCJcXHUyMTkzXCIsXCJEb3duYXJyb3dcIjpcIlxcdTIxRDNcIixcIkRvd25BcnJvd1VwQXJyb3dcIjpcIlxcdTIxRjVcIixcIkRvd25CcmV2ZVwiOlwiXFx1MDMxMVwiLFwiZG93bmRvd25hcnJvd3NcIjpcIlxcdTIxQ0FcIixcImRvd25oYXJwb29ubGVmdFwiOlwiXFx1MjFDM1wiLFwiZG93bmhhcnBvb25yaWdodFwiOlwiXFx1MjFDMlwiLFwiRG93bkxlZnRSaWdodFZlY3RvclwiOlwiXFx1Mjk1MFwiLFwiRG93bkxlZnRUZWVWZWN0b3JcIjpcIlxcdTI5NUVcIixcIkRvd25MZWZ0VmVjdG9yQmFyXCI6XCJcXHUyOTU2XCIsXCJEb3duTGVmdFZlY3RvclwiOlwiXFx1MjFCRFwiLFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6XCJcXHUyOTVGXCIsXCJEb3duUmlnaHRWZWN0b3JCYXJcIjpcIlxcdTI5NTdcIixcIkRvd25SaWdodFZlY3RvclwiOlwiXFx1MjFDMVwiLFwiRG93blRlZUFycm93XCI6XCJcXHUyMUE3XCIsXCJEb3duVGVlXCI6XCJcXHUyMkE0XCIsXCJkcmJrYXJvd1wiOlwiXFx1MjkxMFwiLFwiZHJjb3JuXCI6XCJcXHUyMzFGXCIsXCJkcmNyb3BcIjpcIlxcdTIzMENcIixcIkRzY3JcIjpcIlxcdUQ4MzVcXHVEQzlGXCIsXCJkc2NyXCI6XCJcXHVEODM1XFx1RENCOVwiLFwiRFNjeVwiOlwiXFx1MDQwNVwiLFwiZHNjeVwiOlwiXFx1MDQ1NVwiLFwiZHNvbFwiOlwiXFx1MjlGNlwiLFwiRHN0cm9rXCI6XCJcXHUwMTEwXCIsXCJkc3Ryb2tcIjpcIlxcdTAxMTFcIixcImR0ZG90XCI6XCJcXHUyMkYxXCIsXCJkdHJpXCI6XCJcXHUyNUJGXCIsXCJkdHJpZlwiOlwiXFx1MjVCRVwiLFwiZHVhcnJcIjpcIlxcdTIxRjVcIixcImR1aGFyXCI6XCJcXHUyOTZGXCIsXCJkd2FuZ2xlXCI6XCJcXHUyOUE2XCIsXCJEWmN5XCI6XCJcXHUwNDBGXCIsXCJkemN5XCI6XCJcXHUwNDVGXCIsXCJkemlncmFyclwiOlwiXFx1MjdGRlwiLFwiRWFjdXRlXCI6XCJcXHhDOVwiLFwiZWFjdXRlXCI6XCJcXHhFOVwiLFwiZWFzdGVyXCI6XCJcXHUyQTZFXCIsXCJFY2Fyb25cIjpcIlxcdTAxMUFcIixcImVjYXJvblwiOlwiXFx1MDExQlwiLFwiRWNpcmNcIjpcIlxceENBXCIsXCJlY2lyY1wiOlwiXFx4RUFcIixcImVjaXJcIjpcIlxcdTIyNTZcIixcImVjb2xvblwiOlwiXFx1MjI1NVwiLFwiRWN5XCI6XCJcXHUwNDJEXCIsXCJlY3lcIjpcIlxcdTA0NERcIixcImVERG90XCI6XCJcXHUyQTc3XCIsXCJFZG90XCI6XCJcXHUwMTE2XCIsXCJlZG90XCI6XCJcXHUwMTE3XCIsXCJlRG90XCI6XCJcXHUyMjUxXCIsXCJlZVwiOlwiXFx1MjE0N1wiLFwiZWZEb3RcIjpcIlxcdTIyNTJcIixcIkVmclwiOlwiXFx1RDgzNVxcdUREMDhcIixcImVmclwiOlwiXFx1RDgzNVxcdUREMjJcIixcImVnXCI6XCJcXHUyQTlBXCIsXCJFZ3JhdmVcIjpcIlxceEM4XCIsXCJlZ3JhdmVcIjpcIlxceEU4XCIsXCJlZ3NcIjpcIlxcdTJBOTZcIixcImVnc2RvdFwiOlwiXFx1MkE5OFwiLFwiZWxcIjpcIlxcdTJBOTlcIixcIkVsZW1lbnRcIjpcIlxcdTIyMDhcIixcImVsaW50ZXJzXCI6XCJcXHUyM0U3XCIsXCJlbGxcIjpcIlxcdTIxMTNcIixcImVsc1wiOlwiXFx1MkE5NVwiLFwiZWxzZG90XCI6XCJcXHUyQTk3XCIsXCJFbWFjclwiOlwiXFx1MDExMlwiLFwiZW1hY3JcIjpcIlxcdTAxMTNcIixcImVtcHR5XCI6XCJcXHUyMjA1XCIsXCJlbXB0eXNldFwiOlwiXFx1MjIwNVwiLFwiRW1wdHlTbWFsbFNxdWFyZVwiOlwiXFx1MjVGQlwiLFwiZW1wdHl2XCI6XCJcXHUyMjA1XCIsXCJFbXB0eVZlcnlTbWFsbFNxdWFyZVwiOlwiXFx1MjVBQlwiLFwiZW1zcDEzXCI6XCJcXHUyMDA0XCIsXCJlbXNwMTRcIjpcIlxcdTIwMDVcIixcImVtc3BcIjpcIlxcdTIwMDNcIixcIkVOR1wiOlwiXFx1MDE0QVwiLFwiZW5nXCI6XCJcXHUwMTRCXCIsXCJlbnNwXCI6XCJcXHUyMDAyXCIsXCJFb2dvblwiOlwiXFx1MDExOFwiLFwiZW9nb25cIjpcIlxcdTAxMTlcIixcIkVvcGZcIjpcIlxcdUQ4MzVcXHVERDNDXCIsXCJlb3BmXCI6XCJcXHVEODM1XFx1REQ1NlwiLFwiZXBhclwiOlwiXFx1MjJENVwiLFwiZXBhcnNsXCI6XCJcXHUyOUUzXCIsXCJlcGx1c1wiOlwiXFx1MkE3MVwiLFwiZXBzaVwiOlwiXFx1MDNCNVwiLFwiRXBzaWxvblwiOlwiXFx1MDM5NVwiLFwiZXBzaWxvblwiOlwiXFx1MDNCNVwiLFwiZXBzaXZcIjpcIlxcdTAzRjVcIixcImVxY2lyY1wiOlwiXFx1MjI1NlwiLFwiZXFjb2xvblwiOlwiXFx1MjI1NVwiLFwiZXFzaW1cIjpcIlxcdTIyNDJcIixcImVxc2xhbnRndHJcIjpcIlxcdTJBOTZcIixcImVxc2xhbnRsZXNzXCI6XCJcXHUyQTk1XCIsXCJFcXVhbFwiOlwiXFx1MkE3NVwiLFwiZXF1YWxzXCI6XCI9XCIsXCJFcXVhbFRpbGRlXCI6XCJcXHUyMjQyXCIsXCJlcXVlc3RcIjpcIlxcdTIyNUZcIixcIkVxdWlsaWJyaXVtXCI6XCJcXHUyMUNDXCIsXCJlcXVpdlwiOlwiXFx1MjI2MVwiLFwiZXF1aXZERFwiOlwiXFx1MkE3OFwiLFwiZXF2cGFyc2xcIjpcIlxcdTI5RTVcIixcImVyYXJyXCI6XCJcXHUyOTcxXCIsXCJlckRvdFwiOlwiXFx1MjI1M1wiLFwiZXNjclwiOlwiXFx1MjEyRlwiLFwiRXNjclwiOlwiXFx1MjEzMFwiLFwiZXNkb3RcIjpcIlxcdTIyNTBcIixcIkVzaW1cIjpcIlxcdTJBNzNcIixcImVzaW1cIjpcIlxcdTIyNDJcIixcIkV0YVwiOlwiXFx1MDM5N1wiLFwiZXRhXCI6XCJcXHUwM0I3XCIsXCJFVEhcIjpcIlxceEQwXCIsXCJldGhcIjpcIlxceEYwXCIsXCJFdW1sXCI6XCJcXHhDQlwiLFwiZXVtbFwiOlwiXFx4RUJcIixcImV1cm9cIjpcIlxcdTIwQUNcIixcImV4Y2xcIjpcIiFcIixcImV4aXN0XCI6XCJcXHUyMjAzXCIsXCJFeGlzdHNcIjpcIlxcdTIyMDNcIixcImV4cGVjdGF0aW9uXCI6XCJcXHUyMTMwXCIsXCJleHBvbmVudGlhbGVcIjpcIlxcdTIxNDdcIixcIkV4cG9uZW50aWFsRVwiOlwiXFx1MjE0N1wiLFwiZmFsbGluZ2RvdHNlcVwiOlwiXFx1MjI1MlwiLFwiRmN5XCI6XCJcXHUwNDI0XCIsXCJmY3lcIjpcIlxcdTA0NDRcIixcImZlbWFsZVwiOlwiXFx1MjY0MFwiLFwiZmZpbGlnXCI6XCJcXHVGQjAzXCIsXCJmZmxpZ1wiOlwiXFx1RkIwMFwiLFwiZmZsbGlnXCI6XCJcXHVGQjA0XCIsXCJGZnJcIjpcIlxcdUQ4MzVcXHVERDA5XCIsXCJmZnJcIjpcIlxcdUQ4MzVcXHVERDIzXCIsXCJmaWxpZ1wiOlwiXFx1RkIwMVwiLFwiRmlsbGVkU21hbGxTcXVhcmVcIjpcIlxcdTI1RkNcIixcIkZpbGxlZFZlcnlTbWFsbFNxdWFyZVwiOlwiXFx1MjVBQVwiLFwiZmpsaWdcIjpcImZqXCIsXCJmbGF0XCI6XCJcXHUyNjZEXCIsXCJmbGxpZ1wiOlwiXFx1RkIwMlwiLFwiZmx0bnNcIjpcIlxcdTI1QjFcIixcImZub2ZcIjpcIlxcdTAxOTJcIixcIkZvcGZcIjpcIlxcdUQ4MzVcXHVERDNEXCIsXCJmb3BmXCI6XCJcXHVEODM1XFx1REQ1N1wiLFwiZm9yYWxsXCI6XCJcXHUyMjAwXCIsXCJGb3JBbGxcIjpcIlxcdTIyMDBcIixcImZvcmtcIjpcIlxcdTIyRDRcIixcImZvcmt2XCI6XCJcXHUyQUQ5XCIsXCJGb3VyaWVydHJmXCI6XCJcXHUyMTMxXCIsXCJmcGFydGludFwiOlwiXFx1MkEwRFwiLFwiZnJhYzEyXCI6XCJcXHhCRFwiLFwiZnJhYzEzXCI6XCJcXHUyMTUzXCIsXCJmcmFjMTRcIjpcIlxceEJDXCIsXCJmcmFjMTVcIjpcIlxcdTIxNTVcIixcImZyYWMxNlwiOlwiXFx1MjE1OVwiLFwiZnJhYzE4XCI6XCJcXHUyMTVCXCIsXCJmcmFjMjNcIjpcIlxcdTIxNTRcIixcImZyYWMyNVwiOlwiXFx1MjE1NlwiLFwiZnJhYzM0XCI6XCJcXHhCRVwiLFwiZnJhYzM1XCI6XCJcXHUyMTU3XCIsXCJmcmFjMzhcIjpcIlxcdTIxNUNcIixcImZyYWM0NVwiOlwiXFx1MjE1OFwiLFwiZnJhYzU2XCI6XCJcXHUyMTVBXCIsXCJmcmFjNThcIjpcIlxcdTIxNURcIixcImZyYWM3OFwiOlwiXFx1MjE1RVwiLFwiZnJhc2xcIjpcIlxcdTIwNDRcIixcImZyb3duXCI6XCJcXHUyMzIyXCIsXCJmc2NyXCI6XCJcXHVEODM1XFx1RENCQlwiLFwiRnNjclwiOlwiXFx1MjEzMVwiLFwiZ2FjdXRlXCI6XCJcXHUwMUY1XCIsXCJHYW1tYVwiOlwiXFx1MDM5M1wiLFwiZ2FtbWFcIjpcIlxcdTAzQjNcIixcIkdhbW1hZFwiOlwiXFx1MDNEQ1wiLFwiZ2FtbWFkXCI6XCJcXHUwM0REXCIsXCJnYXBcIjpcIlxcdTJBODZcIixcIkdicmV2ZVwiOlwiXFx1MDExRVwiLFwiZ2JyZXZlXCI6XCJcXHUwMTFGXCIsXCJHY2VkaWxcIjpcIlxcdTAxMjJcIixcIkdjaXJjXCI6XCJcXHUwMTFDXCIsXCJnY2lyY1wiOlwiXFx1MDExRFwiLFwiR2N5XCI6XCJcXHUwNDEzXCIsXCJnY3lcIjpcIlxcdTA0MzNcIixcIkdkb3RcIjpcIlxcdTAxMjBcIixcImdkb3RcIjpcIlxcdTAxMjFcIixcImdlXCI6XCJcXHUyMjY1XCIsXCJnRVwiOlwiXFx1MjI2N1wiLFwiZ0VsXCI6XCJcXHUyQThDXCIsXCJnZWxcIjpcIlxcdTIyREJcIixcImdlcVwiOlwiXFx1MjI2NVwiLFwiZ2VxcVwiOlwiXFx1MjI2N1wiLFwiZ2Vxc2xhbnRcIjpcIlxcdTJBN0VcIixcImdlc2NjXCI6XCJcXHUyQUE5XCIsXCJnZXNcIjpcIlxcdTJBN0VcIixcImdlc2RvdFwiOlwiXFx1MkE4MFwiLFwiZ2VzZG90b1wiOlwiXFx1MkE4MlwiLFwiZ2VzZG90b2xcIjpcIlxcdTJBODRcIixcImdlc2xcIjpcIlxcdTIyREJcXHVGRTAwXCIsXCJnZXNsZXNcIjpcIlxcdTJBOTRcIixcIkdmclwiOlwiXFx1RDgzNVxcdUREMEFcIixcImdmclwiOlwiXFx1RDgzNVxcdUREMjRcIixcImdnXCI6XCJcXHUyMjZCXCIsXCJHZ1wiOlwiXFx1MjJEOVwiLFwiZ2dnXCI6XCJcXHUyMkQ5XCIsXCJnaW1lbFwiOlwiXFx1MjEzN1wiLFwiR0pjeVwiOlwiXFx1MDQwM1wiLFwiZ2pjeVwiOlwiXFx1MDQ1M1wiLFwiZ2xhXCI6XCJcXHUyQUE1XCIsXCJnbFwiOlwiXFx1MjI3N1wiLFwiZ2xFXCI6XCJcXHUyQTkyXCIsXCJnbGpcIjpcIlxcdTJBQTRcIixcImduYXBcIjpcIlxcdTJBOEFcIixcImduYXBwcm94XCI6XCJcXHUyQThBXCIsXCJnbmVcIjpcIlxcdTJBODhcIixcImduRVwiOlwiXFx1MjI2OVwiLFwiZ25lcVwiOlwiXFx1MkE4OFwiLFwiZ25lcXFcIjpcIlxcdTIyNjlcIixcImduc2ltXCI6XCJcXHUyMkU3XCIsXCJHb3BmXCI6XCJcXHVEODM1XFx1REQzRVwiLFwiZ29wZlwiOlwiXFx1RDgzNVxcdURENThcIixcImdyYXZlXCI6XCJgXCIsXCJHcmVhdGVyRXF1YWxcIjpcIlxcdTIyNjVcIixcIkdyZWF0ZXJFcXVhbExlc3NcIjpcIlxcdTIyREJcIixcIkdyZWF0ZXJGdWxsRXF1YWxcIjpcIlxcdTIyNjdcIixcIkdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyQUEyXCIsXCJHcmVhdGVyTGVzc1wiOlwiXFx1MjI3N1wiLFwiR3JlYXRlclNsYW50RXF1YWxcIjpcIlxcdTJBN0VcIixcIkdyZWF0ZXJUaWxkZVwiOlwiXFx1MjI3M1wiLFwiR3NjclwiOlwiXFx1RDgzNVxcdURDQTJcIixcImdzY3JcIjpcIlxcdTIxMEFcIixcImdzaW1cIjpcIlxcdTIyNzNcIixcImdzaW1lXCI6XCJcXHUyQThFXCIsXCJnc2ltbFwiOlwiXFx1MkE5MFwiLFwiZ3RjY1wiOlwiXFx1MkFBN1wiLFwiZ3RjaXJcIjpcIlxcdTJBN0FcIixcImd0XCI6XCI+XCIsXCJHVFwiOlwiPlwiLFwiR3RcIjpcIlxcdTIyNkJcIixcImd0ZG90XCI6XCJcXHUyMkQ3XCIsXCJndGxQYXJcIjpcIlxcdTI5OTVcIixcImd0cXVlc3RcIjpcIlxcdTJBN0NcIixcImd0cmFwcHJveFwiOlwiXFx1MkE4NlwiLFwiZ3RyYXJyXCI6XCJcXHUyOTc4XCIsXCJndHJkb3RcIjpcIlxcdTIyRDdcIixcImd0cmVxbGVzc1wiOlwiXFx1MjJEQlwiLFwiZ3RyZXFxbGVzc1wiOlwiXFx1MkE4Q1wiLFwiZ3RybGVzc1wiOlwiXFx1MjI3N1wiLFwiZ3Ryc2ltXCI6XCJcXHUyMjczXCIsXCJndmVydG5lcXFcIjpcIlxcdTIyNjlcXHVGRTAwXCIsXCJndm5FXCI6XCJcXHUyMjY5XFx1RkUwMFwiLFwiSGFjZWtcIjpcIlxcdTAyQzdcIixcImhhaXJzcFwiOlwiXFx1MjAwQVwiLFwiaGFsZlwiOlwiXFx4QkRcIixcImhhbWlsdFwiOlwiXFx1MjEwQlwiLFwiSEFSRGN5XCI6XCJcXHUwNDJBXCIsXCJoYXJkY3lcIjpcIlxcdTA0NEFcIixcImhhcnJjaXJcIjpcIlxcdTI5NDhcIixcImhhcnJcIjpcIlxcdTIxOTRcIixcImhBcnJcIjpcIlxcdTIxRDRcIixcImhhcnJ3XCI6XCJcXHUyMUFEXCIsXCJIYXRcIjpcIl5cIixcImhiYXJcIjpcIlxcdTIxMEZcIixcIkhjaXJjXCI6XCJcXHUwMTI0XCIsXCJoY2lyY1wiOlwiXFx1MDEyNVwiLFwiaGVhcnRzXCI6XCJcXHUyNjY1XCIsXCJoZWFydHN1aXRcIjpcIlxcdTI2NjVcIixcImhlbGxpcFwiOlwiXFx1MjAyNlwiLFwiaGVyY29uXCI6XCJcXHUyMkI5XCIsXCJoZnJcIjpcIlxcdUQ4MzVcXHVERDI1XCIsXCJIZnJcIjpcIlxcdTIxMENcIixcIkhpbGJlcnRTcGFjZVwiOlwiXFx1MjEwQlwiLFwiaGtzZWFyb3dcIjpcIlxcdTI5MjVcIixcImhrc3dhcm93XCI6XCJcXHUyOTI2XCIsXCJob2FyclwiOlwiXFx1MjFGRlwiLFwiaG9tdGh0XCI6XCJcXHUyMjNCXCIsXCJob29rbGVmdGFycm93XCI6XCJcXHUyMUE5XCIsXCJob29rcmlnaHRhcnJvd1wiOlwiXFx1MjFBQVwiLFwiaG9wZlwiOlwiXFx1RDgzNVxcdURENTlcIixcIkhvcGZcIjpcIlxcdTIxMERcIixcImhvcmJhclwiOlwiXFx1MjAxNVwiLFwiSG9yaXpvbnRhbExpbmVcIjpcIlxcdTI1MDBcIixcImhzY3JcIjpcIlxcdUQ4MzVcXHVEQ0JEXCIsXCJIc2NyXCI6XCJcXHUyMTBCXCIsXCJoc2xhc2hcIjpcIlxcdTIxMEZcIixcIkhzdHJva1wiOlwiXFx1MDEyNlwiLFwiaHN0cm9rXCI6XCJcXHUwMTI3XCIsXCJIdW1wRG93bkh1bXBcIjpcIlxcdTIyNEVcIixcIkh1bXBFcXVhbFwiOlwiXFx1MjI0RlwiLFwiaHlidWxsXCI6XCJcXHUyMDQzXCIsXCJoeXBoZW5cIjpcIlxcdTIwMTBcIixcIklhY3V0ZVwiOlwiXFx4Q0RcIixcImlhY3V0ZVwiOlwiXFx4RURcIixcImljXCI6XCJcXHUyMDYzXCIsXCJJY2lyY1wiOlwiXFx4Q0VcIixcImljaXJjXCI6XCJcXHhFRVwiLFwiSWN5XCI6XCJcXHUwNDE4XCIsXCJpY3lcIjpcIlxcdTA0MzhcIixcIklkb3RcIjpcIlxcdTAxMzBcIixcIklFY3lcIjpcIlxcdTA0MTVcIixcImllY3lcIjpcIlxcdTA0MzVcIixcImlleGNsXCI6XCJcXHhBMVwiLFwiaWZmXCI6XCJcXHUyMUQ0XCIsXCJpZnJcIjpcIlxcdUQ4MzVcXHVERDI2XCIsXCJJZnJcIjpcIlxcdTIxMTFcIixcIklncmF2ZVwiOlwiXFx4Q0NcIixcImlncmF2ZVwiOlwiXFx4RUNcIixcImlpXCI6XCJcXHUyMTQ4XCIsXCJpaWlpbnRcIjpcIlxcdTJBMENcIixcImlpaW50XCI6XCJcXHUyMjJEXCIsXCJpaW5maW5cIjpcIlxcdTI5RENcIixcImlpb3RhXCI6XCJcXHUyMTI5XCIsXCJJSmxpZ1wiOlwiXFx1MDEzMlwiLFwiaWpsaWdcIjpcIlxcdTAxMzNcIixcIkltYWNyXCI6XCJcXHUwMTJBXCIsXCJpbWFjclwiOlwiXFx1MDEyQlwiLFwiaW1hZ2VcIjpcIlxcdTIxMTFcIixcIkltYWdpbmFyeUlcIjpcIlxcdTIxNDhcIixcImltYWdsaW5lXCI6XCJcXHUyMTEwXCIsXCJpbWFncGFydFwiOlwiXFx1MjExMVwiLFwiaW1hdGhcIjpcIlxcdTAxMzFcIixcIkltXCI6XCJcXHUyMTExXCIsXCJpbW9mXCI6XCJcXHUyMkI3XCIsXCJpbXBlZFwiOlwiXFx1MDFCNVwiLFwiSW1wbGllc1wiOlwiXFx1MjFEMlwiLFwiaW5jYXJlXCI6XCJcXHUyMTA1XCIsXCJpblwiOlwiXFx1MjIwOFwiLFwiaW5maW5cIjpcIlxcdTIyMUVcIixcImluZmludGllXCI6XCJcXHUyOUREXCIsXCJpbm9kb3RcIjpcIlxcdTAxMzFcIixcImludGNhbFwiOlwiXFx1MjJCQVwiLFwiaW50XCI6XCJcXHUyMjJCXCIsXCJJbnRcIjpcIlxcdTIyMkNcIixcImludGVnZXJzXCI6XCJcXHUyMTI0XCIsXCJJbnRlZ3JhbFwiOlwiXFx1MjIyQlwiLFwiaW50ZXJjYWxcIjpcIlxcdTIyQkFcIixcIkludGVyc2VjdGlvblwiOlwiXFx1MjJDMlwiLFwiaW50bGFyaGtcIjpcIlxcdTJBMTdcIixcImludHByb2RcIjpcIlxcdTJBM0NcIixcIkludmlzaWJsZUNvbW1hXCI6XCJcXHUyMDYzXCIsXCJJbnZpc2libGVUaW1lc1wiOlwiXFx1MjA2MlwiLFwiSU9jeVwiOlwiXFx1MDQwMVwiLFwiaW9jeVwiOlwiXFx1MDQ1MVwiLFwiSW9nb25cIjpcIlxcdTAxMkVcIixcImlvZ29uXCI6XCJcXHUwMTJGXCIsXCJJb3BmXCI6XCJcXHVEODM1XFx1REQ0MFwiLFwiaW9wZlwiOlwiXFx1RDgzNVxcdURENUFcIixcIklvdGFcIjpcIlxcdTAzOTlcIixcImlvdGFcIjpcIlxcdTAzQjlcIixcImlwcm9kXCI6XCJcXHUyQTNDXCIsXCJpcXVlc3RcIjpcIlxceEJGXCIsXCJpc2NyXCI6XCJcXHVEODM1XFx1RENCRVwiLFwiSXNjclwiOlwiXFx1MjExMFwiLFwiaXNpblwiOlwiXFx1MjIwOFwiLFwiaXNpbmRvdFwiOlwiXFx1MjJGNVwiLFwiaXNpbkVcIjpcIlxcdTIyRjlcIixcImlzaW5zXCI6XCJcXHUyMkY0XCIsXCJpc2luc3ZcIjpcIlxcdTIyRjNcIixcImlzaW52XCI6XCJcXHUyMjA4XCIsXCJpdFwiOlwiXFx1MjA2MlwiLFwiSXRpbGRlXCI6XCJcXHUwMTI4XCIsXCJpdGlsZGVcIjpcIlxcdTAxMjlcIixcIkl1a2N5XCI6XCJcXHUwNDA2XCIsXCJpdWtjeVwiOlwiXFx1MDQ1NlwiLFwiSXVtbFwiOlwiXFx4Q0ZcIixcIml1bWxcIjpcIlxceEVGXCIsXCJKY2lyY1wiOlwiXFx1MDEzNFwiLFwiamNpcmNcIjpcIlxcdTAxMzVcIixcIkpjeVwiOlwiXFx1MDQxOVwiLFwiamN5XCI6XCJcXHUwNDM5XCIsXCJKZnJcIjpcIlxcdUQ4MzVcXHVERDBEXCIsXCJqZnJcIjpcIlxcdUQ4MzVcXHVERDI3XCIsXCJqbWF0aFwiOlwiXFx1MDIzN1wiLFwiSm9wZlwiOlwiXFx1RDgzNVxcdURENDFcIixcImpvcGZcIjpcIlxcdUQ4MzVcXHVERDVCXCIsXCJKc2NyXCI6XCJcXHVEODM1XFx1RENBNVwiLFwianNjclwiOlwiXFx1RDgzNVxcdURDQkZcIixcIkpzZXJjeVwiOlwiXFx1MDQwOFwiLFwianNlcmN5XCI6XCJcXHUwNDU4XCIsXCJKdWtjeVwiOlwiXFx1MDQwNFwiLFwianVrY3lcIjpcIlxcdTA0NTRcIixcIkthcHBhXCI6XCJcXHUwMzlBXCIsXCJrYXBwYVwiOlwiXFx1MDNCQVwiLFwia2FwcGF2XCI6XCJcXHUwM0YwXCIsXCJLY2VkaWxcIjpcIlxcdTAxMzZcIixcImtjZWRpbFwiOlwiXFx1MDEzN1wiLFwiS2N5XCI6XCJcXHUwNDFBXCIsXCJrY3lcIjpcIlxcdTA0M0FcIixcIktmclwiOlwiXFx1RDgzNVxcdUREMEVcIixcImtmclwiOlwiXFx1RDgzNVxcdUREMjhcIixcImtncmVlblwiOlwiXFx1MDEzOFwiLFwiS0hjeVwiOlwiXFx1MDQyNVwiLFwia2hjeVwiOlwiXFx1MDQ0NVwiLFwiS0pjeVwiOlwiXFx1MDQwQ1wiLFwia2pjeVwiOlwiXFx1MDQ1Q1wiLFwiS29wZlwiOlwiXFx1RDgzNVxcdURENDJcIixcImtvcGZcIjpcIlxcdUQ4MzVcXHVERDVDXCIsXCJLc2NyXCI6XCJcXHVEODM1XFx1RENBNlwiLFwia3NjclwiOlwiXFx1RDgzNVxcdURDQzBcIixcImxBYXJyXCI6XCJcXHUyMURBXCIsXCJMYWN1dGVcIjpcIlxcdTAxMzlcIixcImxhY3V0ZVwiOlwiXFx1MDEzQVwiLFwibGFlbXB0eXZcIjpcIlxcdTI5QjRcIixcImxhZ3JhblwiOlwiXFx1MjExMlwiLFwiTGFtYmRhXCI6XCJcXHUwMzlCXCIsXCJsYW1iZGFcIjpcIlxcdTAzQkJcIixcImxhbmdcIjpcIlxcdTI3RThcIixcIkxhbmdcIjpcIlxcdTI3RUFcIixcImxhbmdkXCI6XCJcXHUyOTkxXCIsXCJsYW5nbGVcIjpcIlxcdTI3RThcIixcImxhcFwiOlwiXFx1MkE4NVwiLFwiTGFwbGFjZXRyZlwiOlwiXFx1MjExMlwiLFwibGFxdW9cIjpcIlxceEFCXCIsXCJsYXJyYlwiOlwiXFx1MjFFNFwiLFwibGFycmJmc1wiOlwiXFx1MjkxRlwiLFwibGFyclwiOlwiXFx1MjE5MFwiLFwiTGFyclwiOlwiXFx1MjE5RVwiLFwibEFyclwiOlwiXFx1MjFEMFwiLFwibGFycmZzXCI6XCJcXHUyOTFEXCIsXCJsYXJyaGtcIjpcIlxcdTIxQTlcIixcImxhcnJscFwiOlwiXFx1MjFBQlwiLFwibGFycnBsXCI6XCJcXHUyOTM5XCIsXCJsYXJyc2ltXCI6XCJcXHUyOTczXCIsXCJsYXJydGxcIjpcIlxcdTIxQTJcIixcImxhdGFpbFwiOlwiXFx1MjkxOVwiLFwibEF0YWlsXCI6XCJcXHUyOTFCXCIsXCJsYXRcIjpcIlxcdTJBQUJcIixcImxhdGVcIjpcIlxcdTJBQURcIixcImxhdGVzXCI6XCJcXHUyQUFEXFx1RkUwMFwiLFwibGJhcnJcIjpcIlxcdTI5MENcIixcImxCYXJyXCI6XCJcXHUyOTBFXCIsXCJsYmJya1wiOlwiXFx1Mjc3MlwiLFwibGJyYWNlXCI6XCJ7XCIsXCJsYnJhY2tcIjpcIltcIixcImxicmtlXCI6XCJcXHUyOThCXCIsXCJsYnJrc2xkXCI6XCJcXHUyOThGXCIsXCJsYnJrc2x1XCI6XCJcXHUyOThEXCIsXCJMY2Fyb25cIjpcIlxcdTAxM0RcIixcImxjYXJvblwiOlwiXFx1MDEzRVwiLFwiTGNlZGlsXCI6XCJcXHUwMTNCXCIsXCJsY2VkaWxcIjpcIlxcdTAxM0NcIixcImxjZWlsXCI6XCJcXHUyMzA4XCIsXCJsY3ViXCI6XCJ7XCIsXCJMY3lcIjpcIlxcdTA0MUJcIixcImxjeVwiOlwiXFx1MDQzQlwiLFwibGRjYVwiOlwiXFx1MjkzNlwiLFwibGRxdW9cIjpcIlxcdTIwMUNcIixcImxkcXVvclwiOlwiXFx1MjAxRVwiLFwibGRyZGhhclwiOlwiXFx1Mjk2N1wiLFwibGRydXNoYXJcIjpcIlxcdTI5NEJcIixcImxkc2hcIjpcIlxcdTIxQjJcIixcImxlXCI6XCJcXHUyMjY0XCIsXCJsRVwiOlwiXFx1MjI2NlwiLFwiTGVmdEFuZ2xlQnJhY2tldFwiOlwiXFx1MjdFOFwiLFwiTGVmdEFycm93QmFyXCI6XCJcXHUyMUU0XCIsXCJsZWZ0YXJyb3dcIjpcIlxcdTIxOTBcIixcIkxlZnRBcnJvd1wiOlwiXFx1MjE5MFwiLFwiTGVmdGFycm93XCI6XCJcXHUyMUQwXCIsXCJMZWZ0QXJyb3dSaWdodEFycm93XCI6XCJcXHUyMUM2XCIsXCJsZWZ0YXJyb3d0YWlsXCI6XCJcXHUyMUEyXCIsXCJMZWZ0Q2VpbGluZ1wiOlwiXFx1MjMwOFwiLFwiTGVmdERvdWJsZUJyYWNrZXRcIjpcIlxcdTI3RTZcIixcIkxlZnREb3duVGVlVmVjdG9yXCI6XCJcXHUyOTYxXCIsXCJMZWZ0RG93blZlY3RvckJhclwiOlwiXFx1Mjk1OVwiLFwiTGVmdERvd25WZWN0b3JcIjpcIlxcdTIxQzNcIixcIkxlZnRGbG9vclwiOlwiXFx1MjMwQVwiLFwibGVmdGhhcnBvb25kb3duXCI6XCJcXHUyMUJEXCIsXCJsZWZ0aGFycG9vbnVwXCI6XCJcXHUyMUJDXCIsXCJsZWZ0bGVmdGFycm93c1wiOlwiXFx1MjFDN1wiLFwibGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTIxOTRcIixcIkxlZnRSaWdodEFycm93XCI6XCJcXHUyMTk0XCIsXCJMZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjFENFwiLFwibGVmdHJpZ2h0YXJyb3dzXCI6XCJcXHUyMUM2XCIsXCJsZWZ0cmlnaHRoYXJwb29uc1wiOlwiXFx1MjFDQlwiLFwibGVmdHJpZ2h0c3F1aWdhcnJvd1wiOlwiXFx1MjFBRFwiLFwiTGVmdFJpZ2h0VmVjdG9yXCI6XCJcXHUyOTRFXCIsXCJMZWZ0VGVlQXJyb3dcIjpcIlxcdTIxQTRcIixcIkxlZnRUZWVcIjpcIlxcdTIyQTNcIixcIkxlZnRUZWVWZWN0b3JcIjpcIlxcdTI5NUFcIixcImxlZnR0aHJlZXRpbWVzXCI6XCJcXHUyMkNCXCIsXCJMZWZ0VHJpYW5nbGVCYXJcIjpcIlxcdTI5Q0ZcIixcIkxlZnRUcmlhbmdsZVwiOlwiXFx1MjJCMlwiLFwiTGVmdFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyQjRcIixcIkxlZnRVcERvd25WZWN0b3JcIjpcIlxcdTI5NTFcIixcIkxlZnRVcFRlZVZlY3RvclwiOlwiXFx1Mjk2MFwiLFwiTGVmdFVwVmVjdG9yQmFyXCI6XCJcXHUyOTU4XCIsXCJMZWZ0VXBWZWN0b3JcIjpcIlxcdTIxQkZcIixcIkxlZnRWZWN0b3JCYXJcIjpcIlxcdTI5NTJcIixcIkxlZnRWZWN0b3JcIjpcIlxcdTIxQkNcIixcImxFZ1wiOlwiXFx1MkE4QlwiLFwibGVnXCI6XCJcXHUyMkRBXCIsXCJsZXFcIjpcIlxcdTIyNjRcIixcImxlcXFcIjpcIlxcdTIyNjZcIixcImxlcXNsYW50XCI6XCJcXHUyQTdEXCIsXCJsZXNjY1wiOlwiXFx1MkFBOFwiLFwibGVzXCI6XCJcXHUyQTdEXCIsXCJsZXNkb3RcIjpcIlxcdTJBN0ZcIixcImxlc2RvdG9cIjpcIlxcdTJBODFcIixcImxlc2RvdG9yXCI6XCJcXHUyQTgzXCIsXCJsZXNnXCI6XCJcXHUyMkRBXFx1RkUwMFwiLFwibGVzZ2VzXCI6XCJcXHUyQTkzXCIsXCJsZXNzYXBwcm94XCI6XCJcXHUyQTg1XCIsXCJsZXNzZG90XCI6XCJcXHUyMkQ2XCIsXCJsZXNzZXFndHJcIjpcIlxcdTIyREFcIixcImxlc3NlcXFndHJcIjpcIlxcdTJBOEJcIixcIkxlc3NFcXVhbEdyZWF0ZXJcIjpcIlxcdTIyREFcIixcIkxlc3NGdWxsRXF1YWxcIjpcIlxcdTIyNjZcIixcIkxlc3NHcmVhdGVyXCI6XCJcXHUyMjc2XCIsXCJsZXNzZ3RyXCI6XCJcXHUyMjc2XCIsXCJMZXNzTGVzc1wiOlwiXFx1MkFBMVwiLFwibGVzc3NpbVwiOlwiXFx1MjI3MlwiLFwiTGVzc1NsYW50RXF1YWxcIjpcIlxcdTJBN0RcIixcIkxlc3NUaWxkZVwiOlwiXFx1MjI3MlwiLFwibGZpc2h0XCI6XCJcXHUyOTdDXCIsXCJsZmxvb3JcIjpcIlxcdTIzMEFcIixcIkxmclwiOlwiXFx1RDgzNVxcdUREMEZcIixcImxmclwiOlwiXFx1RDgzNVxcdUREMjlcIixcImxnXCI6XCJcXHUyMjc2XCIsXCJsZ0VcIjpcIlxcdTJBOTFcIixcImxIYXJcIjpcIlxcdTI5NjJcIixcImxoYXJkXCI6XCJcXHUyMUJEXCIsXCJsaGFydVwiOlwiXFx1MjFCQ1wiLFwibGhhcnVsXCI6XCJcXHUyOTZBXCIsXCJsaGJsa1wiOlwiXFx1MjU4NFwiLFwiTEpjeVwiOlwiXFx1MDQwOVwiLFwibGpjeVwiOlwiXFx1MDQ1OVwiLFwibGxhcnJcIjpcIlxcdTIxQzdcIixcImxsXCI6XCJcXHUyMjZBXCIsXCJMbFwiOlwiXFx1MjJEOFwiLFwibGxjb3JuZXJcIjpcIlxcdTIzMUVcIixcIkxsZWZ0YXJyb3dcIjpcIlxcdTIxREFcIixcImxsaGFyZFwiOlwiXFx1Mjk2QlwiLFwibGx0cmlcIjpcIlxcdTI1RkFcIixcIkxtaWRvdFwiOlwiXFx1MDEzRlwiLFwibG1pZG90XCI6XCJcXHUwMTQwXCIsXCJsbW91c3RhY2hlXCI6XCJcXHUyM0IwXCIsXCJsbW91c3RcIjpcIlxcdTIzQjBcIixcImxuYXBcIjpcIlxcdTJBODlcIixcImxuYXBwcm94XCI6XCJcXHUyQTg5XCIsXCJsbmVcIjpcIlxcdTJBODdcIixcImxuRVwiOlwiXFx1MjI2OFwiLFwibG5lcVwiOlwiXFx1MkE4N1wiLFwibG5lcXFcIjpcIlxcdTIyNjhcIixcImxuc2ltXCI6XCJcXHUyMkU2XCIsXCJsb2FuZ1wiOlwiXFx1MjdFQ1wiLFwibG9hcnJcIjpcIlxcdTIxRkRcIixcImxvYnJrXCI6XCJcXHUyN0U2XCIsXCJsb25nbGVmdGFycm93XCI6XCJcXHUyN0Y1XCIsXCJMb25nTGVmdEFycm93XCI6XCJcXHUyN0Y1XCIsXCJMb25nbGVmdGFycm93XCI6XCJcXHUyN0Y4XCIsXCJsb25nbGVmdHJpZ2h0YXJyb3dcIjpcIlxcdTI3RjdcIixcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwiXFx1MjdGN1wiLFwiTG9uZ2xlZnRyaWdodGFycm93XCI6XCJcXHUyN0ZBXCIsXCJsb25nbWFwc3RvXCI6XCJcXHUyN0ZDXCIsXCJsb25ncmlnaHRhcnJvd1wiOlwiXFx1MjdGNlwiLFwiTG9uZ1JpZ2h0QXJyb3dcIjpcIlxcdTI3RjZcIixcIkxvbmdyaWdodGFycm93XCI6XCJcXHUyN0Y5XCIsXCJsb29wYXJyb3dsZWZ0XCI6XCJcXHUyMUFCXCIsXCJsb29wYXJyb3dyaWdodFwiOlwiXFx1MjFBQ1wiLFwibG9wYXJcIjpcIlxcdTI5ODVcIixcIkxvcGZcIjpcIlxcdUQ4MzVcXHVERDQzXCIsXCJsb3BmXCI6XCJcXHVEODM1XFx1REQ1RFwiLFwibG9wbHVzXCI6XCJcXHUyQTJEXCIsXCJsb3RpbWVzXCI6XCJcXHUyQTM0XCIsXCJsb3dhc3RcIjpcIlxcdTIyMTdcIixcImxvd2JhclwiOlwiX1wiLFwiTG93ZXJMZWZ0QXJyb3dcIjpcIlxcdTIxOTlcIixcIkxvd2VyUmlnaHRBcnJvd1wiOlwiXFx1MjE5OFwiLFwibG96XCI6XCJcXHUyNUNBXCIsXCJsb3plbmdlXCI6XCJcXHUyNUNBXCIsXCJsb3pmXCI6XCJcXHUyOUVCXCIsXCJscGFyXCI6XCIoXCIsXCJscGFybHRcIjpcIlxcdTI5OTNcIixcImxyYXJyXCI6XCJcXHUyMUM2XCIsXCJscmNvcm5lclwiOlwiXFx1MjMxRlwiLFwibHJoYXJcIjpcIlxcdTIxQ0JcIixcImxyaGFyZFwiOlwiXFx1Mjk2RFwiLFwibHJtXCI6XCJcXHUyMDBFXCIsXCJscnRyaVwiOlwiXFx1MjJCRlwiLFwibHNhcXVvXCI6XCJcXHUyMDM5XCIsXCJsc2NyXCI6XCJcXHVEODM1XFx1RENDMVwiLFwiTHNjclwiOlwiXFx1MjExMlwiLFwibHNoXCI6XCJcXHUyMUIwXCIsXCJMc2hcIjpcIlxcdTIxQjBcIixcImxzaW1cIjpcIlxcdTIyNzJcIixcImxzaW1lXCI6XCJcXHUyQThEXCIsXCJsc2ltZ1wiOlwiXFx1MkE4RlwiLFwibHNxYlwiOlwiW1wiLFwibHNxdW9cIjpcIlxcdTIwMThcIixcImxzcXVvclwiOlwiXFx1MjAxQVwiLFwiTHN0cm9rXCI6XCJcXHUwMTQxXCIsXCJsc3Ryb2tcIjpcIlxcdTAxNDJcIixcImx0Y2NcIjpcIlxcdTJBQTZcIixcImx0Y2lyXCI6XCJcXHUyQTc5XCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIkx0XCI6XCJcXHUyMjZBXCIsXCJsdGRvdFwiOlwiXFx1MjJENlwiLFwibHRocmVlXCI6XCJcXHUyMkNCXCIsXCJsdGltZXNcIjpcIlxcdTIyQzlcIixcImx0bGFyclwiOlwiXFx1Mjk3NlwiLFwibHRxdWVzdFwiOlwiXFx1MkE3QlwiLFwibHRyaVwiOlwiXFx1MjVDM1wiLFwibHRyaWVcIjpcIlxcdTIyQjRcIixcImx0cmlmXCI6XCJcXHUyNUMyXCIsXCJsdHJQYXJcIjpcIlxcdTI5OTZcIixcImx1cmRzaGFyXCI6XCJcXHUyOTRBXCIsXCJsdXJ1aGFyXCI6XCJcXHUyOTY2XCIsXCJsdmVydG5lcXFcIjpcIlxcdTIyNjhcXHVGRTAwXCIsXCJsdm5FXCI6XCJcXHUyMjY4XFx1RkUwMFwiLFwibWFjclwiOlwiXFx4QUZcIixcIm1hbGVcIjpcIlxcdTI2NDJcIixcIm1hbHRcIjpcIlxcdTI3MjBcIixcIm1hbHRlc2VcIjpcIlxcdTI3MjBcIixcIk1hcFwiOlwiXFx1MjkwNVwiLFwibWFwXCI6XCJcXHUyMUE2XCIsXCJtYXBzdG9cIjpcIlxcdTIxQTZcIixcIm1hcHN0b2Rvd25cIjpcIlxcdTIxQTdcIixcIm1hcHN0b2xlZnRcIjpcIlxcdTIxQTRcIixcIm1hcHN0b3VwXCI6XCJcXHUyMUE1XCIsXCJtYXJrZXJcIjpcIlxcdTI1QUVcIixcIm1jb21tYVwiOlwiXFx1MkEyOVwiLFwiTWN5XCI6XCJcXHUwNDFDXCIsXCJtY3lcIjpcIlxcdTA0M0NcIixcIm1kYXNoXCI6XCJcXHUyMDE0XCIsXCJtRERvdFwiOlwiXFx1MjIzQVwiLFwibWVhc3VyZWRhbmdsZVwiOlwiXFx1MjIyMVwiLFwiTWVkaXVtU3BhY2VcIjpcIlxcdTIwNUZcIixcIk1lbGxpbnRyZlwiOlwiXFx1MjEzM1wiLFwiTWZyXCI6XCJcXHVEODM1XFx1REQxMFwiLFwibWZyXCI6XCJcXHVEODM1XFx1REQyQVwiLFwibWhvXCI6XCJcXHUyMTI3XCIsXCJtaWNyb1wiOlwiXFx4QjVcIixcIm1pZGFzdFwiOlwiKlwiLFwibWlkY2lyXCI6XCJcXHUyQUYwXCIsXCJtaWRcIjpcIlxcdTIyMjNcIixcIm1pZGRvdFwiOlwiXFx4QjdcIixcIm1pbnVzYlwiOlwiXFx1MjI5RlwiLFwibWludXNcIjpcIlxcdTIyMTJcIixcIm1pbnVzZFwiOlwiXFx1MjIzOFwiLFwibWludXNkdVwiOlwiXFx1MkEyQVwiLFwiTWludXNQbHVzXCI6XCJcXHUyMjEzXCIsXCJtbGNwXCI6XCJcXHUyQURCXCIsXCJtbGRyXCI6XCJcXHUyMDI2XCIsXCJtbnBsdXNcIjpcIlxcdTIyMTNcIixcIm1vZGVsc1wiOlwiXFx1MjJBN1wiLFwiTW9wZlwiOlwiXFx1RDgzNVxcdURENDRcIixcIm1vcGZcIjpcIlxcdUQ4MzVcXHVERDVFXCIsXCJtcFwiOlwiXFx1MjIxM1wiLFwibXNjclwiOlwiXFx1RDgzNVxcdURDQzJcIixcIk1zY3JcIjpcIlxcdTIxMzNcIixcIm1zdHBvc1wiOlwiXFx1MjIzRVwiLFwiTXVcIjpcIlxcdTAzOUNcIixcIm11XCI6XCJcXHUwM0JDXCIsXCJtdWx0aW1hcFwiOlwiXFx1MjJCOFwiLFwibXVtYXBcIjpcIlxcdTIyQjhcIixcIm5hYmxhXCI6XCJcXHUyMjA3XCIsXCJOYWN1dGVcIjpcIlxcdTAxNDNcIixcIm5hY3V0ZVwiOlwiXFx1MDE0NFwiLFwibmFuZ1wiOlwiXFx1MjIyMFxcdTIwRDJcIixcIm5hcFwiOlwiXFx1MjI0OVwiLFwibmFwRVwiOlwiXFx1MkE3MFxcdTAzMzhcIixcIm5hcGlkXCI6XCJcXHUyMjRCXFx1MDMzOFwiLFwibmFwb3NcIjpcIlxcdTAxNDlcIixcIm5hcHByb3hcIjpcIlxcdTIyNDlcIixcIm5hdHVyYWxcIjpcIlxcdTI2NkVcIixcIm5hdHVyYWxzXCI6XCJcXHUyMTE1XCIsXCJuYXR1clwiOlwiXFx1MjY2RVwiLFwibmJzcFwiOlwiXFx4QTBcIixcIm5idW1wXCI6XCJcXHUyMjRFXFx1MDMzOFwiLFwibmJ1bXBlXCI6XCJcXHUyMjRGXFx1MDMzOFwiLFwibmNhcFwiOlwiXFx1MkE0M1wiLFwiTmNhcm9uXCI6XCJcXHUwMTQ3XCIsXCJuY2Fyb25cIjpcIlxcdTAxNDhcIixcIk5jZWRpbFwiOlwiXFx1MDE0NVwiLFwibmNlZGlsXCI6XCJcXHUwMTQ2XCIsXCJuY29uZ1wiOlwiXFx1MjI0N1wiLFwibmNvbmdkb3RcIjpcIlxcdTJBNkRcXHUwMzM4XCIsXCJuY3VwXCI6XCJcXHUyQTQyXCIsXCJOY3lcIjpcIlxcdTA0MURcIixcIm5jeVwiOlwiXFx1MDQzRFwiLFwibmRhc2hcIjpcIlxcdTIwMTNcIixcIm5lYXJoa1wiOlwiXFx1MjkyNFwiLFwibmVhcnJcIjpcIlxcdTIxOTdcIixcIm5lQXJyXCI6XCJcXHUyMUQ3XCIsXCJuZWFycm93XCI6XCJcXHUyMTk3XCIsXCJuZVwiOlwiXFx1MjI2MFwiLFwibmVkb3RcIjpcIlxcdTIyNTBcXHUwMzM4XCIsXCJOZWdhdGl2ZU1lZGl1bVNwYWNlXCI6XCJcXHUyMDBCXCIsXCJOZWdhdGl2ZVRoaWNrU3BhY2VcIjpcIlxcdTIwMEJcIixcIk5lZ2F0aXZlVGhpblNwYWNlXCI6XCJcXHUyMDBCXCIsXCJOZWdhdGl2ZVZlcnlUaGluU3BhY2VcIjpcIlxcdTIwMEJcIixcIm5lcXVpdlwiOlwiXFx1MjI2MlwiLFwibmVzZWFyXCI6XCJcXHUyOTI4XCIsXCJuZXNpbVwiOlwiXFx1MjI0MlxcdTAzMzhcIixcIk5lc3RlZEdyZWF0ZXJHcmVhdGVyXCI6XCJcXHUyMjZCXCIsXCJOZXN0ZWRMZXNzTGVzc1wiOlwiXFx1MjI2QVwiLFwiTmV3TGluZVwiOlwiXFxuXCIsXCJuZXhpc3RcIjpcIlxcdTIyMDRcIixcIm5leGlzdHNcIjpcIlxcdTIyMDRcIixcIk5mclwiOlwiXFx1RDgzNVxcdUREMTFcIixcIm5mclwiOlwiXFx1RDgzNVxcdUREMkJcIixcIm5nRVwiOlwiXFx1MjI2N1xcdTAzMzhcIixcIm5nZVwiOlwiXFx1MjI3MVwiLFwibmdlcVwiOlwiXFx1MjI3MVwiLFwibmdlcXFcIjpcIlxcdTIyNjdcXHUwMzM4XCIsXCJuZ2Vxc2xhbnRcIjpcIlxcdTJBN0VcXHUwMzM4XCIsXCJuZ2VzXCI6XCJcXHUyQTdFXFx1MDMzOFwiLFwibkdnXCI6XCJcXHUyMkQ5XFx1MDMzOFwiLFwibmdzaW1cIjpcIlxcdTIyNzVcIixcIm5HdFwiOlwiXFx1MjI2QlxcdTIwRDJcIixcIm5ndFwiOlwiXFx1MjI2RlwiLFwibmd0clwiOlwiXFx1MjI2RlwiLFwibkd0dlwiOlwiXFx1MjI2QlxcdTAzMzhcIixcIm5oYXJyXCI6XCJcXHUyMUFFXCIsXCJuaEFyclwiOlwiXFx1MjFDRVwiLFwibmhwYXJcIjpcIlxcdTJBRjJcIixcIm5pXCI6XCJcXHUyMjBCXCIsXCJuaXNcIjpcIlxcdTIyRkNcIixcIm5pc2RcIjpcIlxcdTIyRkFcIixcIm5pdlwiOlwiXFx1MjIwQlwiLFwiTkpjeVwiOlwiXFx1MDQwQVwiLFwibmpjeVwiOlwiXFx1MDQ1QVwiLFwibmxhcnJcIjpcIlxcdTIxOUFcIixcIm5sQXJyXCI6XCJcXHUyMUNEXCIsXCJubGRyXCI6XCJcXHUyMDI1XCIsXCJubEVcIjpcIlxcdTIyNjZcXHUwMzM4XCIsXCJubGVcIjpcIlxcdTIyNzBcIixcIm5sZWZ0YXJyb3dcIjpcIlxcdTIxOUFcIixcIm5MZWZ0YXJyb3dcIjpcIlxcdTIxQ0RcIixcIm5sZWZ0cmlnaHRhcnJvd1wiOlwiXFx1MjFBRVwiLFwibkxlZnRyaWdodGFycm93XCI6XCJcXHUyMUNFXCIsXCJubGVxXCI6XCJcXHUyMjcwXCIsXCJubGVxcVwiOlwiXFx1MjI2NlxcdTAzMzhcIixcIm5sZXFzbGFudFwiOlwiXFx1MkE3RFxcdTAzMzhcIixcIm5sZXNcIjpcIlxcdTJBN0RcXHUwMzM4XCIsXCJubGVzc1wiOlwiXFx1MjI2RVwiLFwibkxsXCI6XCJcXHUyMkQ4XFx1MDMzOFwiLFwibmxzaW1cIjpcIlxcdTIyNzRcIixcIm5MdFwiOlwiXFx1MjI2QVxcdTIwRDJcIixcIm5sdFwiOlwiXFx1MjI2RVwiLFwibmx0cmlcIjpcIlxcdTIyRUFcIixcIm5sdHJpZVwiOlwiXFx1MjJFQ1wiLFwibkx0dlwiOlwiXFx1MjI2QVxcdTAzMzhcIixcIm5taWRcIjpcIlxcdTIyMjRcIixcIk5vQnJlYWtcIjpcIlxcdTIwNjBcIixcIk5vbkJyZWFraW5nU3BhY2VcIjpcIlxceEEwXCIsXCJub3BmXCI6XCJcXHVEODM1XFx1REQ1RlwiLFwiTm9wZlwiOlwiXFx1MjExNVwiLFwiTm90XCI6XCJcXHUyQUVDXCIsXCJub3RcIjpcIlxceEFDXCIsXCJOb3RDb25ncnVlbnRcIjpcIlxcdTIyNjJcIixcIk5vdEN1cENhcFwiOlwiXFx1MjI2RFwiLFwiTm90RG91YmxlVmVydGljYWxCYXJcIjpcIlxcdTIyMjZcIixcIk5vdEVsZW1lbnRcIjpcIlxcdTIyMDlcIixcIk5vdEVxdWFsXCI6XCJcXHUyMjYwXCIsXCJOb3RFcXVhbFRpbGRlXCI6XCJcXHUyMjQyXFx1MDMzOFwiLFwiTm90RXhpc3RzXCI6XCJcXHUyMjA0XCIsXCJOb3RHcmVhdGVyXCI6XCJcXHUyMjZGXCIsXCJOb3RHcmVhdGVyRXF1YWxcIjpcIlxcdTIyNzFcIixcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjpcIlxcdTIyNjdcXHUwMzM4XCIsXCJOb3RHcmVhdGVyR3JlYXRlclwiOlwiXFx1MjI2QlxcdTAzMzhcIixcIk5vdEdyZWF0ZXJMZXNzXCI6XCJcXHUyMjc5XCIsXCJOb3RHcmVhdGVyU2xhbnRFcXVhbFwiOlwiXFx1MkE3RVxcdTAzMzhcIixcIk5vdEdyZWF0ZXJUaWxkZVwiOlwiXFx1MjI3NVwiLFwiTm90SHVtcERvd25IdW1wXCI6XCJcXHUyMjRFXFx1MDMzOFwiLFwiTm90SHVtcEVxdWFsXCI6XCJcXHUyMjRGXFx1MDMzOFwiLFwibm90aW5cIjpcIlxcdTIyMDlcIixcIm5vdGluZG90XCI6XCJcXHUyMkY1XFx1MDMzOFwiLFwibm90aW5FXCI6XCJcXHUyMkY5XFx1MDMzOFwiLFwibm90aW52YVwiOlwiXFx1MjIwOVwiLFwibm90aW52YlwiOlwiXFx1MjJGN1wiLFwibm90aW52Y1wiOlwiXFx1MjJGNlwiLFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6XCJcXHUyOUNGXFx1MDMzOFwiLFwiTm90TGVmdFRyaWFuZ2xlXCI6XCJcXHUyMkVBXCIsXCJOb3RMZWZ0VHJpYW5nbGVFcXVhbFwiOlwiXFx1MjJFQ1wiLFwiTm90TGVzc1wiOlwiXFx1MjI2RVwiLFwiTm90TGVzc0VxdWFsXCI6XCJcXHUyMjcwXCIsXCJOb3RMZXNzR3JlYXRlclwiOlwiXFx1MjI3OFwiLFwiTm90TGVzc0xlc3NcIjpcIlxcdTIyNkFcXHUwMzM4XCIsXCJOb3RMZXNzU2xhbnRFcXVhbFwiOlwiXFx1MkE3RFxcdTAzMzhcIixcIk5vdExlc3NUaWxkZVwiOlwiXFx1MjI3NFwiLFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIlxcdTJBQTJcXHUwMzM4XCIsXCJOb3ROZXN0ZWRMZXNzTGVzc1wiOlwiXFx1MkFBMVxcdTAzMzhcIixcIm5vdG5pXCI6XCJcXHUyMjBDXCIsXCJub3RuaXZhXCI6XCJcXHUyMjBDXCIsXCJub3RuaXZiXCI6XCJcXHUyMkZFXCIsXCJub3RuaXZjXCI6XCJcXHUyMkZEXCIsXCJOb3RQcmVjZWRlc1wiOlwiXFx1MjI4MFwiLFwiTm90UHJlY2VkZXNFcXVhbFwiOlwiXFx1MkFBRlxcdTAzMzhcIixcIk5vdFByZWNlZGVzU2xhbnRFcXVhbFwiOlwiXFx1MjJFMFwiLFwiTm90UmV2ZXJzZUVsZW1lbnRcIjpcIlxcdTIyMENcIixcIk5vdFJpZ2h0VHJpYW5nbGVCYXJcIjpcIlxcdTI5RDBcXHUwMzM4XCIsXCJOb3RSaWdodFRyaWFuZ2xlXCI6XCJcXHUyMkVCXCIsXCJOb3RSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIlxcdTIyRURcIixcIk5vdFNxdWFyZVN1YnNldFwiOlwiXFx1MjI4RlxcdTAzMzhcIixcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6XCJcXHUyMkUyXCIsXCJOb3RTcXVhcmVTdXBlcnNldFwiOlwiXFx1MjI5MFxcdTAzMzhcIixcIk5vdFNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyRTNcIixcIk5vdFN1YnNldFwiOlwiXFx1MjI4MlxcdTIwRDJcIixcIk5vdFN1YnNldEVxdWFsXCI6XCJcXHUyMjg4XCIsXCJOb3RTdWNjZWVkc1wiOlwiXFx1MjI4MVwiLFwiTm90U3VjY2VlZHNFcXVhbFwiOlwiXFx1MkFCMFxcdTAzMzhcIixcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwiXFx1MjJFMVwiLFwiTm90U3VjY2VlZHNUaWxkZVwiOlwiXFx1MjI3RlxcdTAzMzhcIixcIk5vdFN1cGVyc2V0XCI6XCJcXHUyMjgzXFx1MjBEMlwiLFwiTm90U3VwZXJzZXRFcXVhbFwiOlwiXFx1MjI4OVwiLFwiTm90VGlsZGVcIjpcIlxcdTIyNDFcIixcIk5vdFRpbGRlRXF1YWxcIjpcIlxcdTIyNDRcIixcIk5vdFRpbGRlRnVsbEVxdWFsXCI6XCJcXHUyMjQ3XCIsXCJOb3RUaWxkZVRpbGRlXCI6XCJcXHUyMjQ5XCIsXCJOb3RWZXJ0aWNhbEJhclwiOlwiXFx1MjIyNFwiLFwibnBhcmFsbGVsXCI6XCJcXHUyMjI2XCIsXCJucGFyXCI6XCJcXHUyMjI2XCIsXCJucGFyc2xcIjpcIlxcdTJBRkRcXHUyMEU1XCIsXCJucGFydFwiOlwiXFx1MjIwMlxcdTAzMzhcIixcIm5wb2xpbnRcIjpcIlxcdTJBMTRcIixcIm5wclwiOlwiXFx1MjI4MFwiLFwibnByY3VlXCI6XCJcXHUyMkUwXCIsXCJucHJlY1wiOlwiXFx1MjI4MFwiLFwibnByZWNlcVwiOlwiXFx1MkFBRlxcdTAzMzhcIixcIm5wcmVcIjpcIlxcdTJBQUZcXHUwMzM4XCIsXCJucmFycmNcIjpcIlxcdTI5MzNcXHUwMzM4XCIsXCJucmFyclwiOlwiXFx1MjE5QlwiLFwibnJBcnJcIjpcIlxcdTIxQ0ZcIixcIm5yYXJyd1wiOlwiXFx1MjE5RFxcdTAzMzhcIixcIm5yaWdodGFycm93XCI6XCJcXHUyMTlCXCIsXCJuUmlnaHRhcnJvd1wiOlwiXFx1MjFDRlwiLFwibnJ0cmlcIjpcIlxcdTIyRUJcIixcIm5ydHJpZVwiOlwiXFx1MjJFRFwiLFwibnNjXCI6XCJcXHUyMjgxXCIsXCJuc2NjdWVcIjpcIlxcdTIyRTFcIixcIm5zY2VcIjpcIlxcdTJBQjBcXHUwMzM4XCIsXCJOc2NyXCI6XCJcXHVEODM1XFx1RENBOVwiLFwibnNjclwiOlwiXFx1RDgzNVxcdURDQzNcIixcIm5zaG9ydG1pZFwiOlwiXFx1MjIyNFwiLFwibnNob3J0cGFyYWxsZWxcIjpcIlxcdTIyMjZcIixcIm5zaW1cIjpcIlxcdTIyNDFcIixcIm5zaW1lXCI6XCJcXHUyMjQ0XCIsXCJuc2ltZXFcIjpcIlxcdTIyNDRcIixcIm5zbWlkXCI6XCJcXHUyMjI0XCIsXCJuc3BhclwiOlwiXFx1MjIyNlwiLFwibnNxc3ViZVwiOlwiXFx1MjJFMlwiLFwibnNxc3VwZVwiOlwiXFx1MjJFM1wiLFwibnN1YlwiOlwiXFx1MjI4NFwiLFwibnN1YkVcIjpcIlxcdTJBQzVcXHUwMzM4XCIsXCJuc3ViZVwiOlwiXFx1MjI4OFwiLFwibnN1YnNldFwiOlwiXFx1MjI4MlxcdTIwRDJcIixcIm5zdWJzZXRlcVwiOlwiXFx1MjI4OFwiLFwibnN1YnNldGVxcVwiOlwiXFx1MkFDNVxcdTAzMzhcIixcIm5zdWNjXCI6XCJcXHUyMjgxXCIsXCJuc3VjY2VxXCI6XCJcXHUyQUIwXFx1MDMzOFwiLFwibnN1cFwiOlwiXFx1MjI4NVwiLFwibnN1cEVcIjpcIlxcdTJBQzZcXHUwMzM4XCIsXCJuc3VwZVwiOlwiXFx1MjI4OVwiLFwibnN1cHNldFwiOlwiXFx1MjI4M1xcdTIwRDJcIixcIm5zdXBzZXRlcVwiOlwiXFx1MjI4OVwiLFwibnN1cHNldGVxcVwiOlwiXFx1MkFDNlxcdTAzMzhcIixcIm50Z2xcIjpcIlxcdTIyNzlcIixcIk50aWxkZVwiOlwiXFx4RDFcIixcIm50aWxkZVwiOlwiXFx4RjFcIixcIm50bGdcIjpcIlxcdTIyNzhcIixcIm50cmlhbmdsZWxlZnRcIjpcIlxcdTIyRUFcIixcIm50cmlhbmdsZWxlZnRlcVwiOlwiXFx1MjJFQ1wiLFwibnRyaWFuZ2xlcmlnaHRcIjpcIlxcdTIyRUJcIixcIm50cmlhbmdsZXJpZ2h0ZXFcIjpcIlxcdTIyRURcIixcIk51XCI6XCJcXHUwMzlEXCIsXCJudVwiOlwiXFx1MDNCRFwiLFwibnVtXCI6XCIjXCIsXCJudW1lcm9cIjpcIlxcdTIxMTZcIixcIm51bXNwXCI6XCJcXHUyMDA3XCIsXCJudmFwXCI6XCJcXHUyMjREXFx1MjBEMlwiLFwibnZkYXNoXCI6XCJcXHUyMkFDXCIsXCJudkRhc2hcIjpcIlxcdTIyQURcIixcIm5WZGFzaFwiOlwiXFx1MjJBRVwiLFwiblZEYXNoXCI6XCJcXHUyMkFGXCIsXCJudmdlXCI6XCJcXHUyMjY1XFx1MjBEMlwiLFwibnZndFwiOlwiPlxcdTIwRDJcIixcIm52SGFyclwiOlwiXFx1MjkwNFwiLFwibnZpbmZpblwiOlwiXFx1MjlERVwiLFwibnZsQXJyXCI6XCJcXHUyOTAyXCIsXCJudmxlXCI6XCJcXHUyMjY0XFx1MjBEMlwiLFwibnZsdFwiOlwiPFxcdTIwRDJcIixcIm52bHRyaWVcIjpcIlxcdTIyQjRcXHUyMEQyXCIsXCJudnJBcnJcIjpcIlxcdTI5MDNcIixcIm52cnRyaWVcIjpcIlxcdTIyQjVcXHUyMEQyXCIsXCJudnNpbVwiOlwiXFx1MjIzQ1xcdTIwRDJcIixcIm53YXJoa1wiOlwiXFx1MjkyM1wiLFwibndhcnJcIjpcIlxcdTIxOTZcIixcIm53QXJyXCI6XCJcXHUyMUQ2XCIsXCJud2Fycm93XCI6XCJcXHUyMTk2XCIsXCJud25lYXJcIjpcIlxcdTI5MjdcIixcIk9hY3V0ZVwiOlwiXFx4RDNcIixcIm9hY3V0ZVwiOlwiXFx4RjNcIixcIm9hc3RcIjpcIlxcdTIyOUJcIixcIk9jaXJjXCI6XCJcXHhENFwiLFwib2NpcmNcIjpcIlxceEY0XCIsXCJvY2lyXCI6XCJcXHUyMjlBXCIsXCJPY3lcIjpcIlxcdTA0MUVcIixcIm9jeVwiOlwiXFx1MDQzRVwiLFwib2Rhc2hcIjpcIlxcdTIyOURcIixcIk9kYmxhY1wiOlwiXFx1MDE1MFwiLFwib2RibGFjXCI6XCJcXHUwMTUxXCIsXCJvZGl2XCI6XCJcXHUyQTM4XCIsXCJvZG90XCI6XCJcXHUyMjk5XCIsXCJvZHNvbGRcIjpcIlxcdTI5QkNcIixcIk9FbGlnXCI6XCJcXHUwMTUyXCIsXCJvZWxpZ1wiOlwiXFx1MDE1M1wiLFwib2ZjaXJcIjpcIlxcdTI5QkZcIixcIk9mclwiOlwiXFx1RDgzNVxcdUREMTJcIixcIm9mclwiOlwiXFx1RDgzNVxcdUREMkNcIixcIm9nb25cIjpcIlxcdTAyREJcIixcIk9ncmF2ZVwiOlwiXFx4RDJcIixcIm9ncmF2ZVwiOlwiXFx4RjJcIixcIm9ndFwiOlwiXFx1MjlDMVwiLFwib2hiYXJcIjpcIlxcdTI5QjVcIixcIm9obVwiOlwiXFx1MDNBOVwiLFwib2ludFwiOlwiXFx1MjIyRVwiLFwib2xhcnJcIjpcIlxcdTIxQkFcIixcIm9sY2lyXCI6XCJcXHUyOUJFXCIsXCJvbGNyb3NzXCI6XCJcXHUyOUJCXCIsXCJvbGluZVwiOlwiXFx1MjAzRVwiLFwib2x0XCI6XCJcXHUyOUMwXCIsXCJPbWFjclwiOlwiXFx1MDE0Q1wiLFwib21hY3JcIjpcIlxcdTAxNERcIixcIk9tZWdhXCI6XCJcXHUwM0E5XCIsXCJvbWVnYVwiOlwiXFx1MDNDOVwiLFwiT21pY3JvblwiOlwiXFx1MDM5RlwiLFwib21pY3JvblwiOlwiXFx1MDNCRlwiLFwib21pZFwiOlwiXFx1MjlCNlwiLFwib21pbnVzXCI6XCJcXHUyMjk2XCIsXCJPb3BmXCI6XCJcXHVEODM1XFx1REQ0NlwiLFwib29wZlwiOlwiXFx1RDgzNVxcdURENjBcIixcIm9wYXJcIjpcIlxcdTI5QjdcIixcIk9wZW5DdXJseURvdWJsZVF1b3RlXCI6XCJcXHUyMDFDXCIsXCJPcGVuQ3VybHlRdW90ZVwiOlwiXFx1MjAxOFwiLFwib3BlcnBcIjpcIlxcdTI5QjlcIixcIm9wbHVzXCI6XCJcXHUyMjk1XCIsXCJvcmFyclwiOlwiXFx1MjFCQlwiLFwiT3JcIjpcIlxcdTJBNTRcIixcIm9yXCI6XCJcXHUyMjI4XCIsXCJvcmRcIjpcIlxcdTJBNURcIixcIm9yZGVyXCI6XCJcXHUyMTM0XCIsXCJvcmRlcm9mXCI6XCJcXHUyMTM0XCIsXCJvcmRmXCI6XCJcXHhBQVwiLFwib3JkbVwiOlwiXFx4QkFcIixcIm9yaWdvZlwiOlwiXFx1MjJCNlwiLFwib3JvclwiOlwiXFx1MkE1NlwiLFwib3JzbG9wZVwiOlwiXFx1MkE1N1wiLFwib3J2XCI6XCJcXHUyQTVCXCIsXCJvU1wiOlwiXFx1MjRDOFwiLFwiT3NjclwiOlwiXFx1RDgzNVxcdURDQUFcIixcIm9zY3JcIjpcIlxcdTIxMzRcIixcIk9zbGFzaFwiOlwiXFx4RDhcIixcIm9zbGFzaFwiOlwiXFx4RjhcIixcIm9zb2xcIjpcIlxcdTIyOThcIixcIk90aWxkZVwiOlwiXFx4RDVcIixcIm90aWxkZVwiOlwiXFx4RjVcIixcIm90aW1lc2FzXCI6XCJcXHUyQTM2XCIsXCJPdGltZXNcIjpcIlxcdTJBMzdcIixcIm90aW1lc1wiOlwiXFx1MjI5N1wiLFwiT3VtbFwiOlwiXFx4RDZcIixcIm91bWxcIjpcIlxceEY2XCIsXCJvdmJhclwiOlwiXFx1MjMzRFwiLFwiT3ZlckJhclwiOlwiXFx1MjAzRVwiLFwiT3ZlckJyYWNlXCI6XCJcXHUyM0RFXCIsXCJPdmVyQnJhY2tldFwiOlwiXFx1MjNCNFwiLFwiT3ZlclBhcmVudGhlc2lzXCI6XCJcXHUyM0RDXCIsXCJwYXJhXCI6XCJcXHhCNlwiLFwicGFyYWxsZWxcIjpcIlxcdTIyMjVcIixcInBhclwiOlwiXFx1MjIyNVwiLFwicGFyc2ltXCI6XCJcXHUyQUYzXCIsXCJwYXJzbFwiOlwiXFx1MkFGRFwiLFwicGFydFwiOlwiXFx1MjIwMlwiLFwiUGFydGlhbERcIjpcIlxcdTIyMDJcIixcIlBjeVwiOlwiXFx1MDQxRlwiLFwicGN5XCI6XCJcXHUwNDNGXCIsXCJwZXJjbnRcIjpcIiVcIixcInBlcmlvZFwiOlwiLlwiLFwicGVybWlsXCI6XCJcXHUyMDMwXCIsXCJwZXJwXCI6XCJcXHUyMkE1XCIsXCJwZXJ0ZW5rXCI6XCJcXHUyMDMxXCIsXCJQZnJcIjpcIlxcdUQ4MzVcXHVERDEzXCIsXCJwZnJcIjpcIlxcdUQ4MzVcXHVERDJEXCIsXCJQaGlcIjpcIlxcdTAzQTZcIixcInBoaVwiOlwiXFx1MDNDNlwiLFwicGhpdlwiOlwiXFx1MDNENVwiLFwicGhtbWF0XCI6XCJcXHUyMTMzXCIsXCJwaG9uZVwiOlwiXFx1MjYwRVwiLFwiUGlcIjpcIlxcdTAzQTBcIixcInBpXCI6XCJcXHUwM0MwXCIsXCJwaXRjaGZvcmtcIjpcIlxcdTIyRDRcIixcInBpdlwiOlwiXFx1MDNENlwiLFwicGxhbmNrXCI6XCJcXHUyMTBGXCIsXCJwbGFuY2toXCI6XCJcXHUyMTBFXCIsXCJwbGFua3ZcIjpcIlxcdTIxMEZcIixcInBsdXNhY2lyXCI6XCJcXHUyQTIzXCIsXCJwbHVzYlwiOlwiXFx1MjI5RVwiLFwicGx1c2NpclwiOlwiXFx1MkEyMlwiLFwicGx1c1wiOlwiK1wiLFwicGx1c2RvXCI6XCJcXHUyMjE0XCIsXCJwbHVzZHVcIjpcIlxcdTJBMjVcIixcInBsdXNlXCI6XCJcXHUyQTcyXCIsXCJQbHVzTWludXNcIjpcIlxceEIxXCIsXCJwbHVzbW5cIjpcIlxceEIxXCIsXCJwbHVzc2ltXCI6XCJcXHUyQTI2XCIsXCJwbHVzdHdvXCI6XCJcXHUyQTI3XCIsXCJwbVwiOlwiXFx4QjFcIixcIlBvaW5jYXJlcGxhbmVcIjpcIlxcdTIxMENcIixcInBvaW50aW50XCI6XCJcXHUyQTE1XCIsXCJwb3BmXCI6XCJcXHVEODM1XFx1REQ2MVwiLFwiUG9wZlwiOlwiXFx1MjExOVwiLFwicG91bmRcIjpcIlxceEEzXCIsXCJwcmFwXCI6XCJcXHUyQUI3XCIsXCJQclwiOlwiXFx1MkFCQlwiLFwicHJcIjpcIlxcdTIyN0FcIixcInByY3VlXCI6XCJcXHUyMjdDXCIsXCJwcmVjYXBwcm94XCI6XCJcXHUyQUI3XCIsXCJwcmVjXCI6XCJcXHUyMjdBXCIsXCJwcmVjY3VybHllcVwiOlwiXFx1MjI3Q1wiLFwiUHJlY2VkZXNcIjpcIlxcdTIyN0FcIixcIlByZWNlZGVzRXF1YWxcIjpcIlxcdTJBQUZcIixcIlByZWNlZGVzU2xhbnRFcXVhbFwiOlwiXFx1MjI3Q1wiLFwiUHJlY2VkZXNUaWxkZVwiOlwiXFx1MjI3RVwiLFwicHJlY2VxXCI6XCJcXHUyQUFGXCIsXCJwcmVjbmFwcHJveFwiOlwiXFx1MkFCOVwiLFwicHJlY25lcXFcIjpcIlxcdTJBQjVcIixcInByZWNuc2ltXCI6XCJcXHUyMkU4XCIsXCJwcmVcIjpcIlxcdTJBQUZcIixcInByRVwiOlwiXFx1MkFCM1wiLFwicHJlY3NpbVwiOlwiXFx1MjI3RVwiLFwicHJpbWVcIjpcIlxcdTIwMzJcIixcIlByaW1lXCI6XCJcXHUyMDMzXCIsXCJwcmltZXNcIjpcIlxcdTIxMTlcIixcInBybmFwXCI6XCJcXHUyQUI5XCIsXCJwcm5FXCI6XCJcXHUyQUI1XCIsXCJwcm5zaW1cIjpcIlxcdTIyRThcIixcInByb2RcIjpcIlxcdTIyMEZcIixcIlByb2R1Y3RcIjpcIlxcdTIyMEZcIixcInByb2ZhbGFyXCI6XCJcXHUyMzJFXCIsXCJwcm9mbGluZVwiOlwiXFx1MjMxMlwiLFwicHJvZnN1cmZcIjpcIlxcdTIzMTNcIixcInByb3BcIjpcIlxcdTIyMURcIixcIlByb3BvcnRpb25hbFwiOlwiXFx1MjIxRFwiLFwiUHJvcG9ydGlvblwiOlwiXFx1MjIzN1wiLFwicHJvcHRvXCI6XCJcXHUyMjFEXCIsXCJwcnNpbVwiOlwiXFx1MjI3RVwiLFwicHJ1cmVsXCI6XCJcXHUyMkIwXCIsXCJQc2NyXCI6XCJcXHVEODM1XFx1RENBQlwiLFwicHNjclwiOlwiXFx1RDgzNVxcdURDQzVcIixcIlBzaVwiOlwiXFx1MDNBOFwiLFwicHNpXCI6XCJcXHUwM0M4XCIsXCJwdW5jc3BcIjpcIlxcdTIwMDhcIixcIlFmclwiOlwiXFx1RDgzNVxcdUREMTRcIixcInFmclwiOlwiXFx1RDgzNVxcdUREMkVcIixcInFpbnRcIjpcIlxcdTJBMENcIixcInFvcGZcIjpcIlxcdUQ4MzVcXHVERDYyXCIsXCJRb3BmXCI6XCJcXHUyMTFBXCIsXCJxcHJpbWVcIjpcIlxcdTIwNTdcIixcIlFzY3JcIjpcIlxcdUQ4MzVcXHVEQ0FDXCIsXCJxc2NyXCI6XCJcXHVEODM1XFx1RENDNlwiLFwicXVhdGVybmlvbnNcIjpcIlxcdTIxMERcIixcInF1YXRpbnRcIjpcIlxcdTJBMTZcIixcInF1ZXN0XCI6XCI/XCIsXCJxdWVzdGVxXCI6XCJcXHUyMjVGXCIsXCJxdW90XCI6XCJcXFwiXCIsXCJRVU9UXCI6XCJcXFwiXCIsXCJyQWFyclwiOlwiXFx1MjFEQlwiLFwicmFjZVwiOlwiXFx1MjIzRFxcdTAzMzFcIixcIlJhY3V0ZVwiOlwiXFx1MDE1NFwiLFwicmFjdXRlXCI6XCJcXHUwMTU1XCIsXCJyYWRpY1wiOlwiXFx1MjIxQVwiLFwicmFlbXB0eXZcIjpcIlxcdTI5QjNcIixcInJhbmdcIjpcIlxcdTI3RTlcIixcIlJhbmdcIjpcIlxcdTI3RUJcIixcInJhbmdkXCI6XCJcXHUyOTkyXCIsXCJyYW5nZVwiOlwiXFx1MjlBNVwiLFwicmFuZ2xlXCI6XCJcXHUyN0U5XCIsXCJyYXF1b1wiOlwiXFx4QkJcIixcInJhcnJhcFwiOlwiXFx1Mjk3NVwiLFwicmFycmJcIjpcIlxcdTIxRTVcIixcInJhcnJiZnNcIjpcIlxcdTI5MjBcIixcInJhcnJjXCI6XCJcXHUyOTMzXCIsXCJyYXJyXCI6XCJcXHUyMTkyXCIsXCJSYXJyXCI6XCJcXHUyMUEwXCIsXCJyQXJyXCI6XCJcXHUyMUQyXCIsXCJyYXJyZnNcIjpcIlxcdTI5MUVcIixcInJhcnJoa1wiOlwiXFx1MjFBQVwiLFwicmFycmxwXCI6XCJcXHUyMUFDXCIsXCJyYXJycGxcIjpcIlxcdTI5NDVcIixcInJhcnJzaW1cIjpcIlxcdTI5NzRcIixcIlJhcnJ0bFwiOlwiXFx1MjkxNlwiLFwicmFycnRsXCI6XCJcXHUyMUEzXCIsXCJyYXJyd1wiOlwiXFx1MjE5RFwiLFwicmF0YWlsXCI6XCJcXHUyOTFBXCIsXCJyQXRhaWxcIjpcIlxcdTI5MUNcIixcInJhdGlvXCI6XCJcXHUyMjM2XCIsXCJyYXRpb25hbHNcIjpcIlxcdTIxMUFcIixcInJiYXJyXCI6XCJcXHUyOTBEXCIsXCJyQmFyclwiOlwiXFx1MjkwRlwiLFwiUkJhcnJcIjpcIlxcdTI5MTBcIixcInJiYnJrXCI6XCJcXHUyNzczXCIsXCJyYnJhY2VcIjpcIn1cIixcInJicmFja1wiOlwiXVwiLFwicmJya2VcIjpcIlxcdTI5OENcIixcInJicmtzbGRcIjpcIlxcdTI5OEVcIixcInJicmtzbHVcIjpcIlxcdTI5OTBcIixcIlJjYXJvblwiOlwiXFx1MDE1OFwiLFwicmNhcm9uXCI6XCJcXHUwMTU5XCIsXCJSY2VkaWxcIjpcIlxcdTAxNTZcIixcInJjZWRpbFwiOlwiXFx1MDE1N1wiLFwicmNlaWxcIjpcIlxcdTIzMDlcIixcInJjdWJcIjpcIn1cIixcIlJjeVwiOlwiXFx1MDQyMFwiLFwicmN5XCI6XCJcXHUwNDQwXCIsXCJyZGNhXCI6XCJcXHUyOTM3XCIsXCJyZGxkaGFyXCI6XCJcXHUyOTY5XCIsXCJyZHF1b1wiOlwiXFx1MjAxRFwiLFwicmRxdW9yXCI6XCJcXHUyMDFEXCIsXCJyZHNoXCI6XCJcXHUyMUIzXCIsXCJyZWFsXCI6XCJcXHUyMTFDXCIsXCJyZWFsaW5lXCI6XCJcXHUyMTFCXCIsXCJyZWFscGFydFwiOlwiXFx1MjExQ1wiLFwicmVhbHNcIjpcIlxcdTIxMURcIixcIlJlXCI6XCJcXHUyMTFDXCIsXCJyZWN0XCI6XCJcXHUyNUFEXCIsXCJyZWdcIjpcIlxceEFFXCIsXCJSRUdcIjpcIlxceEFFXCIsXCJSZXZlcnNlRWxlbWVudFwiOlwiXFx1MjIwQlwiLFwiUmV2ZXJzZUVxdWlsaWJyaXVtXCI6XCJcXHUyMUNCXCIsXCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOlwiXFx1Mjk2RlwiLFwicmZpc2h0XCI6XCJcXHUyOTdEXCIsXCJyZmxvb3JcIjpcIlxcdTIzMEJcIixcInJmclwiOlwiXFx1RDgzNVxcdUREMkZcIixcIlJmclwiOlwiXFx1MjExQ1wiLFwickhhclwiOlwiXFx1Mjk2NFwiLFwicmhhcmRcIjpcIlxcdTIxQzFcIixcInJoYXJ1XCI6XCJcXHUyMUMwXCIsXCJyaGFydWxcIjpcIlxcdTI5NkNcIixcIlJob1wiOlwiXFx1MDNBMVwiLFwicmhvXCI6XCJcXHUwM0MxXCIsXCJyaG92XCI6XCJcXHUwM0YxXCIsXCJSaWdodEFuZ2xlQnJhY2tldFwiOlwiXFx1MjdFOVwiLFwiUmlnaHRBcnJvd0JhclwiOlwiXFx1MjFFNVwiLFwicmlnaHRhcnJvd1wiOlwiXFx1MjE5MlwiLFwiUmlnaHRBcnJvd1wiOlwiXFx1MjE5MlwiLFwiUmlnaHRhcnJvd1wiOlwiXFx1MjFEMlwiLFwiUmlnaHRBcnJvd0xlZnRBcnJvd1wiOlwiXFx1MjFDNFwiLFwicmlnaHRhcnJvd3RhaWxcIjpcIlxcdTIxQTNcIixcIlJpZ2h0Q2VpbGluZ1wiOlwiXFx1MjMwOVwiLFwiUmlnaHREb3VibGVCcmFja2V0XCI6XCJcXHUyN0U3XCIsXCJSaWdodERvd25UZWVWZWN0b3JcIjpcIlxcdTI5NURcIixcIlJpZ2h0RG93blZlY3RvckJhclwiOlwiXFx1Mjk1NVwiLFwiUmlnaHREb3duVmVjdG9yXCI6XCJcXHUyMUMyXCIsXCJSaWdodEZsb29yXCI6XCJcXHUyMzBCXCIsXCJyaWdodGhhcnBvb25kb3duXCI6XCJcXHUyMUMxXCIsXCJyaWdodGhhcnBvb251cFwiOlwiXFx1MjFDMFwiLFwicmlnaHRsZWZ0YXJyb3dzXCI6XCJcXHUyMUM0XCIsXCJyaWdodGxlZnRoYXJwb29uc1wiOlwiXFx1MjFDQ1wiLFwicmlnaHRyaWdodGFycm93c1wiOlwiXFx1MjFDOVwiLFwicmlnaHRzcXVpZ2Fycm93XCI6XCJcXHUyMTlEXCIsXCJSaWdodFRlZUFycm93XCI6XCJcXHUyMUE2XCIsXCJSaWdodFRlZVwiOlwiXFx1MjJBMlwiLFwiUmlnaHRUZWVWZWN0b3JcIjpcIlxcdTI5NUJcIixcInJpZ2h0dGhyZWV0aW1lc1wiOlwiXFx1MjJDQ1wiLFwiUmlnaHRUcmlhbmdsZUJhclwiOlwiXFx1MjlEMFwiLFwiUmlnaHRUcmlhbmdsZVwiOlwiXFx1MjJCM1wiLFwiUmlnaHRUcmlhbmdsZUVxdWFsXCI6XCJcXHUyMkI1XCIsXCJSaWdodFVwRG93blZlY3RvclwiOlwiXFx1Mjk0RlwiLFwiUmlnaHRVcFRlZVZlY3RvclwiOlwiXFx1Mjk1Q1wiLFwiUmlnaHRVcFZlY3RvckJhclwiOlwiXFx1Mjk1NFwiLFwiUmlnaHRVcFZlY3RvclwiOlwiXFx1MjFCRVwiLFwiUmlnaHRWZWN0b3JCYXJcIjpcIlxcdTI5NTNcIixcIlJpZ2h0VmVjdG9yXCI6XCJcXHUyMUMwXCIsXCJyaW5nXCI6XCJcXHUwMkRBXCIsXCJyaXNpbmdkb3RzZXFcIjpcIlxcdTIyNTNcIixcInJsYXJyXCI6XCJcXHUyMUM0XCIsXCJybGhhclwiOlwiXFx1MjFDQ1wiLFwicmxtXCI6XCJcXHUyMDBGXCIsXCJybW91c3RhY2hlXCI6XCJcXHUyM0IxXCIsXCJybW91c3RcIjpcIlxcdTIzQjFcIixcInJubWlkXCI6XCJcXHUyQUVFXCIsXCJyb2FuZ1wiOlwiXFx1MjdFRFwiLFwicm9hcnJcIjpcIlxcdTIxRkVcIixcInJvYnJrXCI6XCJcXHUyN0U3XCIsXCJyb3BhclwiOlwiXFx1Mjk4NlwiLFwicm9wZlwiOlwiXFx1RDgzNVxcdURENjNcIixcIlJvcGZcIjpcIlxcdTIxMURcIixcInJvcGx1c1wiOlwiXFx1MkEyRVwiLFwicm90aW1lc1wiOlwiXFx1MkEzNVwiLFwiUm91bmRJbXBsaWVzXCI6XCJcXHUyOTcwXCIsXCJycGFyXCI6XCIpXCIsXCJycGFyZ3RcIjpcIlxcdTI5OTRcIixcInJwcG9saW50XCI6XCJcXHUyQTEyXCIsXCJycmFyclwiOlwiXFx1MjFDOVwiLFwiUnJpZ2h0YXJyb3dcIjpcIlxcdTIxREJcIixcInJzYXF1b1wiOlwiXFx1MjAzQVwiLFwicnNjclwiOlwiXFx1RDgzNVxcdURDQzdcIixcIlJzY3JcIjpcIlxcdTIxMUJcIixcInJzaFwiOlwiXFx1MjFCMVwiLFwiUnNoXCI6XCJcXHUyMUIxXCIsXCJyc3FiXCI6XCJdXCIsXCJyc3F1b1wiOlwiXFx1MjAxOVwiLFwicnNxdW9yXCI6XCJcXHUyMDE5XCIsXCJydGhyZWVcIjpcIlxcdTIyQ0NcIixcInJ0aW1lc1wiOlwiXFx1MjJDQVwiLFwicnRyaVwiOlwiXFx1MjVCOVwiLFwicnRyaWVcIjpcIlxcdTIyQjVcIixcInJ0cmlmXCI6XCJcXHUyNUI4XCIsXCJydHJpbHRyaVwiOlwiXFx1MjlDRVwiLFwiUnVsZURlbGF5ZWRcIjpcIlxcdTI5RjRcIixcInJ1bHVoYXJcIjpcIlxcdTI5NjhcIixcInJ4XCI6XCJcXHUyMTFFXCIsXCJTYWN1dGVcIjpcIlxcdTAxNUFcIixcInNhY3V0ZVwiOlwiXFx1MDE1QlwiLFwic2JxdW9cIjpcIlxcdTIwMUFcIixcInNjYXBcIjpcIlxcdTJBQjhcIixcIlNjYXJvblwiOlwiXFx1MDE2MFwiLFwic2Nhcm9uXCI6XCJcXHUwMTYxXCIsXCJTY1wiOlwiXFx1MkFCQ1wiLFwic2NcIjpcIlxcdTIyN0JcIixcInNjY3VlXCI6XCJcXHUyMjdEXCIsXCJzY2VcIjpcIlxcdTJBQjBcIixcInNjRVwiOlwiXFx1MkFCNFwiLFwiU2NlZGlsXCI6XCJcXHUwMTVFXCIsXCJzY2VkaWxcIjpcIlxcdTAxNUZcIixcIlNjaXJjXCI6XCJcXHUwMTVDXCIsXCJzY2lyY1wiOlwiXFx1MDE1RFwiLFwic2NuYXBcIjpcIlxcdTJBQkFcIixcInNjbkVcIjpcIlxcdTJBQjZcIixcInNjbnNpbVwiOlwiXFx1MjJFOVwiLFwic2Nwb2xpbnRcIjpcIlxcdTJBMTNcIixcInNjc2ltXCI6XCJcXHUyMjdGXCIsXCJTY3lcIjpcIlxcdTA0MjFcIixcInNjeVwiOlwiXFx1MDQ0MVwiLFwic2RvdGJcIjpcIlxcdTIyQTFcIixcInNkb3RcIjpcIlxcdTIyQzVcIixcInNkb3RlXCI6XCJcXHUyQTY2XCIsXCJzZWFyaGtcIjpcIlxcdTI5MjVcIixcInNlYXJyXCI6XCJcXHUyMTk4XCIsXCJzZUFyclwiOlwiXFx1MjFEOFwiLFwic2VhcnJvd1wiOlwiXFx1MjE5OFwiLFwic2VjdFwiOlwiXFx4QTdcIixcInNlbWlcIjpcIjtcIixcInNlc3dhclwiOlwiXFx1MjkyOVwiLFwic2V0bWludXNcIjpcIlxcdTIyMTZcIixcInNldG1uXCI6XCJcXHUyMjE2XCIsXCJzZXh0XCI6XCJcXHUyNzM2XCIsXCJTZnJcIjpcIlxcdUQ4MzVcXHVERDE2XCIsXCJzZnJcIjpcIlxcdUQ4MzVcXHVERDMwXCIsXCJzZnJvd25cIjpcIlxcdTIzMjJcIixcInNoYXJwXCI6XCJcXHUyNjZGXCIsXCJTSENIY3lcIjpcIlxcdTA0MjlcIixcInNoY2hjeVwiOlwiXFx1MDQ0OVwiLFwiU0hjeVwiOlwiXFx1MDQyOFwiLFwic2hjeVwiOlwiXFx1MDQ0OFwiLFwiU2hvcnREb3duQXJyb3dcIjpcIlxcdTIxOTNcIixcIlNob3J0TGVmdEFycm93XCI6XCJcXHUyMTkwXCIsXCJzaG9ydG1pZFwiOlwiXFx1MjIyM1wiLFwic2hvcnRwYXJhbGxlbFwiOlwiXFx1MjIyNVwiLFwiU2hvcnRSaWdodEFycm93XCI6XCJcXHUyMTkyXCIsXCJTaG9ydFVwQXJyb3dcIjpcIlxcdTIxOTFcIixcInNoeVwiOlwiXFx4QURcIixcIlNpZ21hXCI6XCJcXHUwM0EzXCIsXCJzaWdtYVwiOlwiXFx1MDNDM1wiLFwic2lnbWFmXCI6XCJcXHUwM0MyXCIsXCJzaWdtYXZcIjpcIlxcdTAzQzJcIixcInNpbVwiOlwiXFx1MjIzQ1wiLFwic2ltZG90XCI6XCJcXHUyQTZBXCIsXCJzaW1lXCI6XCJcXHUyMjQzXCIsXCJzaW1lcVwiOlwiXFx1MjI0M1wiLFwic2ltZ1wiOlwiXFx1MkE5RVwiLFwic2ltZ0VcIjpcIlxcdTJBQTBcIixcInNpbWxcIjpcIlxcdTJBOURcIixcInNpbWxFXCI6XCJcXHUyQTlGXCIsXCJzaW1uZVwiOlwiXFx1MjI0NlwiLFwic2ltcGx1c1wiOlwiXFx1MkEyNFwiLFwic2ltcmFyclwiOlwiXFx1Mjk3MlwiLFwic2xhcnJcIjpcIlxcdTIxOTBcIixcIlNtYWxsQ2lyY2xlXCI6XCJcXHUyMjE4XCIsXCJzbWFsbHNldG1pbnVzXCI6XCJcXHUyMjE2XCIsXCJzbWFzaHBcIjpcIlxcdTJBMzNcIixcInNtZXBhcnNsXCI6XCJcXHUyOUU0XCIsXCJzbWlkXCI6XCJcXHUyMjIzXCIsXCJzbWlsZVwiOlwiXFx1MjMyM1wiLFwic210XCI6XCJcXHUyQUFBXCIsXCJzbXRlXCI6XCJcXHUyQUFDXCIsXCJzbXRlc1wiOlwiXFx1MkFBQ1xcdUZFMDBcIixcIlNPRlRjeVwiOlwiXFx1MDQyQ1wiLFwic29mdGN5XCI6XCJcXHUwNDRDXCIsXCJzb2xiYXJcIjpcIlxcdTIzM0ZcIixcInNvbGJcIjpcIlxcdTI5QzRcIixcInNvbFwiOlwiL1wiLFwiU29wZlwiOlwiXFx1RDgzNVxcdURENEFcIixcInNvcGZcIjpcIlxcdUQ4MzVcXHVERDY0XCIsXCJzcGFkZXNcIjpcIlxcdTI2NjBcIixcInNwYWRlc3VpdFwiOlwiXFx1MjY2MFwiLFwic3BhclwiOlwiXFx1MjIyNVwiLFwic3FjYXBcIjpcIlxcdTIyOTNcIixcInNxY2Fwc1wiOlwiXFx1MjI5M1xcdUZFMDBcIixcInNxY3VwXCI6XCJcXHUyMjk0XCIsXCJzcWN1cHNcIjpcIlxcdTIyOTRcXHVGRTAwXCIsXCJTcXJ0XCI6XCJcXHUyMjFBXCIsXCJzcXN1YlwiOlwiXFx1MjI4RlwiLFwic3FzdWJlXCI6XCJcXHUyMjkxXCIsXCJzcXN1YnNldFwiOlwiXFx1MjI4RlwiLFwic3FzdWJzZXRlcVwiOlwiXFx1MjI5MVwiLFwic3FzdXBcIjpcIlxcdTIyOTBcIixcInNxc3VwZVwiOlwiXFx1MjI5MlwiLFwic3FzdXBzZXRcIjpcIlxcdTIyOTBcIixcInNxc3Vwc2V0ZXFcIjpcIlxcdTIyOTJcIixcInNxdWFyZVwiOlwiXFx1MjVBMVwiLFwiU3F1YXJlXCI6XCJcXHUyNUExXCIsXCJTcXVhcmVJbnRlcnNlY3Rpb25cIjpcIlxcdTIyOTNcIixcIlNxdWFyZVN1YnNldFwiOlwiXFx1MjI4RlwiLFwiU3F1YXJlU3Vic2V0RXF1YWxcIjpcIlxcdTIyOTFcIixcIlNxdWFyZVN1cGVyc2V0XCI6XCJcXHUyMjkwXCIsXCJTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCJcXHUyMjkyXCIsXCJTcXVhcmVVbmlvblwiOlwiXFx1MjI5NFwiLFwic3F1YXJmXCI6XCJcXHUyNUFBXCIsXCJzcXVcIjpcIlxcdTI1QTFcIixcInNxdWZcIjpcIlxcdTI1QUFcIixcInNyYXJyXCI6XCJcXHUyMTkyXCIsXCJTc2NyXCI6XCJcXHVEODM1XFx1RENBRVwiLFwic3NjclwiOlwiXFx1RDgzNVxcdURDQzhcIixcInNzZXRtblwiOlwiXFx1MjIxNlwiLFwic3NtaWxlXCI6XCJcXHUyMzIzXCIsXCJzc3RhcmZcIjpcIlxcdTIyQzZcIixcIlN0YXJcIjpcIlxcdTIyQzZcIixcInN0YXJcIjpcIlxcdTI2MDZcIixcInN0YXJmXCI6XCJcXHUyNjA1XCIsXCJzdHJhaWdodGVwc2lsb25cIjpcIlxcdTAzRjVcIixcInN0cmFpZ2h0cGhpXCI6XCJcXHUwM0Q1XCIsXCJzdHJuc1wiOlwiXFx4QUZcIixcInN1YlwiOlwiXFx1MjI4MlwiLFwiU3ViXCI6XCJcXHUyMkQwXCIsXCJzdWJkb3RcIjpcIlxcdTJBQkRcIixcInN1YkVcIjpcIlxcdTJBQzVcIixcInN1YmVcIjpcIlxcdTIyODZcIixcInN1YmVkb3RcIjpcIlxcdTJBQzNcIixcInN1Ym11bHRcIjpcIlxcdTJBQzFcIixcInN1Ym5FXCI6XCJcXHUyQUNCXCIsXCJzdWJuZVwiOlwiXFx1MjI4QVwiLFwic3VicGx1c1wiOlwiXFx1MkFCRlwiLFwic3VicmFyclwiOlwiXFx1Mjk3OVwiLFwic3Vic2V0XCI6XCJcXHUyMjgyXCIsXCJTdWJzZXRcIjpcIlxcdTIyRDBcIixcInN1YnNldGVxXCI6XCJcXHUyMjg2XCIsXCJzdWJzZXRlcXFcIjpcIlxcdTJBQzVcIixcIlN1YnNldEVxdWFsXCI6XCJcXHUyMjg2XCIsXCJzdWJzZXRuZXFcIjpcIlxcdTIyOEFcIixcInN1YnNldG5lcXFcIjpcIlxcdTJBQ0JcIixcInN1YnNpbVwiOlwiXFx1MkFDN1wiLFwic3Vic3ViXCI6XCJcXHUyQUQ1XCIsXCJzdWJzdXBcIjpcIlxcdTJBRDNcIixcInN1Y2NhcHByb3hcIjpcIlxcdTJBQjhcIixcInN1Y2NcIjpcIlxcdTIyN0JcIixcInN1Y2NjdXJseWVxXCI6XCJcXHUyMjdEXCIsXCJTdWNjZWVkc1wiOlwiXFx1MjI3QlwiLFwiU3VjY2VlZHNFcXVhbFwiOlwiXFx1MkFCMFwiLFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6XCJcXHUyMjdEXCIsXCJTdWNjZWVkc1RpbGRlXCI6XCJcXHUyMjdGXCIsXCJzdWNjZXFcIjpcIlxcdTJBQjBcIixcInN1Y2NuYXBwcm94XCI6XCJcXHUyQUJBXCIsXCJzdWNjbmVxcVwiOlwiXFx1MkFCNlwiLFwic3VjY25zaW1cIjpcIlxcdTIyRTlcIixcInN1Y2NzaW1cIjpcIlxcdTIyN0ZcIixcIlN1Y2hUaGF0XCI6XCJcXHUyMjBCXCIsXCJzdW1cIjpcIlxcdTIyMTFcIixcIlN1bVwiOlwiXFx1MjIxMVwiLFwic3VuZ1wiOlwiXFx1MjY2QVwiLFwic3VwMVwiOlwiXFx4QjlcIixcInN1cDJcIjpcIlxceEIyXCIsXCJzdXAzXCI6XCJcXHhCM1wiLFwic3VwXCI6XCJcXHUyMjgzXCIsXCJTdXBcIjpcIlxcdTIyRDFcIixcInN1cGRvdFwiOlwiXFx1MkFCRVwiLFwic3VwZHN1YlwiOlwiXFx1MkFEOFwiLFwic3VwRVwiOlwiXFx1MkFDNlwiLFwic3VwZVwiOlwiXFx1MjI4N1wiLFwic3VwZWRvdFwiOlwiXFx1MkFDNFwiLFwiU3VwZXJzZXRcIjpcIlxcdTIyODNcIixcIlN1cGVyc2V0RXF1YWxcIjpcIlxcdTIyODdcIixcInN1cGhzb2xcIjpcIlxcdTI3QzlcIixcInN1cGhzdWJcIjpcIlxcdTJBRDdcIixcInN1cGxhcnJcIjpcIlxcdTI5N0JcIixcInN1cG11bHRcIjpcIlxcdTJBQzJcIixcInN1cG5FXCI6XCJcXHUyQUNDXCIsXCJzdXBuZVwiOlwiXFx1MjI4QlwiLFwic3VwcGx1c1wiOlwiXFx1MkFDMFwiLFwic3Vwc2V0XCI6XCJcXHUyMjgzXCIsXCJTdXBzZXRcIjpcIlxcdTIyRDFcIixcInN1cHNldGVxXCI6XCJcXHUyMjg3XCIsXCJzdXBzZXRlcXFcIjpcIlxcdTJBQzZcIixcInN1cHNldG5lcVwiOlwiXFx1MjI4QlwiLFwic3Vwc2V0bmVxcVwiOlwiXFx1MkFDQ1wiLFwic3Vwc2ltXCI6XCJcXHUyQUM4XCIsXCJzdXBzdWJcIjpcIlxcdTJBRDRcIixcInN1cHN1cFwiOlwiXFx1MkFENlwiLFwic3dhcmhrXCI6XCJcXHUyOTI2XCIsXCJzd2FyclwiOlwiXFx1MjE5OVwiLFwic3dBcnJcIjpcIlxcdTIxRDlcIixcInN3YXJyb3dcIjpcIlxcdTIxOTlcIixcInN3bndhclwiOlwiXFx1MjkyQVwiLFwic3psaWdcIjpcIlxceERGXCIsXCJUYWJcIjpcIlxcdFwiLFwidGFyZ2V0XCI6XCJcXHUyMzE2XCIsXCJUYXVcIjpcIlxcdTAzQTRcIixcInRhdVwiOlwiXFx1MDNDNFwiLFwidGJya1wiOlwiXFx1MjNCNFwiLFwiVGNhcm9uXCI6XCJcXHUwMTY0XCIsXCJ0Y2Fyb25cIjpcIlxcdTAxNjVcIixcIlRjZWRpbFwiOlwiXFx1MDE2MlwiLFwidGNlZGlsXCI6XCJcXHUwMTYzXCIsXCJUY3lcIjpcIlxcdTA0MjJcIixcInRjeVwiOlwiXFx1MDQ0MlwiLFwidGRvdFwiOlwiXFx1MjBEQlwiLFwidGVscmVjXCI6XCJcXHUyMzE1XCIsXCJUZnJcIjpcIlxcdUQ4MzVcXHVERDE3XCIsXCJ0ZnJcIjpcIlxcdUQ4MzVcXHVERDMxXCIsXCJ0aGVyZTRcIjpcIlxcdTIyMzRcIixcInRoZXJlZm9yZVwiOlwiXFx1MjIzNFwiLFwiVGhlcmVmb3JlXCI6XCJcXHUyMjM0XCIsXCJUaGV0YVwiOlwiXFx1MDM5OFwiLFwidGhldGFcIjpcIlxcdTAzQjhcIixcInRoZXRhc3ltXCI6XCJcXHUwM0QxXCIsXCJ0aGV0YXZcIjpcIlxcdTAzRDFcIixcInRoaWNrYXBwcm94XCI6XCJcXHUyMjQ4XCIsXCJ0aGlja3NpbVwiOlwiXFx1MjIzQ1wiLFwiVGhpY2tTcGFjZVwiOlwiXFx1MjA1RlxcdTIwMEFcIixcIlRoaW5TcGFjZVwiOlwiXFx1MjAwOVwiLFwidGhpbnNwXCI6XCJcXHUyMDA5XCIsXCJ0aGthcFwiOlwiXFx1MjI0OFwiLFwidGhrc2ltXCI6XCJcXHUyMjNDXCIsXCJUSE9STlwiOlwiXFx4REVcIixcInRob3JuXCI6XCJcXHhGRVwiLFwidGlsZGVcIjpcIlxcdTAyRENcIixcIlRpbGRlXCI6XCJcXHUyMjNDXCIsXCJUaWxkZUVxdWFsXCI6XCJcXHUyMjQzXCIsXCJUaWxkZUZ1bGxFcXVhbFwiOlwiXFx1MjI0NVwiLFwiVGlsZGVUaWxkZVwiOlwiXFx1MjI0OFwiLFwidGltZXNiYXJcIjpcIlxcdTJBMzFcIixcInRpbWVzYlwiOlwiXFx1MjJBMFwiLFwidGltZXNcIjpcIlxceEQ3XCIsXCJ0aW1lc2RcIjpcIlxcdTJBMzBcIixcInRpbnRcIjpcIlxcdTIyMkRcIixcInRvZWFcIjpcIlxcdTI5MjhcIixcInRvcGJvdFwiOlwiXFx1MjMzNlwiLFwidG9wY2lyXCI6XCJcXHUyQUYxXCIsXCJ0b3BcIjpcIlxcdTIyQTRcIixcIlRvcGZcIjpcIlxcdUQ4MzVcXHVERDRCXCIsXCJ0b3BmXCI6XCJcXHVEODM1XFx1REQ2NVwiLFwidG9wZm9ya1wiOlwiXFx1MkFEQVwiLFwidG9zYVwiOlwiXFx1MjkyOVwiLFwidHByaW1lXCI6XCJcXHUyMDM0XCIsXCJ0cmFkZVwiOlwiXFx1MjEyMlwiLFwiVFJBREVcIjpcIlxcdTIxMjJcIixcInRyaWFuZ2xlXCI6XCJcXHUyNUI1XCIsXCJ0cmlhbmdsZWRvd25cIjpcIlxcdTI1QkZcIixcInRyaWFuZ2xlbGVmdFwiOlwiXFx1MjVDM1wiLFwidHJpYW5nbGVsZWZ0ZXFcIjpcIlxcdTIyQjRcIixcInRyaWFuZ2xlcVwiOlwiXFx1MjI1Q1wiLFwidHJpYW5nbGVyaWdodFwiOlwiXFx1MjVCOVwiLFwidHJpYW5nbGVyaWdodGVxXCI6XCJcXHUyMkI1XCIsXCJ0cmlkb3RcIjpcIlxcdTI1RUNcIixcInRyaWVcIjpcIlxcdTIyNUNcIixcInRyaW1pbnVzXCI6XCJcXHUyQTNBXCIsXCJUcmlwbGVEb3RcIjpcIlxcdTIwREJcIixcInRyaXBsdXNcIjpcIlxcdTJBMzlcIixcInRyaXNiXCI6XCJcXHUyOUNEXCIsXCJ0cml0aW1lXCI6XCJcXHUyQTNCXCIsXCJ0cnBleml1bVwiOlwiXFx1MjNFMlwiLFwiVHNjclwiOlwiXFx1RDgzNVxcdURDQUZcIixcInRzY3JcIjpcIlxcdUQ4MzVcXHVEQ0M5XCIsXCJUU2N5XCI6XCJcXHUwNDI2XCIsXCJ0c2N5XCI6XCJcXHUwNDQ2XCIsXCJUU0hjeVwiOlwiXFx1MDQwQlwiLFwidHNoY3lcIjpcIlxcdTA0NUJcIixcIlRzdHJva1wiOlwiXFx1MDE2NlwiLFwidHN0cm9rXCI6XCJcXHUwMTY3XCIsXCJ0d2l4dFwiOlwiXFx1MjI2Q1wiLFwidHdvaGVhZGxlZnRhcnJvd1wiOlwiXFx1MjE5RVwiLFwidHdvaGVhZHJpZ2h0YXJyb3dcIjpcIlxcdTIxQTBcIixcIlVhY3V0ZVwiOlwiXFx4REFcIixcInVhY3V0ZVwiOlwiXFx4RkFcIixcInVhcnJcIjpcIlxcdTIxOTFcIixcIlVhcnJcIjpcIlxcdTIxOUZcIixcInVBcnJcIjpcIlxcdTIxRDFcIixcIlVhcnJvY2lyXCI6XCJcXHUyOTQ5XCIsXCJVYnJjeVwiOlwiXFx1MDQwRVwiLFwidWJyY3lcIjpcIlxcdTA0NUVcIixcIlVicmV2ZVwiOlwiXFx1MDE2Q1wiLFwidWJyZXZlXCI6XCJcXHUwMTZEXCIsXCJVY2lyY1wiOlwiXFx4REJcIixcInVjaXJjXCI6XCJcXHhGQlwiLFwiVWN5XCI6XCJcXHUwNDIzXCIsXCJ1Y3lcIjpcIlxcdTA0NDNcIixcInVkYXJyXCI6XCJcXHUyMUM1XCIsXCJVZGJsYWNcIjpcIlxcdTAxNzBcIixcInVkYmxhY1wiOlwiXFx1MDE3MVwiLFwidWRoYXJcIjpcIlxcdTI5NkVcIixcInVmaXNodFwiOlwiXFx1Mjk3RVwiLFwiVWZyXCI6XCJcXHVEODM1XFx1REQxOFwiLFwidWZyXCI6XCJcXHVEODM1XFx1REQzMlwiLFwiVWdyYXZlXCI6XCJcXHhEOVwiLFwidWdyYXZlXCI6XCJcXHhGOVwiLFwidUhhclwiOlwiXFx1Mjk2M1wiLFwidWhhcmxcIjpcIlxcdTIxQkZcIixcInVoYXJyXCI6XCJcXHUyMUJFXCIsXCJ1aGJsa1wiOlwiXFx1MjU4MFwiLFwidWxjb3JuXCI6XCJcXHUyMzFDXCIsXCJ1bGNvcm5lclwiOlwiXFx1MjMxQ1wiLFwidWxjcm9wXCI6XCJcXHUyMzBGXCIsXCJ1bHRyaVwiOlwiXFx1MjVGOFwiLFwiVW1hY3JcIjpcIlxcdTAxNkFcIixcInVtYWNyXCI6XCJcXHUwMTZCXCIsXCJ1bWxcIjpcIlxceEE4XCIsXCJVbmRlckJhclwiOlwiX1wiLFwiVW5kZXJCcmFjZVwiOlwiXFx1MjNERlwiLFwiVW5kZXJCcmFja2V0XCI6XCJcXHUyM0I1XCIsXCJVbmRlclBhcmVudGhlc2lzXCI6XCJcXHUyM0REXCIsXCJVbmlvblwiOlwiXFx1MjJDM1wiLFwiVW5pb25QbHVzXCI6XCJcXHUyMjhFXCIsXCJVb2dvblwiOlwiXFx1MDE3MlwiLFwidW9nb25cIjpcIlxcdTAxNzNcIixcIlVvcGZcIjpcIlxcdUQ4MzVcXHVERDRDXCIsXCJ1b3BmXCI6XCJcXHVEODM1XFx1REQ2NlwiLFwiVXBBcnJvd0JhclwiOlwiXFx1MjkxMlwiLFwidXBhcnJvd1wiOlwiXFx1MjE5MVwiLFwiVXBBcnJvd1wiOlwiXFx1MjE5MVwiLFwiVXBhcnJvd1wiOlwiXFx1MjFEMVwiLFwiVXBBcnJvd0Rvd25BcnJvd1wiOlwiXFx1MjFDNVwiLFwidXBkb3duYXJyb3dcIjpcIlxcdTIxOTVcIixcIlVwRG93bkFycm93XCI6XCJcXHUyMTk1XCIsXCJVcGRvd25hcnJvd1wiOlwiXFx1MjFENVwiLFwiVXBFcXVpbGlicml1bVwiOlwiXFx1Mjk2RVwiLFwidXBoYXJwb29ubGVmdFwiOlwiXFx1MjFCRlwiLFwidXBoYXJwb29ucmlnaHRcIjpcIlxcdTIxQkVcIixcInVwbHVzXCI6XCJcXHUyMjhFXCIsXCJVcHBlckxlZnRBcnJvd1wiOlwiXFx1MjE5NlwiLFwiVXBwZXJSaWdodEFycm93XCI6XCJcXHUyMTk3XCIsXCJ1cHNpXCI6XCJcXHUwM0M1XCIsXCJVcHNpXCI6XCJcXHUwM0QyXCIsXCJ1cHNpaFwiOlwiXFx1MDNEMlwiLFwiVXBzaWxvblwiOlwiXFx1MDNBNVwiLFwidXBzaWxvblwiOlwiXFx1MDNDNVwiLFwiVXBUZWVBcnJvd1wiOlwiXFx1MjFBNVwiLFwiVXBUZWVcIjpcIlxcdTIyQTVcIixcInVwdXBhcnJvd3NcIjpcIlxcdTIxQzhcIixcInVyY29yblwiOlwiXFx1MjMxRFwiLFwidXJjb3JuZXJcIjpcIlxcdTIzMURcIixcInVyY3JvcFwiOlwiXFx1MjMwRVwiLFwiVXJpbmdcIjpcIlxcdTAxNkVcIixcInVyaW5nXCI6XCJcXHUwMTZGXCIsXCJ1cnRyaVwiOlwiXFx1MjVGOVwiLFwiVXNjclwiOlwiXFx1RDgzNVxcdURDQjBcIixcInVzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NBXCIsXCJ1dGRvdFwiOlwiXFx1MjJGMFwiLFwiVXRpbGRlXCI6XCJcXHUwMTY4XCIsXCJ1dGlsZGVcIjpcIlxcdTAxNjlcIixcInV0cmlcIjpcIlxcdTI1QjVcIixcInV0cmlmXCI6XCJcXHUyNUI0XCIsXCJ1dWFyclwiOlwiXFx1MjFDOFwiLFwiVXVtbFwiOlwiXFx4RENcIixcInV1bWxcIjpcIlxceEZDXCIsXCJ1d2FuZ2xlXCI6XCJcXHUyOUE3XCIsXCJ2YW5ncnRcIjpcIlxcdTI5OUNcIixcInZhcmVwc2lsb25cIjpcIlxcdTAzRjVcIixcInZhcmthcHBhXCI6XCJcXHUwM0YwXCIsXCJ2YXJub3RoaW5nXCI6XCJcXHUyMjA1XCIsXCJ2YXJwaGlcIjpcIlxcdTAzRDVcIixcInZhcnBpXCI6XCJcXHUwM0Q2XCIsXCJ2YXJwcm9wdG9cIjpcIlxcdTIyMURcIixcInZhcnJcIjpcIlxcdTIxOTVcIixcInZBcnJcIjpcIlxcdTIxRDVcIixcInZhcnJob1wiOlwiXFx1MDNGMVwiLFwidmFyc2lnbWFcIjpcIlxcdTAzQzJcIixcInZhcnN1YnNldG5lcVwiOlwiXFx1MjI4QVxcdUZFMDBcIixcInZhcnN1YnNldG5lcXFcIjpcIlxcdTJBQ0JcXHVGRTAwXCIsXCJ2YXJzdXBzZXRuZXFcIjpcIlxcdTIyOEJcXHVGRTAwXCIsXCJ2YXJzdXBzZXRuZXFxXCI6XCJcXHUyQUNDXFx1RkUwMFwiLFwidmFydGhldGFcIjpcIlxcdTAzRDFcIixcInZhcnRyaWFuZ2xlbGVmdFwiOlwiXFx1MjJCMlwiLFwidmFydHJpYW5nbGVyaWdodFwiOlwiXFx1MjJCM1wiLFwidkJhclwiOlwiXFx1MkFFOFwiLFwiVmJhclwiOlwiXFx1MkFFQlwiLFwidkJhcnZcIjpcIlxcdTJBRTlcIixcIlZjeVwiOlwiXFx1MDQxMlwiLFwidmN5XCI6XCJcXHUwNDMyXCIsXCJ2ZGFzaFwiOlwiXFx1MjJBMlwiLFwidkRhc2hcIjpcIlxcdTIyQThcIixcIlZkYXNoXCI6XCJcXHUyMkE5XCIsXCJWRGFzaFwiOlwiXFx1MjJBQlwiLFwiVmRhc2hsXCI6XCJcXHUyQUU2XCIsXCJ2ZWViYXJcIjpcIlxcdTIyQkJcIixcInZlZVwiOlwiXFx1MjIyOFwiLFwiVmVlXCI6XCJcXHUyMkMxXCIsXCJ2ZWVlcVwiOlwiXFx1MjI1QVwiLFwidmVsbGlwXCI6XCJcXHUyMkVFXCIsXCJ2ZXJiYXJcIjpcInxcIixcIlZlcmJhclwiOlwiXFx1MjAxNlwiLFwidmVydFwiOlwifFwiLFwiVmVydFwiOlwiXFx1MjAxNlwiLFwiVmVydGljYWxCYXJcIjpcIlxcdTIyMjNcIixcIlZlcnRpY2FsTGluZVwiOlwifFwiLFwiVmVydGljYWxTZXBhcmF0b3JcIjpcIlxcdTI3NThcIixcIlZlcnRpY2FsVGlsZGVcIjpcIlxcdTIyNDBcIixcIlZlcnlUaGluU3BhY2VcIjpcIlxcdTIwMEFcIixcIlZmclwiOlwiXFx1RDgzNVxcdUREMTlcIixcInZmclwiOlwiXFx1RDgzNVxcdUREMzNcIixcInZsdHJpXCI6XCJcXHUyMkIyXCIsXCJ2bnN1YlwiOlwiXFx1MjI4MlxcdTIwRDJcIixcInZuc3VwXCI6XCJcXHUyMjgzXFx1MjBEMlwiLFwiVm9wZlwiOlwiXFx1RDgzNVxcdURENERcIixcInZvcGZcIjpcIlxcdUQ4MzVcXHVERDY3XCIsXCJ2cHJvcFwiOlwiXFx1MjIxRFwiLFwidnJ0cmlcIjpcIlxcdTIyQjNcIixcIlZzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IxXCIsXCJ2c2NyXCI6XCJcXHVEODM1XFx1RENDQlwiLFwidnN1Ym5FXCI6XCJcXHUyQUNCXFx1RkUwMFwiLFwidnN1Ym5lXCI6XCJcXHUyMjhBXFx1RkUwMFwiLFwidnN1cG5FXCI6XCJcXHUyQUNDXFx1RkUwMFwiLFwidnN1cG5lXCI6XCJcXHUyMjhCXFx1RkUwMFwiLFwiVnZkYXNoXCI6XCJcXHUyMkFBXCIsXCJ2emlnemFnXCI6XCJcXHUyOTlBXCIsXCJXY2lyY1wiOlwiXFx1MDE3NFwiLFwid2NpcmNcIjpcIlxcdTAxNzVcIixcIndlZGJhclwiOlwiXFx1MkE1RlwiLFwid2VkZ2VcIjpcIlxcdTIyMjdcIixcIldlZGdlXCI6XCJcXHUyMkMwXCIsXCJ3ZWRnZXFcIjpcIlxcdTIyNTlcIixcIndlaWVycFwiOlwiXFx1MjExOFwiLFwiV2ZyXCI6XCJcXHVEODM1XFx1REQxQVwiLFwid2ZyXCI6XCJcXHVEODM1XFx1REQzNFwiLFwiV29wZlwiOlwiXFx1RDgzNVxcdURENEVcIixcIndvcGZcIjpcIlxcdUQ4MzVcXHVERDY4XCIsXCJ3cFwiOlwiXFx1MjExOFwiLFwid3JcIjpcIlxcdTIyNDBcIixcIndyZWF0aFwiOlwiXFx1MjI0MFwiLFwiV3NjclwiOlwiXFx1RDgzNVxcdURDQjJcIixcIndzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NDXCIsXCJ4Y2FwXCI6XCJcXHUyMkMyXCIsXCJ4Y2lyY1wiOlwiXFx1MjVFRlwiLFwieGN1cFwiOlwiXFx1MjJDM1wiLFwieGR0cmlcIjpcIlxcdTI1QkRcIixcIlhmclwiOlwiXFx1RDgzNVxcdUREMUJcIixcInhmclwiOlwiXFx1RDgzNVxcdUREMzVcIixcInhoYXJyXCI6XCJcXHUyN0Y3XCIsXCJ4aEFyclwiOlwiXFx1MjdGQVwiLFwiWGlcIjpcIlxcdTAzOUVcIixcInhpXCI6XCJcXHUwM0JFXCIsXCJ4bGFyclwiOlwiXFx1MjdGNVwiLFwieGxBcnJcIjpcIlxcdTI3RjhcIixcInhtYXBcIjpcIlxcdTI3RkNcIixcInhuaXNcIjpcIlxcdTIyRkJcIixcInhvZG90XCI6XCJcXHUyQTAwXCIsXCJYb3BmXCI6XCJcXHVEODM1XFx1REQ0RlwiLFwieG9wZlwiOlwiXFx1RDgzNVxcdURENjlcIixcInhvcGx1c1wiOlwiXFx1MkEwMVwiLFwieG90aW1lXCI6XCJcXHUyQTAyXCIsXCJ4cmFyclwiOlwiXFx1MjdGNlwiLFwieHJBcnJcIjpcIlxcdTI3RjlcIixcIlhzY3JcIjpcIlxcdUQ4MzVcXHVEQ0IzXCIsXCJ4c2NyXCI6XCJcXHVEODM1XFx1RENDRFwiLFwieHNxY3VwXCI6XCJcXHUyQTA2XCIsXCJ4dXBsdXNcIjpcIlxcdTJBMDRcIixcInh1dHJpXCI6XCJcXHUyNUIzXCIsXCJ4dmVlXCI6XCJcXHUyMkMxXCIsXCJ4d2VkZ2VcIjpcIlxcdTIyQzBcIixcIllhY3V0ZVwiOlwiXFx4RERcIixcInlhY3V0ZVwiOlwiXFx4RkRcIixcIllBY3lcIjpcIlxcdTA0MkZcIixcInlhY3lcIjpcIlxcdTA0NEZcIixcIlljaXJjXCI6XCJcXHUwMTc2XCIsXCJ5Y2lyY1wiOlwiXFx1MDE3N1wiLFwiWWN5XCI6XCJcXHUwNDJCXCIsXCJ5Y3lcIjpcIlxcdTA0NEJcIixcInllblwiOlwiXFx4QTVcIixcIllmclwiOlwiXFx1RDgzNVxcdUREMUNcIixcInlmclwiOlwiXFx1RDgzNVxcdUREMzZcIixcIllJY3lcIjpcIlxcdTA0MDdcIixcInlpY3lcIjpcIlxcdTA0NTdcIixcIllvcGZcIjpcIlxcdUQ4MzVcXHVERDUwXCIsXCJ5b3BmXCI6XCJcXHVEODM1XFx1REQ2QVwiLFwiWXNjclwiOlwiXFx1RDgzNVxcdURDQjRcIixcInlzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NFXCIsXCJZVWN5XCI6XCJcXHUwNDJFXCIsXCJ5dWN5XCI6XCJcXHUwNDRFXCIsXCJ5dW1sXCI6XCJcXHhGRlwiLFwiWXVtbFwiOlwiXFx1MDE3OFwiLFwiWmFjdXRlXCI6XCJcXHUwMTc5XCIsXCJ6YWN1dGVcIjpcIlxcdTAxN0FcIixcIlpjYXJvblwiOlwiXFx1MDE3RFwiLFwiemNhcm9uXCI6XCJcXHUwMTdFXCIsXCJaY3lcIjpcIlxcdTA0MTdcIixcInpjeVwiOlwiXFx1MDQzN1wiLFwiWmRvdFwiOlwiXFx1MDE3QlwiLFwiemRvdFwiOlwiXFx1MDE3Q1wiLFwiemVldHJmXCI6XCJcXHUyMTI4XCIsXCJaZXJvV2lkdGhTcGFjZVwiOlwiXFx1MjAwQlwiLFwiWmV0YVwiOlwiXFx1MDM5NlwiLFwiemV0YVwiOlwiXFx1MDNCNlwiLFwiemZyXCI6XCJcXHVEODM1XFx1REQzN1wiLFwiWmZyXCI6XCJcXHUyMTI4XCIsXCJaSGN5XCI6XCJcXHUwNDE2XCIsXCJ6aGN5XCI6XCJcXHUwNDM2XCIsXCJ6aWdyYXJyXCI6XCJcXHUyMUREXCIsXCJ6b3BmXCI6XCJcXHVEODM1XFx1REQ2QlwiLFwiWm9wZlwiOlwiXFx1MjEyNFwiLFwiWnNjclwiOlwiXFx1RDgzNVxcdURDQjVcIixcInpzY3JcIjpcIlxcdUQ4MzVcXHVEQ0NGXCIsXCJ6d2pcIjpcIlxcdTIwMERcIixcInp3bmpcIjpcIlxcdTIwMENcIn07fSx7fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPXtcIkFhY3V0ZVwiOlwiXFx4QzFcIixcImFhY3V0ZVwiOlwiXFx4RTFcIixcIkFjaXJjXCI6XCJcXHhDMlwiLFwiYWNpcmNcIjpcIlxceEUyXCIsXCJhY3V0ZVwiOlwiXFx4QjRcIixcIkFFbGlnXCI6XCJcXHhDNlwiLFwiYWVsaWdcIjpcIlxceEU2XCIsXCJBZ3JhdmVcIjpcIlxceEMwXCIsXCJhZ3JhdmVcIjpcIlxceEUwXCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiQXJpbmdcIjpcIlxceEM1XCIsXCJhcmluZ1wiOlwiXFx4RTVcIixcIkF0aWxkZVwiOlwiXFx4QzNcIixcImF0aWxkZVwiOlwiXFx4RTNcIixcIkF1bWxcIjpcIlxceEM0XCIsXCJhdW1sXCI6XCJcXHhFNFwiLFwiYnJ2YmFyXCI6XCJcXHhBNlwiLFwiQ2NlZGlsXCI6XCJcXHhDN1wiLFwiY2NlZGlsXCI6XCJcXHhFN1wiLFwiY2VkaWxcIjpcIlxceEI4XCIsXCJjZW50XCI6XCJcXHhBMlwiLFwiY29weVwiOlwiXFx4QTlcIixcIkNPUFlcIjpcIlxceEE5XCIsXCJjdXJyZW5cIjpcIlxceEE0XCIsXCJkZWdcIjpcIlxceEIwXCIsXCJkaXZpZGVcIjpcIlxceEY3XCIsXCJFYWN1dGVcIjpcIlxceEM5XCIsXCJlYWN1dGVcIjpcIlxceEU5XCIsXCJFY2lyY1wiOlwiXFx4Q0FcIixcImVjaXJjXCI6XCJcXHhFQVwiLFwiRWdyYXZlXCI6XCJcXHhDOFwiLFwiZWdyYXZlXCI6XCJcXHhFOFwiLFwiRVRIXCI6XCJcXHhEMFwiLFwiZXRoXCI6XCJcXHhGMFwiLFwiRXVtbFwiOlwiXFx4Q0JcIixcImV1bWxcIjpcIlxceEVCXCIsXCJmcmFjMTJcIjpcIlxceEJEXCIsXCJmcmFjMTRcIjpcIlxceEJDXCIsXCJmcmFjMzRcIjpcIlxceEJFXCIsXCJndFwiOlwiPlwiLFwiR1RcIjpcIj5cIixcIklhY3V0ZVwiOlwiXFx4Q0RcIixcImlhY3V0ZVwiOlwiXFx4RURcIixcIkljaXJjXCI6XCJcXHhDRVwiLFwiaWNpcmNcIjpcIlxceEVFXCIsXCJpZXhjbFwiOlwiXFx4QTFcIixcIklncmF2ZVwiOlwiXFx4Q0NcIixcImlncmF2ZVwiOlwiXFx4RUNcIixcImlxdWVzdFwiOlwiXFx4QkZcIixcIkl1bWxcIjpcIlxceENGXCIsXCJpdW1sXCI6XCJcXHhFRlwiLFwibGFxdW9cIjpcIlxceEFCXCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIm1hY3JcIjpcIlxceEFGXCIsXCJtaWNyb1wiOlwiXFx4QjVcIixcIm1pZGRvdFwiOlwiXFx4QjdcIixcIm5ic3BcIjpcIlxceEEwXCIsXCJub3RcIjpcIlxceEFDXCIsXCJOdGlsZGVcIjpcIlxceEQxXCIsXCJudGlsZGVcIjpcIlxceEYxXCIsXCJPYWN1dGVcIjpcIlxceEQzXCIsXCJvYWN1dGVcIjpcIlxceEYzXCIsXCJPY2lyY1wiOlwiXFx4RDRcIixcIm9jaXJjXCI6XCJcXHhGNFwiLFwiT2dyYXZlXCI6XCJcXHhEMlwiLFwib2dyYXZlXCI6XCJcXHhGMlwiLFwib3JkZlwiOlwiXFx4QUFcIixcIm9yZG1cIjpcIlxceEJBXCIsXCJPc2xhc2hcIjpcIlxceEQ4XCIsXCJvc2xhc2hcIjpcIlxceEY4XCIsXCJPdGlsZGVcIjpcIlxceEQ1XCIsXCJvdGlsZGVcIjpcIlxceEY1XCIsXCJPdW1sXCI6XCJcXHhENlwiLFwib3VtbFwiOlwiXFx4RjZcIixcInBhcmFcIjpcIlxceEI2XCIsXCJwbHVzbW5cIjpcIlxceEIxXCIsXCJwb3VuZFwiOlwiXFx4QTNcIixcInF1b3RcIjpcIlxcXCJcIixcIlFVT1RcIjpcIlxcXCJcIixcInJhcXVvXCI6XCJcXHhCQlwiLFwicmVnXCI6XCJcXHhBRVwiLFwiUkVHXCI6XCJcXHhBRVwiLFwic2VjdFwiOlwiXFx4QTdcIixcInNoeVwiOlwiXFx4QURcIixcInN1cDFcIjpcIlxceEI5XCIsXCJzdXAyXCI6XCJcXHhCMlwiLFwic3VwM1wiOlwiXFx4QjNcIixcInN6bGlnXCI6XCJcXHhERlwiLFwiVEhPUk5cIjpcIlxceERFXCIsXCJ0aG9yblwiOlwiXFx4RkVcIixcInRpbWVzXCI6XCJcXHhEN1wiLFwiVWFjdXRlXCI6XCJcXHhEQVwiLFwidWFjdXRlXCI6XCJcXHhGQVwiLFwiVWNpcmNcIjpcIlxceERCXCIsXCJ1Y2lyY1wiOlwiXFx4RkJcIixcIlVncmF2ZVwiOlwiXFx4RDlcIixcInVncmF2ZVwiOlwiXFx4RjlcIixcInVtbFwiOlwiXFx4QThcIixcIlV1bWxcIjpcIlxceERDXCIsXCJ1dW1sXCI6XCJcXHhGQ1wiLFwiWWFjdXRlXCI6XCJcXHhERFwiLFwieWFjdXRlXCI6XCJcXHhGRFwiLFwieWVuXCI6XCJcXHhBNVwiLFwieXVtbFwiOlwiXFx4RkZcIn07fSx7fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPXtcImFtcFwiOlwiJlwiLFwiYXBvc1wiOlwiJ1wiLFwiZ3RcIjpcIj5cIixcImx0XCI6XCI8XCIsXCJxdW90XCI6XCJcXFwiXCJ9O30se31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbnZhciBvYmplY3RDcmVhdGU9T2JqZWN0LmNyZWF0ZXx8b2JqZWN0Q3JlYXRlUG9seWZpbGw7dmFyIG9iamVjdEtleXM9T2JqZWN0LmtleXN8fG9iamVjdEtleXNQb2x5ZmlsbDt2YXIgYmluZD1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8ZnVuY3Rpb25CaW5kUG9seWZpbGw7ZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCl7aWYoIXRoaXMuX2V2ZW50c3x8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCdfZXZlbnRzJykpe3RoaXMuX2V2ZW50cz1vYmplY3RDcmVhdGUobnVsbCk7dGhpcy5fZXZlbnRzQ291bnQ9MDt9dGhpcy5fbWF4TGlzdGVuZXJzPXRoaXMuX21heExpc3RlbmVyc3x8dW5kZWZpbmVkO31tb2R1bGUuZXhwb3J0cz1FdmVudEVtaXR0ZXI7Ly8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyPUV2ZW50RW1pdHRlcjtFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHM9dW5kZWZpbmVkO0V2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycz11bmRlZmluZWQ7Ly8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnM9MTA7dmFyIGhhc0RlZmluZVByb3BlcnR5O3RyeXt2YXIgbz17fTtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sJ3gnLHt2YWx1ZTowfSk7aGFzRGVmaW5lUHJvcGVydHk9by54PT09MDt9Y2F0Y2goZXJyKXtoYXNEZWZpbmVQcm9wZXJ0eT1mYWxzZTt9aWYoaGFzRGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO30sc2V0OmZ1bmN0aW9uIHNldChhcmcpey8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4vLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuaWYodHlwZW9mIGFyZyE9PSdudW1iZXInfHxhcmc8MHx8YXJnIT09YXJnKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtkZWZhdWx0TWF4TGlzdGVuZXJzPWFyZzt9fSk7fWVsc2V7RXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM9ZGVmYXVsdE1heExpc3RlbmVyczt9Ly8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKXtpZih0eXBlb2YgbiE9PSdudW1iZXInfHxuPDB8fGlzTmFOKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTt0aGlzLl9tYXhMaXN0ZW5lcnM9bjtyZXR1cm4gdGhpczt9O2Z1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCl7aWYodGhhdC5fbWF4TGlzdGVuZXJzPT09dW5kZWZpbmVkKXJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztyZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO31FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycz1mdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKXtyZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTt9Oy8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLGlzRm4sc2VsZil7aWYoaXNGbiloYW5kbGVyLmNhbGwoc2VsZik7ZWxzZXt2YXIgbGVuPWhhbmRsZXIubGVuZ3RoO3ZhciBsaXN0ZW5lcnM9YXJyYXlDbG9uZShoYW5kbGVyLGxlbik7Zm9yKHZhciBpPTA7aTxsZW47KytpKXtsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTt9fX1mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsaXNGbixzZWxmLGFyZzEpe2lmKGlzRm4paGFuZGxlci5jYWxsKHNlbGYsYXJnMSk7ZWxzZXt2YXIgbGVuPWhhbmRsZXIubGVuZ3RoO3ZhciBsaXN0ZW5lcnM9YXJyYXlDbG9uZShoYW5kbGVyLGxlbik7Zm9yKHZhciBpPTA7aTxsZW47KytpKXtsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLGFyZzEpO319fWZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlcixpc0ZuLHNlbGYsYXJnMSxhcmcyKXtpZihpc0ZuKWhhbmRsZXIuY2FsbChzZWxmLGFyZzEsYXJnMik7ZWxzZXt2YXIgbGVuPWhhbmRsZXIubGVuZ3RoO3ZhciBsaXN0ZW5lcnM9YXJyYXlDbG9uZShoYW5kbGVyLGxlbik7Zm9yKHZhciBpPTA7aTxsZW47KytpKXtsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLGFyZzEsYXJnMik7fX19ZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsaXNGbixzZWxmLGFyZzEsYXJnMixhcmczKXtpZihpc0ZuKWhhbmRsZXIuY2FsbChzZWxmLGFyZzEsYXJnMixhcmczKTtlbHNle3ZhciBsZW49aGFuZGxlci5sZW5ndGg7dmFyIGxpc3RlbmVycz1hcnJheUNsb25lKGhhbmRsZXIsbGVuKTtmb3IodmFyIGk9MDtpPGxlbjsrK2kpe2xpc3RlbmVyc1tpXS5jYWxsKHNlbGYsYXJnMSxhcmcyLGFyZzMpO319fWZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsaXNGbixzZWxmLGFyZ3Mpe2lmKGlzRm4paGFuZGxlci5hcHBseShzZWxmLGFyZ3MpO2Vsc2V7dmFyIGxlbj1oYW5kbGVyLmxlbmd0aDt2YXIgbGlzdGVuZXJzPWFycmF5Q2xvbmUoaGFuZGxlcixsZW4pO2Zvcih2YXIgaT0wO2k8bGVuOysraSl7bGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsYXJncyk7fX19RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uIGVtaXQodHlwZSl7dmFyIGVyLGhhbmRsZXIsbGVuLGFyZ3MsaSxldmVudHM7dmFyIGRvRXJyb3I9dHlwZT09PSdlcnJvcic7ZXZlbnRzPXRoaXMuX2V2ZW50cztpZihldmVudHMpZG9FcnJvcj1kb0Vycm9yJiZldmVudHMuZXJyb3I9PW51bGw7ZWxzZSBpZighZG9FcnJvcilyZXR1cm4gZmFsc2U7Ly8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuaWYoZG9FcnJvcil7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWVyPWFyZ3VtZW50c1sxXTtpZihlciBpbnN0YW5jZW9mIEVycm9yKXt0aHJvdyBlcjsvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxufWVsc2V7Ly8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxudmFyIGVycj1uZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnK2VyKycpJyk7ZXJyLmNvbnRleHQ9ZXI7dGhyb3cgZXJyO31yZXR1cm4gZmFsc2U7fWhhbmRsZXI9ZXZlbnRzW3R5cGVdO2lmKCFoYW5kbGVyKXJldHVybiBmYWxzZTt2YXIgaXNGbj10eXBlb2YgaGFuZGxlcj09PSdmdW5jdGlvbic7bGVuPWFyZ3VtZW50cy5sZW5ndGg7c3dpdGNoKGxlbil7Ly8gZmFzdCBjYXNlc1xuY2FzZSAxOmVtaXROb25lKGhhbmRsZXIsaXNGbix0aGlzKTticmVhaztjYXNlIDI6ZW1pdE9uZShoYW5kbGVyLGlzRm4sdGhpcyxhcmd1bWVudHNbMV0pO2JyZWFrO2Nhc2UgMzplbWl0VHdvKGhhbmRsZXIsaXNGbix0aGlzLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pO2JyZWFrO2Nhc2UgNDplbWl0VGhyZWUoaGFuZGxlcixpc0ZuLHRoaXMsYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10pO2JyZWFrOy8vIHNsb3dlclxuZGVmYXVsdDphcmdzPW5ldyBBcnJheShsZW4tMSk7Zm9yKGk9MTtpPGxlbjtpKyspe2FyZ3NbaS0xXT1hcmd1bWVudHNbaV07fWVtaXRNYW55KGhhbmRsZXIsaXNGbix0aGlzLGFyZ3MpO31yZXR1cm4gdHJ1ZTt9O2Z1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsdHlwZSxsaXN0ZW5lcixwcmVwZW5kKXt2YXIgbTt2YXIgZXZlbnRzO3ZhciBleGlzdGluZztpZih0eXBlb2YgbGlzdGVuZXIhPT0nZnVuY3Rpb24nKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtldmVudHM9dGFyZ2V0Ll9ldmVudHM7aWYoIWV2ZW50cyl7ZXZlbnRzPXRhcmdldC5fZXZlbnRzPW9iamVjdENyZWF0ZShudWxsKTt0YXJnZXQuX2V2ZW50c0NvdW50PTA7fWVsc2V7Ly8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbi8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbmlmKGV2ZW50cy5uZXdMaXN0ZW5lcil7dGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJyx0eXBlLGxpc3RlbmVyLmxpc3RlbmVyP2xpc3RlbmVyLmxpc3RlbmVyOmxpc3RlbmVyKTsvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4vLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG5ldmVudHM9dGFyZ2V0Ll9ldmVudHM7fWV4aXN0aW5nPWV2ZW50c1t0eXBlXTt9aWYoIWV4aXN0aW5nKXsvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbmV4aXN0aW5nPWV2ZW50c1t0eXBlXT1saXN0ZW5lcjsrK3RhcmdldC5fZXZlbnRzQ291bnQ7fWVsc2V7aWYodHlwZW9mIGV4aXN0aW5nPT09J2Z1bmN0aW9uJyl7Ly8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG5leGlzdGluZz1ldmVudHNbdHlwZV09cHJlcGVuZD9bbGlzdGVuZXIsZXhpc3RpbmddOltleGlzdGluZyxsaXN0ZW5lcl07fWVsc2V7Ly8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuaWYocHJlcGVuZCl7ZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7fWVsc2V7ZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7fX0vLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuaWYoIWV4aXN0aW5nLndhcm5lZCl7bT0kZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7aWYobSYmbT4wJiZleGlzdGluZy5sZW5ndGg+bSl7ZXhpc3Rpbmcud2FybmVkPXRydWU7dmFyIHc9bmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcrZXhpc3RpbmcubGVuZ3RoKycgXCInK1N0cmluZyh0eXBlKSsnXCIgbGlzdGVuZXJzICcrJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnKydpbmNyZWFzZSBsaW1pdC4nKTt3Lm5hbWU9J01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7dy5lbWl0dGVyPXRhcmdldDt3LnR5cGU9dHlwZTt3LmNvdW50PWV4aXN0aW5nLmxlbmd0aDtpZigodHlwZW9mIGNvbnNvbGU9PT1cInVuZGVmaW5lZFwiP1widW5kZWZpbmVkXCI6X3R5cGVvZihjb25zb2xlKSk9PT0nb2JqZWN0JyYmY29uc29sZS53YXJuKXtjb25zb2xlLndhcm4oJyVzOiAlcycsdy5uYW1lLHcubWVzc2FnZSk7fX19fXJldHVybiB0YXJnZXQ7fUV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSxsaXN0ZW5lcil7cmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLHR5cGUsbGlzdGVuZXIsZmFsc2UpO307RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbj1FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO0V2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyPWZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLGxpc3RlbmVyKXtyZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsdHlwZSxsaXN0ZW5lcix0cnVlKTt9O2Z1bmN0aW9uIG9uY2VXcmFwcGVyKCl7aWYoIXRoaXMuZmlyZWQpe3RoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSx0aGlzLndyYXBGbik7dGhpcy5maXJlZD10cnVlO3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7Y2FzZSAxOnJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsYXJndW1lbnRzWzBdKTtjYXNlIDI6cmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCxhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKTtjYXNlIDM6cmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCxhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSk7ZGVmYXVsdDp2YXIgYXJncz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxhcmdzLmxlbmd0aDsrK2kpe2FyZ3NbaV09YXJndW1lbnRzW2ldO310aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LGFyZ3MpO319fWZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsdHlwZSxsaXN0ZW5lcil7dmFyIHN0YXRlPXtmaXJlZDpmYWxzZSx3cmFwRm46dW5kZWZpbmVkLHRhcmdldDp0YXJnZXQsdHlwZTp0eXBlLGxpc3RlbmVyOmxpc3RlbmVyfTt2YXIgd3JhcHBlZD1iaW5kLmNhbGwob25jZVdyYXBwZXIsc3RhdGUpO3dyYXBwZWQubGlzdGVuZXI9bGlzdGVuZXI7c3RhdGUud3JhcEZuPXdyYXBwZWQ7cmV0dXJuIHdyYXBwZWQ7fUV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZT1mdW5jdGlvbiBvbmNlKHR5cGUsbGlzdGVuZXIpe2lmKHR5cGVvZiBsaXN0ZW5lciE9PSdmdW5jdGlvbicpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO3RoaXMub24odHlwZSxfb25jZVdyYXAodGhpcyx0eXBlLGxpc3RlbmVyKSk7cmV0dXJuIHRoaXM7fTtFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXI9ZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLGxpc3RlbmVyKXtpZih0eXBlb2YgbGlzdGVuZXIhPT0nZnVuY3Rpb24nKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTt0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLF9vbmNlV3JhcCh0aGlzLHR5cGUsbGlzdGVuZXIpKTtyZXR1cm4gdGhpczt9Oy8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsbGlzdGVuZXIpe3ZhciBsaXN0LGV2ZW50cyxwb3NpdGlvbixpLG9yaWdpbmFsTGlzdGVuZXI7aWYodHlwZW9mIGxpc3RlbmVyIT09J2Z1bmN0aW9uJyl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7ZXZlbnRzPXRoaXMuX2V2ZW50cztpZighZXZlbnRzKXJldHVybiB0aGlzO2xpc3Q9ZXZlbnRzW3R5cGVdO2lmKCFsaXN0KXJldHVybiB0aGlzO2lmKGxpc3Q9PT1saXN0ZW5lcnx8bGlzdC5saXN0ZW5lcj09PWxpc3RlbmVyKXtpZigtLXRoaXMuX2V2ZW50c0NvdW50PT09MCl0aGlzLl9ldmVudHM9b2JqZWN0Q3JlYXRlKG51bGwpO2Vsc2V7ZGVsZXRlIGV2ZW50c1t0eXBlXTtpZihldmVudHMucmVtb3ZlTGlzdGVuZXIpdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsdHlwZSxsaXN0Lmxpc3RlbmVyfHxsaXN0ZW5lcik7fX1lbHNlIGlmKHR5cGVvZiBsaXN0IT09J2Z1bmN0aW9uJyl7cG9zaXRpb249LTE7Zm9yKGk9bGlzdC5sZW5ndGgtMTtpPj0wO2ktLSl7aWYobGlzdFtpXT09PWxpc3RlbmVyfHxsaXN0W2ldLmxpc3RlbmVyPT09bGlzdGVuZXIpe29yaWdpbmFsTGlzdGVuZXI9bGlzdFtpXS5saXN0ZW5lcjtwb3NpdGlvbj1pO2JyZWFrO319aWYocG9zaXRpb248MClyZXR1cm4gdGhpcztpZihwb3NpdGlvbj09PTApbGlzdC5zaGlmdCgpO2Vsc2Ugc3BsaWNlT25lKGxpc3QscG9zaXRpb24pO2lmKGxpc3QubGVuZ3RoPT09MSlldmVudHNbdHlwZV09bGlzdFswXTtpZihldmVudHMucmVtb3ZlTGlzdGVuZXIpdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsdHlwZSxvcmlnaW5hbExpc3RlbmVyfHxsaXN0ZW5lcik7fXJldHVybiB0aGlzO307RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpe3ZhciBsaXN0ZW5lcnMsZXZlbnRzLGk7ZXZlbnRzPXRoaXMuX2V2ZW50cztpZighZXZlbnRzKXJldHVybiB0aGlzOy8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbmlmKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpe2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXt0aGlzLl9ldmVudHM9b2JqZWN0Q3JlYXRlKG51bGwpO3RoaXMuX2V2ZW50c0NvdW50PTA7fWVsc2UgaWYoZXZlbnRzW3R5cGVdKXtpZigtLXRoaXMuX2V2ZW50c0NvdW50PT09MCl0aGlzLl9ldmVudHM9b2JqZWN0Q3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXTt9cmV0dXJuIHRoaXM7fS8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuaWYoYXJndW1lbnRzLmxlbmd0aD09PTApe3ZhciBrZXlzPW9iamVjdEtleXMoZXZlbnRzKTt2YXIga2V5O2ZvcihpPTA7aTxrZXlzLmxlbmd0aDsrK2kpe2tleT1rZXlzW2ldO2lmKGtleT09PSdyZW1vdmVMaXN0ZW5lcicpY29udGludWU7dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTt9dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7dGhpcy5fZXZlbnRzPW9iamVjdENyZWF0ZShudWxsKTt0aGlzLl9ldmVudHNDb3VudD0wO3JldHVybiB0aGlzO31saXN0ZW5lcnM9ZXZlbnRzW3R5cGVdO2lmKHR5cGVvZiBsaXN0ZW5lcnM9PT0nZnVuY3Rpb24nKXt0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsbGlzdGVuZXJzKTt9ZWxzZSBpZihsaXN0ZW5lcnMpey8vIExJRk8gb3JkZXJcbmZvcihpPWxpc3RlbmVycy5sZW5ndGgtMTtpPj0wO2ktLSl7dGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLGxpc3RlbmVyc1tpXSk7fX1yZXR1cm4gdGhpczt9O2Z1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LHR5cGUsdW53cmFwKXt2YXIgZXZlbnRzPXRhcmdldC5fZXZlbnRzO2lmKCFldmVudHMpcmV0dXJuW107dmFyIGV2bGlzdGVuZXI9ZXZlbnRzW3R5cGVdO2lmKCFldmxpc3RlbmVyKXJldHVybltdO2lmKHR5cGVvZiBldmxpc3RlbmVyPT09J2Z1bmN0aW9uJylyZXR1cm4gdW53cmFwP1tldmxpc3RlbmVyLmxpc3RlbmVyfHxldmxpc3RlbmVyXTpbZXZsaXN0ZW5lcl07cmV0dXJuIHVud3JhcD91bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcik6YXJyYXlDbG9uZShldmxpc3RlbmVyLGV2bGlzdGVuZXIubGVuZ3RoKTt9RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpe3JldHVybiBfbGlzdGVuZXJzKHRoaXMsdHlwZSx0cnVlKTt9O0V2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzPWZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKXtyZXR1cm4gX2xpc3RlbmVycyh0aGlzLHR5cGUsZmFsc2UpO307RXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24oZW1pdHRlcix0eXBlKXtpZih0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50PT09J2Z1bmN0aW9uJyl7cmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTt9ZWxzZXtyZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsdHlwZSk7fX07RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PWxpc3RlbmVyQ291bnQ7ZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKXt2YXIgZXZlbnRzPXRoaXMuX2V2ZW50cztpZihldmVudHMpe3ZhciBldmxpc3RlbmVyPWV2ZW50c1t0eXBlXTtpZih0eXBlb2YgZXZsaXN0ZW5lcj09PSdmdW5jdGlvbicpe3JldHVybiAxO31lbHNlIGlmKGV2bGlzdGVuZXIpe3JldHVybiBldmxpc3RlbmVyLmxlbmd0aDt9fXJldHVybiAwO31FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXM9ZnVuY3Rpb24gZXZlbnROYW1lcygpe3JldHVybiB0aGlzLl9ldmVudHNDb3VudD4wP1JlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpOltdO307Ly8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsaW5kZXgpe2Zvcih2YXIgaT1pbmRleCxrPWkrMSxuPWxpc3QubGVuZ3RoO2s8bjtpKz0xLGsrPTEpe2xpc3RbaV09bGlzdFtrXTt9bGlzdC5wb3AoKTt9ZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsbil7dmFyIGNvcHk9bmV3IEFycmF5KG4pO2Zvcih2YXIgaT0wO2k8bjsrK2kpe2NvcHlbaV09YXJyW2ldO31yZXR1cm4gY29weTt9ZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycil7dmFyIHJldD1uZXcgQXJyYXkoYXJyLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxyZXQubGVuZ3RoOysraSl7cmV0W2ldPWFycltpXS5saXN0ZW5lcnx8YXJyW2ldO31yZXR1cm4gcmV0O31mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90byl7dmFyIEY9ZnVuY3Rpb24gRigpe307Ri5wcm90b3R5cGU9cHJvdG87cmV0dXJuIG5ldyBGKCk7fWZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmope3ZhciBrZXlzPVtdO2Zvcih2YXIgayBpbiBvYmope2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosaykpe2tleXMucHVzaChrKTt9fXJldHVybiBrO31mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KXt2YXIgZm49dGhpcztyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZm4uYXBwbHkoY29udGV4dCxhcmd1bWVudHMpO307fX0se31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgX19leHRlbmRzPXRoaXMmJnRoaXMuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciBfZXh0ZW5kU3RhdGljczI9ZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLGIpe19leHRlbmRTdGF0aWNzMj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZCxiKXtkLl9fcHJvdG9fXz1iO318fGZ1bmN0aW9uKGQsYil7Zm9yKHZhciBwIGluIGIpe2lmKGIuaGFzT3duUHJvcGVydHkocCkpZFtwXT1iW3BdO319O3JldHVybiBfZXh0ZW5kU3RhdGljczIoZCxiKTt9O3JldHVybiBmdW5jdGlvbihkLGIpe19leHRlbmRTdGF0aWNzMihkLGIpO2Z1bmN0aW9uIF9fKCl7dGhpcy5jb25zdHJ1Y3Rvcj1kO31kLnByb3RvdHlwZT1iPT09bnVsbD9PYmplY3QuY3JlYXRlKGIpOihfXy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsbmV3IF9fKCkpO307fSgpO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOntcImRlZmF1bHRcIjptb2R9O307T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgTXVsdGlwbGV4SGFuZGxlcl8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9NdWx0aXBsZXhIYW5kbGVyXCIpKTt2YXIgQ29sbGVjdGluZ0hhbmRsZXI9LyoqIEBjbGFzcyAqL2Z1bmN0aW9uKF9zdXBlcil7X19leHRlbmRzKENvbGxlY3RpbmdIYW5kbGVyLF9zdXBlcik7ZnVuY3Rpb24gQ29sbGVjdGluZ0hhbmRsZXIoY2JzKXtpZihjYnM9PT12b2lkIDApe2Nicz17fTt9dmFyIF90aGlzPV9zdXBlci5jYWxsKHRoaXMsZnVuY3Rpb24obmFtZSl7dmFyIF9hO3ZhciBhcmdzPVtdO2Zvcih2YXIgX2k9MTtfaTxhcmd1bWVudHMubGVuZ3RoO19pKyspe2FyZ3NbX2ktMV09YXJndW1lbnRzW19pXTt9X3RoaXMuZXZlbnRzLnB1c2goW25hbWVdLmNvbmNhdChhcmdzKSk7Ly8gQHRzLWlnbm9yZVxuaWYoX3RoaXMuX2Nic1tuYW1lXSkoX2E9X3RoaXMuX2NicylbbmFtZV0uYXBwbHkoX2EsYXJncyk7fSl8fHRoaXM7X3RoaXMuX2Nicz1jYnM7X3RoaXMuZXZlbnRzPVtdO3JldHVybiBfdGhpczt9Q29sbGVjdGluZ0hhbmRsZXIucHJvdG90eXBlLm9ucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmV2ZW50cz1bXTtpZih0aGlzLl9jYnMub25yZXNldCl0aGlzLl9jYnMub25yZXNldCgpO307Q29sbGVjdGluZ0hhbmRsZXIucHJvdG90eXBlLnJlc3RhcnQ9ZnVuY3Rpb24oKXt2YXIgX2E7aWYodGhpcy5fY2JzLm9ucmVzZXQpdGhpcy5fY2JzLm9ucmVzZXQoKTtmb3IodmFyIGk9MDtpPHRoaXMuZXZlbnRzLmxlbmd0aDtpKyspe3ZhciBfYj10aGlzLmV2ZW50c1tpXSxuYW1lXzE9X2JbMF0sYXJncz1fYi5zbGljZSgxKTtpZighdGhpcy5fY2JzW25hbWVfMV0pe2NvbnRpbnVlO30vLyBAdHMtaWdub3JlXG4oX2E9dGhpcy5fY2JzKVtuYW1lXzFdLmFwcGx5KF9hLGFyZ3MpO319O3JldHVybiBDb2xsZWN0aW5nSGFuZGxlcjt9KE11bHRpcGxleEhhbmRsZXJfMVtcImRlZmF1bHRcIl0pO2V4cG9ydHMuQ29sbGVjdGluZ0hhbmRsZXI9Q29sbGVjdGluZ0hhbmRsZXI7fSx7XCIuL011bHRpcGxleEhhbmRsZXJcIjoyOH1dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgX19leHRlbmRzPXRoaXMmJnRoaXMuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciBfZXh0ZW5kU3RhdGljczM9ZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLGIpe19leHRlbmRTdGF0aWNzMz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZCxiKXtkLl9fcHJvdG9fXz1iO318fGZ1bmN0aW9uKGQsYil7Zm9yKHZhciBwIGluIGIpe2lmKGIuaGFzT3duUHJvcGVydHkocCkpZFtwXT1iW3BdO319O3JldHVybiBfZXh0ZW5kU3RhdGljczMoZCxiKTt9O3JldHVybiBmdW5jdGlvbihkLGIpe19leHRlbmRTdGF0aWNzMyhkLGIpO2Z1bmN0aW9uIF9fKCl7dGhpcy5jb25zdHJ1Y3Rvcj1kO31kLnByb3RvdHlwZT1iPT09bnVsbD9PYmplY3QuY3JlYXRlKGIpOihfXy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsbmV3IF9fKCkpO307fSgpO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOntcImRlZmF1bHRcIjptb2R9O307dmFyIF9faW1wb3J0U3Rhcj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24obW9kKXtpZihtb2QmJm1vZC5fX2VzTW9kdWxlKXJldHVybiBtb2Q7dmFyIHJlc3VsdD17fTtpZihtb2QhPW51bGwpZm9yKHZhciBrIGluIG1vZCl7aWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLGspKXJlc3VsdFtrXT1tb2Rba107fXJlc3VsdFtcImRlZmF1bHRcIl09bW9kO3JldHVybiByZXN1bHQ7fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBkb21oYW5kbGVyXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkb21oYW5kbGVyXCIpKTt2YXIgRG9tVXRpbHM9X19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb211dGlsc1wiKSk7dmFyIFBhcnNlcl8xPXJlcXVpcmUoXCIuL1BhcnNlclwiKTsvL1RPRE86IENvbnN1bWUgZGF0YSBhcyBpdCBpcyBjb21pbmcgaW5cbnZhciBGZWVkSGFuZGxlcj0vKiogQGNsYXNzICovZnVuY3Rpb24oX3N1cGVyKXtfX2V4dGVuZHMoRmVlZEhhbmRsZXIsX3N1cGVyKTsvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovZnVuY3Rpb24gRmVlZEhhbmRsZXIoY2FsbGJhY2ssb3B0aW9ucyl7dmFyIF90aGlzPXRoaXM7aWYoX3R5cGVvZihjYWxsYmFjayk9PT1cIm9iamVjdFwiJiZjYWxsYmFjayE9PW51bGwpe2NhbGxiYWNrPXVuZGVmaW5lZDtvcHRpb25zPWNhbGxiYWNrO31fdGhpcz1fc3VwZXIuY2FsbCh0aGlzLGNhbGxiYWNrLG9wdGlvbnMpfHx0aGlzO3JldHVybiBfdGhpczt9RmVlZEhhbmRsZXIucHJvdG90eXBlLm9uZW5kPWZ1bmN0aW9uKCl7dmFyIGZlZWQ9e307dmFyIGZlZWRSb290PWdldE9uZUVsZW1lbnQoaXNWYWxpZEZlZWQsdGhpcy5kb20pO2lmKGZlZWRSb290KXtpZihmZWVkUm9vdC5uYW1lPT09XCJmZWVkXCIpe3ZhciBjaGlsZHM9ZmVlZFJvb3QuY2hpbGRyZW47ZmVlZC50eXBlPVwiYXRvbVwiO2FkZENvbmRpdGlvbmFsbHkoZmVlZCxcImlkXCIsXCJpZFwiLGNoaWxkcyk7YWRkQ29uZGl0aW9uYWxseShmZWVkLFwidGl0bGVcIixcInRpdGxlXCIsY2hpbGRzKTt2YXIgaHJlZj1nZXRBdHRyaWJ1dGUoXCJocmVmXCIsZ2V0T25lRWxlbWVudChcImxpbmtcIixjaGlsZHMpKTtpZihocmVmKXtmZWVkLmxpbms9aHJlZjt9YWRkQ29uZGl0aW9uYWxseShmZWVkLFwiZGVzY3JpcHRpb25cIixcInN1YnRpdGxlXCIsY2hpbGRzKTt2YXIgdXBkYXRlZD1mZXRjaChcInVwZGF0ZWRcIixjaGlsZHMpO2lmKHVwZGF0ZWQpe2ZlZWQudXBkYXRlZD1uZXcgRGF0ZSh1cGRhdGVkKTt9YWRkQ29uZGl0aW9uYWxseShmZWVkLFwiYXV0aG9yXCIsXCJlbWFpbFwiLGNoaWxkcyx0cnVlKTtmZWVkLml0ZW1zPWdldEVsZW1lbnRzKFwiZW50cnlcIixjaGlsZHMpLm1hcChmdW5jdGlvbihpdGVtKXt2YXIgZW50cnk9e307dmFyIGNoaWxkcmVuPWl0ZW0uY2hpbGRyZW47YWRkQ29uZGl0aW9uYWxseShlbnRyeSxcImlkXCIsXCJpZFwiLGNoaWxkcmVuKTthZGRDb25kaXRpb25hbGx5KGVudHJ5LFwidGl0bGVcIixcInRpdGxlXCIsY2hpbGRyZW4pO3ZhciBocmVmPWdldEF0dHJpYnV0ZShcImhyZWZcIixnZXRPbmVFbGVtZW50KFwibGlua1wiLGNoaWxkcmVuKSk7aWYoaHJlZil7ZW50cnkubGluaz1ocmVmO312YXIgZGVzY3JpcHRpb249ZmV0Y2goXCJzdW1tYXJ5XCIsY2hpbGRyZW4pfHxmZXRjaChcImNvbnRlbnRcIixjaGlsZHJlbik7aWYoZGVzY3JpcHRpb24pe2VudHJ5LmRlc2NyaXB0aW9uPWRlc2NyaXB0aW9uO312YXIgcHViRGF0ZT1mZXRjaChcInVwZGF0ZWRcIixjaGlsZHJlbik7aWYocHViRGF0ZSl7ZW50cnkucHViRGF0ZT1uZXcgRGF0ZShwdWJEYXRlKTt9cmV0dXJuIGVudHJ5O30pO31lbHNle3ZhciBjaGlsZHM9Z2V0T25lRWxlbWVudChcImNoYW5uZWxcIixmZWVkUm9vdC5jaGlsZHJlbikuY2hpbGRyZW47ZmVlZC50eXBlPWZlZWRSb290Lm5hbWUuc3Vic3RyKDAsMyk7ZmVlZC5pZD1cIlwiO2FkZENvbmRpdGlvbmFsbHkoZmVlZCxcInRpdGxlXCIsXCJ0aXRsZVwiLGNoaWxkcyk7YWRkQ29uZGl0aW9uYWxseShmZWVkLFwibGlua1wiLFwibGlua1wiLGNoaWxkcyk7YWRkQ29uZGl0aW9uYWxseShmZWVkLFwiZGVzY3JpcHRpb25cIixcImRlc2NyaXB0aW9uXCIsY2hpbGRzKTt2YXIgdXBkYXRlZD1mZXRjaChcImxhc3RCdWlsZERhdGVcIixjaGlsZHMpO2lmKHVwZGF0ZWQpe2ZlZWQudXBkYXRlZD1uZXcgRGF0ZSh1cGRhdGVkKTt9YWRkQ29uZGl0aW9uYWxseShmZWVkLFwiYXV0aG9yXCIsXCJtYW5hZ2luZ0VkaXRvclwiLGNoaWxkcyx0cnVlKTtmZWVkLml0ZW1zPWdldEVsZW1lbnRzKFwiaXRlbVwiLGZlZWRSb290LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oaXRlbSl7dmFyIGVudHJ5PXt9O3ZhciBjaGlsZHJlbj1pdGVtLmNoaWxkcmVuO2FkZENvbmRpdGlvbmFsbHkoZW50cnksXCJpZFwiLFwiZ3VpZFwiLGNoaWxkcmVuKTthZGRDb25kaXRpb25hbGx5KGVudHJ5LFwidGl0bGVcIixcInRpdGxlXCIsY2hpbGRyZW4pO2FkZENvbmRpdGlvbmFsbHkoZW50cnksXCJsaW5rXCIsXCJsaW5rXCIsY2hpbGRyZW4pO2FkZENvbmRpdGlvbmFsbHkoZW50cnksXCJkZXNjcmlwdGlvblwiLFwiZGVzY3JpcHRpb25cIixjaGlsZHJlbik7dmFyIHB1YkRhdGU9ZmV0Y2goXCJwdWJEYXRlXCIsY2hpbGRyZW4pO2lmKHB1YkRhdGUpZW50cnkucHViRGF0ZT1uZXcgRGF0ZShwdWJEYXRlKTtyZXR1cm4gZW50cnk7fSk7fX10aGlzLmZlZWQ9ZmVlZDt0aGlzLmhhbmRsZUNhbGxiYWNrKGZlZWRSb290P251bGw6RXJyb3IoXCJjb3VsZG4ndCBmaW5kIHJvb3Qgb2YgZmVlZFwiKSk7fTtyZXR1cm4gRmVlZEhhbmRsZXI7fShkb21oYW5kbGVyXzFbXCJkZWZhdWx0XCJdKTtleHBvcnRzLkZlZWRIYW5kbGVyPUZlZWRIYW5kbGVyO2Z1bmN0aW9uIGdldEVsZW1lbnRzKHdoYXQsd2hlcmUpe3JldHVybiBEb21VdGlscy5nZXRFbGVtZW50c0J5VGFnTmFtZSh3aGF0LHdoZXJlLHRydWUpO31mdW5jdGlvbiBnZXRPbmVFbGVtZW50KHdoYXQsd2hlcmUpe3JldHVybiBEb21VdGlscy5nZXRFbGVtZW50c0J5VGFnTmFtZSh3aGF0LHdoZXJlLHRydWUsMSlbMF07fWZ1bmN0aW9uIGZldGNoKHdoYXQsd2hlcmUscmVjdXJzZSl7aWYocmVjdXJzZT09PXZvaWQgMCl7cmVjdXJzZT1mYWxzZTt9cmV0dXJuIERvbVV0aWxzLmdldFRleHQoRG9tVXRpbHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUod2hhdCx3aGVyZSxyZWN1cnNlLDEpKS50cmltKCk7fWZ1bmN0aW9uIGdldEF0dHJpYnV0ZShuYW1lLGVsZW0pe2lmKCFlbGVtKXtyZXR1cm4gbnVsbDt9dmFyIGF0dHJpYnM9ZWxlbS5hdHRyaWJzO3JldHVybiBhdHRyaWJzW25hbWVdO31mdW5jdGlvbiBhZGRDb25kaXRpb25hbGx5KG9iaixwcm9wLHdoYXQsd2hlcmUscmVjdXJzZSl7aWYocmVjdXJzZT09PXZvaWQgMCl7cmVjdXJzZT1mYWxzZTt9dmFyIHRtcD1mZXRjaCh3aGF0LHdoZXJlLHJlY3Vyc2UpOy8vIEB0cy1pZ25vcmVcbmlmKHRtcClvYmpbcHJvcF09dG1wO31mdW5jdGlvbiBpc1ZhbGlkRmVlZCh2YWx1ZSl7cmV0dXJuIHZhbHVlPT09XCJyc3NcInx8dmFsdWU9PT1cImZlZWRcInx8dmFsdWU9PT1cInJkZjpSREZcIjt9dmFyIGRlZmF1bHRPcHRpb25zPXt4bWxNb2RlOnRydWV9Oy8qKlxuICogUGFyc2UgYSBmZWVkLlxuICpcbiAqIEBwYXJhbSBmZWVkIFRoZSBmZWVkIHRoYXQgc2hvdWxkIGJlIHBhcnNlZCwgYXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbGx5LCBvcHRpb25zIGZvciBwYXJzaW5nLiBXaGVuIHVzaW5nIHRoaXMgb3B0aW9uLCB5b3UgcHJvYmFibHkgd2FudCB0byBzZXQgYHhtbE1vZGVgIHRvIGB0cnVlYC5cbiAqL2Z1bmN0aW9uIHBhcnNlRmVlZChmZWVkLG9wdGlvbnMpe2lmKG9wdGlvbnM9PT12b2lkIDApe29wdGlvbnM9ZGVmYXVsdE9wdGlvbnM7fXZhciBoYW5kbGVyPW5ldyBGZWVkSGFuZGxlcihvcHRpb25zKTtuZXcgUGFyc2VyXzEuUGFyc2VyKGhhbmRsZXIsb3B0aW9ucykuZW5kKGZlZWQpO3JldHVybiBoYW5kbGVyLmZlZWQ7fWV4cG9ydHMucGFyc2VGZWVkPXBhcnNlRmVlZDt9LHtcIi4vUGFyc2VyXCI6MjksXCJkb21oYW5kbGVyXCI6NyxcImRvbXV0aWxzXCI6MTB9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTsvKipcbiAqIENhbGxzIGEgc3BlY2lmaWMgaGFuZGxlciBmdW5jdGlvbiBmb3IgYWxsIGV2ZW50cyB0aGF0IGFyZSBlbmNvdW50ZXJlZC5cbiAqXG4gKiBAcGFyYW0gZnVuYyDigJQgVGhlIGZ1bmN0aW9uIHRvIG11bHRpcGxleCBhbGwgZXZlbnRzIHRvLlxuICovdmFyIE11bHRpcGxleEhhbmRsZXI9LyoqIEBjbGFzcyAqL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gTXVsdGlwbGV4SGFuZGxlcihmdW5jKXt0aGlzLl9mdW5jPWZ1bmM7fS8qIEZvcm1hdDogZXZlbnRuYW1lOiBudW1iZXIgb2YgYXJndW1lbnRzICovTXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25hdHRyaWJ1dGU9ZnVuY3Rpb24obmFtZSx2YWx1ZSl7dGhpcy5fZnVuYyhcIm9uYXR0cmlidXRlXCIsbmFtZSx2YWx1ZSk7fTtNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmNkYXRhc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLl9mdW5jKFwib25jZGF0YXN0YXJ0XCIpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25jZGF0YWVuZD1mdW5jdGlvbigpe3RoaXMuX2Z1bmMoXCJvbmNkYXRhZW5kXCIpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub250ZXh0PWZ1bmN0aW9uKHRleHQpe3RoaXMuX2Z1bmMoXCJvbnRleHRcIix0ZXh0KTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uPWZ1bmN0aW9uKG5hbWUsdmFsdWUpe3RoaXMuX2Z1bmMoXCJvbnByb2Nlc3NpbmdpbnN0cnVjdGlvblwiLG5hbWUsdmFsdWUpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25jb21tZW50PWZ1bmN0aW9uKGNvbW1lbnQpe3RoaXMuX2Z1bmMoXCJvbmNvbW1lbnRcIixjb21tZW50KTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9uY29tbWVudGVuZD1mdW5jdGlvbigpe3RoaXMuX2Z1bmMoXCJvbmNvbW1lbnRlbmRcIik7fTtNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbmNsb3NldGFnPWZ1bmN0aW9uKG5hbWUpe3RoaXMuX2Z1bmMoXCJvbmNsb3NldGFnXCIsbmFtZSk7fTtNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbm9wZW50YWc9ZnVuY3Rpb24obmFtZSxhdHRyaWJzKXt0aGlzLl9mdW5jKFwib25vcGVudGFnXCIsbmFtZSxhdHRyaWJzKTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9ub3BlbnRhZ25hbWU9ZnVuY3Rpb24obmFtZSl7dGhpcy5fZnVuYyhcIm9ub3BlbnRhZ25hbWVcIixuYW1lKTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9uZXJyb3I9ZnVuY3Rpb24oZXJyb3Ipe3RoaXMuX2Z1bmMoXCJvbmVycm9yXCIsZXJyb3IpO307TXVsdGlwbGV4SGFuZGxlci5wcm90b3R5cGUub25lbmQ9ZnVuY3Rpb24oKXt0aGlzLl9mdW5jKFwib25lbmRcIik7fTtNdWx0aXBsZXhIYW5kbGVyLnByb3RvdHlwZS5vbnBhcnNlcmluaXQ9ZnVuY3Rpb24ocGFyc2VyKXt0aGlzLl9mdW5jKFwib25wYXJzZXJpbml0XCIscGFyc2VyKTt9O011bHRpcGxleEhhbmRsZXIucHJvdG90eXBlLm9ucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9mdW5jKFwib25yZXNldFwiKTt9O3JldHVybiBNdWx0aXBsZXhIYW5kbGVyO30oKTtleHBvcnRzW1wiZGVmYXVsdFwiXT1NdWx0aXBsZXhIYW5kbGVyO30se31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgX19leHRlbmRzPXRoaXMmJnRoaXMuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciBfZXh0ZW5kU3RhdGljczQ9ZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLGIpe19leHRlbmRTdGF0aWNzND1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZCxiKXtkLl9fcHJvdG9fXz1iO318fGZ1bmN0aW9uKGQsYil7Zm9yKHZhciBwIGluIGIpe2lmKGIuaGFzT3duUHJvcGVydHkocCkpZFtwXT1iW3BdO319O3JldHVybiBfZXh0ZW5kU3RhdGljczQoZCxiKTt9O3JldHVybiBmdW5jdGlvbihkLGIpe19leHRlbmRTdGF0aWNzNChkLGIpO2Z1bmN0aW9uIF9fKCl7dGhpcy5jb25zdHJ1Y3Rvcj1kO31kLnByb3RvdHlwZT1iPT09bnVsbD9PYmplY3QuY3JlYXRlKGIpOihfXy5wcm90b3R5cGU9Yi5wcm90b3R5cGUsbmV3IF9fKCkpO307fSgpO3ZhciBfX2ltcG9ydERlZmF1bHQ9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKG1vZCl7cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOntcImRlZmF1bHRcIjptb2R9O307T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTt2YXIgVG9rZW5pemVyXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Rva2VuaXplclwiKSk7dmFyIGV2ZW50c18xPXJlcXVpcmUoXCJldmVudHNcIik7dmFyIGZvcm1UYWdzPW5ldyBTZXQoW1wiaW5wdXRcIixcIm9wdGlvblwiLFwib3B0Z3JvdXBcIixcInNlbGVjdFwiLFwiYnV0dG9uXCIsXCJkYXRhbGlzdFwiLFwidGV4dGFyZWFcIl0pO3ZhciBwVGFnPW5ldyBTZXQoW1wicFwiXSk7dmFyIG9wZW5JbXBsaWVzQ2xvc2U9e3RyOm5ldyBTZXQoW1widHJcIixcInRoXCIsXCJ0ZFwiXSksdGg6bmV3IFNldChbXCJ0aFwiXSksdGQ6bmV3IFNldChbXCJ0aGVhZFwiLFwidGhcIixcInRkXCJdKSxib2R5Om5ldyBTZXQoW1wiaGVhZFwiLFwibGlua1wiLFwic2NyaXB0XCJdKSxsaTpuZXcgU2V0KFtcImxpXCJdKSxwOnBUYWcsaDE6cFRhZyxoMjpwVGFnLGgzOnBUYWcsaDQ6cFRhZyxoNTpwVGFnLGg2OnBUYWcsc2VsZWN0OmZvcm1UYWdzLGlucHV0OmZvcm1UYWdzLG91dHB1dDpmb3JtVGFncyxidXR0b246Zm9ybVRhZ3MsZGF0YWxpc3Q6Zm9ybVRhZ3MsdGV4dGFyZWE6Zm9ybVRhZ3Msb3B0aW9uOm5ldyBTZXQoW1wib3B0aW9uXCJdKSxvcHRncm91cDpuZXcgU2V0KFtcIm9wdGdyb3VwXCIsXCJvcHRpb25cIl0pLGRkOm5ldyBTZXQoW1wiZHRcIixcImRkXCJdKSxkdDpuZXcgU2V0KFtcImR0XCIsXCJkZFwiXSksYWRkcmVzczpwVGFnLGFydGljbGU6cFRhZyxhc2lkZTpwVGFnLGJsb2NrcXVvdGU6cFRhZyxkZXRhaWxzOnBUYWcsZGl2OnBUYWcsZGw6cFRhZyxmaWVsZHNldDpwVGFnLGZpZ2NhcHRpb246cFRhZyxmaWd1cmU6cFRhZyxmb290ZXI6cFRhZyxmb3JtOnBUYWcsaGVhZGVyOnBUYWcsaHI6cFRhZyxtYWluOnBUYWcsbmF2OnBUYWcsb2w6cFRhZyxwcmU6cFRhZyxzZWN0aW9uOnBUYWcsdGFibGU6cFRhZyx1bDpwVGFnLHJ0Om5ldyBTZXQoW1wicnRcIixcInJwXCJdKSxycDpuZXcgU2V0KFtcInJ0XCIsXCJycFwiXSksdGJvZHk6bmV3IFNldChbXCJ0aGVhZFwiLFwidGJvZHlcIl0pLHRmb290Om5ldyBTZXQoW1widGhlYWRcIixcInRib2R5XCJdKX07dmFyIHZvaWRFbGVtZW50cz1uZXcgU2V0KFtcImFyZWFcIixcImJhc2VcIixcImJhc2Vmb250XCIsXCJiclwiLFwiY29sXCIsXCJjb21tYW5kXCIsXCJlbWJlZFwiLFwiZnJhbWVcIixcImhyXCIsXCJpbWdcIixcImlucHV0XCIsXCJpc2luZGV4XCIsXCJrZXlnZW5cIixcImxpbmtcIixcIm1ldGFcIixcInBhcmFtXCIsXCJzb3VyY2VcIixcInRyYWNrXCIsXCJ3YnJcIl0pO3ZhciBmb3JlaWduQ29udGV4dEVsZW1lbnRzPW5ldyBTZXQoW1wibWF0aFwiLFwic3ZnXCJdKTt2YXIgaHRtbEludGVncmF0aW9uRWxlbWVudHM9bmV3IFNldChbXCJtaVwiLFwibW9cIixcIm1uXCIsXCJtc1wiLFwibXRleHRcIixcImFubm90YXRpb24teG1sXCIsXCJmb3JlaWduT2JqZWN0XCIsXCJkZXNjXCIsXCJ0aXRsZVwiXSk7dmFyIHJlTmFtZUVuZD0vXFxzfFxcLy87dmFyIFBhcnNlcj0vKiogQGNsYXNzICovZnVuY3Rpb24oX3N1cGVyKXtfX2V4dGVuZHMoUGFyc2VyLF9zdXBlcik7ZnVuY3Rpb24gUGFyc2VyKGNicyxvcHRpb25zKXt2YXIgX3RoaXM9X3N1cGVyLmNhbGwodGhpcyl8fHRoaXM7X3RoaXMuX3RhZ25hbWU9XCJcIjtfdGhpcy5fYXR0cmlibmFtZT1cIlwiO190aGlzLl9hdHRyaWJ2YWx1ZT1cIlwiO190aGlzLl9hdHRyaWJzPW51bGw7X3RoaXMuX3N0YWNrPVtdO190aGlzLl9mb3JlaWduQ29udGV4dD1bXTtfdGhpcy5zdGFydEluZGV4PTA7X3RoaXMuZW5kSW5kZXg9bnVsbDsvLyBBbGlhc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuX3RoaXMucGFyc2VDaHVuaz1QYXJzZXIucHJvdG90eXBlLndyaXRlO190aGlzLmRvbmU9UGFyc2VyLnByb3RvdHlwZS5lbmQ7X3RoaXMuX29wdGlvbnM9b3B0aW9uc3x8e307X3RoaXMuX2Nicz1jYnN8fHt9O190aGlzLl90YWduYW1lPVwiXCI7X3RoaXMuX2F0dHJpYm5hbWU9XCJcIjtfdGhpcy5fYXR0cmlidmFsdWU9XCJcIjtfdGhpcy5fYXR0cmlicz1udWxsO190aGlzLl9zdGFjaz1bXTtfdGhpcy5fZm9yZWlnbkNvbnRleHQ9W107X3RoaXMuc3RhcnRJbmRleD0wO190aGlzLmVuZEluZGV4PW51bGw7X3RoaXMuX2xvd2VyQ2FzZVRhZ05hbWVzPVwibG93ZXJDYXNlVGFnc1wiaW4gX3RoaXMuX29wdGlvbnM/ISFfdGhpcy5fb3B0aW9ucy5sb3dlckNhc2VUYWdzOiFfdGhpcy5fb3B0aW9ucy54bWxNb2RlO190aGlzLl9sb3dlckNhc2VBdHRyaWJ1dGVOYW1lcz1cImxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzXCJpbiBfdGhpcy5fb3B0aW9ucz8hIV90aGlzLl9vcHRpb25zLmxvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzOiFfdGhpcy5fb3B0aW9ucy54bWxNb2RlO190aGlzLl90b2tlbml6ZXI9bmV3KF90aGlzLl9vcHRpb25zLlRva2VuaXplcnx8VG9rZW5pemVyXzFbXCJkZWZhdWx0XCJdKShfdGhpcy5fb3B0aW9ucyxfdGhpcyk7aWYoX3RoaXMuX2Nicy5vbnBhcnNlcmluaXQpX3RoaXMuX2Nicy5vbnBhcnNlcmluaXQoX3RoaXMpO3JldHVybiBfdGhpczt9UGFyc2VyLnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb249ZnVuY3Rpb24oaW5pdGlhbE9mZnNldCl7aWYodGhpcy5lbmRJbmRleD09PW51bGwpe2lmKHRoaXMuX3Rva2VuaXplci5fc2VjdGlvblN0YXJ0PD1pbml0aWFsT2Zmc2V0KXt0aGlzLnN0YXJ0SW5kZXg9MDt9ZWxzZXt0aGlzLnN0YXJ0SW5kZXg9dGhpcy5fdG9rZW5pemVyLl9zZWN0aW9uU3RhcnQtaW5pdGlhbE9mZnNldDt9fWVsc2UgdGhpcy5zdGFydEluZGV4PXRoaXMuZW5kSW5kZXgrMTt0aGlzLmVuZEluZGV4PXRoaXMuX3Rva2VuaXplci5nZXRBYnNvbHV0ZUluZGV4KCk7fTsvL1Rva2VuaXplciBldmVudCBoYW5kbGVyc1xuUGFyc2VyLnByb3RvdHlwZS5vbnRleHQ9ZnVuY3Rpb24oZGF0YSl7dGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7Ly8gQHRzLWlnbm9yZVxudGhpcy5lbmRJbmRleC0tO2lmKHRoaXMuX2Nicy5vbnRleHQpdGhpcy5fY2JzLm9udGV4dChkYXRhKTt9O1BhcnNlci5wcm90b3R5cGUub25vcGVudGFnbmFtZT1mdW5jdGlvbihuYW1lKXtpZih0aGlzLl9sb3dlckNhc2VUYWdOYW1lcyl7bmFtZT1uYW1lLnRvTG93ZXJDYXNlKCk7fXRoaXMuX3RhZ25hbWU9bmFtZTtpZighdGhpcy5fb3B0aW9ucy54bWxNb2RlJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3BlbkltcGxpZXNDbG9zZSxuYW1lKSl7Zm9yKHZhciBlbD12b2lkIDA7Ly8gQHRzLWlnbm9yZVxub3BlbkltcGxpZXNDbG9zZVtuYW1lXS5oYXMoZWw9dGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoLTFdKTt0aGlzLm9uY2xvc2V0YWcoZWwpKXs7fX1pZih0aGlzLl9vcHRpb25zLnhtbE1vZGV8fCF2b2lkRWxlbWVudHMuaGFzKG5hbWUpKXt0aGlzLl9zdGFjay5wdXNoKG5hbWUpO2lmKGZvcmVpZ25Db250ZXh0RWxlbWVudHMuaGFzKG5hbWUpKXt0aGlzLl9mb3JlaWduQ29udGV4dC5wdXNoKHRydWUpO31lbHNlIGlmKGh0bWxJbnRlZ3JhdGlvbkVsZW1lbnRzLmhhcyhuYW1lKSl7dGhpcy5fZm9yZWlnbkNvbnRleHQucHVzaChmYWxzZSk7fX1pZih0aGlzLl9jYnMub25vcGVudGFnbmFtZSl0aGlzLl9jYnMub25vcGVudGFnbmFtZShuYW1lKTtpZih0aGlzLl9jYnMub25vcGVudGFnKXRoaXMuX2F0dHJpYnM9e307fTtQYXJzZXIucHJvdG90eXBlLm9ub3BlbnRhZ2VuZD1mdW5jdGlvbigpe3RoaXMuX3VwZGF0ZVBvc2l0aW9uKDEpO2lmKHRoaXMuX2F0dHJpYnMpe2lmKHRoaXMuX2Nicy5vbm9wZW50YWcpe3RoaXMuX2Nicy5vbm9wZW50YWcodGhpcy5fdGFnbmFtZSx0aGlzLl9hdHRyaWJzKTt9dGhpcy5fYXR0cmlicz1udWxsO31pZighdGhpcy5fb3B0aW9ucy54bWxNb2RlJiZ0aGlzLl9jYnMub25jbG9zZXRhZyYmdm9pZEVsZW1lbnRzLmhhcyh0aGlzLl90YWduYW1lKSl7dGhpcy5fY2JzLm9uY2xvc2V0YWcodGhpcy5fdGFnbmFtZSk7fXRoaXMuX3RhZ25hbWU9XCJcIjt9O1BhcnNlci5wcm90b3R5cGUub25jbG9zZXRhZz1mdW5jdGlvbihuYW1lKXt0aGlzLl91cGRhdGVQb3NpdGlvbigxKTtpZih0aGlzLl9sb3dlckNhc2VUYWdOYW1lcyl7bmFtZT1uYW1lLnRvTG93ZXJDYXNlKCk7fWlmKGZvcmVpZ25Db250ZXh0RWxlbWVudHMuaGFzKG5hbWUpfHxodG1sSW50ZWdyYXRpb25FbGVtZW50cy5oYXMobmFtZSkpe3RoaXMuX2ZvcmVpZ25Db250ZXh0LnBvcCgpO31pZih0aGlzLl9zdGFjay5sZW5ndGgmJih0aGlzLl9vcHRpb25zLnhtbE1vZGV8fCF2b2lkRWxlbWVudHMuaGFzKG5hbWUpKSl7dmFyIHBvcz10aGlzLl9zdGFjay5sYXN0SW5kZXhPZihuYW1lKTtpZihwb3MhPT0tMSl7aWYodGhpcy5fY2JzLm9uY2xvc2V0YWcpe3Bvcz10aGlzLl9zdGFjay5sZW5ndGgtcG9zOy8vIEB0cy1pZ25vcmVcbndoaWxlKHBvcy0tKXt0aGlzLl9jYnMub25jbG9zZXRhZyh0aGlzLl9zdGFjay5wb3AoKSk7fX1lbHNlIHRoaXMuX3N0YWNrLmxlbmd0aD1wb3M7fWVsc2UgaWYobmFtZT09PVwicFwiJiYhdGhpcy5fb3B0aW9ucy54bWxNb2RlKXt0aGlzLm9ub3BlbnRhZ25hbWUobmFtZSk7dGhpcy5fY2xvc2VDdXJyZW50VGFnKCk7fX1lbHNlIGlmKCF0aGlzLl9vcHRpb25zLnhtbE1vZGUmJihuYW1lPT09XCJiclwifHxuYW1lPT09XCJwXCIpKXt0aGlzLm9ub3BlbnRhZ25hbWUobmFtZSk7dGhpcy5fY2xvc2VDdXJyZW50VGFnKCk7fX07UGFyc2VyLnByb3RvdHlwZS5vbnNlbGZjbG9zaW5ndGFnPWZ1bmN0aW9uKCl7aWYodGhpcy5fb3B0aW9ucy54bWxNb2RlfHx0aGlzLl9vcHRpb25zLnJlY29nbml6ZVNlbGZDbG9zaW5nfHx0aGlzLl9mb3JlaWduQ29udGV4dFt0aGlzLl9mb3JlaWduQ29udGV4dC5sZW5ndGgtMV0pe3RoaXMuX2Nsb3NlQ3VycmVudFRhZygpO31lbHNle3RoaXMub25vcGVudGFnZW5kKCk7fX07UGFyc2VyLnByb3RvdHlwZS5fY2xvc2VDdXJyZW50VGFnPWZ1bmN0aW9uKCl7dmFyIG5hbWU9dGhpcy5fdGFnbmFtZTt0aGlzLm9ub3BlbnRhZ2VuZCgpOy8vc2VsZi1jbG9zaW5nIHRhZ3Mgd2lsbCBiZSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFja1xuLy8oY2hlYXBlciBjaGVjayB0aGFuIGluIG9uY2xvc2V0YWcpXG5pZih0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGgtMV09PT1uYW1lKXtpZih0aGlzLl9jYnMub25jbG9zZXRhZyl7dGhpcy5fY2JzLm9uY2xvc2V0YWcobmFtZSk7fXRoaXMuX3N0YWNrLnBvcCgpO319O1BhcnNlci5wcm90b3R5cGUub25hdHRyaWJuYW1lPWZ1bmN0aW9uKG5hbWUpe2lmKHRoaXMuX2xvd2VyQ2FzZUF0dHJpYnV0ZU5hbWVzKXtuYW1lPW5hbWUudG9Mb3dlckNhc2UoKTt9dGhpcy5fYXR0cmlibmFtZT1uYW1lO307UGFyc2VyLnByb3RvdHlwZS5vbmF0dHJpYmRhdGE9ZnVuY3Rpb24odmFsdWUpe3RoaXMuX2F0dHJpYnZhbHVlKz12YWx1ZTt9O1BhcnNlci5wcm90b3R5cGUub25hdHRyaWJlbmQ9ZnVuY3Rpb24oKXtpZih0aGlzLl9jYnMub25hdHRyaWJ1dGUpdGhpcy5fY2JzLm9uYXR0cmlidXRlKHRoaXMuX2F0dHJpYm5hbWUsdGhpcy5fYXR0cmlidmFsdWUpO2lmKHRoaXMuX2F0dHJpYnMmJiFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fYXR0cmlicyx0aGlzLl9hdHRyaWJuYW1lKSl7dGhpcy5fYXR0cmlic1t0aGlzLl9hdHRyaWJuYW1lXT10aGlzLl9hdHRyaWJ2YWx1ZTt9dGhpcy5fYXR0cmlibmFtZT1cIlwiO3RoaXMuX2F0dHJpYnZhbHVlPVwiXCI7fTtQYXJzZXIucHJvdG90eXBlLl9nZXRJbnN0cnVjdGlvbk5hbWU9ZnVuY3Rpb24odmFsdWUpe3ZhciBpZHg9dmFsdWUuc2VhcmNoKHJlTmFtZUVuZCk7dmFyIG5hbWU9aWR4PDA/dmFsdWU6dmFsdWUuc3Vic3RyKDAsaWR4KTtpZih0aGlzLl9sb3dlckNhc2VUYWdOYW1lcyl7bmFtZT1uYW1lLnRvTG93ZXJDYXNlKCk7fXJldHVybiBuYW1lO307UGFyc2VyLnByb3RvdHlwZS5vbmRlY2xhcmF0aW9uPWZ1bmN0aW9uKHZhbHVlKXtpZih0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pe3ZhciBuYW1lXzE9dGhpcy5fZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTt0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oXCIhXCIrbmFtZV8xLFwiIVwiK3ZhbHVlKTt9fTtQYXJzZXIucHJvdG90eXBlLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uPWZ1bmN0aW9uKHZhbHVlKXtpZih0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24pe3ZhciBuYW1lXzI9dGhpcy5fZ2V0SW5zdHJ1Y3Rpb25OYW1lKHZhbHVlKTt0aGlzLl9jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24oXCI/XCIrbmFtZV8yLFwiP1wiK3ZhbHVlKTt9fTtQYXJzZXIucHJvdG90eXBlLm9uY29tbWVudD1mdW5jdGlvbih2YWx1ZSl7dGhpcy5fdXBkYXRlUG9zaXRpb24oNCk7aWYodGhpcy5fY2JzLm9uY29tbWVudCl0aGlzLl9jYnMub25jb21tZW50KHZhbHVlKTtpZih0aGlzLl9jYnMub25jb21tZW50ZW5kKXRoaXMuX2Nicy5vbmNvbW1lbnRlbmQoKTt9O1BhcnNlci5wcm90b3R5cGUub25jZGF0YT1mdW5jdGlvbih2YWx1ZSl7dGhpcy5fdXBkYXRlUG9zaXRpb24oMSk7aWYodGhpcy5fb3B0aW9ucy54bWxNb2RlfHx0aGlzLl9vcHRpb25zLnJlY29nbml6ZUNEQVRBKXtpZih0aGlzLl9jYnMub25jZGF0YXN0YXJ0KXRoaXMuX2Nicy5vbmNkYXRhc3RhcnQoKTtpZih0aGlzLl9jYnMub250ZXh0KXRoaXMuX2Nicy5vbnRleHQodmFsdWUpO2lmKHRoaXMuX2Nicy5vbmNkYXRhZW5kKXRoaXMuX2Nicy5vbmNkYXRhZW5kKCk7fWVsc2V7dGhpcy5vbmNvbW1lbnQoXCJbQ0RBVEFbXCIrdmFsdWUrXCJdXVwiKTt9fTtQYXJzZXIucHJvdG90eXBlLm9uZXJyb3I9ZnVuY3Rpb24oZXJyKXtpZih0aGlzLl9jYnMub25lcnJvcil0aGlzLl9jYnMub25lcnJvcihlcnIpO307UGFyc2VyLnByb3RvdHlwZS5vbmVuZD1mdW5jdGlvbigpe2lmKHRoaXMuX2Nicy5vbmNsb3NldGFnKXtmb3IodmFyIGk9dGhpcy5fc3RhY2subGVuZ3RoO2k+MDt0aGlzLl9jYnMub25jbG9zZXRhZyh0aGlzLl9zdGFja1stLWldKSl7O319aWYodGhpcy5fY2JzLm9uZW5kKXRoaXMuX2Nicy5vbmVuZCgpO307Ly9SZXNldHMgdGhlIHBhcnNlciB0byBhIGJsYW5rIHN0YXRlLCByZWFkeSB0byBwYXJzZSBhIG5ldyBIVE1MIGRvY3VtZW50XG5QYXJzZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7aWYodGhpcy5fY2JzLm9ucmVzZXQpdGhpcy5fY2JzLm9ucmVzZXQoKTt0aGlzLl90b2tlbml6ZXIucmVzZXQoKTt0aGlzLl90YWduYW1lPVwiXCI7dGhpcy5fYXR0cmlibmFtZT1cIlwiO3RoaXMuX2F0dHJpYnM9bnVsbDt0aGlzLl9zdGFjaz1bXTtpZih0aGlzLl9jYnMub25wYXJzZXJpbml0KXRoaXMuX2Nicy5vbnBhcnNlcmluaXQodGhpcyk7fTsvL1BhcnNlcyBhIGNvbXBsZXRlIEhUTUwgZG9jdW1lbnQgYW5kIHB1c2hlcyBpdCB0byB0aGUgaGFuZGxlclxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbXBsZXRlPWZ1bmN0aW9uKGRhdGEpe3RoaXMucmVzZXQoKTt0aGlzLmVuZChkYXRhKTt9O1BhcnNlci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oY2h1bmspe3RoaXMuX3Rva2VuaXplci53cml0ZShjaHVuayk7fTtQYXJzZXIucHJvdG90eXBlLmVuZD1mdW5jdGlvbihjaHVuayl7dGhpcy5fdG9rZW5pemVyLmVuZChjaHVuayk7fTtQYXJzZXIucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKCl7dGhpcy5fdG9rZW5pemVyLnBhdXNlKCk7fTtQYXJzZXIucHJvdG90eXBlLnJlc3VtZT1mdW5jdGlvbigpe3RoaXMuX3Rva2VuaXplci5yZXN1bWUoKTt9O3JldHVybiBQYXJzZXI7fShldmVudHNfMS5FdmVudEVtaXR0ZXIpO2V4cG9ydHMuUGFyc2VyPVBhcnNlcjt9LHtcIi4vVG9rZW5pemVyXCI6MzAsXCJldmVudHNcIjoyNX1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgX19pbXBvcnREZWZhdWx0PXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihtb2Qpe3JldHVybiBtb2QmJm1vZC5fX2VzTW9kdWxlP21vZDp7XCJkZWZhdWx0XCI6bW9kfTt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7dmFyIGRlY29kZV9jb2RlcG9pbnRfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVudGl0aWVzL2xpYi9kZWNvZGVfY29kZXBvaW50XCIpKTt2YXIgZW50aXRpZXNfanNvbl8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZW50aXRpZXMvbGliL21hcHMvZW50aXRpZXMuanNvblwiKSk7dmFyIGxlZ2FjeV9qc29uXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvbWFwcy9sZWdhY3kuanNvblwiKSk7dmFyIHhtbF9qc29uXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJlbnRpdGllcy9saWIvbWFwcy94bWwuanNvblwiKSk7ZnVuY3Rpb24gd2hpdGVzcGFjZShjKXtyZXR1cm4gYz09PVwiIFwifHxjPT09XCJcXG5cInx8Yz09PVwiXFx0XCJ8fGM9PT1cIlxcZlwifHxjPT09XCJcXHJcIjt9ZnVuY3Rpb24gaWZFbHNlU3RhdGUodXBwZXIsU1VDQ0VTUyxGQUlMVVJFKXt2YXIgbG93ZXI9dXBwZXIudG9Mb3dlckNhc2UoKTtpZih1cHBlcj09PWxvd2VyKXtyZXR1cm4gZnVuY3Rpb24odCxjKXtpZihjPT09bG93ZXIpe3QuX3N0YXRlPVNVQ0NFU1M7fWVsc2V7dC5fc3RhdGU9RkFJTFVSRTt0Ll9pbmRleC0tO319O31lbHNle3JldHVybiBmdW5jdGlvbih0LGMpe2lmKGM9PT1sb3dlcnx8Yz09PXVwcGVyKXt0Ll9zdGF0ZT1TVUNDRVNTO31lbHNle3QuX3N0YXRlPUZBSUxVUkU7dC5faW5kZXgtLTt9fTt9fWZ1bmN0aW9uIGNvbnN1bWVTcGVjaWFsTmFtZUNoYXIodXBwZXIsTkVYVF9TVEFURSl7dmFyIGxvd2VyPXVwcGVyLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGZ1bmN0aW9uKHQsYyl7aWYoYz09PWxvd2VyfHxjPT09dXBwZXIpe3QuX3N0YXRlPU5FWFRfU1RBVEU7fWVsc2V7dC5fc3RhdGU9My8qIEluVGFnTmFtZSAqLzt0Ll9pbmRleC0tOy8vY29uc3VtZSB0aGUgdG9rZW4gYWdhaW5cbn19O312YXIgc3RhdGVCZWZvcmVDZGF0YTE9aWZFbHNlU3RhdGUoXCJDXCIsMjMvKiBCZWZvcmVDZGF0YTIgKi8sMTYvKiBJbkRlY2xhcmF0aW9uICovKTt2YXIgc3RhdGVCZWZvcmVDZGF0YTI9aWZFbHNlU3RhdGUoXCJEXCIsMjQvKiBCZWZvcmVDZGF0YTMgKi8sMTYvKiBJbkRlY2xhcmF0aW9uICovKTt2YXIgc3RhdGVCZWZvcmVDZGF0YTM9aWZFbHNlU3RhdGUoXCJBXCIsMjUvKiBCZWZvcmVDZGF0YTQgKi8sMTYvKiBJbkRlY2xhcmF0aW9uICovKTt2YXIgc3RhdGVCZWZvcmVDZGF0YTQ9aWZFbHNlU3RhdGUoXCJUXCIsMjYvKiBCZWZvcmVDZGF0YTUgKi8sMTYvKiBJbkRlY2xhcmF0aW9uICovKTt2YXIgc3RhdGVCZWZvcmVDZGF0YTU9aWZFbHNlU3RhdGUoXCJBXCIsMjcvKiBCZWZvcmVDZGF0YTYgKi8sMTYvKiBJbkRlY2xhcmF0aW9uICovKTt2YXIgc3RhdGVCZWZvcmVTY3JpcHQxPWNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJSXCIsMzQvKiBCZWZvcmVTY3JpcHQyICovKTt2YXIgc3RhdGVCZWZvcmVTY3JpcHQyPWNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJJXCIsMzUvKiBCZWZvcmVTY3JpcHQzICovKTt2YXIgc3RhdGVCZWZvcmVTY3JpcHQzPWNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJQXCIsMzYvKiBCZWZvcmVTY3JpcHQ0ICovKTt2YXIgc3RhdGVCZWZvcmVTY3JpcHQ0PWNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJUXCIsMzcvKiBCZWZvcmVTY3JpcHQ1ICovKTt2YXIgc3RhdGVBZnRlclNjcmlwdDE9aWZFbHNlU3RhdGUoXCJSXCIsMzkvKiBBZnRlclNjcmlwdDIgKi8sMS8qIFRleHQgKi8pO3ZhciBzdGF0ZUFmdGVyU2NyaXB0Mj1pZkVsc2VTdGF0ZShcIklcIiw0MC8qIEFmdGVyU2NyaXB0MyAqLywxLyogVGV4dCAqLyk7dmFyIHN0YXRlQWZ0ZXJTY3JpcHQzPWlmRWxzZVN0YXRlKFwiUFwiLDQxLyogQWZ0ZXJTY3JpcHQ0ICovLDEvKiBUZXh0ICovKTt2YXIgc3RhdGVBZnRlclNjcmlwdDQ9aWZFbHNlU3RhdGUoXCJUXCIsNDIvKiBBZnRlclNjcmlwdDUgKi8sMS8qIFRleHQgKi8pO3ZhciBzdGF0ZUJlZm9yZVN0eWxlMT1jb25zdW1lU3BlY2lhbE5hbWVDaGFyKFwiWVwiLDQ0LyogQmVmb3JlU3R5bGUyICovKTt2YXIgc3RhdGVCZWZvcmVTdHlsZTI9Y29uc3VtZVNwZWNpYWxOYW1lQ2hhcihcIkxcIiw0NS8qIEJlZm9yZVN0eWxlMyAqLyk7dmFyIHN0YXRlQmVmb3JlU3R5bGUzPWNvbnN1bWVTcGVjaWFsTmFtZUNoYXIoXCJFXCIsNDYvKiBCZWZvcmVTdHlsZTQgKi8pO3ZhciBzdGF0ZUFmdGVyU3R5bGUxPWlmRWxzZVN0YXRlKFwiWVwiLDQ4LyogQWZ0ZXJTdHlsZTIgKi8sMS8qIFRleHQgKi8pO3ZhciBzdGF0ZUFmdGVyU3R5bGUyPWlmRWxzZVN0YXRlKFwiTFwiLDQ5LyogQWZ0ZXJTdHlsZTMgKi8sMS8qIFRleHQgKi8pO3ZhciBzdGF0ZUFmdGVyU3R5bGUzPWlmRWxzZVN0YXRlKFwiRVwiLDUwLyogQWZ0ZXJTdHlsZTQgKi8sMS8qIFRleHQgKi8pO3ZhciBzdGF0ZUJlZm9yZUVudGl0eT1pZkVsc2VTdGF0ZShcIiNcIiw1Mi8qIEJlZm9yZU51bWVyaWNFbnRpdHkgKi8sNTMvKiBJbk5hbWVkRW50aXR5ICovKTt2YXIgc3RhdGVCZWZvcmVOdW1lcmljRW50aXR5PWlmRWxzZVN0YXRlKFwiWFwiLDU1LyogSW5IZXhFbnRpdHkgKi8sNTQvKiBJbk51bWVyaWNFbnRpdHkgKi8pO3ZhciBUb2tlbml6ZXI9LyoqIEBjbGFzcyAqL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gVG9rZW5pemVyKG9wdGlvbnMsY2JzKXsvKiogVGhlIGN1cnJlbnQgc3RhdGUgdGhlIHRva2VuaXplciBpcyBpbi4gKi90aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzsvKiogVGhlIHJlYWQgYnVmZmVyLiAqL3RoaXMuX2J1ZmZlcj1cIlwiOy8qKiBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzZWN0aW9uIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHJlYWQuICovdGhpcy5fc2VjdGlvblN0YXJ0PTA7LyoqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJ1ZmZlciB0aGF0IHdlIGFyZSBjdXJyZW50bHkgbG9va2luZyBhdC4gKi90aGlzLl9pbmRleD0wOy8qKlxuICAgICAgICAgKiBEYXRhIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGJ1ZmZlciBvY2Nhc2lvbmFsbHkuXG4gICAgICAgICAqIGBfYnVmZmVyT2Zmc2V0YCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZW1vdmVkLCB0byBtYWtlIHN1cmUgcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgYWNjdXJhdGUuXG4gICAgICAgICAqL3RoaXMuX2J1ZmZlck9mZnNldD0wOy8qKiBTb21lIGJlaGF2aW9yLCBlZy4gd2hlbiBkZWNvZGluZyBlbnRpdGllcywgaXMgZG9uZSB3aGlsZSB3ZSBhcmUgaW4gYW5vdGhlciBzdGF0ZS4gVGhpcyBrZWVwcyB0cmFjayBvZiB0aGUgb3RoZXIgc3RhdGUgdHlwZS4gKi90aGlzLl9iYXNlU3RhdGU9MS8qIFRleHQgKi87LyoqIEZvciBzcGVjaWFsIHBhcnNpbmcgYmVoYXZpb3IgaW5zaWRlIG9mIHNjcmlwdCBhbmQgc3R5bGUgdGFncy4gKi90aGlzLl9zcGVjaWFsPTEvKiBOb25lICovOy8qKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdG9rZW5pemVyIGhhcyBiZWVuIHBhdXNlZC4gKi90aGlzLl9ydW5uaW5nPXRydWU7LyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0b2tlbml6ZXIgaGFzIGZpbmlzaGVkIHJ1bm5pbmcgLyBgLmVuZGAgaGFzIGJlZW4gY2FsbGVkLiAqL3RoaXMuX2VuZGVkPWZhbHNlO3RoaXMuX2Nicz1jYnM7dGhpcy5feG1sTW9kZT0hIShvcHRpb25zJiZvcHRpb25zLnhtbE1vZGUpO3RoaXMuX2RlY29kZUVudGl0aWVzPSEhKG9wdGlvbnMmJm9wdGlvbnMuZGVjb2RlRW50aXRpZXMpO31Ub2tlbml6ZXIucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87dGhpcy5fYnVmZmVyPVwiXCI7dGhpcy5fc2VjdGlvblN0YXJ0PTA7dGhpcy5faW5kZXg9MDt0aGlzLl9idWZmZXJPZmZzZXQ9MDt0aGlzLl9iYXNlU3RhdGU9MS8qIFRleHQgKi87dGhpcy5fc3BlY2lhbD0xLyogTm9uZSAqLzt0aGlzLl9ydW5uaW5nPXRydWU7dGhpcy5fZW5kZWQ9ZmFsc2U7fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZVRleHQ9ZnVuY3Rpb24oYyl7aWYoYz09PVwiPFwiKXtpZih0aGlzLl9pbmRleD50aGlzLl9zZWN0aW9uU3RhcnQpe3RoaXMuX2Nicy5vbnRleHQodGhpcy5fZ2V0U2VjdGlvbigpKTt9dGhpcy5fc3RhdGU9Mi8qIEJlZm9yZVRhZ05hbWUgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O31lbHNlIGlmKHRoaXMuX2RlY29kZUVudGl0aWVzJiZ0aGlzLl9zcGVjaWFsPT09MS8qIE5vbmUgKi8mJmM9PT1cIiZcIil7aWYodGhpcy5faW5kZXg+dGhpcy5fc2VjdGlvblN0YXJ0KXt0aGlzLl9jYnMub250ZXh0KHRoaXMuX2dldFNlY3Rpb24oKSk7fXRoaXMuX2Jhc2VTdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9zdGF0ZT01MS8qIEJlZm9yZUVudGl0eSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVUYWdOYW1lPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIi9cIil7dGhpcy5fc3RhdGU9NS8qIEJlZm9yZUNsb3NpbmdUYWdOYW1lICovO31lbHNlIGlmKGM9PT1cIjxcIil7dGhpcy5fY2JzLm9udGV4dCh0aGlzLl9nZXRTZWN0aW9uKCkpO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleDt9ZWxzZSBpZihjPT09XCI+XCJ8fHRoaXMuX3NwZWNpYWwhPT0xLyogTm9uZSAqL3x8d2hpdGVzcGFjZShjKSl7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87fWVsc2UgaWYoYz09PVwiIVwiKXt0aGlzLl9zdGF0ZT0xNS8qIEJlZm9yZURlY2xhcmF0aW9uICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleCsxO31lbHNlIGlmKGM9PT1cIj9cIil7dGhpcy5fc3RhdGU9MTcvKiBJblByb2Nlc3NpbmdJbnN0cnVjdGlvbiAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9ZWxzZXt0aGlzLl9zdGF0ZT0hdGhpcy5feG1sTW9kZSYmKGM9PT1cInNcInx8Yz09PVwiU1wiKT8zMS8qIEJlZm9yZVNwZWNpYWwgKi86My8qIEluVGFnTmFtZSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJblRhZ05hbWU9ZnVuY3Rpb24oYyl7aWYoYz09PVwiL1wifHxjPT09XCI+XCJ8fHdoaXRlc3BhY2UoYykpe3RoaXMuX2VtaXRUb2tlbihcIm9ub3BlbnRhZ25hbWVcIik7dGhpcy5fc3RhdGU9OC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87dGhpcy5faW5kZXgtLTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lPWZ1bmN0aW9uKGMpe2lmKHdoaXRlc3BhY2UoYykpey8vIGlnbm9yZVxufWVsc2UgaWYoYz09PVwiPlwiKXt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt9ZWxzZSBpZih0aGlzLl9zcGVjaWFsIT09MS8qIE5vbmUgKi8pe2lmKGM9PT1cInNcInx8Yz09PVwiU1wiKXt0aGlzLl9zdGF0ZT0zMi8qIEJlZm9yZVNwZWNpYWxFbmQgKi87fWVsc2V7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87dGhpcy5faW5kZXgtLTt9fWVsc2V7dGhpcy5fc3RhdGU9Ni8qIEluQ2xvc2luZ1RhZ05hbWUgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5DbG9zaW5nVGFnTmFtZT1mdW5jdGlvbihjKXtpZihjPT09XCI+XCJ8fHdoaXRlc3BhY2UoYykpe3RoaXMuX2VtaXRUb2tlbihcIm9uY2xvc2V0YWdcIik7dGhpcy5fc3RhdGU9Ny8qIEFmdGVyQ2xvc2luZ1RhZ05hbWUgKi87dGhpcy5faW5kZXgtLTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWU9ZnVuY3Rpb24oYyl7Ly9za2lwIGV2ZXJ5dGhpbmcgdW50aWwgXCI+XCJcbmlmKGM9PT1cIj5cIil7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVOYW1lPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIj5cIil7dGhpcy5fY2JzLm9ub3BlbnRhZ2VuZCgpO3RoaXMuX3N0YXRlPTEvKiBUZXh0ICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleCsxO31lbHNlIGlmKGM9PT1cIi9cIil7dGhpcy5fc3RhdGU9NC8qIEluU2VsZkNsb3NpbmdUYWcgKi87fWVsc2UgaWYoIXdoaXRlc3BhY2UoYykpe3RoaXMuX3N0YXRlPTkvKiBJbkF0dHJpYnV0ZU5hbWUgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5TZWxmQ2xvc2luZ1RhZz1mdW5jdGlvbihjKXtpZihjPT09XCI+XCIpe3RoaXMuX2Nicy5vbnNlbGZjbG9zaW5ndGFnKCk7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fWVsc2UgaWYoIXdoaXRlc3BhY2UoYykpe3RoaXMuX3N0YXRlPTgvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO3RoaXMuX2luZGV4LS07fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkF0dHJpYnV0ZU5hbWU9ZnVuY3Rpb24oYyl7aWYoYz09PVwiPVwifHxjPT09XCIvXCJ8fGM9PT1cIj5cInx8d2hpdGVzcGFjZShjKSl7dGhpcy5fY2JzLm9uYXR0cmlibmFtZSh0aGlzLl9nZXRTZWN0aW9uKCkpO3RoaXMuX3NlY3Rpb25TdGFydD0tMTt0aGlzLl9zdGF0ZT0xMC8qIEFmdGVyQXR0cmlidXRlTmFtZSAqLzt0aGlzLl9pbmRleC0tO319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJBdHRyaWJ1dGVOYW1lPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIj1cIil7dGhpcy5fc3RhdGU9MTEvKiBCZWZvcmVBdHRyaWJ1dGVWYWx1ZSAqLzt9ZWxzZSBpZihjPT09XCIvXCJ8fGM9PT1cIj5cIil7dGhpcy5fY2JzLm9uYXR0cmliZW5kKCk7dGhpcy5fc3RhdGU9OC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi87dGhpcy5faW5kZXgtLTt9ZWxzZSBpZighd2hpdGVzcGFjZShjKSl7dGhpcy5fY2JzLm9uYXR0cmliZW5kKCk7dGhpcy5fc3RhdGU9OS8qIEluQXR0cmlidXRlTmFtZSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXg7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZT1mdW5jdGlvbihjKXtpZihjPT09J1wiJyl7dGhpcy5fc3RhdGU9MTIvKiBJbkF0dHJpYnV0ZVZhbHVlRHEgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fWVsc2UgaWYoYz09PVwiJ1wiKXt0aGlzLl9zdGF0ZT0xMy8qIEluQXR0cmlidXRlVmFsdWVTcSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9ZWxzZSBpZighd2hpdGVzcGFjZShjKSl7dGhpcy5fc3RhdGU9MTQvKiBJbkF0dHJpYnV0ZVZhbHVlTnEgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O3RoaXMuX2luZGV4LS07Ly9yZWNvbnN1bWUgdG9rZW5cbn19O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3Rlcz1mdW5jdGlvbihjKXtpZihjPT09J1wiJyl7dGhpcy5fZW1pdFRva2VuKFwib25hdHRyaWJkYXRhXCIpO3RoaXMuX2Nicy5vbmF0dHJpYmVuZCgpO3RoaXMuX3N0YXRlPTgvKiBCZWZvcmVBdHRyaWJ1dGVOYW1lICovO31lbHNlIGlmKHRoaXMuX2RlY29kZUVudGl0aWVzJiZjPT09XCImXCIpe3RoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTt0aGlzLl9iYXNlU3RhdGU9dGhpcy5fc3RhdGU7dGhpcy5fc3RhdGU9NTEvKiBCZWZvcmVFbnRpdHkgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3Rlcz1mdW5jdGlvbihjKXtpZihjPT09XCInXCIpe3RoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTt0aGlzLl9jYnMub25hdHRyaWJlbmQoKTt0aGlzLl9zdGF0ZT04LyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLzt9ZWxzZSBpZih0aGlzLl9kZWNvZGVFbnRpdGllcyYmYz09PVwiJlwiKXt0aGlzLl9lbWl0VG9rZW4oXCJvbmF0dHJpYmRhdGFcIik7dGhpcy5fYmFzZVN0YXRlPXRoaXMuX3N0YXRlO3RoaXMuX3N0YXRlPTUxLyogQmVmb3JlRW50aXR5ICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleDt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluQXR0cmlidXRlVmFsdWVOb1F1b3Rlcz1mdW5jdGlvbihjKXtpZih3aGl0ZXNwYWNlKGMpfHxjPT09XCI+XCIpe3RoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTt0aGlzLl9jYnMub25hdHRyaWJlbmQoKTt0aGlzLl9zdGF0ZT04LyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLzt0aGlzLl9pbmRleC0tO31lbHNlIGlmKHRoaXMuX2RlY29kZUVudGl0aWVzJiZjPT09XCImXCIpe3RoaXMuX2VtaXRUb2tlbihcIm9uYXR0cmliZGF0YVwiKTt0aGlzLl9iYXNlU3RhdGU9dGhpcy5fc3RhdGU7dGhpcy5fc3RhdGU9NTEvKiBCZWZvcmVFbnRpdHkgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlRGVjbGFyYXRpb249ZnVuY3Rpb24oYyl7dGhpcy5fc3RhdGU9Yz09PVwiW1wiPzIyLyogQmVmb3JlQ2RhdGExICovOmM9PT1cIi1cIj8xOC8qIEJlZm9yZUNvbW1lbnQgKi86MTYvKiBJbkRlY2xhcmF0aW9uICovO307VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkRlY2xhcmF0aW9uPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIj5cIil7dGhpcy5fY2JzLm9uZGVjbGFyYXRpb24odGhpcy5fZ2V0U2VjdGlvbigpKTt0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIj5cIil7dGhpcy5fY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKHRoaXMuX2dldFNlY3Rpb24oKSk7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDb21tZW50PWZ1bmN0aW9uKGMpe2lmKGM9PT1cIi1cIil7dGhpcy5fc3RhdGU9MTkvKiBJbkNvbW1lbnQgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fWVsc2V7dGhpcy5fc3RhdGU9MTYvKiBJbkRlY2xhcmF0aW9uICovO319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5Db21tZW50PWZ1bmN0aW9uKGMpe2lmKGM9PT1cIi1cIil0aGlzLl9zdGF0ZT0yMC8qIEFmdGVyQ29tbWVudDEgKi87fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUFmdGVyQ29tbWVudDE9ZnVuY3Rpb24oYyl7aWYoYz09PVwiLVwiKXt0aGlzLl9zdGF0ZT0yMS8qIEFmdGVyQ29tbWVudDIgKi87fWVsc2V7dGhpcy5fc3RhdGU9MTkvKiBJbkNvbW1lbnQgKi87fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNvbW1lbnQyPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIj5cIil7Ly9yZW1vdmUgMiB0cmFpbGluZyBjaGFyc1xudGhpcy5fY2JzLm9uY29tbWVudCh0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCx0aGlzLl9pbmRleC0yKSk7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fWVsc2UgaWYoYyE9PVwiLVwiKXt0aGlzLl9zdGF0ZT0xOS8qIEluQ29tbWVudCAqLzt9Ly8gZWxzZTogc3RheSBpbiBBRlRFUl9DT01NRU5UXzIgKGAtLS0+YClcbn07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVDZGF0YTY9ZnVuY3Rpb24oYyl7aWYoYz09PVwiW1wiKXt0aGlzLl9zdGF0ZT0yOC8qIEluQ2RhdGEgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fWVsc2V7dGhpcy5fc3RhdGU9MTYvKiBJbkRlY2xhcmF0aW9uICovO3RoaXMuX2luZGV4LS07fX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVJbkNkYXRhPWZ1bmN0aW9uKGMpe2lmKGM9PT1cIl1cIil0aGlzLl9zdGF0ZT0yOS8qIEFmdGVyQ2RhdGExICovO307VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVBZnRlckNkYXRhMT1mdW5jdGlvbihjKXtpZihjPT09XCJdXCIpdGhpcy5fc3RhdGU9MzAvKiBBZnRlckNkYXRhMiAqLztlbHNlIHRoaXMuX3N0YXRlPTI4LyogSW5DZGF0YSAqLzt9O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJDZGF0YTI9ZnVuY3Rpb24oYyl7aWYoYz09PVwiPlwiKXsvL3JlbW92ZSAyIHRyYWlsaW5nIGNoYXJzXG50aGlzLl9jYnMub25jZGF0YSh0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCx0aGlzLl9pbmRleC0yKSk7dGhpcy5fc3RhdGU9MS8qIFRleHQgKi87dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4KzE7fWVsc2UgaWYoYyE9PVwiXVwiKXt0aGlzLl9zdGF0ZT0yOC8qIEluQ2RhdGEgKi87fS8vZWxzZTogc3RheSBpbiBBRlRFUl9DREFUQV8yIChgXV1dPmApXG59O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQmVmb3JlU3BlY2lhbD1mdW5jdGlvbihjKXtpZihjPT09XCJjXCJ8fGM9PT1cIkNcIil7dGhpcy5fc3RhdGU9MzMvKiBCZWZvcmVTY3JpcHQxICovO31lbHNlIGlmKGM9PT1cInRcInx8Yz09PVwiVFwiKXt0aGlzLl9zdGF0ZT00My8qIEJlZm9yZVN0eWxlMSAqLzt9ZWxzZXt0aGlzLl9zdGF0ZT0zLyogSW5UYWdOYW1lICovO3RoaXMuX2luZGV4LS07Ly9jb25zdW1lIHRoZSB0b2tlbiBhZ2FpblxufX07VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTcGVjaWFsRW5kPWZ1bmN0aW9uKGMpe2lmKHRoaXMuX3NwZWNpYWw9PT0yLyogU2NyaXB0ICovJiYoYz09PVwiY1wifHxjPT09XCJDXCIpKXt0aGlzLl9zdGF0ZT0zOC8qIEFmdGVyU2NyaXB0MSAqLzt9ZWxzZSBpZih0aGlzLl9zcGVjaWFsPT09My8qIFN0eWxlICovJiYoYz09PVwidFwifHxjPT09XCJUXCIpKXt0aGlzLl9zdGF0ZT00Ny8qIEFmdGVyU3R5bGUxICovO31lbHNlIHRoaXMuX3N0YXRlPTEvKiBUZXh0ICovO307VG9rZW5pemVyLnByb3RvdHlwZS5fc3RhdGVCZWZvcmVTY3JpcHQ1PWZ1bmN0aW9uKGMpe2lmKGM9PT1cIi9cInx8Yz09PVwiPlwifHx3aGl0ZXNwYWNlKGMpKXt0aGlzLl9zcGVjaWFsPTIvKiBTY3JpcHQgKi87fXRoaXMuX3N0YXRlPTMvKiBJblRhZ05hbWUgKi87dGhpcy5faW5kZXgtLTsvL2NvbnN1bWUgdGhlIHRva2VuIGFnYWluXG59O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJTY3JpcHQ1PWZ1bmN0aW9uKGMpe2lmKGM9PT1cIj5cInx8d2hpdGVzcGFjZShjKSl7dGhpcy5fc3BlY2lhbD0xLyogTm9uZSAqLzt0aGlzLl9zdGF0ZT02LyogSW5DbG9zaW5nVGFnTmFtZSAqLzt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgtNjt0aGlzLl9pbmRleC0tOy8vcmVjb25zdW1lIHRoZSB0b2tlblxufWVsc2UgdGhpcy5fc3RhdGU9MS8qIFRleHQgKi87fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUJlZm9yZVN0eWxlND1mdW5jdGlvbihjKXtpZihjPT09XCIvXCJ8fGM9PT1cIj5cInx8d2hpdGVzcGFjZShjKSl7dGhpcy5fc3BlY2lhbD0zLyogU3R5bGUgKi87fXRoaXMuX3N0YXRlPTMvKiBJblRhZ05hbWUgKi87dGhpcy5faW5kZXgtLTsvL2NvbnN1bWUgdGhlIHRva2VuIGFnYWluXG59O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlQWZ0ZXJTdHlsZTQ9ZnVuY3Rpb24oYyl7aWYoYz09PVwiPlwifHx3aGl0ZXNwYWNlKGMpKXt0aGlzLl9zcGVjaWFsPTEvKiBOb25lICovO3RoaXMuX3N0YXRlPTYvKiBJbkNsb3NpbmdUYWdOYW1lICovO3RoaXMuX3NlY3Rpb25TdGFydD10aGlzLl9pbmRleC01O3RoaXMuX2luZGV4LS07Ly9yZWNvbnN1bWUgdGhlIHRva2VuXG59ZWxzZSB0aGlzLl9zdGF0ZT0xLyogVGV4dCAqLzt9Oy8vZm9yIGVudGl0aWVzIHRlcm1pbmF0ZWQgd2l0aCBhIHNlbWljb2xvblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcGFyc2VOYW1lZEVudGl0eVN0cmljdD1mdW5jdGlvbigpey8vb2Zmc2V0ID0gMVxuaWYodGhpcy5fc2VjdGlvblN0YXJ0KzE8dGhpcy5faW5kZXgpe3ZhciBlbnRpdHk9dGhpcy5fYnVmZmVyLnN1YnN0cmluZyh0aGlzLl9zZWN0aW9uU3RhcnQrMSx0aGlzLl9pbmRleCksbWFwPXRoaXMuX3htbE1vZGU/eG1sX2pzb25fMVtcImRlZmF1bHRcIl06ZW50aXRpZXNfanNvbl8xW1wiZGVmYXVsdFwiXTtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLGVudGl0eSkpey8vIEB0cy1pZ25vcmVcbnRoaXMuX2VtaXRQYXJ0aWFsKG1hcFtlbnRpdHldKTt0aGlzLl9zZWN0aW9uU3RhcnQ9dGhpcy5faW5kZXgrMTt9fX07Ly9wYXJzZXMgbGVnYWN5IGVudGl0aWVzICh3aXRob3V0IHRyYWlsaW5nIHNlbWljb2xvbilcblRva2VuaXplci5wcm90b3R5cGUuX3BhcnNlTGVnYWN5RW50aXR5PWZ1bmN0aW9uKCl7dmFyIHN0YXJ0PXRoaXMuX3NlY3Rpb25TdGFydCsxO3ZhciBsaW1pdD10aGlzLl9pbmRleC1zdGFydDtpZihsaW1pdD42KWxpbWl0PTY7Ly8gVGhlIG1heCBsZW5ndGggb2YgbGVnYWN5IGVudGl0aWVzIGlzIDZcbndoaWxlKGxpbWl0Pj0yKXsvLyBUaGUgbWluIGxlbmd0aCBvZiBsZWdhY3kgZW50aXRpZXMgaXMgMlxudmFyIGVudGl0eT10aGlzLl9idWZmZXIuc3Vic3RyKHN0YXJ0LGxpbWl0KTtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGVnYWN5X2pzb25fMVtcImRlZmF1bHRcIl0sZW50aXR5KSl7Ly8gQHRzLWlnbm9yZVxudGhpcy5fZW1pdFBhcnRpYWwobGVnYWN5X2pzb25fMVtcImRlZmF1bHRcIl1bZW50aXR5XSk7dGhpcy5fc2VjdGlvblN0YXJ0Kz1saW1pdCsxO3JldHVybjt9ZWxzZXtsaW1pdC0tO319fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluTmFtZWRFbnRpdHk9ZnVuY3Rpb24oYyl7aWYoYz09PVwiO1wiKXt0aGlzLl9wYXJzZU5hbWVkRW50aXR5U3RyaWN0KCk7aWYodGhpcy5fc2VjdGlvblN0YXJ0KzE8dGhpcy5faW5kZXgmJiF0aGlzLl94bWxNb2RlKXt0aGlzLl9wYXJzZUxlZ2FjeUVudGl0eSgpO310aGlzLl9zdGF0ZT10aGlzLl9iYXNlU3RhdGU7fWVsc2UgaWYoKGM8XCJhXCJ8fGM+XCJ6XCIpJiYoYzxcIkFcInx8Yz5cIlpcIikmJihjPFwiMFwifHxjPlwiOVwiKSl7aWYodGhpcy5feG1sTW9kZXx8dGhpcy5fc2VjdGlvblN0YXJ0KzE9PT10aGlzLl9pbmRleCl7Ly8gaWdub3JlXG59ZWxzZSBpZih0aGlzLl9iYXNlU3RhdGUhPT0xLyogVGV4dCAqLyl7aWYoYyE9PVwiPVwiKXt0aGlzLl9wYXJzZU5hbWVkRW50aXR5U3RyaWN0KCk7fX1lbHNle3RoaXMuX3BhcnNlTGVnYWN5RW50aXR5KCk7fXRoaXMuX3N0YXRlPXRoaXMuX2Jhc2VTdGF0ZTt0aGlzLl9pbmRleC0tO319O1Rva2VuaXplci5wcm90b3R5cGUuX2RlY29kZU51bWVyaWNFbnRpdHk9ZnVuY3Rpb24ob2Zmc2V0LGJhc2Upe3ZhciBzZWN0aW9uU3RhcnQ9dGhpcy5fc2VjdGlvblN0YXJ0K29mZnNldDtpZihzZWN0aW9uU3RhcnQhPT10aGlzLl9pbmRleCl7Ly9wYXJzZSBlbnRpdHlcbnZhciBlbnRpdHk9dGhpcy5fYnVmZmVyLnN1YnN0cmluZyhzZWN0aW9uU3RhcnQsdGhpcy5faW5kZXgpO3ZhciBwYXJzZWQ9cGFyc2VJbnQoZW50aXR5LGJhc2UpO3RoaXMuX2VtaXRQYXJ0aWFsKGRlY29kZV9jb2RlcG9pbnRfMVtcImRlZmF1bHRcIl0ocGFyc2VkKSk7dGhpcy5fc2VjdGlvblN0YXJ0PXRoaXMuX2luZGV4O31lbHNle3RoaXMuX3NlY3Rpb25TdGFydC0tO310aGlzLl9zdGF0ZT10aGlzLl9iYXNlU3RhdGU7fTtUb2tlbml6ZXIucHJvdG90eXBlLl9zdGF0ZUluTnVtZXJpY0VudGl0eT1mdW5jdGlvbihjKXtpZihjPT09XCI7XCIpe3RoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwxMCk7dGhpcy5fc2VjdGlvblN0YXJ0Kys7fWVsc2UgaWYoYzxcIjBcInx8Yz5cIjlcIil7aWYoIXRoaXMuX3htbE1vZGUpe3RoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwxMCk7fWVsc2V7dGhpcy5fc3RhdGU9dGhpcy5fYmFzZVN0YXRlO310aGlzLl9pbmRleC0tO319O1Rva2VuaXplci5wcm90b3R5cGUuX3N0YXRlSW5IZXhFbnRpdHk9ZnVuY3Rpb24oYyl7aWYoYz09PVwiO1wiKXt0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDMsMTYpO3RoaXMuX3NlY3Rpb25TdGFydCsrO31lbHNlIGlmKChjPFwiYVwifHxjPlwiZlwiKSYmKGM8XCJBXCJ8fGM+XCJGXCIpJiYoYzxcIjBcInx8Yz5cIjlcIikpe2lmKCF0aGlzLl94bWxNb2RlKXt0aGlzLl9kZWNvZGVOdW1lcmljRW50aXR5KDMsMTYpO31lbHNle3RoaXMuX3N0YXRlPXRoaXMuX2Jhc2VTdGF0ZTt9dGhpcy5faW5kZXgtLTt9fTtUb2tlbml6ZXIucHJvdG90eXBlLl9jbGVhbnVwPWZ1bmN0aW9uKCl7aWYodGhpcy5fc2VjdGlvblN0YXJ0PDApe3RoaXMuX2J1ZmZlcj1cIlwiO3RoaXMuX2J1ZmZlck9mZnNldCs9dGhpcy5faW5kZXg7dGhpcy5faW5kZXg9MDt9ZWxzZSBpZih0aGlzLl9ydW5uaW5nKXtpZih0aGlzLl9zdGF0ZT09PTEvKiBUZXh0ICovKXtpZih0aGlzLl9zZWN0aW9uU3RhcnQhPT10aGlzLl9pbmRleCl7dGhpcy5fY2JzLm9udGV4dCh0aGlzLl9idWZmZXIuc3Vic3RyKHRoaXMuX3NlY3Rpb25TdGFydCkpO310aGlzLl9idWZmZXI9XCJcIjt0aGlzLl9idWZmZXJPZmZzZXQrPXRoaXMuX2luZGV4O3RoaXMuX2luZGV4PTA7fWVsc2UgaWYodGhpcy5fc2VjdGlvblN0YXJ0PT09dGhpcy5faW5kZXgpey8vdGhlIHNlY3Rpb24ganVzdCBzdGFydGVkXG50aGlzLl9idWZmZXI9XCJcIjt0aGlzLl9idWZmZXJPZmZzZXQrPXRoaXMuX2luZGV4O3RoaXMuX2luZGV4PTA7fWVsc2V7Ly9yZW1vdmUgZXZlcnl0aGluZyB1bm5lY2Vzc2FyeVxudGhpcy5fYnVmZmVyPXRoaXMuX2J1ZmZlci5zdWJzdHIodGhpcy5fc2VjdGlvblN0YXJ0KTt0aGlzLl9pbmRleC09dGhpcy5fc2VjdGlvblN0YXJ0O3RoaXMuX2J1ZmZlck9mZnNldCs9dGhpcy5fc2VjdGlvblN0YXJ0O310aGlzLl9zZWN0aW9uU3RhcnQ9MDt9fTsvL1RPRE8gbWFrZSBldmVudHMgY29uZGl0aW9uYWxcblRva2VuaXplci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oY2h1bmspe2lmKHRoaXMuX2VuZGVkKXRoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwiLndyaXRlKCkgYWZ0ZXIgZG9uZSFcIikpO3RoaXMuX2J1ZmZlcis9Y2h1bms7dGhpcy5fcGFyc2UoKTt9Oy8vIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGJ1ZmZlciwgY2FsbGluZyB0aGUgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbi8vIFN0YXRlcyB0aGF0IGFyZSBtb3JlIGxpa2VseSB0byBiZSBoaXQgYXJlIGhpZ2hlciB1cCwgYXMgYSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC5cblRva2VuaXplci5wcm90b3R5cGUuX3BhcnNlPWZ1bmN0aW9uKCl7d2hpbGUodGhpcy5faW5kZXg8dGhpcy5fYnVmZmVyLmxlbmd0aCYmdGhpcy5fcnVubmluZyl7dmFyIGM9dGhpcy5fYnVmZmVyLmNoYXJBdCh0aGlzLl9pbmRleCk7aWYodGhpcy5fc3RhdGU9PT0xLyogVGV4dCAqLyl7dGhpcy5fc3RhdGVUZXh0KGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MTIvKiBJbkF0dHJpYnV0ZVZhbHVlRHEgKi8pe3RoaXMuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlcyhjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTkvKiBJbkF0dHJpYnV0ZU5hbWUgKi8pe3RoaXMuX3N0YXRlSW5BdHRyaWJ1dGVOYW1lKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MTkvKiBJbkNvbW1lbnQgKi8pe3RoaXMuX3N0YXRlSW5Db21tZW50KGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09OC8qIEJlZm9yZUF0dHJpYnV0ZU5hbWUgKi8pe3RoaXMuX3N0YXRlQmVmb3JlQXR0cmlidXRlTmFtZShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTMvKiBJblRhZ05hbWUgKi8pe3RoaXMuX3N0YXRlSW5UYWdOYW1lKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09Ni8qIEluQ2xvc2luZ1RhZ05hbWUgKi8pe3RoaXMuX3N0YXRlSW5DbG9zaW5nVGFnTmFtZShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTIvKiBCZWZvcmVUYWdOYW1lICovKXt0aGlzLl9zdGF0ZUJlZm9yZVRhZ05hbWUoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xMC8qIEFmdGVyQXR0cmlidXRlTmFtZSAqLyl7dGhpcy5fc3RhdGVBZnRlckF0dHJpYnV0ZU5hbWUoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xMy8qIEluQXR0cmlidXRlVmFsdWVTcSAqLyl7dGhpcy5fc3RhdGVJbkF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVzKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MTEvKiBCZWZvcmVBdHRyaWJ1dGVWYWx1ZSAqLyl7dGhpcy5fc3RhdGVCZWZvcmVBdHRyaWJ1dGVWYWx1ZShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTUvKiBCZWZvcmVDbG9zaW5nVGFnTmFtZSAqLyl7dGhpcy5fc3RhdGVCZWZvcmVDbG9zaW5nVGFnTmFtZShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTcvKiBBZnRlckNsb3NpbmdUYWdOYW1lICovKXt0aGlzLl9zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0zMS8qIEJlZm9yZVNwZWNpYWwgKi8pe3RoaXMuX3N0YXRlQmVmb3JlU3BlY2lhbChjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTIwLyogQWZ0ZXJDb21tZW50MSAqLyl7dGhpcy5fc3RhdGVBZnRlckNvbW1lbnQxKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MTQvKiBJbkF0dHJpYnV0ZVZhbHVlTnEgKi8pe3RoaXMuX3N0YXRlSW5BdHRyaWJ1dGVWYWx1ZU5vUXVvdGVzKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NC8qIEluU2VsZkNsb3NpbmdUYWcgKi8pe3RoaXMuX3N0YXRlSW5TZWxmQ2xvc2luZ1RhZyhjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTE2LyogSW5EZWNsYXJhdGlvbiAqLyl7dGhpcy5fc3RhdGVJbkRlY2xhcmF0aW9uKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MTUvKiBCZWZvcmVEZWNsYXJhdGlvbiAqLyl7dGhpcy5fc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTIxLyogQWZ0ZXJDb21tZW50MiAqLyl7dGhpcy5fc3RhdGVBZnRlckNvbW1lbnQyKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MTgvKiBCZWZvcmVDb21tZW50ICovKXt0aGlzLl9zdGF0ZUJlZm9yZUNvbW1lbnQoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0zMi8qIEJlZm9yZVNwZWNpYWxFbmQgKi8pe3RoaXMuX3N0YXRlQmVmb3JlU3BlY2lhbEVuZChjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTM4LyogQWZ0ZXJTY3JpcHQxICovKXtzdGF0ZUFmdGVyU2NyaXB0MSh0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MzkvKiBBZnRlclNjcmlwdDIgKi8pe3N0YXRlQWZ0ZXJTY3JpcHQyKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00MC8qIEFmdGVyU2NyaXB0MyAqLyl7c3RhdGVBZnRlclNjcmlwdDModGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTMzLyogQmVmb3JlU2NyaXB0MSAqLyl7c3RhdGVCZWZvcmVTY3JpcHQxKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0zNC8qIEJlZm9yZVNjcmlwdDIgKi8pe3N0YXRlQmVmb3JlU2NyaXB0Mih0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MzUvKiBCZWZvcmVTY3JpcHQzICovKXtzdGF0ZUJlZm9yZVNjcmlwdDModGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTM2LyogQmVmb3JlU2NyaXB0NCAqLyl7c3RhdGVCZWZvcmVTY3JpcHQ0KHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0zNy8qIEJlZm9yZVNjcmlwdDUgKi8pe3RoaXMuX3N0YXRlQmVmb3JlU2NyaXB0NShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTQxLyogQWZ0ZXJTY3JpcHQ0ICovKXtzdGF0ZUFmdGVyU2NyaXB0NCh0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NDIvKiBBZnRlclNjcmlwdDUgKi8pe3RoaXMuX3N0YXRlQWZ0ZXJTY3JpcHQ1KGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NDMvKiBCZWZvcmVTdHlsZTEgKi8pe3N0YXRlQmVmb3JlU3R5bGUxKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0yOC8qIEluQ2RhdGEgKi8pe3RoaXMuX3N0YXRlSW5DZGF0YShjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTQ0LyogQmVmb3JlU3R5bGUyICovKXtzdGF0ZUJlZm9yZVN0eWxlMih0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NDUvKiBCZWZvcmVTdHlsZTMgKi8pe3N0YXRlQmVmb3JlU3R5bGUzKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00Ni8qIEJlZm9yZVN0eWxlNCAqLyl7dGhpcy5fc3RhdGVCZWZvcmVTdHlsZTQoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00Ny8qIEFmdGVyU3R5bGUxICovKXtzdGF0ZUFmdGVyU3R5bGUxKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00OC8qIEFmdGVyU3R5bGUyICovKXtzdGF0ZUFmdGVyU3R5bGUyKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT00OS8qIEFmdGVyU3R5bGUzICovKXtzdGF0ZUFmdGVyU3R5bGUzKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT01MC8qIEFmdGVyU3R5bGU0ICovKXt0aGlzLl9zdGF0ZUFmdGVyU3R5bGU0KGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MTcvKiBJblByb2Nlc3NpbmdJbnN0cnVjdGlvbiAqLyl7dGhpcy5fc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbihjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTUzLyogSW5OYW1lZEVudGl0eSAqLyl7dGhpcy5fc3RhdGVJbk5hbWVkRW50aXR5KGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MjIvKiBCZWZvcmVDZGF0YTEgKi8pe3N0YXRlQmVmb3JlQ2RhdGExKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT01MS8qIEJlZm9yZUVudGl0eSAqLyl7c3RhdGVCZWZvcmVFbnRpdHkodGhpcyxjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTIzLyogQmVmb3JlQ2RhdGEyICovKXtzdGF0ZUJlZm9yZUNkYXRhMih0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MjQvKiBCZWZvcmVDZGF0YTMgKi8pe3N0YXRlQmVmb3JlQ2RhdGEzKHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0yOS8qIEFmdGVyQ2RhdGExICovKXt0aGlzLl9zdGF0ZUFmdGVyQ2RhdGExKGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MzAvKiBBZnRlckNkYXRhMiAqLyl7dGhpcy5fc3RhdGVBZnRlckNkYXRhMihjKTt9ZWxzZSBpZih0aGlzLl9zdGF0ZT09PTI1LyogQmVmb3JlQ2RhdGE0ICovKXtzdGF0ZUJlZm9yZUNkYXRhNCh0aGlzLGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09MjYvKiBCZWZvcmVDZGF0YTUgKi8pe3N0YXRlQmVmb3JlQ2RhdGE1KHRoaXMsYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0yNy8qIEJlZm9yZUNkYXRhNiAqLyl7dGhpcy5fc3RhdGVCZWZvcmVDZGF0YTYoYyk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT01NS8qIEluSGV4RW50aXR5ICovKXt0aGlzLl9zdGF0ZUluSGV4RW50aXR5KGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NTQvKiBJbk51bWVyaWNFbnRpdHkgKi8pe3RoaXMuX3N0YXRlSW5OdW1lcmljRW50aXR5KGMpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NTIvKiBCZWZvcmVOdW1lcmljRW50aXR5ICovKXtzdGF0ZUJlZm9yZU51bWVyaWNFbnRpdHkodGhpcyxjKTt9ZWxzZXt0aGlzLl9jYnMub25lcnJvcihFcnJvcihcInVua25vd24gX3N0YXRlXCIpLHRoaXMuX3N0YXRlKTt9dGhpcy5faW5kZXgrKzt9dGhpcy5fY2xlYW51cCgpO307VG9rZW5pemVyLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbigpe3RoaXMuX3J1bm5pbmc9ZmFsc2U7fTtUb2tlbml6ZXIucHJvdG90eXBlLnJlc3VtZT1mdW5jdGlvbigpe3RoaXMuX3J1bm5pbmc9dHJ1ZTtpZih0aGlzLl9pbmRleDx0aGlzLl9idWZmZXIubGVuZ3RoKXt0aGlzLl9wYXJzZSgpO31pZih0aGlzLl9lbmRlZCl7dGhpcy5fZmluaXNoKCk7fX07VG9rZW5pemVyLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24oY2h1bmspe2lmKHRoaXMuX2VuZGVkKXRoaXMuX2Nicy5vbmVycm9yKEVycm9yKFwiLmVuZCgpIGFmdGVyIGRvbmUhXCIpKTtpZihjaHVuayl0aGlzLndyaXRlKGNodW5rKTt0aGlzLl9lbmRlZD10cnVlO2lmKHRoaXMuX3J1bm5pbmcpdGhpcy5fZmluaXNoKCk7fTtUb2tlbml6ZXIucHJvdG90eXBlLl9maW5pc2g9ZnVuY3Rpb24oKXsvL2lmIHRoZXJlIGlzIHJlbWFpbmluZyBkYXRhLCBlbWl0IGl0IGluIGEgcmVhc29uYWJsZSB3YXlcbmlmKHRoaXMuX3NlY3Rpb25TdGFydDx0aGlzLl9pbmRleCl7dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7fXRoaXMuX2Nicy5vbmVuZCgpO307VG9rZW5pemVyLnByb3RvdHlwZS5faGFuZGxlVHJhaWxpbmdEYXRhPWZ1bmN0aW9uKCl7dmFyIGRhdGE9dGhpcy5fYnVmZmVyLnN1YnN0cih0aGlzLl9zZWN0aW9uU3RhcnQpO2lmKHRoaXMuX3N0YXRlPT09MjgvKiBJbkNkYXRhICovfHx0aGlzLl9zdGF0ZT09PTI5LyogQWZ0ZXJDZGF0YTEgKi98fHRoaXMuX3N0YXRlPT09MzAvKiBBZnRlckNkYXRhMiAqLyl7dGhpcy5fY2JzLm9uY2RhdGEoZGF0YSk7fWVsc2UgaWYodGhpcy5fc3RhdGU9PT0xOS8qIEluQ29tbWVudCAqL3x8dGhpcy5fc3RhdGU9PT0yMC8qIEFmdGVyQ29tbWVudDEgKi98fHRoaXMuX3N0YXRlPT09MjEvKiBBZnRlckNvbW1lbnQyICovKXt0aGlzLl9jYnMub25jb21tZW50KGRhdGEpO31lbHNlIGlmKHRoaXMuX3N0YXRlPT09NTMvKiBJbk5hbWVkRW50aXR5ICovJiYhdGhpcy5feG1sTW9kZSl7dGhpcy5fcGFyc2VMZWdhY3lFbnRpdHkoKTtpZih0aGlzLl9zZWN0aW9uU3RhcnQ8dGhpcy5faW5kZXgpe3RoaXMuX3N0YXRlPXRoaXMuX2Jhc2VTdGF0ZTt0aGlzLl9oYW5kbGVUcmFpbGluZ0RhdGEoKTt9fWVsc2UgaWYodGhpcy5fc3RhdGU9PT01NC8qIEluTnVtZXJpY0VudGl0eSAqLyYmIXRoaXMuX3htbE1vZGUpe3RoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMiwxMCk7aWYodGhpcy5fc2VjdGlvblN0YXJ0PHRoaXMuX2luZGV4KXt0aGlzLl9zdGF0ZT10aGlzLl9iYXNlU3RhdGU7dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7fX1lbHNlIGlmKHRoaXMuX3N0YXRlPT09NTUvKiBJbkhleEVudGl0eSAqLyYmIXRoaXMuX3htbE1vZGUpe3RoaXMuX2RlY29kZU51bWVyaWNFbnRpdHkoMywxNik7aWYodGhpcy5fc2VjdGlvblN0YXJ0PHRoaXMuX2luZGV4KXt0aGlzLl9zdGF0ZT10aGlzLl9iYXNlU3RhdGU7dGhpcy5faGFuZGxlVHJhaWxpbmdEYXRhKCk7fX1lbHNlIGlmKHRoaXMuX3N0YXRlIT09My8qIEluVGFnTmFtZSAqLyYmdGhpcy5fc3RhdGUhPT04LyogQmVmb3JlQXR0cmlidXRlTmFtZSAqLyYmdGhpcy5fc3RhdGUhPT0xMS8qIEJlZm9yZUF0dHJpYnV0ZVZhbHVlICovJiZ0aGlzLl9zdGF0ZSE9PTEwLyogQWZ0ZXJBdHRyaWJ1dGVOYW1lICovJiZ0aGlzLl9zdGF0ZSE9PTkvKiBJbkF0dHJpYnV0ZU5hbWUgKi8mJnRoaXMuX3N0YXRlIT09MTMvKiBJbkF0dHJpYnV0ZVZhbHVlU3EgKi8mJnRoaXMuX3N0YXRlIT09MTIvKiBJbkF0dHJpYnV0ZVZhbHVlRHEgKi8mJnRoaXMuX3N0YXRlIT09MTQvKiBJbkF0dHJpYnV0ZVZhbHVlTnEgKi8mJnRoaXMuX3N0YXRlIT09Ni8qIEluQ2xvc2luZ1RhZ05hbWUgKi8pe3RoaXMuX2Nicy5vbnRleHQoZGF0YSk7fS8vZWxzZSwgaWdub3JlIHJlbWFpbmluZyBkYXRhXG4vL1RPRE8gYWRkIGEgd2F5IHRvIHJlbW92ZSBjdXJyZW50IHRhZ1xufTtUb2tlbml6ZXIucHJvdG90eXBlLmdldEFic29sdXRlSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnVmZmVyT2Zmc2V0K3RoaXMuX2luZGV4O307VG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0U2VjdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9idWZmZXIuc3Vic3RyaW5nKHRoaXMuX3NlY3Rpb25TdGFydCx0aGlzLl9pbmRleCk7fTtUb2tlbml6ZXIucHJvdG90eXBlLl9lbWl0VG9rZW49ZnVuY3Rpb24obmFtZSl7dGhpcy5fY2JzW25hbWVdKHRoaXMuX2dldFNlY3Rpb24oKSk7dGhpcy5fc2VjdGlvblN0YXJ0PS0xO307VG9rZW5pemVyLnByb3RvdHlwZS5fZW1pdFBhcnRpYWw9ZnVuY3Rpb24odmFsdWUpe2lmKHRoaXMuX2Jhc2VTdGF0ZSE9PTEvKiBUZXh0ICovKXt0aGlzLl9jYnMub25hdHRyaWJkYXRhKHZhbHVlKTsvL1RPRE8gaW1wbGVtZW50IHRoZSBuZXcgZXZlbnRcbn1lbHNle3RoaXMuX2Nicy5vbnRleHQodmFsdWUpO319O3JldHVybiBUb2tlbml6ZXI7fSgpO2V4cG9ydHNbXCJkZWZhdWx0XCJdPVRva2VuaXplcjt9LHtcImVudGl0aWVzL2xpYi9kZWNvZGVfY29kZXBvaW50XCI6MTgsXCJlbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uXCI6MjIsXCJlbnRpdGllcy9saWIvbWFwcy9sZWdhY3kuanNvblwiOjIzLFwiZW50aXRpZXMvbGliL21hcHMveG1sLmpzb25cIjoyNH1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfX2V4cG9ydChtKXtmb3IodmFyIHAgaW4gbSl7aWYoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpZXhwb3J0c1twXT1tW3BdO319dmFyIF9faW1wb3J0U3Rhcj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24obW9kKXtpZihtb2QmJm1vZC5fX2VzTW9kdWxlKXJldHVybiBtb2Q7dmFyIHJlc3VsdD17fTtpZihtb2QhPW51bGwpZm9yKHZhciBrIGluIG1vZCl7aWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLGspKXJlc3VsdFtrXT1tb2Rba107fXJlc3VsdFtcImRlZmF1bHRcIl09bW9kO3JldHVybiByZXN1bHQ7fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO3ZhciBQYXJzZXJfMT1yZXF1aXJlKFwiLi9QYXJzZXJcIik7ZXhwb3J0cy5QYXJzZXI9UGFyc2VyXzEuUGFyc2VyO3ZhciBkb21oYW5kbGVyXzE9cmVxdWlyZShcImRvbWhhbmRsZXJcIik7ZXhwb3J0cy5Eb21IYW5kbGVyPWRvbWhhbmRsZXJfMS5Eb21IYW5kbGVyO2V4cG9ydHMuRGVmYXVsdEhhbmRsZXI9ZG9taGFuZGxlcl8xLkRvbUhhbmRsZXI7Ly8gSGVscGVyIG1ldGhvZHNcbi8qKlxuICogUGFyc2VzIGRhdGEsIHJldHVybnMgdGhlIHJlc3VsdGluZyBET00uXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHBhcnNlciBhbmQgRE9NIGJ1aWxkZXIuXG4gKi9mdW5jdGlvbiBwYXJzZURPTShkYXRhLG9wdGlvbnMpe3ZhciBoYW5kbGVyPW5ldyBkb21oYW5kbGVyXzEuRG9tSGFuZGxlcih2b2lkIDAsb3B0aW9ucyk7bmV3IFBhcnNlcl8xLlBhcnNlcihoYW5kbGVyLG9wdGlvbnMpLmVuZChkYXRhKTtyZXR1cm4gaGFuZGxlci5kb207fWV4cG9ydHMucGFyc2VET009cGFyc2VET007LyoqXG4gKiBDcmVhdGVzIGEgcGFyc2VyIGluc3RhbmNlLCB3aXRoIGFuIGF0dGFjaGVkIERPTSBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSBjYiBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBwYXJzaW5nIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIgYW5kIERPTSBidWlsZGVyLlxuICogQHBhcmFtIGVsZW1lbnRDYiBBbiBvcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgYSB0YWcgaGFzIGJlZW4gY29tcGxldGVkIGluc2lkZSBvZiB0aGUgRE9NLlxuICovZnVuY3Rpb24gY3JlYXRlRG9tU3RyZWFtKGNiLG9wdGlvbnMsZWxlbWVudENiKXt2YXIgaGFuZGxlcj1uZXcgZG9taGFuZGxlcl8xLkRvbUhhbmRsZXIoY2Isb3B0aW9ucyxlbGVtZW50Q2IpO3JldHVybiBuZXcgUGFyc2VyXzEuUGFyc2VyKGhhbmRsZXIsb3B0aW9ucyk7fWV4cG9ydHMuY3JlYXRlRG9tU3RyZWFtPWNyZWF0ZURvbVN0cmVhbTt2YXIgVG9rZW5pemVyXzE9cmVxdWlyZShcIi4vVG9rZW5pemVyXCIpO2V4cG9ydHMuVG9rZW5pemVyPVRva2VuaXplcl8xW1wiZGVmYXVsdFwiXTt2YXIgRWxlbWVudFR5cGU9X19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkb21lbGVtZW50dHlwZVwiKSk7ZXhwb3J0cy5FbGVtZW50VHlwZT1FbGVtZW50VHlwZTsvKipcbiAqIExpc3Qgb2YgYWxsIGV2ZW50cyB0aGF0IHRoZSBwYXJzZXIgZW1pdHMuXG4gKlxuICogRm9ybWF0OiBldmVudG5hbWU6IG51bWJlciBvZiBhcmd1bWVudHMuXG4gKi9leHBvcnRzLkVWRU5UUz17YXR0cmlidXRlOjIsY2RhdGFzdGFydDowLGNkYXRhZW5kOjAsdGV4dDoxLHByb2Nlc3NpbmdpbnN0cnVjdGlvbjoyLGNvbW1lbnQ6MSxjb21tZW50ZW5kOjAsY2xvc2V0YWc6MSxvcGVudGFnOjIsb3BlbnRhZ25hbWU6MSxlcnJvcjoxLGVuZDowfTsvKlxuICAgIEFsbCBvZiB0aGUgZm9sbG93aW5nIGV4cG9ydHMgZXhpc3QgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICAgIFRoZXkgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWQgZXZlbnR1YWxseS5cbiovX19leHBvcnQocmVxdWlyZShcIi4vRmVlZEhhbmRsZXJcIikpO19fZXhwb3J0KHJlcXVpcmUoXCIuL1dyaXRhYmxlU3RyZWFtXCIpKTtfX2V4cG9ydChyZXF1aXJlKFwiLi9Db2xsZWN0aW5nSGFuZGxlclwiKSk7dmFyIERvbVV0aWxzPV9faW1wb3J0U3RhcihyZXF1aXJlKFwiZG9tdXRpbHNcIikpO2V4cG9ydHMuRG9tVXRpbHM9RG9tVXRpbHM7dmFyIEZlZWRIYW5kbGVyXzE9cmVxdWlyZShcIi4vRmVlZEhhbmRsZXJcIik7ZXhwb3J0cy5Sc3NIYW5kbGVyPUZlZWRIYW5kbGVyXzEuRmVlZEhhbmRsZXI7fSx7XCIuL0NvbGxlY3RpbmdIYW5kbGVyXCI6MjYsXCIuL0ZlZWRIYW5kbGVyXCI6MjcsXCIuL1BhcnNlclwiOjI5LFwiLi9Ub2tlbml6ZXJcIjozMCxcIi4vV3JpdGFibGVTdHJlYW1cIjoyLFwiZG9tZWxlbWVudHR5cGVcIjo2LFwiZG9taGFuZGxlclwiOjcsXCJkb211dGlsc1wiOjEwfV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe2V4cG9ydHMucmVhZD1mdW5jdGlvbihidWZmZXIsb2Zmc2V0LGlzTEUsbUxlbixuQnl0ZXMpe3ZhciBlLG07dmFyIGVMZW49bkJ5dGVzKjgtbUxlbi0xO3ZhciBlTWF4PSgxPDxlTGVuKS0xO3ZhciBlQmlhcz1lTWF4Pj4xO3ZhciBuQml0cz0tNzt2YXIgaT1pc0xFP25CeXRlcy0xOjA7dmFyIGQ9aXNMRT8tMToxO3ZhciBzPWJ1ZmZlcltvZmZzZXQraV07aSs9ZDtlPXMmKDE8PC1uQml0cyktMTtzPj49LW5CaXRzO25CaXRzKz1lTGVuO2Zvcig7bkJpdHM+MDtlPWUqMjU2K2J1ZmZlcltvZmZzZXQraV0saSs9ZCxuQml0cy09OCl7fW09ZSYoMTw8LW5CaXRzKS0xO2U+Pj0tbkJpdHM7bkJpdHMrPW1MZW47Zm9yKDtuQml0cz4wO209bSoyNTYrYnVmZmVyW29mZnNldCtpXSxpKz1kLG5CaXRzLT04KXt9aWYoZT09PTApe2U9MS1lQmlhczt9ZWxzZSBpZihlPT09ZU1heCl7cmV0dXJuIG0/TmFOOihzPy0xOjEpKkluZmluaXR5O31lbHNle209bStNYXRoLnBvdygyLG1MZW4pO2U9ZS1lQmlhczt9cmV0dXJuKHM/LTE6MSkqbSpNYXRoLnBvdygyLGUtbUxlbik7fTtleHBvcnRzLndyaXRlPWZ1bmN0aW9uKGJ1ZmZlcix2YWx1ZSxvZmZzZXQsaXNMRSxtTGVuLG5CeXRlcyl7dmFyIGUsbSxjO3ZhciBlTGVuPW5CeXRlcyo4LW1MZW4tMTt2YXIgZU1heD0oMTw8ZUxlbiktMTt2YXIgZUJpYXM9ZU1heD4+MTt2YXIgcnQ9bUxlbj09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MDt2YXIgaT1pc0xFPzA6bkJ5dGVzLTE7dmFyIGQ9aXNMRT8xOi0xO3ZhciBzPXZhbHVlPDB8fHZhbHVlPT09MCYmMS92YWx1ZTwwPzE6MDt2YWx1ZT1NYXRoLmFicyh2YWx1ZSk7aWYoaXNOYU4odmFsdWUpfHx2YWx1ZT09PUluZmluaXR5KXttPWlzTmFOKHZhbHVlKT8xOjA7ZT1lTWF4O31lbHNle2U9TWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkvTWF0aC5MTjIpO2lmKHZhbHVlKihjPU1hdGgucG93KDIsLWUpKTwxKXtlLS07Yyo9Mjt9aWYoZStlQmlhcz49MSl7dmFsdWUrPXJ0L2M7fWVsc2V7dmFsdWUrPXJ0Kk1hdGgucG93KDIsMS1lQmlhcyk7fWlmKHZhbHVlKmM+PTIpe2UrKztjLz0yO31pZihlK2VCaWFzPj1lTWF4KXttPTA7ZT1lTWF4O31lbHNlIGlmKGUrZUJpYXM+PTEpe209KHZhbHVlKmMtMSkqTWF0aC5wb3coMixtTGVuKTtlPWUrZUJpYXM7fWVsc2V7bT12YWx1ZSpNYXRoLnBvdygyLGVCaWFzLTEpKk1hdGgucG93KDIsbUxlbik7ZT0wO319Zm9yKDttTGVuPj04O2J1ZmZlcltvZmZzZXQraV09bSYweGZmLGkrPWQsbS89MjU2LG1MZW4tPTgpe31lPWU8PG1MZW58bTtlTGVuKz1tTGVuO2Zvcig7ZUxlbj4wO2J1ZmZlcltvZmZzZXQraV09ZSYweGZmLGkrPWQsZS89MjU2LGVMZW4tPTgpe31idWZmZXJbb2Zmc2V0K2ktZF18PXMqMTI4O307fSx7fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpey8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqLyAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi92YXIgTEFSR0VfQVJSQVlfU0laRT0yMDA7LyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL3ZhciBIQVNIX1VOREVGSU5FRD0nX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovdmFyIE1BWF9TQUZFX0lOVEVHRVI9OTAwNzE5OTI1NDc0MDk5MTsvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovdmFyIGFyZ3NUYWc9J1tvYmplY3QgQXJndW1lbnRzXScsYXJyYXlUYWc9J1tvYmplY3QgQXJyYXldJyxib29sVGFnPSdbb2JqZWN0IEJvb2xlYW5dJyxkYXRlVGFnPSdbb2JqZWN0IERhdGVdJyxlcnJvclRhZz0nW29iamVjdCBFcnJvcl0nLGZ1bmNUYWc9J1tvYmplY3QgRnVuY3Rpb25dJyxnZW5UYWc9J1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxtYXBUYWc9J1tvYmplY3QgTWFwXScsbnVtYmVyVGFnPSdbb2JqZWN0IE51bWJlcl0nLG9iamVjdFRhZz0nW29iamVjdCBPYmplY3RdJyxwcm9taXNlVGFnPSdbb2JqZWN0IFByb21pc2VdJyxyZWdleHBUYWc9J1tvYmplY3QgUmVnRXhwXScsc2V0VGFnPSdbb2JqZWN0IFNldF0nLHN0cmluZ1RhZz0nW29iamVjdCBTdHJpbmddJyxzeW1ib2xUYWc9J1tvYmplY3QgU3ltYm9sXScsd2Vha01hcFRhZz0nW29iamVjdCBXZWFrTWFwXSc7dmFyIGFycmF5QnVmZmVyVGFnPSdbb2JqZWN0IEFycmF5QnVmZmVyXScsZGF0YVZpZXdUYWc9J1tvYmplY3QgRGF0YVZpZXddJyxmbG9hdDMyVGFnPSdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLGZsb2F0NjRUYWc9J1tvYmplY3QgRmxvYXQ2NEFycmF5XScsaW50OFRhZz0nW29iamVjdCBJbnQ4QXJyYXldJyxpbnQxNlRhZz0nW29iamVjdCBJbnQxNkFycmF5XScsaW50MzJUYWc9J1tvYmplY3QgSW50MzJBcnJheV0nLHVpbnQ4VGFnPSdbb2JqZWN0IFVpbnQ4QXJyYXldJyx1aW50OENsYW1wZWRUYWc9J1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyx1aW50MTZUYWc9J1tvYmplY3QgVWludDE2QXJyYXldJyx1aW50MzJUYWc9J1tvYmplY3QgVWludDMyQXJyYXldJzsvKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovdmFyIHJlUmVnRXhwQ2hhcj0vW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7LyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovdmFyIHJlRmxhZ3M9L1xcdyokLzsvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovdmFyIHJlSXNIb3N0Q3Rvcj0vXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvOy8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi92YXIgcmVJc1VpbnQ9L14oPzowfFsxLTldXFxkKikkLzsvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL3ZhciBjbG9uZWFibGVUYWdzPXt9O2Nsb25lYWJsZVRhZ3NbYXJnc1RhZ109Y2xvbmVhYmxlVGFnc1thcnJheVRhZ109Y2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ109Y2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ109Y2xvbmVhYmxlVGFnc1tib29sVGFnXT1jbG9uZWFibGVUYWdzW2RhdGVUYWddPWNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ109Y2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXT1jbG9uZWFibGVUYWdzW2ludDhUYWddPWNsb25lYWJsZVRhZ3NbaW50MTZUYWddPWNsb25lYWJsZVRhZ3NbaW50MzJUYWddPWNsb25lYWJsZVRhZ3NbbWFwVGFnXT1jbG9uZWFibGVUYWdzW251bWJlclRhZ109Y2xvbmVhYmxlVGFnc1tvYmplY3RUYWddPWNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXT1jbG9uZWFibGVUYWdzW3NldFRhZ109Y2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddPWNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXT1jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXT1jbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ109Y2xvbmVhYmxlVGFnc1t1aW50MTZUYWddPWNsb25lYWJsZVRhZ3NbdWludDMyVGFnXT10cnVlO2Nsb25lYWJsZVRhZ3NbZXJyb3JUYWddPWNsb25lYWJsZVRhZ3NbZnVuY1RhZ109Y2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXT1mYWxzZTsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL3ZhciBmcmVlR2xvYmFsPV90eXBlb2YoZ2xvYmFsKT09J29iamVjdCcmJmdsb2JhbCYmZ2xvYmFsLk9iamVjdD09PU9iamVjdCYmZ2xvYmFsOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovdmFyIGZyZWVTZWxmPSh0eXBlb2Ygc2VsZj09PVwidW5kZWZpbmVkXCI/XCJ1bmRlZmluZWRcIjpfdHlwZW9mKHNlbGYpKT09J29iamVjdCcmJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmOy8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL3ZhciByb290PWZyZWVHbG9iYWx8fGZyZWVTZWxmfHxGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovdmFyIGZyZWVFeHBvcnRzPV90eXBlb2YoZXhwb3J0cyk9PSdvYmplY3QnJiZleHBvcnRzJiYhZXhwb3J0cy5ub2RlVHlwZSYmZXhwb3J0czsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovdmFyIGZyZWVNb2R1bGU9ZnJlZUV4cG9ydHMmJl90eXBlb2YobW9kdWxlKT09J29iamVjdCcmJm1vZHVsZSYmIW1vZHVsZS5ub2RlVHlwZSYmbW9kdWxlOy8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovdmFyIG1vZHVsZUV4cG9ydHM9ZnJlZU1vZHVsZSYmZnJlZU1vZHVsZS5leHBvcnRzPT09ZnJlZUV4cG9ydHM7LyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL2Z1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCxwYWlyKXsvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxubWFwLnNldChwYWlyWzBdLHBhaXJbMV0pO3JldHVybiBtYXA7fS8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL2Z1bmN0aW9uIGFkZFNldEVudHJ5KHNldCx2YWx1ZSl7Ly8gRG9uJ3QgcmV0dXJuIGBzZXQuYWRkYCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbnNldC5hZGQodmFsdWUpO3JldHVybiBzZXQ7fS8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LGl0ZXJhdGVlKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWFycmF5P2FycmF5Lmxlbmd0aDowO3doaWxlKCsraW5kZXg8bGVuZ3RoKXtpZihpdGVyYXRlZShhcnJheVtpbmRleF0saW5kZXgsYXJyYXkpPT09ZmFsc2Upe2JyZWFrO319cmV0dXJuIGFycmF5O30vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL2Z1bmN0aW9uIGFycmF5UHVzaChhcnJheSx2YWx1ZXMpe3ZhciBpbmRleD0tMSxsZW5ndGg9dmFsdWVzLmxlbmd0aCxvZmZzZXQ9YXJyYXkubGVuZ3RoO3doaWxlKCsraW5kZXg8bGVuZ3RoKXthcnJheVtvZmZzZXQraW5kZXhdPXZhbHVlc1tpbmRleF07fXJldHVybiBhcnJheTt9LyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksaXRlcmF0ZWUsYWNjdW11bGF0b3IsaW5pdEFjY3VtKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWFycmF5P2FycmF5Lmxlbmd0aDowO2lmKGluaXRBY2N1bSYmbGVuZ3RoKXthY2N1bXVsYXRvcj1hcnJheVsrK2luZGV4XTt9d2hpbGUoKytpbmRleDxsZW5ndGgpe2FjY3VtdWxhdG9yPWl0ZXJhdGVlKGFjY3VtdWxhdG9yLGFycmF5W2luZGV4XSxpbmRleCxhcnJheSk7fXJldHVybiBhY2N1bXVsYXRvcjt9LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9mdW5jdGlvbiBiYXNlVGltZXMobixpdGVyYXRlZSl7dmFyIGluZGV4PS0xLHJlc3VsdD1BcnJheShuKTt3aGlsZSgrK2luZGV4PG4pe3Jlc3VsdFtpbmRleF09aXRlcmF0ZWUoaW5kZXgpO31yZXR1cm4gcmVzdWx0O30vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LGtleSl7cmV0dXJuIG9iamVjdD09bnVsbD91bmRlZmluZWQ6b2JqZWN0W2tleV07fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKXsvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbnZhciByZXN1bHQ9ZmFsc2U7aWYodmFsdWUhPW51bGwmJnR5cGVvZiB2YWx1ZS50b1N0cmluZyE9J2Z1bmN0aW9uJyl7dHJ5e3Jlc3VsdD0hISh2YWx1ZSsnJyk7fWNhdGNoKGUpe319cmV0dXJuIHJlc3VsdDt9LyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovZnVuY3Rpb24gbWFwVG9BcnJheShtYXApe3ZhciBpbmRleD0tMSxyZXN1bHQ9QXJyYXkobWFwLnNpemUpO21hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLGtleSl7cmVzdWx0WysraW5kZXhdPVtrZXksdmFsdWVdO30pO3JldHVybiByZXN1bHQ7fS8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovZnVuY3Rpb24gb3ZlckFyZyhmdW5jLHRyYW5zZm9ybSl7cmV0dXJuIGZ1bmN0aW9uKGFyZyl7cmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO307fS8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL2Z1bmN0aW9uIHNldFRvQXJyYXkoc2V0KXt2YXIgaW5kZXg9LTEscmVzdWx0PUFycmF5KHNldC5zaXplKTtzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7cmVzdWx0WysraW5kZXhdPXZhbHVlO30pO3JldHVybiByZXN1bHQ7fS8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi92YXIgYXJyYXlQcm90bz1BcnJheS5wcm90b3R5cGUsZnVuY1Byb3RvPUZ1bmN0aW9uLnByb3RvdHlwZSxvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi92YXIgY29yZUpzRGF0YT1yb290WydfX2NvcmUtanNfc2hhcmVkX18nXTsvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL3ZhciBtYXNrU3JjS2V5PWZ1bmN0aW9uKCl7dmFyIHVpZD0vW14uXSskLy5leGVjKGNvcmVKc0RhdGEmJmNvcmVKc0RhdGEua2V5cyYmY29yZUpzRGF0YS5rZXlzLklFX1BST1RPfHwnJyk7cmV0dXJuIHVpZD8nU3ltYm9sKHNyYylfMS4nK3VpZDonJzt9KCk7LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL3ZhciBmdW5jVG9TdHJpbmc9ZnVuY1Byb3RvLnRvU3RyaW5nOy8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsvKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovdmFyIG9iamVjdFRvU3RyaW5nPW9iamVjdFByb3RvLnRvU3RyaW5nOy8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovdmFyIHJlSXNOYXRpdmU9UmVnRXhwKCdeJytmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsJ1xcXFwkJicpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csJyQxLio/JykrJyQnKTsvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi92YXIgQnVmZmVyPW1vZHVsZUV4cG9ydHM/cm9vdC5CdWZmZXI6dW5kZWZpbmVkLF9TeW1ib2w9cm9vdC5TeW1ib2wsVWludDhBcnJheT1yb290LlVpbnQ4QXJyYXksZ2V0UHJvdG90eXBlPW92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLE9iamVjdCksb2JqZWN0Q3JlYXRlPU9iamVjdC5jcmVhdGUscHJvcGVydHlJc0VudW1lcmFibGU9b2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsc3BsaWNlPWFycmF5UHJvdG8uc3BsaWNlOy8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi92YXIgbmF0aXZlR2V0U3ltYm9scz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLG5hdGl2ZUlzQnVmZmVyPUJ1ZmZlcj9CdWZmZXIuaXNCdWZmZXI6dW5kZWZpbmVkLG5hdGl2ZUtleXM9b3ZlckFyZyhPYmplY3Qua2V5cyxPYmplY3QpOy8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi92YXIgRGF0YVZpZXc9Z2V0TmF0aXZlKHJvb3QsJ0RhdGFWaWV3JyksTWFwPWdldE5hdGl2ZShyb290LCdNYXAnKSxQcm9taXNlPWdldE5hdGl2ZShyb290LCdQcm9taXNlJyksU2V0PWdldE5hdGl2ZShyb290LCdTZXQnKSxXZWFrTWFwPWdldE5hdGl2ZShyb290LCdXZWFrTWFwJyksbmF0aXZlQ3JlYXRlPWdldE5hdGl2ZShPYmplY3QsJ2NyZWF0ZScpOy8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovdmFyIGRhdGFWaWV3Q3RvclN0cmluZz10b1NvdXJjZShEYXRhVmlldyksbWFwQ3RvclN0cmluZz10b1NvdXJjZShNYXApLHByb21pc2VDdG9yU3RyaW5nPXRvU291cmNlKFByb21pc2UpLHNldEN0b3JTdHJpbmc9dG9Tb3VyY2UoU2V0KSx3ZWFrTWFwQ3RvclN0cmluZz10b1NvdXJjZShXZWFrTWFwKTsvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi92YXIgc3ltYm9sUHJvdG89X1N5bWJvbD9fU3ltYm9sLnByb3RvdHlwZTp1bmRlZmluZWQsc3ltYm9sVmFsdWVPZj1zeW1ib2xQcm90bz9zeW1ib2xQcm90by52YWx1ZU9mOnVuZGVmaW5lZDsvKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL2Z1bmN0aW9uIEhhc2goZW50cmllcyl7dmFyIGluZGV4PS0xLGxlbmd0aD1lbnRyaWVzP2VudHJpZXMubGVuZ3RoOjA7dGhpcy5jbGVhcigpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgZW50cnk9ZW50cmllc1tpbmRleF07dGhpcy5zZXQoZW50cnlbMF0sZW50cnlbMV0pO319LyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL2Z1bmN0aW9uIGhhc2hDbGVhcigpe3RoaXMuX19kYXRhX189bmF0aXZlQ3JlYXRlP25hdGl2ZUNyZWF0ZShudWxsKTp7fTt9LyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSl7cmV0dXJuIHRoaXMuaGFzKGtleSkmJmRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07fS8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovZnVuY3Rpb24gaGFzaEdldChrZXkpe3ZhciBkYXRhPXRoaXMuX19kYXRhX187aWYobmF0aXZlQ3JlYXRlKXt2YXIgcmVzdWx0PWRhdGFba2V5XTtyZXR1cm4gcmVzdWx0PT09SEFTSF9VTkRFRklORUQ/dW5kZWZpbmVkOnJlc3VsdDt9cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSxrZXkpP2RhdGFba2V5XTp1bmRlZmluZWQ7fS8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGhhc2hIYXMoa2V5KXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fO3JldHVybiBuYXRpdmVDcmVhdGU/ZGF0YVtrZXldIT09dW5kZWZpbmVkOmhhc093blByb3BlcnR5LmNhbGwoZGF0YSxrZXkpO30vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovZnVuY3Rpb24gaGFzaFNldChrZXksdmFsdWUpe3ZhciBkYXRhPXRoaXMuX19kYXRhX187ZGF0YVtrZXldPW5hdGl2ZUNyZWF0ZSYmdmFsdWU9PT11bmRlZmluZWQ/SEFTSF9VTkRFRklORUQ6dmFsdWU7cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyPWhhc2hDbGVhcjtIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ109aGFzaERlbGV0ZTtIYXNoLnByb3RvdHlwZS5nZXQ9aGFzaEdldDtIYXNoLnByb3RvdHlwZS5oYXM9aGFzaEhhcztIYXNoLnByb3RvdHlwZS5zZXQ9aGFzaFNldDsvKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcyl7dmFyIGluZGV4PS0xLGxlbmd0aD1lbnRyaWVzP2VudHJpZXMubGVuZ3RoOjA7dGhpcy5jbGVhcigpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgZW50cnk9ZW50cmllc1tpbmRleF07dGhpcy5zZXQoZW50cnlbMF0sZW50cnlbMV0pO319LyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKXt0aGlzLl9fZGF0YV9fPVtdO30vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXyxpbmRleD1hc3NvY0luZGV4T2YoZGF0YSxrZXkpO2lmKGluZGV4PDApe3JldHVybiBmYWxzZTt9dmFyIGxhc3RJbmRleD1kYXRhLmxlbmd0aC0xO2lmKGluZGV4PT1sYXN0SW5kZXgpe2RhdGEucG9wKCk7fWVsc2V7c3BsaWNlLmNhbGwoZGF0YSxpbmRleCwxKTt9cmV0dXJuIHRydWU7fS8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fLGluZGV4PWFzc29jSW5kZXhPZihkYXRhLGtleSk7cmV0dXJuIGluZGV4PDA/dW5kZWZpbmVkOmRhdGFbaW5kZXhdWzFdO30vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpe3JldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXyxrZXkpPi0xO30vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LHZhbHVlKXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fLGluZGV4PWFzc29jSW5kZXhPZihkYXRhLGtleSk7aWYoaW5kZXg8MCl7ZGF0YS5wdXNoKFtrZXksdmFsdWVdKTt9ZWxzZXtkYXRhW2luZGV4XVsxXT12YWx1ZTt9cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhcj1saXN0Q2FjaGVDbGVhcjtMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXT1saXN0Q2FjaGVEZWxldGU7TGlzdENhY2hlLnByb3RvdHlwZS5nZXQ9bGlzdENhY2hlR2V0O0xpc3RDYWNoZS5wcm90b3R5cGUuaGFzPWxpc3RDYWNoZUhhcztMaXN0Q2FjaGUucHJvdG90eXBlLnNldD1saXN0Q2FjaGVTZXQ7LyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWVudHJpZXM/ZW50cmllcy5sZW5ndGg6MDt0aGlzLmNsZWFyKCk7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciBlbnRyeT1lbnRyaWVzW2luZGV4XTt0aGlzLnNldChlbnRyeVswXSxlbnRyeVsxXSk7fX0vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpe3RoaXMuX19kYXRhX189eydoYXNoJzpuZXcgSGFzaCgpLCdtYXAnOm5ldyhNYXB8fExpc3RDYWNoZSkoKSwnc3RyaW5nJzpuZXcgSGFzaCgpfTt9LyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpe3JldHVybiBnZXRNYXBEYXRhKHRoaXMsa2V5KVsnZGVsZXRlJ10oa2V5KTt9LyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpe3JldHVybiBnZXRNYXBEYXRhKHRoaXMsa2V5KS5nZXQoa2V5KTt9LyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KXtyZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLGtleSkuaGFzKGtleSk7fS8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL2Z1bmN0aW9uIG1hcENhY2hlU2V0KGtleSx2YWx1ZSl7Z2V0TWFwRGF0YSh0aGlzLGtleSkuc2V0KGtleSx2YWx1ZSk7cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXI9bWFwQ2FjaGVDbGVhcjtNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddPW1hcENhY2hlRGVsZXRlO01hcENhY2hlLnByb3RvdHlwZS5nZXQ9bWFwQ2FjaGVHZXQ7TWFwQ2FjaGUucHJvdG90eXBlLmhhcz1tYXBDYWNoZUhhcztNYXBDYWNoZS5wcm90b3R5cGUuc2V0PW1hcENhY2hlU2V0Oy8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9mdW5jdGlvbiBTdGFjayhlbnRyaWVzKXt0aGlzLl9fZGF0YV9fPW5ldyBMaXN0Q2FjaGUoZW50cmllcyk7fS8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL2Z1bmN0aW9uIHN0YWNrQ2xlYXIoKXt0aGlzLl9fZGF0YV9fPW5ldyBMaXN0Q2FjaGUoKTt9LyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSl7cmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7fS8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9mdW5jdGlvbiBzdGFja0dldChrZXkpe3JldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO30vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIHN0YWNrSGFzKGtleSl7cmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7fS8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9mdW5jdGlvbiBzdGFja1NldChrZXksdmFsdWUpe3ZhciBjYWNoZT10aGlzLl9fZGF0YV9fO2lmKGNhY2hlIGluc3RhbmNlb2YgTGlzdENhY2hlKXt2YXIgcGFpcnM9Y2FjaGUuX19kYXRhX187aWYoIU1hcHx8cGFpcnMubGVuZ3RoPExBUkdFX0FSUkFZX1NJWkUtMSl7cGFpcnMucHVzaChba2V5LHZhbHVlXSk7cmV0dXJuIHRoaXM7fWNhY2hlPXRoaXMuX19kYXRhX189bmV3IE1hcENhY2hlKHBhaXJzKTt9Y2FjaGUuc2V0KGtleSx2YWx1ZSk7cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXI9c3RhY2tDbGVhcjtTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddPXN0YWNrRGVsZXRlO1N0YWNrLnByb3RvdHlwZS5nZXQ9c3RhY2tHZXQ7U3RhY2sucHJvdG90eXBlLmhhcz1zdGFja0hhcztTdGFjay5wcm90b3R5cGUuc2V0PXN0YWNrU2V0Oy8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLGluaGVyaXRlZCl7Ly8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbi8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxudmFyIHJlc3VsdD1pc0FycmF5KHZhbHVlKXx8aXNBcmd1bWVudHModmFsdWUpP2Jhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsU3RyaW5nKTpbXTt2YXIgbGVuZ3RoPXJlc3VsdC5sZW5ndGgsc2tpcEluZGV4ZXM9ISFsZW5ndGg7Zm9yKHZhciBrZXkgaW4gdmFsdWUpe2lmKChpbmhlcml0ZWR8fGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsa2V5KSkmJiEoc2tpcEluZGV4ZXMmJihrZXk9PSdsZW5ndGgnfHxpc0luZGV4KGtleSxsZW5ndGgpKSkpe3Jlc3VsdC5wdXNoKGtleSk7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL2Z1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCxrZXksdmFsdWUpe3ZhciBvYmpWYWx1ZT1vYmplY3Rba2V5XTtpZighKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LGtleSkmJmVxKG9ialZhbHVlLHZhbHVlKSl8fHZhbHVlPT09dW5kZWZpbmVkJiYhKGtleSBpbiBvYmplY3QpKXtvYmplY3Rba2V5XT12YWx1ZTt9fS8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksa2V5KXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDt3aGlsZShsZW5ndGgtLSl7aWYoZXEoYXJyYXlbbGVuZ3RoXVswXSxrZXkpKXtyZXR1cm4gbGVuZ3RoO319cmV0dXJuLTE7fS8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3Qsc291cmNlKXtyZXR1cm4gb2JqZWN0JiZjb3B5T2JqZWN0KHNvdXJjZSxrZXlzKHNvdXJjZSksb2JqZWN0KTt9LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNGdWxsXSBTcGVjaWZ5IGEgY2xvbmUgaW5jbHVkaW5nIHN5bWJvbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLGlzRGVlcCxpc0Z1bGwsY3VzdG9taXplcixrZXksb2JqZWN0LHN0YWNrKXt2YXIgcmVzdWx0O2lmKGN1c3RvbWl6ZXIpe3Jlc3VsdD1vYmplY3Q/Y3VzdG9taXplcih2YWx1ZSxrZXksb2JqZWN0LHN0YWNrKTpjdXN0b21pemVyKHZhbHVlKTt9aWYocmVzdWx0IT09dW5kZWZpbmVkKXtyZXR1cm4gcmVzdWx0O31pZighaXNPYmplY3QodmFsdWUpKXtyZXR1cm4gdmFsdWU7fXZhciBpc0Fycj1pc0FycmF5KHZhbHVlKTtpZihpc0Fycil7cmVzdWx0PWluaXRDbG9uZUFycmF5KHZhbHVlKTtpZighaXNEZWVwKXtyZXR1cm4gY29weUFycmF5KHZhbHVlLHJlc3VsdCk7fX1lbHNle3ZhciB0YWc9Z2V0VGFnKHZhbHVlKSxpc0Z1bmM9dGFnPT1mdW5jVGFnfHx0YWc9PWdlblRhZztpZihpc0J1ZmZlcih2YWx1ZSkpe3JldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSxpc0RlZXApO31pZih0YWc9PW9iamVjdFRhZ3x8dGFnPT1hcmdzVGFnfHxpc0Z1bmMmJiFvYmplY3Qpe2lmKGlzSG9zdE9iamVjdCh2YWx1ZSkpe3JldHVybiBvYmplY3Q/dmFsdWU6e307fXJlc3VsdD1pbml0Q2xvbmVPYmplY3QoaXNGdW5jP3t9OnZhbHVlKTtpZighaXNEZWVwKXtyZXR1cm4gY29weVN5bWJvbHModmFsdWUsYmFzZUFzc2lnbihyZXN1bHQsdmFsdWUpKTt9fWVsc2V7aWYoIWNsb25lYWJsZVRhZ3NbdGFnXSl7cmV0dXJuIG9iamVjdD92YWx1ZTp7fTt9cmVzdWx0PWluaXRDbG9uZUJ5VGFnKHZhbHVlLHRhZyxiYXNlQ2xvbmUsaXNEZWVwKTt9fS8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG5zdGFja3x8KHN0YWNrPW5ldyBTdGFjaygpKTt2YXIgc3RhY2tlZD1zdGFjay5nZXQodmFsdWUpO2lmKHN0YWNrZWQpe3JldHVybiBzdGFja2VkO31zdGFjay5zZXQodmFsdWUscmVzdWx0KTtpZighaXNBcnIpe3ZhciBwcm9wcz1pc0Z1bGw/Z2V0QWxsS2V5cyh2YWx1ZSk6a2V5cyh2YWx1ZSk7fWFycmF5RWFjaChwcm9wc3x8dmFsdWUsZnVuY3Rpb24oc3ViVmFsdWUsa2V5KXtpZihwcm9wcyl7a2V5PXN1YlZhbHVlO3N1YlZhbHVlPXZhbHVlW2tleV07fS8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5hc3NpZ25WYWx1ZShyZXN1bHQsa2V5LGJhc2VDbG9uZShzdWJWYWx1ZSxpc0RlZXAsaXNGdWxsLGN1c3RvbWl6ZXIsa2V5LHZhbHVlLHN0YWNrKSk7fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9mdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvKXtyZXR1cm4gaXNPYmplY3QocHJvdG8pP29iamVjdENyZWF0ZShwcm90byk6e307fS8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL2Z1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCxrZXlzRnVuYyxzeW1ib2xzRnVuYyl7dmFyIHJlc3VsdD1rZXlzRnVuYyhvYmplY3QpO3JldHVybiBpc0FycmF5KG9iamVjdCk/cmVzdWx0OmFycmF5UHVzaChyZXN1bHQsc3ltYm9sc0Z1bmMob2JqZWN0KSk7fS8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL2Z1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpe3JldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTt9LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKXtpZighaXNPYmplY3QodmFsdWUpfHxpc01hc2tlZCh2YWx1ZSkpe3JldHVybiBmYWxzZTt9dmFyIHBhdHRlcm49aXNGdW5jdGlvbih2YWx1ZSl8fGlzSG9zdE9iamVjdCh2YWx1ZSk/cmVJc05hdGl2ZTpyZUlzSG9zdEN0b3I7cmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO30vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL2Z1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCl7aWYoIWlzUHJvdG90eXBlKG9iamVjdCkpe3JldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7fXZhciByZXN1bHQ9W107Zm9yKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpe2lmKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LGtleSkmJmtleSE9J2NvbnN0cnVjdG9yJyl7cmVzdWx0LnB1c2goa2V5KTt9fXJldHVybiByZXN1bHQ7fS8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsaXNEZWVwKXtpZihpc0RlZXApe3JldHVybiBidWZmZXIuc2xpY2UoKTt9dmFyIHJlc3VsdD1uZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGJ1ZmZlci5sZW5ndGgpO2J1ZmZlci5jb3B5KHJlc3VsdCk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL2Z1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpe3ZhciByZXN1bHQ9bmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO25ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL2Z1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsaXNEZWVwKXt2YXIgYnVmZmVyPWlzRGVlcD9jbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcik6ZGF0YVZpZXcuYnVmZmVyO3JldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLGRhdGFWaWV3LmJ5dGVPZmZzZXQsZGF0YVZpZXcuYnl0ZUxlbmd0aCk7fS8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICovZnVuY3Rpb24gY2xvbmVNYXAobWFwLGlzRGVlcCxjbG9uZUZ1bmMpe3ZhciBhcnJheT1pc0RlZXA/Y2xvbmVGdW5jKG1hcFRvQXJyYXkobWFwKSx0cnVlKTptYXBUb0FycmF5KG1hcCk7cmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LGFkZE1hcEVudHJ5LG5ldyBtYXAuY29uc3RydWN0b3IoKSk7fS8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKXt2YXIgcmVzdWx0PW5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSxyZUZsYWdzLmV4ZWMocmVnZXhwKSk7cmVzdWx0Lmxhc3RJbmRleD1yZWdleHAubGFzdEluZGV4O3JldHVybiByZXN1bHQ7fS8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovZnVuY3Rpb24gY2xvbmVTZXQoc2V0LGlzRGVlcCxjbG9uZUZ1bmMpe3ZhciBhcnJheT1pc0RlZXA/Y2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSx0cnVlKTpzZXRUb0FycmF5KHNldCk7cmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LGFkZFNldEVudHJ5LG5ldyBzZXQuY29uc3RydWN0b3IoKSk7fS8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL2Z1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCl7cmV0dXJuIHN5bWJvbFZhbHVlT2Y/T2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKTp7fTt9LyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksaXNEZWVwKXt2YXIgYnVmZmVyPWlzRGVlcD9jbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKTp0eXBlZEFycmF5LmJ1ZmZlcjtyZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLHR5cGVkQXJyYXkuYnl0ZU9mZnNldCx0eXBlZEFycmF5Lmxlbmd0aCk7fS8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL2Z1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsYXJyYXkpe3ZhciBpbmRleD0tMSxsZW5ndGg9c291cmNlLmxlbmd0aDthcnJheXx8KGFycmF5PUFycmF5KGxlbmd0aCkpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXthcnJheVtpbmRleF09c291cmNlW2luZGV4XTt9cmV0dXJuIGFycmF5O30vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UscHJvcHMsb2JqZWN0LGN1c3RvbWl6ZXIpe29iamVjdHx8KG9iamVjdD17fSk7dmFyIGluZGV4PS0xLGxlbmd0aD1wcm9wcy5sZW5ndGg7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciBrZXk9cHJvcHNbaW5kZXhdO3ZhciBuZXdWYWx1ZT1jdXN0b21pemVyP2N1c3RvbWl6ZXIob2JqZWN0W2tleV0sc291cmNlW2tleV0sa2V5LG9iamVjdCxzb3VyY2UpOnVuZGVmaW5lZDthc3NpZ25WYWx1ZShvYmplY3Qsa2V5LG5ld1ZhbHVlPT09dW5kZWZpbmVkP3NvdXJjZVtrZXldOm5ld1ZhbHVlKTt9cmV0dXJuIG9iamVjdDt9LyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLG9iamVjdCl7cmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLGdldFN5bWJvbHMoc291cmNlKSxvYmplY3QpO30vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCl7cmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCxrZXlzLGdldFN5bWJvbHMpO30vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsa2V5KXt2YXIgZGF0YT1tYXAuX19kYXRhX187cmV0dXJuIGlzS2V5YWJsZShrZXkpP2RhdGFbdHlwZW9mIGtleT09J3N0cmluZyc/J3N0cmluZyc6J2hhc2gnXTpkYXRhLm1hcDt9LyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL2Z1bmN0aW9uIGdldE5hdGl2ZShvYmplY3Qsa2V5KXt2YXIgdmFsdWU9Z2V0VmFsdWUob2JqZWN0LGtleSk7cmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk/dmFsdWU6dW5kZWZpbmVkO30vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi92YXIgZ2V0U3ltYm9scz1uYXRpdmVHZXRTeW1ib2xzP292ZXJBcmcobmF0aXZlR2V0U3ltYm9scyxPYmplY3QpOnN0dWJBcnJheTsvKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovdmFyIGdldFRhZz1iYXNlR2V0VGFnOy8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSA8IDE0LCBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcy5cbmlmKERhdGFWaWV3JiZnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpIT1kYXRhVmlld1RhZ3x8TWFwJiZnZXRUYWcobmV3IE1hcCgpKSE9bWFwVGFnfHxQcm9taXNlJiZnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpIT1wcm9taXNlVGFnfHxTZXQmJmdldFRhZyhuZXcgU2V0KCkpIT1zZXRUYWd8fFdlYWtNYXAmJmdldFRhZyhuZXcgV2Vha01hcCgpKSE9d2Vha01hcFRhZyl7Z2V0VGFnPWZ1bmN0aW9uIGdldFRhZyh2YWx1ZSl7dmFyIHJlc3VsdD1vYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxDdG9yPXJlc3VsdD09b2JqZWN0VGFnP3ZhbHVlLmNvbnN0cnVjdG9yOnVuZGVmaW5lZCxjdG9yU3RyaW5nPUN0b3I/dG9Tb3VyY2UoQ3Rvcik6dW5kZWZpbmVkO2lmKGN0b3JTdHJpbmcpe3N3aXRjaChjdG9yU3RyaW5nKXtjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzpyZXR1cm4gZGF0YVZpZXdUYWc7Y2FzZSBtYXBDdG9yU3RyaW5nOnJldHVybiBtYXBUYWc7Y2FzZSBwcm9taXNlQ3RvclN0cmluZzpyZXR1cm4gcHJvbWlzZVRhZztjYXNlIHNldEN0b3JTdHJpbmc6cmV0dXJuIHNldFRhZztjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOnJldHVybiB3ZWFrTWFwVGFnO319cmV0dXJuIHJlc3VsdDt9O30vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpe3ZhciBsZW5ndGg9YXJyYXkubGVuZ3RoLHJlc3VsdD1hcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpOy8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG5pZihsZW5ndGgmJnR5cGVvZiBhcnJheVswXT09J3N0cmluZycmJmhhc093blByb3BlcnR5LmNhbGwoYXJyYXksJ2luZGV4Jykpe3Jlc3VsdC5pbmRleD1hcnJheS5pbmRleDtyZXN1bHQuaW5wdXQ9YXJyYXkuaW5wdXQ7fXJldHVybiByZXN1bHQ7fS8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL2Z1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3Qpe3JldHVybiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yPT0nZnVuY3Rpb24nJiYhaXNQcm90b3R5cGUob2JqZWN0KT9iYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKTp7fTt9LyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL2Z1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCx0YWcsY2xvbmVGdW5jLGlzRGVlcCl7dmFyIEN0b3I9b2JqZWN0LmNvbnN0cnVjdG9yO3N3aXRjaCh0YWcpe2Nhc2UgYXJyYXlCdWZmZXJUYWc6cmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtjYXNlIGJvb2xUYWc6Y2FzZSBkYXRlVGFnOnJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtjYXNlIGRhdGFWaWV3VGFnOnJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCxpc0RlZXApO2Nhc2UgZmxvYXQzMlRhZzpjYXNlIGZsb2F0NjRUYWc6Y2FzZSBpbnQ4VGFnOmNhc2UgaW50MTZUYWc6Y2FzZSBpbnQzMlRhZzpjYXNlIHVpbnQ4VGFnOmNhc2UgdWludDhDbGFtcGVkVGFnOmNhc2UgdWludDE2VGFnOmNhc2UgdWludDMyVGFnOnJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LGlzRGVlcCk7Y2FzZSBtYXBUYWc6cmV0dXJuIGNsb25lTWFwKG9iamVjdCxpc0RlZXAsY2xvbmVGdW5jKTtjYXNlIG51bWJlclRhZzpjYXNlIHN0cmluZ1RhZzpyZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtjYXNlIHJlZ2V4cFRhZzpyZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtjYXNlIHNldFRhZzpyZXR1cm4gY2xvbmVTZXQob2JqZWN0LGlzRGVlcCxjbG9uZUZ1bmMpO2Nhc2Ugc3ltYm9sVGFnOnJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO319LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSxsZW5ndGgpe2xlbmd0aD1sZW5ndGg9PW51bGw/TUFYX1NBRkVfSU5URUdFUjpsZW5ndGg7cmV0dXJuISFsZW5ndGgmJih0eXBlb2YgdmFsdWU9PSdudW1iZXInfHxyZUlzVWludC50ZXN0KHZhbHVlKSkmJnZhbHVlPi0xJiZ2YWx1ZSUxPT0wJiZ2YWx1ZTxsZW5ndGg7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKXt2YXIgdHlwZT1fdHlwZW9mKHZhbHVlKTtyZXR1cm4gdHlwZT09J3N0cmluZyd8fHR5cGU9PSdudW1iZXInfHx0eXBlPT0nc3ltYm9sJ3x8dHlwZT09J2Jvb2xlYW4nP3ZhbHVlIT09J19fcHJvdG9fXyc6dmFsdWU9PT1udWxsO30vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBpc01hc2tlZChmdW5jKXtyZXR1cm4hIW1hc2tTcmNLZXkmJm1hc2tTcmNLZXkgaW4gZnVuYzt9LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSl7dmFyIEN0b3I9dmFsdWUmJnZhbHVlLmNvbnN0cnVjdG9yLHByb3RvPXR5cGVvZiBDdG9yPT0nZnVuY3Rpb24nJiZDdG9yLnByb3RvdHlwZXx8b2JqZWN0UHJvdG87cmV0dXJuIHZhbHVlPT09cHJvdG87fS8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYyl7aWYoZnVuYyE9bnVsbCl7dHJ5e3JldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTt9Y2F0Y2goZSl7fXRyeXtyZXR1cm4gZnVuYysnJzt9Y2F0Y2goZSl7fX1yZXR1cm4nJzt9LyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSl7cmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSx0cnVlLHRydWUpO30vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9mdW5jdGlvbiBlcSh2YWx1ZSxvdGhlcil7cmV0dXJuIHZhbHVlPT09b3RoZXJ8fHZhbHVlIT09dmFsdWUmJm90aGVyIT09b3RoZXI7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSl7Ly8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbnJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkmJmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsJ2NhbGxlZScpJiYoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsJ2NhbGxlZScpfHxvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKT09YXJnc1RhZyk7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL3ZhciBpc0FycmF5PUFycmF5LmlzQXJyYXk7LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKXtyZXR1cm4gdmFsdWUhPW51bGwmJmlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkmJiFpc0Z1bmN0aW9uKHZhbHVlKTt9LyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKXtyZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSYmaXNBcnJheUxpa2UodmFsdWUpO30vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovdmFyIGlzQnVmZmVyPW5hdGl2ZUlzQnVmZmVyfHxzdHViRmFsc2U7LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKXsvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3Jcbi8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbnZhciB0YWc9aXNPYmplY3QodmFsdWUpP29iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpOicnO3JldHVybiB0YWc9PWZ1bmNUYWd8fHRhZz09Z2VuVGFnO30vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlPT0nbnVtYmVyJyYmdmFsdWU+LTEmJnZhbHVlJTE9PTAmJnZhbHVlPD1NQVhfU0FGRV9JTlRFR0VSO30vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpe3ZhciB0eXBlPV90eXBlb2YodmFsdWUpO3JldHVybiEhdmFsdWUmJih0eXBlPT0nb2JqZWN0J3x8dHlwZT09J2Z1bmN0aW9uJyk7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKXtyZXR1cm4hIXZhbHVlJiZfdHlwZW9mKHZhbHVlKT09J29iamVjdCc7fS8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL2Z1bmN0aW9uIGtleXMob2JqZWN0KXtyZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KT9hcnJheUxpa2VLZXlzKG9iamVjdCk6YmFzZUtleXMob2JqZWN0KTt9LyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gc3R1YkFycmF5KCl7cmV0dXJuW107fS8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovZnVuY3Rpb24gc3R1YkZhbHNlKCl7cmV0dXJuIGZhbHNlO31tb2R1bGUuZXhwb3J0cz1jbG9uZURlZXA7fSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiP2dsb2JhbDp0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pO30se31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXsvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi8gLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovdmFyIElORklOSVRZPTEvMDsvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovdmFyIHN5bWJvbFRhZz0nW29iamVjdCBTeW1ib2xdJzsvKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcGF0dGVybnMpLlxuICovdmFyIHJlUmVnRXhwQ2hhcj0vW1xcXFxeJC4qKz8oKVtcXF17fXxdL2cscmVIYXNSZWdFeHBDaGFyPVJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL3ZhciBmcmVlR2xvYmFsPV90eXBlb2YoZ2xvYmFsKT09J29iamVjdCcmJmdsb2JhbCYmZ2xvYmFsLk9iamVjdD09PU9iamVjdCYmZ2xvYmFsOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovdmFyIGZyZWVTZWxmPSh0eXBlb2Ygc2VsZj09PVwidW5kZWZpbmVkXCI/XCJ1bmRlZmluZWRcIjpfdHlwZW9mKHNlbGYpKT09J29iamVjdCcmJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmOy8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL3ZhciByb290PWZyZWVHbG9iYWx8fGZyZWVTZWxmfHxGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpOy8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi92YXIgb2JqZWN0UHJvdG89T2JqZWN0LnByb3RvdHlwZTsvKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovdmFyIG9iamVjdFRvU3RyaW5nPW9iamVjdFByb3RvLnRvU3RyaW5nOy8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL3ZhciBfU3ltYm9sMj1yb290LlN5bWJvbDsvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi92YXIgc3ltYm9sUHJvdG89X1N5bWJvbDI/X1N5bWJvbDIucHJvdG90eXBlOnVuZGVmaW5lZCxzeW1ib2xUb1N0cmluZz1zeW1ib2xQcm90bz9zeW1ib2xQcm90by50b1N0cmluZzp1bmRlZmluZWQ7LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKXsvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuaWYodHlwZW9mIHZhbHVlPT0nc3RyaW5nJyl7cmV0dXJuIHZhbHVlO31pZihpc1N5bWJvbCh2YWx1ZSkpe3JldHVybiBzeW1ib2xUb1N0cmluZz9zeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKTonJzt9dmFyIHJlc3VsdD12YWx1ZSsnJztyZXR1cm4gcmVzdWx0PT0nMCcmJjEvdmFsdWU9PS1JTkZJTklUWT8nLTAnOnJlc3VsdDt9LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpe3JldHVybiEhdmFsdWUmJl90eXBlb2YodmFsdWUpPT0nb2JqZWN0Jzt9LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpe3JldHVybiBfdHlwZW9mKHZhbHVlKT09J3N5bWJvbCd8fGlzT2JqZWN0TGlrZSh2YWx1ZSkmJm9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpPT1zeW1ib2xUYWc7fS8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSl7cmV0dXJuIHZhbHVlPT1udWxsPycnOmJhc2VUb1N0cmluZyh2YWx1ZSk7fS8qKlxuICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICovZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZyl7c3RyaW5nPXRvU3RyaW5nKHN0cmluZyk7cmV0dXJuIHN0cmluZyYmcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKT9zdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsJ1xcXFwkJicpOnN0cmluZzt9bW9kdWxlLmV4cG9ydHM9ZXNjYXBlUmVnRXhwO30pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIj9nbG9iYWw6dHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KTt9LHt9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi92YXIgb2JqZWN0VGFnPSdbb2JqZWN0IE9iamVjdF0nOy8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKXsvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbnZhciByZXN1bHQ9ZmFsc2U7aWYodmFsdWUhPW51bGwmJnR5cGVvZiB2YWx1ZS50b1N0cmluZyE9J2Z1bmN0aW9uJyl7dHJ5e3Jlc3VsdD0hISh2YWx1ZSsnJyk7fWNhdGNoKGUpe319cmV0dXJuIHJlc3VsdDt9LyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsdHJhbnNmb3JtKXtyZXR1cm4gZnVuY3Rpb24oYXJnKXtyZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7fTt9LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBmdW5jUHJvdG89RnVuY3Rpb24ucHJvdG90eXBlLG9iamVjdFByb3RvPU9iamVjdC5wcm90b3R5cGU7LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL3ZhciBmdW5jVG9TdHJpbmc9ZnVuY1Byb3RvLnRvU3RyaW5nOy8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovdmFyIG9iamVjdEN0b3JTdHJpbmc9ZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTsvKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovdmFyIG9iamVjdFRvU3RyaW5nPW9iamVjdFByb3RvLnRvU3RyaW5nOy8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL3ZhciBnZXRQcm90b3R5cGU9b3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KTsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSl7cmV0dXJuISF2YWx1ZSYmX3R5cGVvZih2YWx1ZSk9PSdvYmplY3QnO30vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSl7aWYoIWlzT2JqZWN0TGlrZSh2YWx1ZSl8fG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIT1vYmplY3RUYWd8fGlzSG9zdE9iamVjdCh2YWx1ZSkpe3JldHVybiBmYWxzZTt9dmFyIHByb3RvPWdldFByb3RvdHlwZSh2YWx1ZSk7aWYocHJvdG89PT1udWxsKXtyZXR1cm4gdHJ1ZTt9dmFyIEN0b3I9aGFzT3duUHJvcGVydHkuY2FsbChwcm90bywnY29uc3RydWN0b3InKSYmcHJvdG8uY29uc3RydWN0b3I7cmV0dXJuIHR5cGVvZiBDdG9yPT0nZnVuY3Rpb24nJiZDdG9yIGluc3RhbmNlb2YgQ3RvciYmZnVuY1RvU3RyaW5nLmNhbGwoQ3Rvcik9PW9iamVjdEN0b3JTdHJpbmc7fW1vZHVsZS5leHBvcnRzPWlzUGxhaW5PYmplY3Q7fSx7fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qKlxuICogbG9kYXNoIDQuMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi8gLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL3ZhciBzdHJpbmdUYWc9J1tvYmplY3QgU3RyaW5nXSc7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBvYmplY3RQcm90bz1PYmplY3QucHJvdG90eXBlOy8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL3ZhciBvYmplY3RUb1N0cmluZz1vYmplY3RQcm90by50b1N0cmluZzsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL3ZhciBpc0FycmF5PUFycmF5LmlzQXJyYXk7LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKXtyZXR1cm4hIXZhbHVlJiZfdHlwZW9mKHZhbHVlKT09J29iamVjdCc7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWU9PSdzdHJpbmcnfHwhaXNBcnJheSh2YWx1ZSkmJmlzT2JqZWN0TGlrZSh2YWx1ZSkmJm9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpPT1zdHJpbmdUYWc7fW1vZHVsZS5leHBvcnRzPWlzU3RyaW5nO30se31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXsvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL3ZhciBMQVJHRV9BUlJBWV9TSVpFPTIwMDsvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovdmFyIEhBU0hfVU5ERUZJTkVEPSdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJzsvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovdmFyIEhPVF9DT1VOVD04MDAsSE9UX1NQQU49MTY7LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovdmFyIE1BWF9TQUZFX0lOVEVHRVI9OTAwNzE5OTI1NDc0MDk5MTsvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovdmFyIGFyZ3NUYWc9J1tvYmplY3QgQXJndW1lbnRzXScsYXJyYXlUYWc9J1tvYmplY3QgQXJyYXldJyxhc3luY1RhZz0nW29iamVjdCBBc3luY0Z1bmN0aW9uXScsYm9vbFRhZz0nW29iamVjdCBCb29sZWFuXScsZGF0ZVRhZz0nW29iamVjdCBEYXRlXScsZXJyb3JUYWc9J1tvYmplY3QgRXJyb3JdJyxmdW5jVGFnPSdbb2JqZWN0IEZ1bmN0aW9uXScsZ2VuVGFnPSdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsbWFwVGFnPSdbb2JqZWN0IE1hcF0nLG51bWJlclRhZz0nW29iamVjdCBOdW1iZXJdJyxudWxsVGFnPSdbb2JqZWN0IE51bGxdJyxvYmplY3RUYWc9J1tvYmplY3QgT2JqZWN0XScscHJveHlUYWc9J1tvYmplY3QgUHJveHldJyxyZWdleHBUYWc9J1tvYmplY3QgUmVnRXhwXScsc2V0VGFnPSdbb2JqZWN0IFNldF0nLHN0cmluZ1RhZz0nW29iamVjdCBTdHJpbmddJyx1bmRlZmluZWRUYWc9J1tvYmplY3QgVW5kZWZpbmVkXScsd2Vha01hcFRhZz0nW29iamVjdCBXZWFrTWFwXSc7dmFyIGFycmF5QnVmZmVyVGFnPSdbb2JqZWN0IEFycmF5QnVmZmVyXScsZGF0YVZpZXdUYWc9J1tvYmplY3QgRGF0YVZpZXddJyxmbG9hdDMyVGFnPSdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLGZsb2F0NjRUYWc9J1tvYmplY3QgRmxvYXQ2NEFycmF5XScsaW50OFRhZz0nW29iamVjdCBJbnQ4QXJyYXldJyxpbnQxNlRhZz0nW29iamVjdCBJbnQxNkFycmF5XScsaW50MzJUYWc9J1tvYmplY3QgSW50MzJBcnJheV0nLHVpbnQ4VGFnPSdbb2JqZWN0IFVpbnQ4QXJyYXldJyx1aW50OENsYW1wZWRUYWc9J1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyx1aW50MTZUYWc9J1tvYmplY3QgVWludDE2QXJyYXldJyx1aW50MzJUYWc9J1tvYmplY3QgVWludDMyQXJyYXldJzsvKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovdmFyIHJlUmVnRXhwQ2hhcj0vW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7LyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL3ZhciByZUlzSG9zdEN0b3I9L15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLzsvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovdmFyIHJlSXNVaW50PS9eKD86MHxbMS05XVxcZCopJC87LyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL3ZhciB0eXBlZEFycmF5VGFncz17fTt0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXT10eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXT10eXBlZEFycmF5VGFnc1tpbnQ4VGFnXT10eXBlZEFycmF5VGFnc1tpbnQxNlRhZ109dHlwZWRBcnJheVRhZ3NbaW50MzJUYWddPXR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXT10eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddPXR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ109dHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXT10cnVlO3R5cGVkQXJyYXlUYWdzW2FyZ3NUYWddPXR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXT10eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ109dHlwZWRBcnJheVRhZ3NbYm9vbFRhZ109dHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddPXR5cGVkQXJyYXlUYWdzW2RhdGVUYWddPXR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXT10eXBlZEFycmF5VGFnc1tmdW5jVGFnXT10eXBlZEFycmF5VGFnc1ttYXBUYWddPXR5cGVkQXJyYXlUYWdzW251bWJlclRhZ109dHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXT10eXBlZEFycmF5VGFnc1tyZWdleHBUYWddPXR5cGVkQXJyYXlUYWdzW3NldFRhZ109dHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXT10eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXT1mYWxzZTsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL3ZhciBmcmVlR2xvYmFsPV90eXBlb2YoZ2xvYmFsKT09J29iamVjdCcmJmdsb2JhbCYmZ2xvYmFsLk9iamVjdD09PU9iamVjdCYmZ2xvYmFsOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovdmFyIGZyZWVTZWxmPSh0eXBlb2Ygc2VsZj09PVwidW5kZWZpbmVkXCI/XCJ1bmRlZmluZWRcIjpfdHlwZW9mKHNlbGYpKT09J29iamVjdCcmJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmOy8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL3ZhciByb290PWZyZWVHbG9iYWx8fGZyZWVTZWxmfHxGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovdmFyIGZyZWVFeHBvcnRzPV90eXBlb2YoZXhwb3J0cyk9PSdvYmplY3QnJiZleHBvcnRzJiYhZXhwb3J0cy5ub2RlVHlwZSYmZXhwb3J0czsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovdmFyIGZyZWVNb2R1bGU9ZnJlZUV4cG9ydHMmJl90eXBlb2YobW9kdWxlKT09J29iamVjdCcmJm1vZHVsZSYmIW1vZHVsZS5ub2RlVHlwZSYmbW9kdWxlOy8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovdmFyIG1vZHVsZUV4cG9ydHM9ZnJlZU1vZHVsZSYmZnJlZU1vZHVsZS5leHBvcnRzPT09ZnJlZUV4cG9ydHM7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovdmFyIGZyZWVQcm9jZXNzPW1vZHVsZUV4cG9ydHMmJmZyZWVHbG9iYWwucHJvY2VzczsvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi92YXIgbm9kZVV0aWw9ZnVuY3Rpb24oKXt0cnl7Ly8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG52YXIgdHlwZXM9ZnJlZU1vZHVsZSYmZnJlZU1vZHVsZS5yZXF1aXJlJiZmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztpZih0eXBlcyl7cmV0dXJuIHR5cGVzO30vLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxucmV0dXJuIGZyZWVQcm9jZXNzJiZmcmVlUHJvY2Vzcy5iaW5kaW5nJiZmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7fWNhdGNoKGUpe319KCk7LyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi92YXIgbm9kZUlzVHlwZWRBcnJheT1ub2RlVXRpbCYmbm9kZVV0aWwuaXNUeXBlZEFycmF5Oy8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9mdW5jdGlvbiBhcHBseShmdW5jLHRoaXNBcmcsYXJncyl7c3dpdGNoKGFyZ3MubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtjYXNlIDE6cmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLGFyZ3NbMF0pO2Nhc2UgMjpyZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsYXJnc1swXSxhcmdzWzFdKTtjYXNlIDM6cmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLGFyZ3NbMF0sYXJnc1sxXSxhcmdzWzJdKTt9cmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZyxhcmdzKTt9LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9mdW5jdGlvbiBiYXNlVGltZXMobixpdGVyYXRlZSl7dmFyIGluZGV4PS0xLHJlc3VsdD1BcnJheShuKTt3aGlsZSgrK2luZGV4PG4pe3Jlc3VsdFtpbmRleF09aXRlcmF0ZWUoaW5kZXgpO31yZXR1cm4gcmVzdWx0O30vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpe3JldHVybiBmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIGZ1bmModmFsdWUpO307fS8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3Qsa2V5KXtyZXR1cm4gb2JqZWN0PT1udWxsP3VuZGVmaW5lZDpvYmplY3Rba2V5XTt9LyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsdHJhbnNmb3JtKXtyZXR1cm4gZnVuY3Rpb24oYXJnKXtyZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7fTt9LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBhcnJheVByb3RvPUFycmF5LnByb3RvdHlwZSxmdW5jUHJvdG89RnVuY3Rpb24ucHJvdG90eXBlLG9iamVjdFByb3RvPU9iamVjdC5wcm90b3R5cGU7LyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL3ZhciBjb3JlSnNEYXRhPXJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddOy8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi92YXIgZnVuY1RvU3RyaW5nPWZ1bmNQcm90by50b1N0cmluZzsvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi92YXIgaGFzT3duUHJvcGVydHk9b2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7LyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi92YXIgbWFza1NyY0tleT1mdW5jdGlvbigpe3ZhciB1aWQ9L1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhJiZjb3JlSnNEYXRhLmtleXMmJmNvcmVKc0RhdGEua2V5cy5JRV9QUk9UT3x8JycpO3JldHVybiB1aWQ/J1N5bWJvbChzcmMpXzEuJyt1aWQ6Jyc7fSgpOy8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi92YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmc9b2JqZWN0UHJvdG8udG9TdHJpbmc7LyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL3ZhciBvYmplY3RDdG9yU3RyaW5nPWZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7LyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi92YXIgcmVJc05hdGl2ZT1SZWdFeHAoJ14nK2Z1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwnXFxcXCQmJykucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywnJDEuKj8nKSsnJCcpOy8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL3ZhciBCdWZmZXI9bW9kdWxlRXhwb3J0cz9yb290LkJ1ZmZlcjp1bmRlZmluZWQsX1N5bWJvbDM9cm9vdC5TeW1ib2wsVWludDhBcnJheT1yb290LlVpbnQ4QXJyYXksYWxsb2NVbnNhZmU9QnVmZmVyP0J1ZmZlci5hbGxvY1Vuc2FmZTp1bmRlZmluZWQsZ2V0UHJvdG90eXBlPW92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLE9iamVjdCksb2JqZWN0Q3JlYXRlPU9iamVjdC5jcmVhdGUscHJvcGVydHlJc0VudW1lcmFibGU9b2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsc3BsaWNlPWFycmF5UHJvdG8uc3BsaWNlLHN5bVRvU3RyaW5nVGFnPV9TeW1ib2wzP19TeW1ib2wzLnRvU3RyaW5nVGFnOnVuZGVmaW5lZDt2YXIgZGVmaW5lUHJvcGVydHk9ZnVuY3Rpb24oKXt0cnl7dmFyIGZ1bmM9Z2V0TmF0aXZlKE9iamVjdCwnZGVmaW5lUHJvcGVydHknKTtmdW5jKHt9LCcnLHt9KTtyZXR1cm4gZnVuYzt9Y2F0Y2goZSl7fX0oKTsvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovdmFyIG5hdGl2ZUlzQnVmZmVyPUJ1ZmZlcj9CdWZmZXIuaXNCdWZmZXI6dW5kZWZpbmVkLG5hdGl2ZU1heD1NYXRoLm1heCxuYXRpdmVOb3c9RGF0ZS5ub3c7LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL3ZhciBNYXA9Z2V0TmF0aXZlKHJvb3QsJ01hcCcpLG5hdGl2ZUNyZWF0ZT1nZXROYXRpdmUoT2JqZWN0LCdjcmVhdGUnKTsvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovdmFyIGJhc2VDcmVhdGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBvYmplY3QoKXt9cmV0dXJuIGZ1bmN0aW9uKHByb3RvKXtpZighaXNPYmplY3QocHJvdG8pKXtyZXR1cm57fTt9aWYob2JqZWN0Q3JlYXRlKXtyZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTt9b2JqZWN0LnByb3RvdHlwZT1wcm90bzt2YXIgcmVzdWx0PW5ldyBvYmplY3QoKTtvYmplY3QucHJvdG90eXBlPXVuZGVmaW5lZDtyZXR1cm4gcmVzdWx0O307fSgpOy8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovZnVuY3Rpb24gSGFzaChlbnRyaWVzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWVudHJpZXM9PW51bGw/MDplbnRyaWVzLmxlbmd0aDt0aGlzLmNsZWFyKCk7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciBlbnRyeT1lbnRyaWVzW2luZGV4XTt0aGlzLnNldChlbnRyeVswXSxlbnRyeVsxXSk7fX0vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovZnVuY3Rpb24gaGFzaENsZWFyKCl7dGhpcy5fX2RhdGFfXz1uYXRpdmVDcmVhdGU/bmF0aXZlQ3JlYXRlKG51bGwpOnt9O3RoaXMuc2l6ZT0wO30vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGhhc2hEZWxldGUoa2V5KXt2YXIgcmVzdWx0PXRoaXMuaGFzKGtleSkmJmRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07dGhpcy5zaXplLT1yZXN1bHQ/MTowO3JldHVybiByZXN1bHQ7fS8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovZnVuY3Rpb24gaGFzaEdldChrZXkpe3ZhciBkYXRhPXRoaXMuX19kYXRhX187aWYobmF0aXZlQ3JlYXRlKXt2YXIgcmVzdWx0PWRhdGFba2V5XTtyZXR1cm4gcmVzdWx0PT09SEFTSF9VTkRFRklORUQ/dW5kZWZpbmVkOnJlc3VsdDt9cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSxrZXkpP2RhdGFba2V5XTp1bmRlZmluZWQ7fS8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGhhc2hIYXMoa2V5KXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fO3JldHVybiBuYXRpdmVDcmVhdGU/ZGF0YVtrZXldIT09dW5kZWZpbmVkOmhhc093blByb3BlcnR5LmNhbGwoZGF0YSxrZXkpO30vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovZnVuY3Rpb24gaGFzaFNldChrZXksdmFsdWUpe3ZhciBkYXRhPXRoaXMuX19kYXRhX187dGhpcy5zaXplKz10aGlzLmhhcyhrZXkpPzA6MTtkYXRhW2tleV09bmF0aXZlQ3JlYXRlJiZ2YWx1ZT09PXVuZGVmaW5lZD9IQVNIX1VOREVGSU5FRDp2YWx1ZTtyZXR1cm4gdGhpczt9Ly8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXI9aGFzaENsZWFyO0hhc2gucHJvdG90eXBlWydkZWxldGUnXT1oYXNoRGVsZXRlO0hhc2gucHJvdG90eXBlLmdldD1oYXNoR2V0O0hhc2gucHJvdG90eXBlLmhhcz1oYXNoSGFzO0hhc2gucHJvdG90eXBlLnNldD1oYXNoU2V0Oy8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL2Z1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWVudHJpZXM9PW51bGw/MDplbnRyaWVzLmxlbmd0aDt0aGlzLmNsZWFyKCk7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciBlbnRyeT1lbnRyaWVzW2luZGV4XTt0aGlzLnNldChlbnRyeVswXSxlbnRyeVsxXSk7fX0vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpe3RoaXMuX19kYXRhX189W107dGhpcy5zaXplPTA7fS8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fLGluZGV4PWFzc29jSW5kZXhPZihkYXRhLGtleSk7aWYoaW5kZXg8MCl7cmV0dXJuIGZhbHNlO312YXIgbGFzdEluZGV4PWRhdGEubGVuZ3RoLTE7aWYoaW5kZXg9PWxhc3RJbmRleCl7ZGF0YS5wb3AoKTt9ZWxzZXtzcGxpY2UuY2FsbChkYXRhLGluZGV4LDEpO30tLXRoaXMuc2l6ZTtyZXR1cm4gdHJ1ZTt9LyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL2Z1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpe3ZhciBkYXRhPXRoaXMuX19kYXRhX18saW5kZXg9YXNzb2NJbmRleE9mKGRhdGEsa2V5KTtyZXR1cm4gaW5kZXg8MD91bmRlZmluZWQ6ZGF0YVtpbmRleF1bMV07fS8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSl7cmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLGtleSk+LTE7fS8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL2Z1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksdmFsdWUpe3ZhciBkYXRhPXRoaXMuX19kYXRhX18saW5kZXg9YXNzb2NJbmRleE9mKGRhdGEsa2V5KTtpZihpbmRleDwwKXsrK3RoaXMuc2l6ZTtkYXRhLnB1c2goW2tleSx2YWx1ZV0pO31lbHNle2RhdGFbaW5kZXhdWzFdPXZhbHVlO31yZXR1cm4gdGhpczt9Ly8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyPWxpc3RDYWNoZUNsZWFyO0xpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddPWxpc3RDYWNoZURlbGV0ZTtMaXN0Q2FjaGUucHJvdG90eXBlLmdldD1saXN0Q2FjaGVHZXQ7TGlzdENhY2hlLnByb3RvdHlwZS5oYXM9bGlzdENhY2hlSGFzO0xpc3RDYWNoZS5wcm90b3R5cGUuc2V0PWxpc3RDYWNoZVNldDsvKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL2Z1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpe3ZhciBpbmRleD0tMSxsZW5ndGg9ZW50cmllcz09bnVsbD8wOmVudHJpZXMubGVuZ3RoO3RoaXMuY2xlYXIoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIGVudHJ5PWVudHJpZXNbaW5kZXhdO3RoaXMuc2V0KGVudHJ5WzBdLGVudHJ5WzFdKTt9fS8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCl7dGhpcy5zaXplPTA7dGhpcy5fX2RhdGFfXz17J2hhc2gnOm5ldyBIYXNoKCksJ21hcCc6bmV3KE1hcHx8TGlzdENhY2hlKSgpLCdzdHJpbmcnOm5ldyBIYXNoKCl9O30vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSl7dmFyIHJlc3VsdD1nZXRNYXBEYXRhKHRoaXMsa2V5KVsnZGVsZXRlJ10oa2V5KTt0aGlzLnNpemUtPXJlc3VsdD8xOjA7cmV0dXJuIHJlc3VsdDt9LyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpe3JldHVybiBnZXRNYXBEYXRhKHRoaXMsa2V5KS5nZXQoa2V5KTt9LyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KXtyZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLGtleSkuaGFzKGtleSk7fS8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL2Z1bmN0aW9uIG1hcENhY2hlU2V0KGtleSx2YWx1ZSl7dmFyIGRhdGE9Z2V0TWFwRGF0YSh0aGlzLGtleSksc2l6ZT1kYXRhLnNpemU7ZGF0YS5zZXQoa2V5LHZhbHVlKTt0aGlzLnNpemUrPWRhdGEuc2l6ZT09c2l6ZT8wOjE7cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXI9bWFwQ2FjaGVDbGVhcjtNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddPW1hcENhY2hlRGVsZXRlO01hcENhY2hlLnByb3RvdHlwZS5nZXQ9bWFwQ2FjaGVHZXQ7TWFwQ2FjaGUucHJvdG90eXBlLmhhcz1tYXBDYWNoZUhhcztNYXBDYWNoZS5wcm90b3R5cGUuc2V0PW1hcENhY2hlU2V0Oy8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9mdW5jdGlvbiBTdGFjayhlbnRyaWVzKXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fPW5ldyBMaXN0Q2FjaGUoZW50cmllcyk7dGhpcy5zaXplPWRhdGEuc2l6ZTt9LyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovZnVuY3Rpb24gc3RhY2tDbGVhcigpe3RoaXMuX19kYXRhX189bmV3IExpc3RDYWNoZSgpO3RoaXMuc2l6ZT0wO30vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fLHJlc3VsdD1kYXRhWydkZWxldGUnXShrZXkpO3RoaXMuc2l6ZT1kYXRhLnNpemU7cmV0dXJuIHJlc3VsdDt9LyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL2Z1bmN0aW9uIHN0YWNrR2V0KGtleSl7cmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7fS8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gc3RhY2tIYXMoa2V5KXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTt9LyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL2Z1bmN0aW9uIHN0YWNrU2V0KGtleSx2YWx1ZSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXztpZihkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKXt2YXIgcGFpcnM9ZGF0YS5fX2RhdGFfXztpZighTWFwfHxwYWlycy5sZW5ndGg8TEFSR0VfQVJSQVlfU0laRS0xKXtwYWlycy5wdXNoKFtrZXksdmFsdWVdKTt0aGlzLnNpemU9KytkYXRhLnNpemU7cmV0dXJuIHRoaXM7fWRhdGE9dGhpcy5fX2RhdGFfXz1uZXcgTWFwQ2FjaGUocGFpcnMpO31kYXRhLnNldChrZXksdmFsdWUpO3RoaXMuc2l6ZT1kYXRhLnNpemU7cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXI9c3RhY2tDbGVhcjtTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddPXN0YWNrRGVsZXRlO1N0YWNrLnByb3RvdHlwZS5nZXQ9c3RhY2tHZXQ7U3RhY2sucHJvdG90eXBlLmhhcz1zdGFja0hhcztTdGFjay5wcm90b3R5cGUuc2V0PXN0YWNrU2V0Oy8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLGluaGVyaXRlZCl7dmFyIGlzQXJyPWlzQXJyYXkodmFsdWUpLGlzQXJnPSFpc0FyciYmaXNBcmd1bWVudHModmFsdWUpLGlzQnVmZj0haXNBcnImJiFpc0FyZyYmaXNCdWZmZXIodmFsdWUpLGlzVHlwZT0haXNBcnImJiFpc0FyZyYmIWlzQnVmZiYmaXNUeXBlZEFycmF5KHZhbHVlKSxza2lwSW5kZXhlcz1pc0Fycnx8aXNBcmd8fGlzQnVmZnx8aXNUeXBlLHJlc3VsdD1za2lwSW5kZXhlcz9iYXNlVGltZXModmFsdWUubGVuZ3RoLFN0cmluZyk6W10sbGVuZ3RoPXJlc3VsdC5sZW5ndGg7Zm9yKHZhciBrZXkgaW4gdmFsdWUpe2lmKChpbmhlcml0ZWR8fGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsa2V5KSkmJiEoc2tpcEluZGV4ZXMmJigvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG5rZXk9PSdsZW5ndGgnfHwvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbmlzQnVmZiYmKGtleT09J29mZnNldCd8fGtleT09J3BhcmVudCcpfHwvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG5pc1R5cGUmJihrZXk9PSdidWZmZXInfHxrZXk9PSdieXRlTGVuZ3RoJ3x8a2V5PT0nYnl0ZU9mZnNldCcpfHwvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG5pc0luZGV4KGtleSxsZW5ndGgpKSkpe3Jlc3VsdC5wdXNoKGtleSk7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL2Z1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LGtleSx2YWx1ZSl7aWYodmFsdWUhPT11bmRlZmluZWQmJiFlcShvYmplY3Rba2V5XSx2YWx1ZSl8fHZhbHVlPT09dW5kZWZpbmVkJiYhKGtleSBpbiBvYmplY3QpKXtiYXNlQXNzaWduVmFsdWUob2JqZWN0LGtleSx2YWx1ZSk7fX0vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL2Z1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCxrZXksdmFsdWUpe3ZhciBvYmpWYWx1ZT1vYmplY3Rba2V5XTtpZighKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LGtleSkmJmVxKG9ialZhbHVlLHZhbHVlKSl8fHZhbHVlPT09dW5kZWZpbmVkJiYhKGtleSBpbiBvYmplY3QpKXtiYXNlQXNzaWduVmFsdWUob2JqZWN0LGtleSx2YWx1ZSk7fX0vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LGtleSl7dmFyIGxlbmd0aD1hcnJheS5sZW5ndGg7d2hpbGUobGVuZ3RoLS0pe2lmKGVxKGFycmF5W2xlbmd0aF1bMF0sa2V5KSl7cmV0dXJuIGxlbmd0aDt9fXJldHVybi0xO30vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL2Z1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3Qsa2V5LHZhbHVlKXtpZihrZXk9PSdfX3Byb3RvX18nJiZkZWZpbmVQcm9wZXJ0eSl7ZGVmaW5lUHJvcGVydHkob2JqZWN0LGtleSx7J2NvbmZpZ3VyYWJsZSc6dHJ1ZSwnZW51bWVyYWJsZSc6dHJ1ZSwndmFsdWUnOnZhbHVlLCd3cml0YWJsZSc6dHJ1ZX0pO31lbHNle29iamVjdFtrZXldPXZhbHVlO319LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi92YXIgYmFzZUZvcj1jcmVhdGVCYXNlRm9yKCk7LyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKXtpZih2YWx1ZT09bnVsbCl7cmV0dXJuIHZhbHVlPT09dW5kZWZpbmVkP3VuZGVmaW5lZFRhZzpudWxsVGFnO31yZXR1cm4gc3ltVG9TdHJpbmdUYWcmJnN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSk/Z2V0UmF3VGFnKHZhbHVlKTpvYmplY3RUb1N0cmluZyh2YWx1ZSk7fS8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL2Z1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmJhc2VHZXRUYWcodmFsdWUpPT1hcmdzVGFnO30vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpe2lmKCFpc09iamVjdCh2YWx1ZSl8fGlzTWFza2VkKHZhbHVlKSl7cmV0dXJuIGZhbHNlO312YXIgcGF0dGVybj1pc0Z1bmN0aW9uKHZhbHVlKT9yZUlzTmF0aXZlOnJlSXNIb3N0Q3RvcjtyZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7fS8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKXtyZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSYmaXNMZW5ndGgodmFsdWUubGVuZ3RoKSYmISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07fS8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCl7aWYoIWlzT2JqZWN0KG9iamVjdCkpe3JldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTt9dmFyIGlzUHJvdG89aXNQcm90b3R5cGUob2JqZWN0KSxyZXN1bHQ9W107Zm9yKHZhciBrZXkgaW4gb2JqZWN0KXtpZighKGtleT09J2NvbnN0cnVjdG9yJyYmKGlzUHJvdG98fCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCxrZXkpKSkpe3Jlc3VsdC5wdXNoKGtleSk7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCxzb3VyY2Usc3JjSW5kZXgsY3VzdG9taXplcixzdGFjayl7aWYob2JqZWN0PT09c291cmNlKXtyZXR1cm47fWJhc2VGb3Ioc291cmNlLGZ1bmN0aW9uKHNyY1ZhbHVlLGtleSl7c3RhY2t8fChzdGFjaz1uZXcgU3RhY2soKSk7aWYoaXNPYmplY3Qoc3JjVmFsdWUpKXtiYXNlTWVyZ2VEZWVwKG9iamVjdCxzb3VyY2Usa2V5LHNyY0luZGV4LGJhc2VNZXJnZSxjdXN0b21pemVyLHN0YWNrKTt9ZWxzZXt2YXIgbmV3VmFsdWU9Y3VzdG9taXplcj9jdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LGtleSksc3JjVmFsdWUsa2V5KycnLG9iamVjdCxzb3VyY2Usc3RhY2spOnVuZGVmaW5lZDtpZihuZXdWYWx1ZT09PXVuZGVmaW5lZCl7bmV3VmFsdWU9c3JjVmFsdWU7fWFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LGtleSxuZXdWYWx1ZSk7fX0sa2V5c0luKTt9LyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3Qsc291cmNlLGtleSxzcmNJbmRleCxtZXJnZUZ1bmMsY3VzdG9taXplcixzdGFjayl7dmFyIG9ialZhbHVlPXNhZmVHZXQob2JqZWN0LGtleSksc3JjVmFsdWU9c2FmZUdldChzb3VyY2Usa2V5KSxzdGFja2VkPXN0YWNrLmdldChzcmNWYWx1ZSk7aWYoc3RhY2tlZCl7YXNzaWduTWVyZ2VWYWx1ZShvYmplY3Qsa2V5LHN0YWNrZWQpO3JldHVybjt9dmFyIG5ld1ZhbHVlPWN1c3RvbWl6ZXI/Y3VzdG9taXplcihvYmpWYWx1ZSxzcmNWYWx1ZSxrZXkrJycsb2JqZWN0LHNvdXJjZSxzdGFjayk6dW5kZWZpbmVkO3ZhciBpc0NvbW1vbj1uZXdWYWx1ZT09PXVuZGVmaW5lZDtpZihpc0NvbW1vbil7dmFyIGlzQXJyPWlzQXJyYXkoc3JjVmFsdWUpLGlzQnVmZj0haXNBcnImJmlzQnVmZmVyKHNyY1ZhbHVlKSxpc1R5cGVkPSFpc0FyciYmIWlzQnVmZiYmaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtuZXdWYWx1ZT1zcmNWYWx1ZTtpZihpc0Fycnx8aXNCdWZmfHxpc1R5cGVkKXtpZihpc0FycmF5KG9ialZhbHVlKSl7bmV3VmFsdWU9b2JqVmFsdWU7fWVsc2UgaWYoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKXtuZXdWYWx1ZT1jb3B5QXJyYXkob2JqVmFsdWUpO31lbHNlIGlmKGlzQnVmZil7aXNDb21tb249ZmFsc2U7bmV3VmFsdWU9Y2xvbmVCdWZmZXIoc3JjVmFsdWUsdHJ1ZSk7fWVsc2UgaWYoaXNUeXBlZCl7aXNDb21tb249ZmFsc2U7bmV3VmFsdWU9Y2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLHRydWUpO31lbHNle25ld1ZhbHVlPVtdO319ZWxzZSBpZihpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKXx8aXNBcmd1bWVudHMoc3JjVmFsdWUpKXtuZXdWYWx1ZT1vYmpWYWx1ZTtpZihpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpe25ld1ZhbHVlPXRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO31lbHNlIGlmKCFpc09iamVjdChvYmpWYWx1ZSl8fGlzRnVuY3Rpb24ob2JqVmFsdWUpKXtuZXdWYWx1ZT1pbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO319ZWxzZXtpc0NvbW1vbj1mYWxzZTt9fWlmKGlzQ29tbW9uKXsvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbnN0YWNrLnNldChzcmNWYWx1ZSxuZXdWYWx1ZSk7bWVyZ2VGdW5jKG5ld1ZhbHVlLHNyY1ZhbHVlLHNyY0luZGV4LGN1c3RvbWl6ZXIsc3RhY2spO3N0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7fWFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LGtleSxuZXdWYWx1ZSk7fS8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9mdW5jdGlvbiBiYXNlUmVzdChmdW5jLHN0YXJ0KXtyZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYyxzdGFydCxpZGVudGl0eSksZnVuYysnJyk7fS8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL3ZhciBiYXNlU2V0VG9TdHJpbmc9IWRlZmluZVByb3BlcnR5P2lkZW50aXR5OmZ1bmN0aW9uKGZ1bmMsc3RyaW5nKXtyZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywndG9TdHJpbmcnLHsnY29uZmlndXJhYmxlJzp0cnVlLCdlbnVtZXJhYmxlJzpmYWxzZSwndmFsdWUnOmNvbnN0YW50KHN0cmluZyksJ3dyaXRhYmxlJzp0cnVlfSk7fTsvKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLGlzRGVlcCl7aWYoaXNEZWVwKXtyZXR1cm4gYnVmZmVyLnNsaWNlKCk7fXZhciBsZW5ndGg9YnVmZmVyLmxlbmd0aCxyZXN1bHQ9YWxsb2NVbnNhZmU/YWxsb2NVbnNhZmUobGVuZ3RoKTpuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7YnVmZmVyLmNvcHkocmVzdWx0KTtyZXR1cm4gcmVzdWx0O30vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcil7dmFyIHJlc3VsdD1uZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7bmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtyZXR1cm4gcmVzdWx0O30vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSxpc0RlZXApe3ZhciBidWZmZXI9aXNEZWVwP2Nsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpOnR5cGVkQXJyYXkuYnVmZmVyO3JldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsdHlwZWRBcnJheS5ieXRlT2Zmc2V0LHR5cGVkQXJyYXkubGVuZ3RoKTt9LyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSxhcnJheSl7dmFyIGluZGV4PS0xLGxlbmd0aD1zb3VyY2UubGVuZ3RoO2FycmF5fHwoYXJyYXk9QXJyYXkobGVuZ3RoKSk7d2hpbGUoKytpbmRleDxsZW5ndGgpe2FycmF5W2luZGV4XT1zb3VyY2VbaW5kZXhdO31yZXR1cm4gYXJyYXk7fS8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSxwcm9wcyxvYmplY3QsY3VzdG9taXplcil7dmFyIGlzTmV3PSFvYmplY3Q7b2JqZWN0fHwob2JqZWN0PXt9KTt2YXIgaW5kZXg9LTEsbGVuZ3RoPXByb3BzLmxlbmd0aDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIGtleT1wcm9wc1tpbmRleF07dmFyIG5ld1ZhbHVlPWN1c3RvbWl6ZXI/Y3VzdG9taXplcihvYmplY3Rba2V5XSxzb3VyY2Vba2V5XSxrZXksb2JqZWN0LHNvdXJjZSk6dW5kZWZpbmVkO2lmKG5ld1ZhbHVlPT09dW5kZWZpbmVkKXtuZXdWYWx1ZT1zb3VyY2Vba2V5XTt9aWYoaXNOZXcpe2Jhc2VBc3NpZ25WYWx1ZShvYmplY3Qsa2V5LG5ld1ZhbHVlKTt9ZWxzZXthc3NpZ25WYWx1ZShvYmplY3Qsa2V5LG5ld1ZhbHVlKTt9fXJldHVybiBvYmplY3Q7fS8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL2Z1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKXtyZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LHNvdXJjZXMpe3ZhciBpbmRleD0tMSxsZW5ndGg9c291cmNlcy5sZW5ndGgsY3VzdG9taXplcj1sZW5ndGg+MT9zb3VyY2VzW2xlbmd0aC0xXTp1bmRlZmluZWQsZ3VhcmQ9bGVuZ3RoPjI/c291cmNlc1syXTp1bmRlZmluZWQ7Y3VzdG9taXplcj1hc3NpZ25lci5sZW5ndGg+MyYmdHlwZW9mIGN1c3RvbWl6ZXI9PSdmdW5jdGlvbic/KGxlbmd0aC0tLGN1c3RvbWl6ZXIpOnVuZGVmaW5lZDtpZihndWFyZCYmaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSxzb3VyY2VzWzFdLGd1YXJkKSl7Y3VzdG9taXplcj1sZW5ndGg8Mz91bmRlZmluZWQ6Y3VzdG9taXplcjtsZW5ndGg9MTt9b2JqZWN0PU9iamVjdChvYmplY3QpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgc291cmNlPXNvdXJjZXNbaW5kZXhdO2lmKHNvdXJjZSl7YXNzaWduZXIob2JqZWN0LHNvdXJjZSxpbmRleCxjdXN0b21pemVyKTt9fXJldHVybiBvYmplY3Q7fSk7fS8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL2Z1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KXtyZXR1cm4gZnVuY3Rpb24ob2JqZWN0LGl0ZXJhdGVlLGtleXNGdW5jKXt2YXIgaW5kZXg9LTEsaXRlcmFibGU9T2JqZWN0KG9iamVjdCkscHJvcHM9a2V5c0Z1bmMob2JqZWN0KSxsZW5ndGg9cHJvcHMubGVuZ3RoO3doaWxlKGxlbmd0aC0tKXt2YXIga2V5PXByb3BzW2Zyb21SaWdodD9sZW5ndGg6KytpbmRleF07aWYoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSxrZXksaXRlcmFibGUpPT09ZmFsc2Upe2JyZWFrO319cmV0dXJuIG9iamVjdDt9O30vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsa2V5KXt2YXIgZGF0YT1tYXAuX19kYXRhX187cmV0dXJuIGlzS2V5YWJsZShrZXkpP2RhdGFbdHlwZW9mIGtleT09J3N0cmluZyc/J3N0cmluZyc6J2hhc2gnXTpkYXRhLm1hcDt9LyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL2Z1bmN0aW9uIGdldE5hdGl2ZShvYmplY3Qsa2V5KXt2YXIgdmFsdWU9Z2V0VmFsdWUob2JqZWN0LGtleSk7cmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk/dmFsdWU6dW5kZWZpbmVkO30vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpe3ZhciBpc093bj1oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLHN5bVRvU3RyaW5nVGFnKSx0YWc9dmFsdWVbc3ltVG9TdHJpbmdUYWddO3RyeXt2YWx1ZVtzeW1Ub1N0cmluZ1RhZ109dW5kZWZpbmVkO3ZhciB1bm1hc2tlZD10cnVlO31jYXRjaChlKXt9dmFyIHJlc3VsdD1uYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtpZih1bm1hc2tlZCl7aWYoaXNPd24pe3ZhbHVlW3N5bVRvU3RyaW5nVGFnXT10YWc7fWVsc2V7ZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTt9fXJldHVybiByZXN1bHQ7fS8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL2Z1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3Qpe3JldHVybiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yPT0nZnVuY3Rpb24nJiYhaXNQcm90b3R5cGUob2JqZWN0KT9iYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKTp7fTt9LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSxsZW5ndGgpe3ZhciB0eXBlPV90eXBlb2YodmFsdWUpO2xlbmd0aD1sZW5ndGg9PW51bGw/TUFYX1NBRkVfSU5URUdFUjpsZW5ndGg7cmV0dXJuISFsZW5ndGgmJih0eXBlPT0nbnVtYmVyJ3x8dHlwZSE9J3N5bWJvbCcmJnJlSXNVaW50LnRlc3QodmFsdWUpKSYmdmFsdWU+LTEmJnZhbHVlJTE9PTAmJnZhbHVlPGxlbmd0aDt9LyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLGluZGV4LG9iamVjdCl7aWYoIWlzT2JqZWN0KG9iamVjdCkpe3JldHVybiBmYWxzZTt9dmFyIHR5cGU9X3R5cGVvZihpbmRleCk7aWYodHlwZT09J251bWJlcic/aXNBcnJheUxpa2Uob2JqZWN0KSYmaXNJbmRleChpbmRleCxvYmplY3QubGVuZ3RoKTp0eXBlPT0nc3RyaW5nJyYmaW5kZXggaW4gb2JqZWN0KXtyZXR1cm4gZXEob2JqZWN0W2luZGV4XSx2YWx1ZSk7fXJldHVybiBmYWxzZTt9LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpe3ZhciB0eXBlPV90eXBlb2YodmFsdWUpO3JldHVybiB0eXBlPT0nc3RyaW5nJ3x8dHlwZT09J251bWJlcid8fHR5cGU9PSdzeW1ib2wnfHx0eXBlPT0nYm9vbGVhbic/dmFsdWUhPT0nX19wcm90b19fJzp2YWx1ZT09PW51bGw7fS8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGlzTWFza2VkKGZ1bmMpe3JldHVybiEhbWFza1NyY0tleSYmbWFza1NyY0tleSBpbiBmdW5jO30vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL2Z1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKXt2YXIgQ3Rvcj12YWx1ZSYmdmFsdWUuY29uc3RydWN0b3IscHJvdG89dHlwZW9mIEN0b3I9PSdmdW5jdGlvbicmJkN0b3IucHJvdG90eXBlfHxvYmplY3RQcm90bztyZXR1cm4gdmFsdWU9PT1wcm90bzt9LyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KXt2YXIgcmVzdWx0PVtdO2lmKG9iamVjdCE9bnVsbCl7Zm9yKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpe3Jlc3VsdC5wdXNoKGtleSk7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL2Z1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKXtyZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7fS8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL2Z1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsc3RhcnQsdHJhbnNmb3JtKXtzdGFydD1uYXRpdmVNYXgoc3RhcnQ9PT11bmRlZmluZWQ/ZnVuYy5sZW5ndGgtMTpzdGFydCwwKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYXJncz1hcmd1bWVudHMsaW5kZXg9LTEsbGVuZ3RoPW5hdGl2ZU1heChhcmdzLmxlbmd0aC1zdGFydCwwKSxhcnJheT1BcnJheShsZW5ndGgpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXthcnJheVtpbmRleF09YXJnc1tzdGFydCtpbmRleF07fWluZGV4PS0xO3ZhciBvdGhlckFyZ3M9QXJyYXkoc3RhcnQrMSk7d2hpbGUoKytpbmRleDxzdGFydCl7b3RoZXJBcmdzW2luZGV4XT1hcmdzW2luZGV4XTt9b3RoZXJBcmdzW3N0YXJ0XT10cmFuc2Zvcm0oYXJyYXkpO3JldHVybiBhcHBseShmdW5jLHRoaXMsb3RoZXJBcmdzKTt9O30vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovZnVuY3Rpb24gc2FmZUdldChvYmplY3Qsa2V5KXtpZihrZXk9PT0nY29uc3RydWN0b3InJiZ0eXBlb2Ygb2JqZWN0W2tleV09PT0nZnVuY3Rpb24nKXtyZXR1cm47fWlmKGtleT09J19fcHJvdG9fXycpe3JldHVybjt9cmV0dXJuIG9iamVjdFtrZXldO30vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovdmFyIHNldFRvU3RyaW5nPXNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7LyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL2Z1bmN0aW9uIHNob3J0T3V0KGZ1bmMpe3ZhciBjb3VudD0wLGxhc3RDYWxsZWQ9MDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgc3RhbXA9bmF0aXZlTm93KCkscmVtYWluaW5nPUhPVF9TUEFOLShzdGFtcC1sYXN0Q2FsbGVkKTtsYXN0Q2FsbGVkPXN0YW1wO2lmKHJlbWFpbmluZz4wKXtpZigrK2NvdW50Pj1IT1RfQ09VTlQpe3JldHVybiBhcmd1bWVudHNbMF07fX1lbHNle2NvdW50PTA7fXJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCxhcmd1bWVudHMpO307fS8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYyl7aWYoZnVuYyE9bnVsbCl7dHJ5e3JldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTt9Y2F0Y2goZSl7fXRyeXtyZXR1cm4gZnVuYysnJzt9Y2F0Y2goZSl7fX1yZXR1cm4nJzt9LyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovZnVuY3Rpb24gZXEodmFsdWUsb3RoZXIpe3JldHVybiB2YWx1ZT09PW90aGVyfHx2YWx1ZSE9PXZhbHVlJiZvdGhlciE9PW90aGVyO30vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovdmFyIGlzQXJndW1lbnRzPWJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHM7fSgpKT9iYXNlSXNBcmd1bWVudHM6ZnVuY3Rpb24odmFsdWUpe3JldHVybiBpc09iamVjdExpa2UodmFsdWUpJiZoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCdjYWxsZWUnKSYmIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsJ2NhbGxlZScpO307LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovdmFyIGlzQXJyYXk9QXJyYXkuaXNBcnJheTsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpe3JldHVybiB2YWx1ZSE9bnVsbCYmaXNMZW5ndGgodmFsdWUubGVuZ3RoKSYmIWlzRnVuY3Rpb24odmFsdWUpO30vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpe3JldHVybiBpc09iamVjdExpa2UodmFsdWUpJiZpc0FycmF5TGlrZSh2YWx1ZSk7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi92YXIgaXNCdWZmZXI9bmF0aXZlSXNCdWZmZXJ8fHN0dWJGYWxzZTsvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpe2lmKCFpc09iamVjdCh2YWx1ZSkpe3JldHVybiBmYWxzZTt9Ly8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4vLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbnZhciB0YWc9YmFzZUdldFRhZyh2YWx1ZSk7cmV0dXJuIHRhZz09ZnVuY1RhZ3x8dGFnPT1nZW5UYWd8fHRhZz09YXN5bmNUYWd8fHRhZz09cHJveHlUYWc7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWU9PSdudW1iZXInJiZ2YWx1ZT4tMSYmdmFsdWUlMT09MCYmdmFsdWU8PU1BWF9TQUZFX0lOVEVHRVI7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSl7dmFyIHR5cGU9X3R5cGVvZih2YWx1ZSk7cmV0dXJuIHZhbHVlIT1udWxsJiYodHlwZT09J29iamVjdCd8fHR5cGU9PSdmdW5jdGlvbicpO30vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL2Z1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSl7cmV0dXJuIHZhbHVlIT1udWxsJiZfdHlwZW9mKHZhbHVlKT09J29iamVjdCc7fS8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKXtpZighaXNPYmplY3RMaWtlKHZhbHVlKXx8YmFzZUdldFRhZyh2YWx1ZSkhPW9iamVjdFRhZyl7cmV0dXJuIGZhbHNlO312YXIgcHJvdG89Z2V0UHJvdG90eXBlKHZhbHVlKTtpZihwcm90bz09PW51bGwpe3JldHVybiB0cnVlO312YXIgQ3Rvcj1oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCdjb25zdHJ1Y3RvcicpJiZwcm90by5jb25zdHJ1Y3RvcjtyZXR1cm4gdHlwZW9mIEN0b3I9PSdmdW5jdGlvbicmJkN0b3IgaW5zdGFuY2VvZiBDdG9yJiZmdW5jVG9TdHJpbmcuY2FsbChDdG9yKT09b2JqZWN0Q3RvclN0cmluZzt9LyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL3ZhciBpc1R5cGVkQXJyYXk9bm9kZUlzVHlwZWRBcnJheT9iYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSk6YmFzZUlzVHlwZWRBcnJheTsvKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL2Z1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpe3JldHVybiBjb3B5T2JqZWN0KHZhbHVlLGtleXNJbih2YWx1ZSkpO30vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL2Z1bmN0aW9uIGtleXNJbihvYmplY3Qpe3JldHVybiBpc0FycmF5TGlrZShvYmplY3QpP2FycmF5TGlrZUtleXMob2JqZWN0LHRydWUpOmJhc2VLZXlzSW4ob2JqZWN0KTt9LyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gKlxuICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gKi92YXIgbWVyZ2VXaXRoPWNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCxzb3VyY2Usc3JjSW5kZXgsY3VzdG9taXplcil7YmFzZU1lcmdlKG9iamVjdCxzb3VyY2Usc3JjSW5kZXgsY3VzdG9taXplcik7fSk7LyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHZhbHVlO307fS8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpe3JldHVybiB2YWx1ZTt9LyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9mdW5jdGlvbiBzdHViRmFsc2UoKXtyZXR1cm4gZmFsc2U7fW1vZHVsZS5leHBvcnRzPW1lcmdlV2l0aDt9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSk7fSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihwcm9jZXNzKXsvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsYWxsb3dBYm92ZVJvb3Qpey8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG52YXIgdXA9MDtmb3IodmFyIGk9cGFydHMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBsYXN0PXBhcnRzW2ldO2lmKGxhc3Q9PT0nLicpe3BhcnRzLnNwbGljZShpLDEpO31lbHNlIGlmKGxhc3Q9PT0nLi4nKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cCsrO31lbHNlIGlmKHVwKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cC0tO319Ly8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuaWYoYWxsb3dBYm92ZVJvb3Qpe2Zvcig7dXAtLTt1cCl7cGFydHMudW5zaGlmdCgnLi4nKTt9fXJldHVybiBwYXJ0czt9Ly8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlPWZ1bmN0aW9uKCl7dmFyIHJlc29sdmVkUGF0aD0nJyxyZXNvbHZlZEFic29sdXRlPWZhbHNlO2Zvcih2YXIgaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFyZXNvbHZlZEFic29sdXRlO2ktLSl7dmFyIHBhdGg9aT49MD9hcmd1bWVudHNbaV06cHJvY2Vzcy5jd2QoKTsvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbmlmKHR5cGVvZiBwYXRoIT09J3N0cmluZycpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7fWVsc2UgaWYoIXBhdGgpe2NvbnRpbnVlO31yZXNvbHZlZFBhdGg9cGF0aCsnLycrcmVzb2x2ZWRQYXRoO3Jlc29sdmVkQWJzb2x1dGU9cGF0aC5jaGFyQXQoMCk9PT0nLyc7fS8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbi8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuLy8gTm9ybWFsaXplIHRoZSBwYXRoXG5yZXNvbHZlZFBhdGg9bm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLGZ1bmN0aW9uKHApe3JldHVybiEhcDt9KSwhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO3JldHVybihyZXNvbHZlZEFic29sdXRlPycvJzonJykrcmVzb2x2ZWRQYXRofHwnLic7fTsvLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemU9ZnVuY3Rpb24ocGF0aCl7dmFyIGlzQWJzb2x1dGU9ZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLHRyYWlsaW5nU2xhc2g9c3Vic3RyKHBhdGgsLTEpPT09Jy8nOy8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxucGF0aD1ub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLGZ1bmN0aW9uKHApe3JldHVybiEhcDt9KSwhaXNBYnNvbHV0ZSkuam9pbignLycpO2lmKCFwYXRoJiYhaXNBYnNvbHV0ZSl7cGF0aD0nLic7fWlmKHBhdGgmJnRyYWlsaW5nU2xhc2gpe3BhdGgrPScvJzt9cmV0dXJuKGlzQWJzb2x1dGU/Jy8nOicnKStwYXRoO307Ly8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlPWZ1bmN0aW9uKHBhdGgpe3JldHVybiBwYXRoLmNoYXJBdCgwKT09PScvJzt9Oy8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbj1mdW5jdGlvbigpe3ZhciBwYXRocz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocyxmdW5jdGlvbihwLGluZGV4KXtpZih0eXBlb2YgcCE9PSdzdHJpbmcnKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO31yZXR1cm4gcDt9KS5qb2luKCcvJykpO307Ly8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmU9ZnVuY3Rpb24oZnJvbSx0byl7ZnJvbT1leHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO3RvPWV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO2Z1bmN0aW9uIHRyaW0oYXJyKXt2YXIgc3RhcnQ9MDtmb3IoO3N0YXJ0PGFyci5sZW5ndGg7c3RhcnQrKyl7aWYoYXJyW3N0YXJ0XSE9PScnKWJyZWFrO312YXIgZW5kPWFyci5sZW5ndGgtMTtmb3IoO2VuZD49MDtlbmQtLSl7aWYoYXJyW2VuZF0hPT0nJylicmVhazt9aWYoc3RhcnQ+ZW5kKXJldHVybltdO3JldHVybiBhcnIuc2xpY2Uoc3RhcnQsZW5kLXN0YXJ0KzEpO312YXIgZnJvbVBhcnRzPXRyaW0oZnJvbS5zcGxpdCgnLycpKTt2YXIgdG9QYXJ0cz10cmltKHRvLnNwbGl0KCcvJykpO3ZhciBsZW5ndGg9TWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCx0b1BhcnRzLmxlbmd0aCk7dmFyIHNhbWVQYXJ0c0xlbmd0aD1sZW5ndGg7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXtpZihmcm9tUGFydHNbaV0hPT10b1BhcnRzW2ldKXtzYW1lUGFydHNMZW5ndGg9aTticmVhazt9fXZhciBvdXRwdXRQYXJ0cz1bXTtmb3IodmFyIGk9c2FtZVBhcnRzTGVuZ3RoO2k8ZnJvbVBhcnRzLmxlbmd0aDtpKyspe291dHB1dFBhcnRzLnB1c2goJy4uJyk7fW91dHB1dFBhcnRzPW91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO3JldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7fTtleHBvcnRzLnNlcD0nLyc7ZXhwb3J0cy5kZWxpbWl0ZXI9JzonO2V4cG9ydHMuZGlybmFtZT1mdW5jdGlvbihwYXRoKXtpZih0eXBlb2YgcGF0aCE9PSdzdHJpbmcnKXBhdGg9cGF0aCsnJztpZihwYXRoLmxlbmd0aD09PTApcmV0dXJuJy4nO3ZhciBjb2RlPXBhdGguY2hhckNvZGVBdCgwKTt2YXIgaGFzUm9vdD1jb2RlPT09NDcvKi8qLzt2YXIgZW5kPS0xO3ZhciBtYXRjaGVkU2xhc2g9dHJ1ZTtmb3IodmFyIGk9cGF0aC5sZW5ndGgtMTtpPj0xOy0taSl7Y29kZT1wYXRoLmNoYXJDb2RlQXQoaSk7aWYoY29kZT09PTQ3LyovKi8pe2lmKCFtYXRjaGVkU2xhc2gpe2VuZD1pO2JyZWFrO319ZWxzZXsvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxubWF0Y2hlZFNsYXNoPWZhbHNlO319aWYoZW5kPT09LTEpcmV0dXJuIGhhc1Jvb3Q/Jy8nOicuJztpZihoYXNSb290JiZlbmQ9PT0xKXsvLyByZXR1cm4gJy8vJztcbi8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxucmV0dXJuJy8nO31yZXR1cm4gcGF0aC5zbGljZSgwLGVuZCk7fTtmdW5jdGlvbiBiYXNlbmFtZShwYXRoKXtpZih0eXBlb2YgcGF0aCE9PSdzdHJpbmcnKXBhdGg9cGF0aCsnJzt2YXIgc3RhcnQ9MDt2YXIgZW5kPS0xO3ZhciBtYXRjaGVkU2xhc2g9dHJ1ZTt2YXIgaTtmb3IoaT1wYXRoLmxlbmd0aC0xO2k+PTA7LS1pKXtpZihwYXRoLmNoYXJDb2RlQXQoaSk9PT00Ny8qLyovKXsvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG5pZighbWF0Y2hlZFNsYXNoKXtzdGFydD1pKzE7YnJlYWs7fX1lbHNlIGlmKGVuZD09PS0xKXsvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4vLyBwYXRoIGNvbXBvbmVudFxubWF0Y2hlZFNsYXNoPWZhbHNlO2VuZD1pKzE7fX1pZihlbmQ9PT0tMSlyZXR1cm4nJztyZXR1cm4gcGF0aC5zbGljZShzdGFydCxlbmQpO30vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWU9ZnVuY3Rpb24ocGF0aCxleHQpe3ZhciBmPWJhc2VuYW1lKHBhdGgpO2lmKGV4dCYmZi5zdWJzdHIoLTEqZXh0Lmxlbmd0aCk9PT1leHQpe2Y9Zi5zdWJzdHIoMCxmLmxlbmd0aC1leHQubGVuZ3RoKTt9cmV0dXJuIGY7fTtleHBvcnRzLmV4dG5hbWU9ZnVuY3Rpb24ocGF0aCl7aWYodHlwZW9mIHBhdGghPT0nc3RyaW5nJylwYXRoPXBhdGgrJyc7dmFyIHN0YXJ0RG90PS0xO3ZhciBzdGFydFBhcnQ9MDt2YXIgZW5kPS0xO3ZhciBtYXRjaGVkU2xhc2g9dHJ1ZTsvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4vLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxudmFyIHByZURvdFN0YXRlPTA7Zm9yKHZhciBpPXBhdGgubGVuZ3RoLTE7aT49MDstLWkpe3ZhciBjb2RlPXBhdGguY2hhckNvZGVBdChpKTtpZihjb2RlPT09NDcvKi8qLyl7Ly8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbi8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuaWYoIW1hdGNoZWRTbGFzaCl7c3RhcnRQYXJ0PWkrMTticmVhazt9Y29udGludWU7fWlmKGVuZD09PS0xKXsvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4vLyBleHRlbnNpb25cbm1hdGNoZWRTbGFzaD1mYWxzZTtlbmQ9aSsxO31pZihjb2RlPT09NDYvKi4qLyl7Ly8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG5pZihzdGFydERvdD09PS0xKXN0YXJ0RG90PWk7ZWxzZSBpZihwcmVEb3RTdGF0ZSE9PTEpcHJlRG90U3RhdGU9MTt9ZWxzZSBpZihzdGFydERvdCE9PS0xKXsvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbnByZURvdFN0YXRlPS0xO319aWYoc3RhcnREb3Q9PT0tMXx8ZW5kPT09LTF8fC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG5wcmVEb3RTdGF0ZT09PTB8fC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbnByZURvdFN0YXRlPT09MSYmc3RhcnREb3Q9PT1lbmQtMSYmc3RhcnREb3Q9PT1zdGFydFBhcnQrMSl7cmV0dXJuJyc7fXJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LGVuZCk7fTtmdW5jdGlvbiBmaWx0ZXIoeHMsZil7aWYoeHMuZmlsdGVyKXJldHVybiB4cy5maWx0ZXIoZik7dmFyIHJlcz1bXTtmb3IodmFyIGk9MDtpPHhzLmxlbmd0aDtpKyspe2lmKGYoeHNbaV0saSx4cykpcmVzLnB1c2goeHNbaV0pO31yZXR1cm4gcmVzO30vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyPSdhYicuc3Vic3RyKC0xKT09PSdiJz9mdW5jdGlvbihzdHIsc3RhcnQsbGVuKXtyZXR1cm4gc3RyLnN1YnN0cihzdGFydCxsZW4pO306ZnVuY3Rpb24oc3RyLHN0YXJ0LGxlbil7aWYoc3RhcnQ8MClzdGFydD1zdHIubGVuZ3RoK3N0YXJ0O3JldHVybiBzdHIuc3Vic3RyKHN0YXJ0LGxlbik7fTt9KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSk7fSx7XCJfcHJvY2Vzc1wiOjYzfV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2NvbnRhaW5lcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnRhaW5lclwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9LyoqXG4gKiBSZXByZXNlbnRzIGFuIGF0LXJ1bGUuXG4gKlxuICogSWYgaXTigJlzIGZvbGxvd2VkIGluIHRoZSBDU1MgYnkgYSB7fSBibG9jaywgdGhpcyBub2RlIHdpbGwgaGF2ZVxuICogYSBub2RlcyBwcm9wZXJ0eSByZXByZXNlbnRpbmcgaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBleHRlbmRzIENvbnRhaW5lclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnQGNoYXJzZXQgXCJVVEYtOFwiOyBAbWVkaWEgcHJpbnQge30nKVxuICpcbiAqIGNvbnN0IGNoYXJzZXQgPSByb290LmZpcnN0XG4gKiBjaGFyc2V0LnR5cGUgIC8vPT4gJ2F0cnVsZSdcbiAqIGNoYXJzZXQubm9kZXMgLy89PiB1bmRlZmluZWRcbiAqXG4gKiBjb25zdCBtZWRpYSA9IHJvb3QubGFzdFxuICogbWVkaWEubm9kZXMgICAvLz0+IFtdXG4gKi92YXIgQXRSdWxlPS8qI19fUFVSRV9fKi9mdW5jdGlvbihfQ29udGFpbmVyKXtfaW5oZXJpdHNMb29zZShBdFJ1bGUsX0NvbnRhaW5lcik7ZnVuY3Rpb24gQXRSdWxlKGRlZmF1bHRzKXt2YXIgX3RoaXM7X3RoaXM9X0NvbnRhaW5lci5jYWxsKHRoaXMsZGVmYXVsdHMpfHx0aGlzO190aGlzLnR5cGU9J2F0cnVsZSc7cmV0dXJuIF90aGlzO312YXIgX3Byb3RvPUF0UnVsZS5wcm90b3R5cGU7X3Byb3RvLmFwcGVuZD1mdW5jdGlvbiBhcHBlbmQoKXt2YXIgX0NvbnRhaW5lciRwcm90b3R5cGUkO2lmKCF0aGlzLm5vZGVzKXRoaXMubm9kZXM9W107Zm9yKHZhciBfbGVuPWFyZ3VtZW50cy5sZW5ndGgsY2hpbGRyZW49bmV3IEFycmF5KF9sZW4pLF9rZXk9MDtfa2V5PF9sZW47X2tleSsrKXtjaGlsZHJlbltfa2V5XT1hcmd1bWVudHNbX2tleV07fXJldHVybihfQ29udGFpbmVyJHByb3RvdHlwZSQ9X0NvbnRhaW5lci5wcm90b3R5cGUuYXBwZW5kKS5jYWxsLmFwcGx5KF9Db250YWluZXIkcHJvdG90eXBlJCxbdGhpc10uY29uY2F0KGNoaWxkcmVuKSk7fTtfcHJvdG8ucHJlcGVuZD1mdW5jdGlvbiBwcmVwZW5kKCl7dmFyIF9Db250YWluZXIkcHJvdG90eXBlJDI7aWYoIXRoaXMubm9kZXMpdGhpcy5ub2Rlcz1bXTtmb3IodmFyIF9sZW4yPWFyZ3VtZW50cy5sZW5ndGgsY2hpbGRyZW49bmV3IEFycmF5KF9sZW4yKSxfa2V5Mj0wO19rZXkyPF9sZW4yO19rZXkyKyspe2NoaWxkcmVuW19rZXkyXT1hcmd1bWVudHNbX2tleTJdO31yZXR1cm4oX0NvbnRhaW5lciRwcm90b3R5cGUkMj1fQ29udGFpbmVyLnByb3RvdHlwZS5wcmVwZW5kKS5jYWxsLmFwcGx5KF9Db250YWluZXIkcHJvdG90eXBlJDIsW3RoaXNdLmNvbmNhdChjaGlsZHJlbikpO30vKipcbiAgICogQG1lbWJlcm9mIEF0UnVsZSNcbiAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lIFRoZSBhdC1ydWxl4oCZcyBuYW1lIGltbWVkaWF0ZWx5IGZvbGxvd3MgdGhlIGBAYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCAgPSBwb3N0Y3NzLnBhcnNlKCdAbWVkaWEgcHJpbnQge30nKVxuICAgKiBtZWRpYS5uYW1lIC8vPT4gJ21lZGlhJ1xuICAgKiBjb25zdCBtZWRpYSA9IHJvb3QuZmlyc3RcbiAgICovIC8qKlxuICAgKiBAbWVtYmVyb2YgQXRSdWxlI1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9IHBhcmFtcyBUaGUgYXQtcnVsZeKAmXMgcGFyYW1ldGVycywgdGhlIHZhbHVlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IGZvbGxvdyB0aGUgYXQtcnVsZeKAmXMgbmFtZSBidXQgcHJlY2VkZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhbnkge30gYmxvY2suXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgID0gcG9zdGNzcy5wYXJzZSgnQG1lZGlhIHByaW50LCBzY3JlZW4ge30nKVxuICAgKiBjb25zdCBtZWRpYSA9IHJvb3QuZmlyc3RcbiAgICogbWVkaWEucGFyYW1zIC8vPT4gJ3ByaW50LCBzY3JlZW4nXG4gICAqLyAvKipcbiAgICogQG1lbWJlcm9mIEF0UnVsZSNcbiAgICogQG1lbWJlciB7b2JqZWN0fSByYXdzIEluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGJ5dGUtdG8tYnl0ZSBlcXVhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgc3RyaW5nIGFzIGl0IHdhcyBpbiB0aGUgb3JpZ2luIGlucHV0LlxuICAgKlxuICAgKiBFdmVyeSBwYXJzZXIgc2F2ZXMgaXRzIG93biBwcm9wZXJ0aWVzLFxuICAgKiBidXQgdGhlIGRlZmF1bHQgQ1NTIHBhcnNlciB1c2VzOlxuICAgKlxuICAgKiAqIGBiZWZvcmVgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZWZvcmUgdGhlIG5vZGUuIEl0IGFsc28gc3RvcmVzIGAqYFxuICAgKiAgIGFuZCBgX2Agc3ltYm9scyBiZWZvcmUgdGhlIGRlY2xhcmF0aW9uIChJRSBoYWNrKS5cbiAgICogKiBgYWZ0ZXJgOiB0aGUgc3BhY2Ugc3ltYm9scyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgbm9kZVxuICAgKiAgIHRvIHRoZSBlbmQgb2YgdGhlIG5vZGUuXG4gICAqICogYGJldHdlZW5gOiB0aGUgc3ltYm9scyBiZXR3ZWVuIHRoZSBwcm9wZXJ0eSBhbmQgdmFsdWVcbiAgICogICBmb3IgZGVjbGFyYXRpb25zLCBzZWxlY3RvciBhbmQgYHtgIGZvciBydWxlcywgb3IgbGFzdCBwYXJhbWV0ZXJcbiAgICogICBhbmQgYHtgIGZvciBhdC1ydWxlcy5cbiAgICogKiBgc2VtaWNvbG9uYDogY29udGFpbnMgdHJ1ZSBpZiB0aGUgbGFzdCBjaGlsZCBoYXNcbiAgICogICBhbiAob3B0aW9uYWwpIHNlbWljb2xvbi5cbiAgICogKiBgYWZ0ZXJOYW1lYDogdGhlIHNwYWNlIGJldHdlZW4gdGhlIGF0LXJ1bGUgbmFtZSBhbmQgaXRzIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIFBvc3RDU1MgY2xlYW5zIGF0LXJ1bGUgcGFyYW1ldGVycyBmcm9tIGNvbW1lbnRzIGFuZCBleHRyYSBzcGFjZXMsXG4gICAqIGJ1dCBpdCBzdG9yZXMgb3JpZ2luIGNvbnRlbnQgaW4gcmF3cyBwcm9wZXJ0aWVzLlxuICAgKiBBcyBzdWNoLCBpZiB5b3UgZG9u4oCZdCBjaGFuZ2UgYSBkZWNsYXJhdGlvbuKAmXMgdmFsdWUsXG4gICAqIFBvc3RDU1Mgd2lsbCB1c2UgdGhlIHJhdyB2YWx1ZSB3aXRoIGNvbW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnICBAbWVkaWFcXG5wcmludCB7XFxufScpXG4gICAqIHJvb3QuZmlyc3QuZmlyc3QucmF3cyAvLz0+IHsgYmVmb3JlOiAnICAnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJldHdlZW46ICcgJyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBhZnRlck5hbWU6ICdcXG4nLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGFmdGVyOiAnXFxuJyB9XG4gICAqLztyZXR1cm4gQXRSdWxlO30oX2NvbnRhaW5lcltcImRlZmF1bHRcIl0pO3ZhciBfZGVmYXVsdD1BdFJ1bGU7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7XCIuL2NvbnRhaW5lclwiOjQxfV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX25vZGU9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ub2RlXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O31mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcyxzdXBlckNsYXNzKXtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7c3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yPXN1YkNsYXNzO3N1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzO30vKipcbiAqIFJlcHJlc2VudHMgYSBjb21tZW50IGJldHdlZW4gZGVjbGFyYXRpb25zIG9yIHN0YXRlbWVudHMgKHJ1bGUgYW5kIGF0LXJ1bGVzKS5cbiAqXG4gKiBDb21tZW50cyBpbnNpZGUgc2VsZWN0b3JzLCBhdC1ydWxlIHBhcmFtZXRlcnMsIG9yIGRlY2xhcmF0aW9uIHZhbHVlc1xuICogd2lsbCBiZSBzdG9yZWQgaW4gdGhlIGByYXdzYCBwcm9wZXJ0aWVzIGV4cGxhaW5lZCBhYm92ZS5cbiAqXG4gKiBAZXh0ZW5kcyBOb2RlXG4gKi92YXIgQ29tbWVudD0vKiNfX1BVUkVfXyovZnVuY3Rpb24oX05vZGUpe19pbmhlcml0c0xvb3NlKENvbW1lbnQsX05vZGUpO2Z1bmN0aW9uIENvbW1lbnQoZGVmYXVsdHMpe3ZhciBfdGhpcztfdGhpcz1fTm9kZS5jYWxsKHRoaXMsZGVmYXVsdHMpfHx0aGlzO190aGlzLnR5cGU9J2NvbW1lbnQnO3JldHVybiBfdGhpczt9LyoqXG4gICAqIEBtZW1iZXJvZiBDb21tZW50I1xuICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHQgVGhlIGNvbW1lbnTigJlzIHRleHQuXG4gICAqLyAvKipcbiAgICogQG1lbWJlcm9mIENvbW1lbnQjXG4gICAqIEBtZW1iZXIge29iamVjdH0gcmF3cyBJbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBieXRlLXRvLWJ5dGUgZXF1YWxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIG5vZGUgc3RyaW5nIGFzIGl0IHdhcyBpbiB0aGUgb3JpZ2luIGlucHV0LlxuICAgKlxuICAgKiBFdmVyeSBwYXJzZXIgc2F2ZXMgaXRzIG93biBwcm9wZXJ0aWVzLFxuICAgKiBidXQgdGhlIGRlZmF1bHQgQ1NTIHBhcnNlciB1c2VzOlxuICAgKlxuICAgKiAqIGBiZWZvcmVgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZWZvcmUgdGhlIG5vZGUuXG4gICAqICogYGxlZnRgOiB0aGUgc3BhY2Ugc3ltYm9scyBiZXR3ZWVuIGAvKmAgYW5kIHRoZSBjb21tZW504oCZcyB0ZXh0LlxuICAgKiAqIGByaWdodGA6IHRoZSBzcGFjZSBzeW1ib2xzIGJldHdlZW4gdGhlIGNvbW1lbnTigJlzIHRleHQuXG4gICAqL3JldHVybiBDb21tZW50O30oX25vZGVbXCJkZWZhdWx0XCJdKTt2YXIgX2RlZmF1bHQ9Q29tbWVudDtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vbm9kZVwiOjQ4fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2RlY2xhcmF0aW9uPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGVjbGFyYXRpb25cIikpO3ZhciBfY29tbWVudD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRcIikpO3ZhciBfbm9kZT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fWZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpO3JldHVybiBDb25zdHJ1Y3Rvcjt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9ZnVuY3Rpb24gY2xlYW5Tb3VyY2Uobm9kZXMpe3JldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24oaSl7aWYoaS5ub2RlcylpLm5vZGVzPWNsZWFuU291cmNlKGkubm9kZXMpO2RlbGV0ZSBpLnNvdXJjZTtyZXR1cm4gaTt9KTt9LyoqXG4gKiBUaGUge0BsaW5rIFJvb3R9LCB7QGxpbmsgQXRSdWxlfSwgYW5kIHtAbGluayBSdWxlfSBjb250YWluZXIgbm9kZXNcbiAqIGluaGVyaXQgc29tZSBjb21tb24gbWV0aG9kcyB0byBoZWxwIHdvcmsgd2l0aCB0aGVpciBjaGlsZHJlbi5cbiAqXG4gKiBOb3RlIHRoYXQgYWxsIGNvbnRhaW5lcnMgY2FuIHN0b3JlIGFueSBjb250ZW50LiBJZiB5b3Ugd3JpdGUgYSBydWxlIGluc2lkZVxuICogYSBydWxlLCBQb3N0Q1NTIHdpbGwgcGFyc2UgaXQuXG4gKlxuICogQGV4dGVuZHMgTm9kZVxuICogQGFic3RyYWN0XG4gKi92YXIgQ29udGFpbmVyPS8qI19fUFVSRV9fKi9mdW5jdGlvbihfTm9kZSl7X2luaGVyaXRzTG9vc2UoQ29udGFpbmVyLF9Ob2RlKTtmdW5jdGlvbiBDb250YWluZXIoKXtyZXR1cm4gX05vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO312YXIgX3Byb3RvPUNvbnRhaW5lci5wcm90b3R5cGU7X3Byb3RvLnB1c2g9ZnVuY3Rpb24gcHVzaChjaGlsZCl7Y2hpbGQucGFyZW50PXRoaXM7dGhpcy5ub2Rlcy5wdXNoKGNoaWxkKTtyZXR1cm4gdGhpczt9LyoqXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGNvbnRhaW5lcuKAmXMgaW1tZWRpYXRlIGNoaWxkcmVuLFxuICAgKiBjYWxsaW5nIGBjYWxsYmFja2AgZm9yIGVhY2ggY2hpbGQuXG4gICAqXG4gICAqIFJldHVybmluZyBgZmFsc2VgIGluIHRoZSBjYWxsYmFjayB3aWxsIGJyZWFrIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgb25seSBpdGVyYXRlcyB0aHJvdWdoIHRoZSBjb250YWluZXLigJlzIGltbWVkaWF0ZSBjaGlsZHJlbi5cbiAgICogSWYgeW91IG5lZWQgdG8gcmVjdXJzaXZlbHkgaXRlcmF0ZSB0aHJvdWdoIGFsbCB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50XG4gICAqIG5vZGVzLCB1c2Uge0BsaW5rIENvbnRhaW5lciN3YWxrfS5cbiAgICpcbiAgICogVW5saWtlIHRoZSBmb3IgYHt9YC1jeWNsZSBvciBgQXJyYXkjZm9yRWFjaGAgdGhpcyBpdGVyYXRvciBpcyBzYWZlXG4gICAqIGlmIHlvdSBhcmUgbXV0YXRpbmcgdGhlIGFycmF5IG9mIGNoaWxkIG5vZGVzIGR1cmluZyBpdGVyYXRpb24uXG4gICAqIFBvc3RDU1Mgd2lsbCBhZGp1c3QgdGhlIGN1cnJlbnQgaW5kZXggdG8gbWF0Y2ggdGhlIG11dGF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtjaGlsZEl0ZXJhdG9yfSBjYWxsYmFjayBJdGVyYXRvciByZWNlaXZlcyBlYWNoIG5vZGUgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWxzZXx1bmRlZmluZWR9IFJldHVybnMgYGZhbHNlYCBpZiBpdGVyYXRpb24gd2FzIGJyb2tlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7IGNvbG9yOiBibGFjazsgei1pbmRleDogMSB9JylcbiAgICogY29uc3QgcnVsZSA9IHJvb3QuZmlyc3RcbiAgICpcbiAgICogZm9yIChjb25zdCBkZWNsIG9mIHJ1bGUubm9kZXMpIHtcbiAgICogICBkZWNsLmNsb25lQmVmb3JlKHsgcHJvcDogJy13ZWJraXQtJyArIGRlY2wucHJvcCB9KVxuICAgKiAgIC8vIEN5Y2xlIHdpbGwgYmUgaW5maW5pdGUsIGJlY2F1c2UgY2xvbmVCZWZvcmUgbW92ZXMgdGhlIGN1cnJlbnQgbm9kZVxuICAgKiAgIC8vIHRvIHRoZSBuZXh0IGluZGV4XG4gICAqIH1cbiAgICpcbiAgICogcnVsZS5lYWNoKGRlY2wgPT4ge1xuICAgKiAgIGRlY2wuY2xvbmVCZWZvcmUoeyBwcm9wOiAnLXdlYmtpdC0nICsgZGVjbC5wcm9wIH0pXG4gICAqICAgLy8gV2lsbCBiZSBleGVjdXRlZCBvbmx5IGZvciBjb2xvciBhbmQgei1pbmRleFxuICAgKiB9KVxuICAgKi87X3Byb3RvLmVhY2g9ZnVuY3Rpb24gZWFjaChjYWxsYmFjayl7aWYoIXRoaXMubGFzdEVhY2gpdGhpcy5sYXN0RWFjaD0wO2lmKCF0aGlzLmluZGV4ZXMpdGhpcy5pbmRleGVzPXt9O3RoaXMubGFzdEVhY2grPTE7dmFyIGlkPXRoaXMubGFzdEVhY2g7dGhpcy5pbmRleGVzW2lkXT0wO2lmKCF0aGlzLm5vZGVzKXJldHVybiB1bmRlZmluZWQ7dmFyIGluZGV4LHJlc3VsdDt3aGlsZSh0aGlzLmluZGV4ZXNbaWRdPHRoaXMubm9kZXMubGVuZ3RoKXtpbmRleD10aGlzLmluZGV4ZXNbaWRdO3Jlc3VsdD1jYWxsYmFjayh0aGlzLm5vZGVzW2luZGV4XSxpbmRleCk7aWYocmVzdWx0PT09ZmFsc2UpYnJlYWs7dGhpcy5pbmRleGVzW2lkXSs9MTt9ZGVsZXRlIHRoaXMuaW5kZXhlc1tpZF07cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50IG5vZGVzLCBjYWxsaW5nIGNhbGxiYWNrXG4gICAqIGZvciBlYWNoIG5vZGUuXG4gICAqXG4gICAqIExpa2UgY29udGFpbmVyLmVhY2goKSwgdGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2VcbiAgICogaWYgeW91IGFyZSBtdXRhdGluZyBhcnJheXMgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogSWYgeW91IG9ubHkgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGNvbnRhaW5lcuKAmXMgaW1tZWRpYXRlIGNoaWxkcmVuLFxuICAgKiB1c2Uge0BsaW5rIENvbnRhaW5lciNlYWNofS5cbiAgICpcbiAgICogQHBhcmFtIHtjaGlsZEl0ZXJhdG9yfSBjYWxsYmFjayBJdGVyYXRvciByZWNlaXZlcyBlYWNoIG5vZGUgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWxzZXx1bmRlZmluZWR9IFJldHVybnMgYGZhbHNlYCBpZiBpdGVyYXRpb24gd2FzIGJyb2tlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByb290LndhbGsobm9kZSA9PiB7XG4gICAqICAgLy8gVHJhdmVyc2VzIGFsbCBkZXNjZW5kYW50IG5vZGVzLlxuICAgKiB9KVxuICAgKi87X3Byb3RvLndhbGs9ZnVuY3Rpb24gd2FsayhjYWxsYmFjayl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjaGlsZCxpKXt2YXIgcmVzdWx0O3RyeXtyZXN1bHQ9Y2FsbGJhY2soY2hpbGQsaSk7fWNhdGNoKGUpe2UucG9zdGNzc05vZGU9Y2hpbGQ7aWYoZS5zdGFjayYmY2hpbGQuc291cmNlJiYvXFxuXFxzezR9YXQgLy50ZXN0KGUuc3RhY2spKXt2YXIgcz1jaGlsZC5zb3VyY2U7ZS5zdGFjaz1lLnN0YWNrLnJlcGxhY2UoL1xcblxcc3s0fWF0IC8sXCIkJlwiK3MuaW5wdXQuZnJvbStcIjpcIitzLnN0YXJ0LmxpbmUrXCI6XCIrcy5zdGFydC5jb2x1bW4rXCIkJlwiKTt9dGhyb3cgZTt9aWYocmVzdWx0IT09ZmFsc2UmJmNoaWxkLndhbGspe3Jlc3VsdD1jaGlsZC53YWxrKGNhbGxiYWNrKTt9cmV0dXJuIHJlc3VsdDt9KTt9LyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50IG5vZGVzLCBjYWxsaW5nIGNhbGxiYWNrXG4gICAqIGZvciBlYWNoIGRlY2xhcmF0aW9uIG5vZGUuXG4gICAqXG4gICAqIElmIHlvdSBwYXNzIGEgZmlsdGVyLCBpdGVyYXRpb24gd2lsbCBvbmx5IGhhcHBlbiBvdmVyIGRlY2xhcmF0aW9uc1xuICAgKiB3aXRoIG1hdGNoaW5nIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIExpa2Uge0BsaW5rIENvbnRhaW5lciNlYWNofSwgdGhpcyBtZXRob2QgaXMgc2FmZVxuICAgKiB0byB1c2UgaWYgeW91IGFyZSBtdXRhdGluZyBhcnJheXMgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBbcHJvcF0gICBTdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gZmlsdGVyIGRlY2xhcmF0aW9ucyBieSBwcm9wZXJ0eSBuYW1lLlxuICAgKiBAcGFyYW0ge2NoaWxkSXRlcmF0b3J9IGNhbGxiYWNrIEl0ZXJhdG9yIHJlY2VpdmVzIGVhY2ggbm9kZSBhbmQgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm4ge2ZhbHNlfHVuZGVmaW5lZH0gUmV0dXJucyBgZmFsc2VgIGlmIGl0ZXJhdGlvbiB3YXMgYnJva2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3Qud2Fsa0RlY2xzKGRlY2wgPT4ge1xuICAgKiAgIGNoZWNrUHJvcGVydHlTdXBwb3J0KGRlY2wucHJvcClcbiAgICogfSlcbiAgICpcbiAgICogcm9vdC53YWxrRGVjbHMoJ2JvcmRlci1yYWRpdXMnLCBkZWNsID0+IHtcbiAgICogICBkZWNsLnJlbW92ZSgpXG4gICAqIH0pXG4gICAqXG4gICAqIHJvb3Qud2Fsa0RlY2xzKC9eYmFja2dyb3VuZC8sIGRlY2wgPT4ge1xuICAgKiAgIGRlY2wudmFsdWUgPSB0YWtlRmlyc3RDb2xvckZyb21HcmFkaWVudChkZWNsLnZhbHVlKVxuICAgKiB9KVxuICAgKi87X3Byb3RvLndhbGtEZWNscz1mdW5jdGlvbiB3YWxrRGVjbHMocHJvcCxjYWxsYmFjayl7aWYoIWNhbGxiYWNrKXtjYWxsYmFjaz1wcm9wO3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdkZWNsJyl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9aWYocHJvcCBpbnN0YW5jZW9mIFJlZ0V4cCl7cmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCxpKXtpZihjaGlsZC50eXBlPT09J2RlY2wnJiZwcm9wLnRlc3QoY2hpbGQucHJvcCkpe3JldHVybiBjYWxsYmFjayhjaGlsZCxpKTt9fSk7fXJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdkZWNsJyYmY2hpbGQucHJvcD09PXByb3Ape3JldHVybiBjYWxsYmFjayhjaGlsZCxpKTt9fSk7fS8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIGNvbnRhaW5lcuKAmXMgZGVzY2VuZGFudCBub2RlcywgY2FsbGluZyBjYWxsYmFja1xuICAgKiBmb3IgZWFjaCBydWxlIG5vZGUuXG4gICAqXG4gICAqIElmIHlvdSBwYXNzIGEgZmlsdGVyLCBpdGVyYXRpb24gd2lsbCBvbmx5IGhhcHBlbiBvdmVyIHJ1bGVzXG4gICAqIHdpdGggbWF0Y2hpbmcgc2VsZWN0b3JzLlxuICAgKlxuICAgKiBMaWtlIHtAbGluayBDb250YWluZXIjZWFjaH0sIHRoaXMgbWV0aG9kIGlzIHNhZmVcbiAgICogdG8gdXNlIGlmIHlvdSBhcmUgbXV0YXRpbmcgYXJyYXlzIGR1cmluZyBpdGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gW3NlbGVjdG9yXSBTdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBmaWx0ZXIgcnVsZXMgYnkgc2VsZWN0b3IuXG4gICAqIEBwYXJhbSB7Y2hpbGRJdGVyYXRvcn0gY2FsbGJhY2sgICBJdGVyYXRvciByZWNlaXZlcyBlYWNoIG5vZGUgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWxzZXx1bmRlZmluZWR9IHJldHVybnMgYGZhbHNlYCBpZiBpdGVyYXRpb24gd2FzIGJyb2tlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBzZWxlY3RvcnMgPSBbXVxuICAgKiByb290LndhbGtSdWxlcyhydWxlID0+IHtcbiAgICogICBzZWxlY3RvcnMucHVzaChydWxlLnNlbGVjdG9yKVxuICAgKiB9KVxuICAgKiBjb25zb2xlLmxvZyhgWW91ciBDU1MgdXNlcyAkeyBzZWxlY3RvcnMubGVuZ3RoIH0gc2VsZWN0b3JzYClcbiAgICovO19wcm90by53YWxrUnVsZXM9ZnVuY3Rpb24gd2Fsa1J1bGVzKHNlbGVjdG9yLGNhbGxiYWNrKXtpZighY2FsbGJhY2spe2NhbGxiYWNrPXNlbGVjdG9yO3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdydWxlJyl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9aWYoc2VsZWN0b3IgaW5zdGFuY2VvZiBSZWdFeHApe3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdydWxlJyYmc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3Rvcikpe3JldHVybiBjYWxsYmFjayhjaGlsZCxpKTt9fSk7fXJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdydWxlJyYmY2hpbGQuc2VsZWN0b3I9PT1zZWxlY3Rvcil7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9LyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgY29udGFpbmVy4oCZcyBkZXNjZW5kYW50IG5vZGVzLCBjYWxsaW5nIGNhbGxiYWNrXG4gICAqIGZvciBlYWNoIGF0LXJ1bGUgbm9kZS5cbiAgICpcbiAgICogSWYgeW91IHBhc3MgYSBmaWx0ZXIsIGl0ZXJhdGlvbiB3aWxsIG9ubHkgaGFwcGVuIG92ZXIgYXQtcnVsZXNcbiAgICogdGhhdCBoYXZlIG1hdGNoaW5nIG5hbWVzLlxuICAgKlxuICAgKiBMaWtlIHtAbGluayBDb250YWluZXIjZWFjaH0sIHRoaXMgbWV0aG9kIGlzIHNhZmVcbiAgICogdG8gdXNlIGlmIHlvdSBhcmUgbXV0YXRpbmcgYXJyYXlzIGR1cmluZyBpdGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gW25hbWVdICAgU3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGZpbHRlciBhdC1ydWxlcyBieSBuYW1lLlxuICAgKiBAcGFyYW0ge2NoaWxkSXRlcmF0b3J9IGNhbGxiYWNrIEl0ZXJhdG9yIHJlY2VpdmVzIGVhY2ggbm9kZSBhbmQgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm4ge2ZhbHNlfHVuZGVmaW5lZH0gUmV0dXJucyBgZmFsc2VgIGlmIGl0ZXJhdGlvbiB3YXMgYnJva2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3Qud2Fsa0F0UnVsZXMocnVsZSA9PiB7XG4gICAqICAgaWYgKGlzT2xkKHJ1bGUubmFtZSkpIHJ1bGUucmVtb3ZlKClcbiAgICogfSlcbiAgICpcbiAgICogbGV0IGZpcnN0ID0gZmFsc2VcbiAgICogcm9vdC53YWxrQXRSdWxlcygnY2hhcnNldCcsIHJ1bGUgPT4ge1xuICAgKiAgIGlmICghZmlyc3QpIHtcbiAgICogICAgIGZpcnN0ID0gdHJ1ZVxuICAgKiAgIH0gZWxzZSB7XG4gICAqICAgICBydWxlLnJlbW92ZSgpXG4gICAqICAgfVxuICAgKiB9KVxuICAgKi87X3Byb3RvLndhbGtBdFJ1bGVzPWZ1bmN0aW9uIHdhbGtBdFJ1bGVzKG5hbWUsY2FsbGJhY2spe2lmKCFjYWxsYmFjayl7Y2FsbGJhY2s9bmFtZTtyZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLGkpe2lmKGNoaWxkLnR5cGU9PT0nYXRydWxlJyl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9aWYobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCl7cmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCxpKXtpZihjaGlsZC50eXBlPT09J2F0cnVsZScmJm5hbWUudGVzdChjaGlsZC5uYW1lKSl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9cmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCxpKXtpZihjaGlsZC50eXBlPT09J2F0cnVsZScmJmNoaWxkLm5hbWU9PT1uYW1lKXtyZXR1cm4gY2FsbGJhY2soY2hpbGQsaSk7fX0pO30vKipcbiAgICogVHJhdmVyc2VzIHRoZSBjb250YWluZXLigJlzIGRlc2NlbmRhbnQgbm9kZXMsIGNhbGxpbmcgY2FsbGJhY2tcbiAgICogZm9yIGVhY2ggY29tbWVudCBub2RlLlxuICAgKlxuICAgKiBMaWtlIHtAbGluayBDb250YWluZXIjZWFjaH0sIHRoaXMgbWV0aG9kIGlzIHNhZmVcbiAgICogdG8gdXNlIGlmIHlvdSBhcmUgbXV0YXRpbmcgYXJyYXlzIGR1cmluZyBpdGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Y2hpbGRJdGVyYXRvcn0gY2FsbGJhY2sgSXRlcmF0b3IgcmVjZWl2ZXMgZWFjaCBub2RlIGFuZCBpbmRleC5cbiAgICpcbiAgICogQHJldHVybiB7ZmFsc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGBmYWxzZWAgaWYgaXRlcmF0aW9uIHdhcyBicm9rZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcm9vdC53YWxrQ29tbWVudHMoY29tbWVudCA9PiB7XG4gICAqICAgY29tbWVudC5yZW1vdmUoKVxuICAgKiB9KVxuICAgKi87X3Byb3RvLndhbGtDb21tZW50cz1mdW5jdGlvbiB3YWxrQ29tbWVudHMoY2FsbGJhY2spe3JldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsaSl7aWYoY2hpbGQudHlwZT09PSdjb21tZW50Jyl7cmV0dXJuIGNhbGxiYWNrKGNoaWxkLGkpO319KTt9LyoqXG4gICAqIEluc2VydHMgbmV3IG5vZGVzIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oTm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXSl9IGNoaWxkcmVuIE5ldyBub2Rlcy5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkZWNsMSA9IHBvc3Rjc3MuZGVjbCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pXG4gICAqIGNvbnN0IGRlY2wyID0gcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2JhY2tncm91bmQtY29sb3InLCB2YWx1ZTogJ3doaXRlJyB9KVxuICAgKiBydWxlLmFwcGVuZChkZWNsMSwgZGVjbDIpXG4gICAqXG4gICAqIHJvb3QuYXBwZW5kKHsgbmFtZTogJ2NoYXJzZXQnLCBwYXJhbXM6ICdcIlVURi04XCInIH0pICAvLyBhdC1ydWxlXG4gICAqIHJvb3QuYXBwZW5kKHsgc2VsZWN0b3I6ICdhJyB9KSAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVsZVxuICAgKiBydWxlLmFwcGVuZCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pICAgICAgIC8vIGRlY2xhcmF0aW9uXG4gICAqIHJ1bGUuYXBwZW5kKHsgdGV4dDogJ0NvbW1lbnQnIH0pICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWVudFxuICAgKlxuICAgKiByb290LmFwcGVuZCgnYSB7fScpXG4gICAqIHJvb3QuZmlyc3QuYXBwZW5kKCdjb2xvcjogYmxhY2s7IHotaW5kZXg6IDEnKVxuICAgKi87X3Byb3RvLmFwcGVuZD1mdW5jdGlvbiBhcHBlbmQoKXtmb3IodmFyIF9sZW49YXJndW1lbnRzLmxlbmd0aCxjaGlsZHJlbj1uZXcgQXJyYXkoX2xlbiksX2tleT0wO19rZXk8X2xlbjtfa2V5Kyspe2NoaWxkcmVuW19rZXldPWFyZ3VtZW50c1tfa2V5XTt9Zm9yKHZhciBfaT0wLF9jaGlsZHJlbj1jaGlsZHJlbjtfaTxfY2hpbGRyZW4ubGVuZ3RoO19pKyspe3ZhciBjaGlsZD1fY2hpbGRyZW5bX2ldO3ZhciBub2Rlcz10aGlzLm5vcm1hbGl6ZShjaGlsZCx0aGlzLmxhc3QpO2Zvcih2YXIgX2l0ZXJhdG9yPW5vZGVzLF9pc0FycmF5PUFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSxfaTI9MCxfaXRlcmF0b3I9X2lzQXJyYXk/X2l0ZXJhdG9yOl9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY7aWYoX2lzQXJyYXkpe2lmKF9pMj49X2l0ZXJhdG9yLmxlbmd0aClicmVhaztfcmVmPV9pdGVyYXRvcltfaTIrK107fWVsc2V7X2kyPV9pdGVyYXRvci5uZXh0KCk7aWYoX2kyLmRvbmUpYnJlYWs7X3JlZj1faTIudmFsdWU7fXZhciBub2RlPV9yZWY7dGhpcy5ub2Rlcy5wdXNoKG5vZGUpO319cmV0dXJuIHRoaXM7fS8qKlxuICAgKiBJbnNlcnRzIG5ldyBub2RlcyB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oTm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXSl9IGNoaWxkcmVuIE5ldyBub2Rlcy5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhpcyBub2RlIGZvciBtZXRob2RzIGNoYWluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkZWNsMSA9IHBvc3Rjc3MuZGVjbCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAnYmxhY2snIH0pXG4gICAqIGNvbnN0IGRlY2wyID0gcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2JhY2tncm91bmQtY29sb3InLCB2YWx1ZTogJ3doaXRlJyB9KVxuICAgKiBydWxlLnByZXBlbmQoZGVjbDEsIGRlY2wyKVxuICAgKlxuICAgKiByb290LmFwcGVuZCh7IG5hbWU6ICdjaGFyc2V0JywgcGFyYW1zOiAnXCJVVEYtOFwiJyB9KSAgLy8gYXQtcnVsZVxuICAgKiByb290LmFwcGVuZCh7IHNlbGVjdG9yOiAnYScgfSkgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1bGVcbiAgICogcnVsZS5hcHBlbmQoeyBwcm9wOiAnY29sb3InLCB2YWx1ZTogJ2JsYWNrJyB9KSAgICAgICAvLyBkZWNsYXJhdGlvblxuICAgKiBydWxlLmFwcGVuZCh7IHRleHQ6ICdDb21tZW50JyB9KSAgICAgICAgICAgICAgICAgICAgIC8vIGNvbW1lbnRcbiAgICpcbiAgICogcm9vdC5hcHBlbmQoJ2Ege30nKVxuICAgKiByb290LmZpcnN0LmFwcGVuZCgnY29sb3I6IGJsYWNrOyB6LWluZGV4OiAxJylcbiAgICovO19wcm90by5wcmVwZW5kPWZ1bmN0aW9uIHByZXBlbmQoKXtmb3IodmFyIF9sZW4yPWFyZ3VtZW50cy5sZW5ndGgsY2hpbGRyZW49bmV3IEFycmF5KF9sZW4yKSxfa2V5Mj0wO19rZXkyPF9sZW4yO19rZXkyKyspe2NoaWxkcmVuW19rZXkyXT1hcmd1bWVudHNbX2tleTJdO31jaGlsZHJlbj1jaGlsZHJlbi5yZXZlcnNlKCk7Zm9yKHZhciBfaXRlcmF0b3IyPWNoaWxkcmVuLF9pc0FycmF5Mj1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLF9pMz0wLF9pdGVyYXRvcjI9X2lzQXJyYXkyP19pdGVyYXRvcjI6X2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWYyO2lmKF9pc0FycmF5Mil7aWYoX2kzPj1faXRlcmF0b3IyLmxlbmd0aClicmVhaztfcmVmMj1faXRlcmF0b3IyW19pMysrXTt9ZWxzZXtfaTM9X2l0ZXJhdG9yMi5uZXh0KCk7aWYoX2kzLmRvbmUpYnJlYWs7X3JlZjI9X2kzLnZhbHVlO312YXIgY2hpbGQ9X3JlZjI7dmFyIG5vZGVzPXRoaXMubm9ybWFsaXplKGNoaWxkLHRoaXMuZmlyc3QsJ3ByZXBlbmQnKS5yZXZlcnNlKCk7Zm9yKHZhciBfaXRlcmF0b3IzPW5vZGVzLF9pc0FycmF5Mz1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLF9pND0wLF9pdGVyYXRvcjM9X2lzQXJyYXkzP19pdGVyYXRvcjM6X2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWYzO2lmKF9pc0FycmF5Myl7aWYoX2k0Pj1faXRlcmF0b3IzLmxlbmd0aClicmVhaztfcmVmMz1faXRlcmF0b3IzW19pNCsrXTt9ZWxzZXtfaTQ9X2l0ZXJhdG9yMy5uZXh0KCk7aWYoX2k0LmRvbmUpYnJlYWs7X3JlZjM9X2k0LnZhbHVlO312YXIgbm9kZT1fcmVmMzt0aGlzLm5vZGVzLnVuc2hpZnQobm9kZSk7fWZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXt0aGlzLmluZGV4ZXNbaWRdPXRoaXMuaW5kZXhlc1tpZF0rbm9kZXMubGVuZ3RoO319cmV0dXJuIHRoaXM7fTtfcHJvdG8uY2xlYW5SYXdzPWZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbil7X05vZGUucHJvdG90eXBlLmNsZWFuUmF3cy5jYWxsKHRoaXMsa2VlcEJldHdlZW4pO2lmKHRoaXMubm9kZXMpe2Zvcih2YXIgX2l0ZXJhdG9yND10aGlzLm5vZGVzLF9pc0FycmF5ND1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjQpLF9pNT0wLF9pdGVyYXRvcjQ9X2lzQXJyYXk0P19pdGVyYXRvcjQ6X2l0ZXJhdG9yNFtTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY0O2lmKF9pc0FycmF5NCl7aWYoX2k1Pj1faXRlcmF0b3I0Lmxlbmd0aClicmVhaztfcmVmND1faXRlcmF0b3I0W19pNSsrXTt9ZWxzZXtfaTU9X2l0ZXJhdG9yNC5uZXh0KCk7aWYoX2k1LmRvbmUpYnJlYWs7X3JlZjQ9X2k1LnZhbHVlO312YXIgbm9kZT1fcmVmNDtub2RlLmNsZWFuUmF3cyhrZWVwQmV0d2Vlbik7fX19LyoqXG4gICAqIEluc2VydCBuZXcgbm9kZSBiZWZvcmUgb2xkIG5vZGUgd2l0aGluIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZXxudW1iZXJ9IGV4aXN0ICAgICAgICAgICAgIENoaWxkIG9yIGNoaWxk4oCZcyBpbmRleC5cbiAgICogQHBhcmFtIHtOb2RlfG9iamVjdHxzdHJpbmd8Tm9kZVtdfSBhZGQgTmV3IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRoaXMgbm9kZSBmb3IgbWV0aG9kcyBjaGFpbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcnVsZS5pbnNlcnRCZWZvcmUoZGVjbCwgZGVjbC5jbG9uZSh7IHByb3A6ICctd2Via2l0LScgKyBkZWNsLnByb3AgfSkpXG4gICAqLztfcHJvdG8uaW5zZXJ0QmVmb3JlPWZ1bmN0aW9uIGluc2VydEJlZm9yZShleGlzdCxhZGQpe2V4aXN0PXRoaXMuaW5kZXgoZXhpc3QpO3ZhciB0eXBlPWV4aXN0PT09MD8ncHJlcGVuZCc6ZmFsc2U7dmFyIG5vZGVzPXRoaXMubm9ybWFsaXplKGFkZCx0aGlzLm5vZGVzW2V4aXN0XSx0eXBlKS5yZXZlcnNlKCk7Zm9yKHZhciBfaXRlcmF0b3I1PW5vZGVzLF9pc0FycmF5NT1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjUpLF9pNj0wLF9pdGVyYXRvcjU9X2lzQXJyYXk1P19pdGVyYXRvcjU6X2l0ZXJhdG9yNVtTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY1O2lmKF9pc0FycmF5NSl7aWYoX2k2Pj1faXRlcmF0b3I1Lmxlbmd0aClicmVhaztfcmVmNT1faXRlcmF0b3I1W19pNisrXTt9ZWxzZXtfaTY9X2l0ZXJhdG9yNS5uZXh0KCk7aWYoX2k2LmRvbmUpYnJlYWs7X3JlZjU9X2k2LnZhbHVlO312YXIgbm9kZT1fcmVmNTt0aGlzLm5vZGVzLnNwbGljZShleGlzdCwwLG5vZGUpO312YXIgaW5kZXg7Zm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe2luZGV4PXRoaXMuaW5kZXhlc1tpZF07aWYoZXhpc3Q8PWluZGV4KXt0aGlzLmluZGV4ZXNbaWRdPWluZGV4K25vZGVzLmxlbmd0aDt9fXJldHVybiB0aGlzO30vKipcbiAgICogSW5zZXJ0IG5ldyBub2RlIGFmdGVyIG9sZCBub2RlIHdpdGhpbiB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV8bnVtYmVyfSBleGlzdCAgICAgICAgICAgICBDaGlsZCBvciBjaGlsZOKAmXMgaW5kZXguXG4gICAqIEBwYXJhbSB7Tm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXX0gYWRkIE5ldyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqLztfcHJvdG8uaW5zZXJ0QWZ0ZXI9ZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoZXhpc3QsYWRkKXtleGlzdD10aGlzLmluZGV4KGV4aXN0KTt2YXIgbm9kZXM9dGhpcy5ub3JtYWxpemUoYWRkLHRoaXMubm9kZXNbZXhpc3RdKS5yZXZlcnNlKCk7Zm9yKHZhciBfaXRlcmF0b3I2PW5vZGVzLF9pc0FycmF5Nj1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjYpLF9pNz0wLF9pdGVyYXRvcjY9X2lzQXJyYXk2P19pdGVyYXRvcjY6X2l0ZXJhdG9yNltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY2O2lmKF9pc0FycmF5Nil7aWYoX2k3Pj1faXRlcmF0b3I2Lmxlbmd0aClicmVhaztfcmVmNj1faXRlcmF0b3I2W19pNysrXTt9ZWxzZXtfaTc9X2l0ZXJhdG9yNi5uZXh0KCk7aWYoX2k3LmRvbmUpYnJlYWs7X3JlZjY9X2k3LnZhbHVlO312YXIgbm9kZT1fcmVmNjt0aGlzLm5vZGVzLnNwbGljZShleGlzdCsxLDAsbm9kZSk7fXZhciBpbmRleDtmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7aW5kZXg9dGhpcy5pbmRleGVzW2lkXTtpZihleGlzdDxpbmRleCl7dGhpcy5pbmRleGVzW2lkXT1pbmRleCtub2Rlcy5sZW5ndGg7fX1yZXR1cm4gdGhpczt9LyoqXG4gICAqIFJlbW92ZXMgbm9kZSBmcm9tIHRoZSBjb250YWluZXIgYW5kIGNsZWFucyB0aGUgcGFyZW50IHByb3BlcnRpZXNcbiAgICogZnJvbSB0aGUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV8bnVtYmVyfSBjaGlsZCBDaGlsZCBvciBjaGlsZOKAmXMgaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRoaXMgbm9kZSBmb3IgbWV0aG9kcyBjaGFpblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBydWxlLm5vZGVzLmxlbmd0aCAgLy89PiA1XG4gICAqIHJ1bGUucmVtb3ZlQ2hpbGQoZGVjbClcbiAgICogcnVsZS5ub2Rlcy5sZW5ndGggIC8vPT4gNFxuICAgKiBkZWNsLnBhcmVudCAgICAgICAgLy89PiB1bmRlZmluZWRcbiAgICovO19wcm90by5yZW1vdmVDaGlsZD1mdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCl7Y2hpbGQ9dGhpcy5pbmRleChjaGlsZCk7dGhpcy5ub2Rlc1tjaGlsZF0ucGFyZW50PXVuZGVmaW5lZDt0aGlzLm5vZGVzLnNwbGljZShjaGlsZCwxKTt2YXIgaW5kZXg7Zm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe2luZGV4PXRoaXMuaW5kZXhlc1tpZF07aWYoaW5kZXg+PWNoaWxkKXt0aGlzLmluZGV4ZXNbaWRdPWluZGV4LTE7fX1yZXR1cm4gdGhpczt9LyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lclxuICAgKiBhbmQgY2xlYW5zIHRoZWlyIHBhcmVudCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJ1bGUucmVtb3ZlQWxsKClcbiAgICogcnVsZS5ub2Rlcy5sZW5ndGggLy89PiAwXG4gICAqLztfcHJvdG8ucmVtb3ZlQWxsPWZ1bmN0aW9uIHJlbW92ZUFsbCgpe2Zvcih2YXIgX2l0ZXJhdG9yNz10aGlzLm5vZGVzLF9pc0FycmF5Nz1BcnJheS5pc0FycmF5KF9pdGVyYXRvcjcpLF9pOD0wLF9pdGVyYXRvcjc9X2lzQXJyYXk3P19pdGVyYXRvcjc6X2l0ZXJhdG9yN1tTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY3O2lmKF9pc0FycmF5Nyl7aWYoX2k4Pj1faXRlcmF0b3I3Lmxlbmd0aClicmVhaztfcmVmNz1faXRlcmF0b3I3W19pOCsrXTt9ZWxzZXtfaTg9X2l0ZXJhdG9yNy5uZXh0KCk7aWYoX2k4LmRvbmUpYnJlYWs7X3JlZjc9X2k4LnZhbHVlO312YXIgbm9kZT1fcmVmNztub2RlLnBhcmVudD11bmRlZmluZWQ7fXRoaXMubm9kZXM9W107cmV0dXJuIHRoaXM7fS8qKlxuICAgKiBQYXNzZXMgYWxsIGRlY2xhcmF0aW9uIHZhbHVlcyB3aXRoaW4gdGhlIGNvbnRhaW5lciB0aGF0IG1hdGNoIHBhdHRlcm5cbiAgICogdGhyb3VnaCBjYWxsYmFjaywgcmVwbGFjaW5nIHRob3NlIHZhbHVlcyB3aXRoIHRoZSByZXR1cm5lZCByZXN1bHRcbiAgICogb2YgY2FsbGJhY2suXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3UgYXJlIHVzaW5nIGEgY3VzdG9tIHVuaXQgb3IgZnVuY3Rpb25cbiAgICogYW5kIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gcGF0dGVybiAgICAgIFJlcGxhY2UgcGF0dGVybi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgICAgICAgICAgICAgICAgT3B0aW9ucyB0byBzcGVlZCB1cCB0aGUgc2VhcmNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0cy5wcm9wcyBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmFzdCAgICAgICAgICAgU3RyaW5nIHRoYXTigJlzIHVzZWQgdG8gbmFycm93IGRvd25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGFuZCBzcGVlZCB1cCB0aGUgcmVnZXhwIHNlYXJjaC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbnxzdHJpbmd9IGNhbGxiYWNrICAgU3RyaW5nIHRvIHJlcGxhY2UgcGF0dGVybiBvciBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHJldHVybnMgYSBuZXcgdmFsdWUuIFRoZSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHJlY2VpdmUgdGhlIHNhbWUgYXJndW1lbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIHRob3NlIHBhc3NlZCB0byBhIGZ1bmN0aW9uIHBhcmFtZXRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBgU3RyaW5nI3JlcGxhY2VgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3QucmVwbGFjZVZhbHVlcygvXFxkK3JlbS8sIHsgZmFzdDogJ3JlbScgfSwgc3RyaW5nID0+IHtcbiAgICogICByZXR1cm4gMTUgKiBwYXJzZUludChzdHJpbmcpICsgJ3B4J1xuICAgKiB9KVxuICAgKi87X3Byb3RvLnJlcGxhY2VWYWx1ZXM9ZnVuY3Rpb24gcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLG9wdHMsY2FsbGJhY2spe2lmKCFjYWxsYmFjayl7Y2FsbGJhY2s9b3B0cztvcHRzPXt9O310aGlzLndhbGtEZWNscyhmdW5jdGlvbihkZWNsKXtpZihvcHRzLnByb3BzJiZvcHRzLnByb3BzLmluZGV4T2YoZGVjbC5wcm9wKT09PS0xKXJldHVybjtpZihvcHRzLmZhc3QmJmRlY2wudmFsdWUuaW5kZXhPZihvcHRzLmZhc3QpPT09LTEpcmV0dXJuO2RlY2wudmFsdWU9ZGVjbC52YWx1ZS5yZXBsYWNlKHBhdHRlcm4sY2FsbGJhY2spO30pO3JldHVybiB0aGlzO30vKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWBcbiAgICogZm9yIGFsbCBvZiB0aGUgY29udGFpbmVy4oCZcyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtjaGlsZENvbmRpdGlvbn0gY29uZGl0aW9uIEl0ZXJhdG9yIHJldHVybnMgdHJ1ZSBvciBmYWxzZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZXZlcnkgY2hpbGQgcGFzcyBjb25kaXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG5vUHJlZml4ZXMgPSBydWxlLmV2ZXJ5KGkgPT4gaS5wcm9wWzBdICE9PSAnLScpXG4gICAqLztfcHJvdG8uZXZlcnk9ZnVuY3Rpb24gZXZlcnkoY29uZGl0aW9uKXtyZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShjb25kaXRpb24pO30vKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIChhdCBsZWFzdCkgb25lXG4gICAqIG9mIHRoZSBjb250YWluZXLigJlzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2NoaWxkQ29uZGl0aW9ufSBjb25kaXRpb24gSXRlcmF0b3IgcmV0dXJucyB0cnVlIG9yIGZhbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBzb21lIGNoaWxkIHBhc3MgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBoYXNQcmVmaXggPSBydWxlLnNvbWUoaSA9PiBpLnByb3BbMF0gPT09ICctJylcbiAgICovO19wcm90by5zb21lPWZ1bmN0aW9uIHNvbWUoY29uZGl0aW9uKXtyZXR1cm4gdGhpcy5ub2Rlcy5zb21lKGNvbmRpdGlvbik7fS8qKlxuICAgKiBSZXR1cm5zIGEgYGNoaWxkYOKAmXMgaW5kZXggd2l0aGluIHRoZSB7QGxpbmsgQ29udGFpbmVyI25vZGVzfSBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBjaGlsZCBDaGlsZCBvZiB0aGUgY3VycmVudCBjb250YWluZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQ2hpbGQgaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJ1bGUuaW5kZXgoIHJ1bGUubm9kZXNbMl0gKSAvLz0+IDJcbiAgICovO19wcm90by5pbmRleD1mdW5jdGlvbiBpbmRleChjaGlsZCl7aWYodHlwZW9mIGNoaWxkPT09J251bWJlcicpe3JldHVybiBjaGlsZDt9cmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZihjaGlsZCk7fS8qKlxuICAgKiBUaGUgY29udGFpbmVy4oCZcyBmaXJzdCBjaGlsZC5cbiAgICpcbiAgICogQHR5cGUge05vZGV9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJ1bGUuZmlyc3QgPT09IHJ1bGVzLm5vZGVzWzBdXG4gICAqLztfcHJvdG8ubm9ybWFsaXplPWZ1bmN0aW9uIG5vcm1hbGl6ZShub2RlcyxzYW1wbGUpe3ZhciBfdGhpcz10aGlzO2lmKHR5cGVvZiBub2Rlcz09PSdzdHJpbmcnKXt2YXIgcGFyc2U9cmVxdWlyZSgnLi9wYXJzZScpO25vZGVzPWNsZWFuU291cmNlKHBhcnNlKG5vZGVzKS5ub2Rlcyk7fWVsc2UgaWYoQXJyYXkuaXNBcnJheShub2Rlcykpe25vZGVzPW5vZGVzLnNsaWNlKDApO2Zvcih2YXIgX2l0ZXJhdG9yOD1ub2RlcyxfaXNBcnJheTg9QXJyYXkuaXNBcnJheShfaXRlcmF0b3I4KSxfaTk9MCxfaXRlcmF0b3I4PV9pc0FycmF5OD9faXRlcmF0b3I4Ol9pdGVyYXRvcjhbU3ltYm9sLml0ZXJhdG9yXSgpOzspe3ZhciBfcmVmODtpZihfaXNBcnJheTgpe2lmKF9pOT49X2l0ZXJhdG9yOC5sZW5ndGgpYnJlYWs7X3JlZjg9X2l0ZXJhdG9yOFtfaTkrK107fWVsc2V7X2k5PV9pdGVyYXRvcjgubmV4dCgpO2lmKF9pOS5kb25lKWJyZWFrO19yZWY4PV9pOS52YWx1ZTt9dmFyIGk9X3JlZjg7aWYoaS5wYXJlbnQpaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSwnaWdub3JlJyk7fX1lbHNlIGlmKG5vZGVzLnR5cGU9PT0ncm9vdCcpe25vZGVzPW5vZGVzLm5vZGVzLnNsaWNlKDApO2Zvcih2YXIgX2l0ZXJhdG9yOT1ub2RlcyxfaXNBcnJheTk9QXJyYXkuaXNBcnJheShfaXRlcmF0b3I5KSxfaTEwPTAsX2l0ZXJhdG9yOT1faXNBcnJheTk/X2l0ZXJhdG9yOTpfaXRlcmF0b3I5W1N5bWJvbC5pdGVyYXRvcl0oKTs7KXt2YXIgX3JlZjk7aWYoX2lzQXJyYXk5KXtpZihfaTEwPj1faXRlcmF0b3I5Lmxlbmd0aClicmVhaztfcmVmOT1faXRlcmF0b3I5W19pMTArK107fWVsc2V7X2kxMD1faXRlcmF0b3I5Lm5leHQoKTtpZihfaTEwLmRvbmUpYnJlYWs7X3JlZjk9X2kxMC52YWx1ZTt9dmFyIF9pMTE9X3JlZjk7aWYoX2kxMS5wYXJlbnQpX2kxMS5wYXJlbnQucmVtb3ZlQ2hpbGQoX2kxMSwnaWdub3JlJyk7fX1lbHNlIGlmKG5vZGVzLnR5cGUpe25vZGVzPVtub2Rlc107fWVsc2UgaWYobm9kZXMucHJvcCl7aWYodHlwZW9mIG5vZGVzLnZhbHVlPT09J3VuZGVmaW5lZCcpe3Rocm93IG5ldyBFcnJvcignVmFsdWUgZmllbGQgaXMgbWlzc2VkIGluIG5vZGUgY3JlYXRpb24nKTt9ZWxzZSBpZih0eXBlb2Ygbm9kZXMudmFsdWUhPT0nc3RyaW5nJyl7bm9kZXMudmFsdWU9U3RyaW5nKG5vZGVzLnZhbHVlKTt9bm9kZXM9W25ldyBfZGVjbGFyYXRpb25bXCJkZWZhdWx0XCJdKG5vZGVzKV07fWVsc2UgaWYobm9kZXMuc2VsZWN0b3Ipe3ZhciBSdWxlPXJlcXVpcmUoJy4vcnVsZScpO25vZGVzPVtuZXcgUnVsZShub2RlcyldO31lbHNlIGlmKG5vZGVzLm5hbWUpe3ZhciBBdFJ1bGU9cmVxdWlyZSgnLi9hdC1ydWxlJyk7bm9kZXM9W25ldyBBdFJ1bGUobm9kZXMpXTt9ZWxzZSBpZihub2Rlcy50ZXh0KXtub2Rlcz1bbmV3IF9jb21tZW50W1wiZGVmYXVsdFwiXShub2RlcyldO31lbHNle3Rocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgaW4gbm9kZSBjcmVhdGlvbicpO312YXIgcHJvY2Vzc2VkPW5vZGVzLm1hcChmdW5jdGlvbihpKXtpZihpLnBhcmVudClpLnBhcmVudC5yZW1vdmVDaGlsZChpKTtpZih0eXBlb2YgaS5yYXdzLmJlZm9yZT09PSd1bmRlZmluZWQnKXtpZihzYW1wbGUmJnR5cGVvZiBzYW1wbGUucmF3cy5iZWZvcmUhPT0ndW5kZWZpbmVkJyl7aS5yYXdzLmJlZm9yZT1zYW1wbGUucmF3cy5iZWZvcmUucmVwbGFjZSgvW15cXHNdL2csJycpO319aS5wYXJlbnQ9X3RoaXM7cmV0dXJuIGk7fSk7cmV0dXJuIHByb2Nlc3NlZDt9LyoqXG4gICAqIEBtZW1iZXJvZiBDb250YWluZXIjXG4gICAqIEBtZW1iZXIge05vZGVbXX0gbm9kZXMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgY29udGFpbmVy4oCZcyBjaGlsZHJlbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EgeyBjb2xvcjogYmxhY2sgfScpXG4gICAqIHJvb3Qubm9kZXMubGVuZ3RoICAgICAgICAgICAvLz0+IDFcbiAgICogcm9vdC5ub2Rlc1swXS5zZWxlY3RvciAgICAgIC8vPT4gJ2EnXG4gICAqIHJvb3Qubm9kZXNbMF0ubm9kZXNbMF0ucHJvcCAvLz0+ICdjb2xvcidcbiAgICovO19jcmVhdGVDbGFzcyhDb250YWluZXIsW3trZXk6XCJmaXJzdFwiLGdldDpmdW5jdGlvbiBnZXQoKXtpZighdGhpcy5ub2RlcylyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLm5vZGVzWzBdO30vKipcbiAgICAgKiBUaGUgY29udGFpbmVy4oCZcyBsYXN0IGNoaWxkLlxuICAgICAqXG4gICAgICogQHR5cGUge05vZGV9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHJ1bGUubGFzdCA9PT0gcnVsZS5ub2Rlc1tydWxlLm5vZGVzLmxlbmd0aCAtIDFdXG4gICAgICovfSx7a2V5OlwibGFzdFwiLGdldDpmdW5jdGlvbiBnZXQoKXtpZighdGhpcy5ub2RlcylyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoLTFdO319XSk7cmV0dXJuIENvbnRhaW5lcjt9KF9ub2RlW1wiZGVmYXVsdFwiXSk7dmFyIF9kZWZhdWx0PUNvbnRhaW5lcjsvKipcbiAqIEBjYWxsYmFjayBjaGlsZENvbmRpdGlvblxuICogQHBhcmFtIHtOb2RlfSBub2RlICAgIENvbnRhaW5lciBjaGlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBDaGlsZCBpbmRleC5cbiAqIEBwYXJhbSB7Tm9kZVtdfSBub2RlcyBBbGwgY29udGFpbmVyIGNoaWxkcmVuLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqLyAvKipcbiAqIEBjYWxsYmFjayBjaGlsZEl0ZXJhdG9yXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgICAgQ29udGFpbmVyIGNoaWxkLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IENoaWxkIGluZGV4LlxuICogQHJldHVybiB7ZmFsc2V8dW5kZWZpbmVkfSBSZXR1cm5pbmcgYGZhbHNlYCB3aWxsIGJyZWFrIGl0ZXJhdGlvbi5cbiAqL2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se1wiLi9hdC1ydWxlXCI6MzksXCIuL2NvbW1lbnRcIjo0MCxcIi4vZGVjbGFyYXRpb25cIjo0MyxcIi4vbm9kZVwiOjQ4LFwiLi9wYXJzZVwiOjQ5LFwiLi9ydWxlXCI6NTZ9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfc3VwcG9ydHNDb2xvcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJzdXBwb3J0cy1jb2xvclwiKSk7dmFyIF9jaGFsaz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjaGFsa1wiKSk7dmFyIF90ZXJtaW5hbEhpZ2hsaWdodD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Rlcm1pbmFsLWhpZ2hsaWdodFwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKXtpZihzZWxmPT09dm9pZCAwKXt0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7fXJldHVybiBzZWxmO31mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcyxzdXBlckNsYXNzKXtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7c3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yPXN1YkNsYXNzO3N1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzO31mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKXt2YXIgX2NhY2hlPXR5cGVvZiBNYXA9PT1cImZ1bmN0aW9uXCI/bmV3IE1hcCgpOnVuZGVmaW5lZDtfd3JhcE5hdGl2ZVN1cGVyPWZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3Mpe2lmKENsYXNzPT09bnVsbHx8IV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSlyZXR1cm4gQ2xhc3M7aWYodHlwZW9mIENsYXNzIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7fWlmKHR5cGVvZiBfY2FjaGUhPT1cInVuZGVmaW5lZFwiKXtpZihfY2FjaGUuaGFzKENsYXNzKSlyZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7X2NhY2hlLnNldChDbGFzcyxXcmFwcGVyKTt9ZnVuY3Rpb24gV3JhcHBlcigpe3JldHVybiBfY29uc3RydWN0KENsYXNzLGFyZ3VtZW50cyxfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO31XcmFwcGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOldyYXBwZXIsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfX0pO3JldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlcixDbGFzcyk7fTtyZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7fWZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpe2lmKHR5cGVvZiBSZWZsZWN0PT09XCJ1bmRlZmluZWRcInx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiBmYWxzZTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiBmYWxzZTtpZih0eXBlb2YgUHJveHk9PT1cImZ1bmN0aW9uXCIpcmV0dXJuIHRydWU7dHJ5e0RhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSxbXSxmdW5jdGlvbigpe30pKTtyZXR1cm4gdHJ1ZTt9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlO319ZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsYXJncyxDbGFzcyl7aWYoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpe19jb25zdHJ1Y3Q9UmVmbGVjdC5jb25zdHJ1Y3Q7fWVsc2V7X2NvbnN0cnVjdD1mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCxhcmdzLENsYXNzKXt2YXIgYT1bbnVsbF07YS5wdXNoLmFwcGx5KGEsYXJncyk7dmFyIENvbnN0cnVjdG9yPUZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LGEpO3ZhciBpbnN0YW5jZT1uZXcgQ29uc3RydWN0b3IoKTtpZihDbGFzcylfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsQ2xhc3MucHJvdG90eXBlKTtyZXR1cm4gaW5zdGFuY2U7fTt9cmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCxhcmd1bWVudHMpO31mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbil7cmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpIT09LTE7fWZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLHApe19zZXRQcm90b3R5cGVPZj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLHApe28uX19wcm90b19fPXA7cmV0dXJuIG87fTtyZXR1cm4gX3NldFByb3RvdHlwZU9mKG8scCk7fWZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKXtfZ2V0UHJvdG90eXBlT2Y9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobyl7cmV0dXJuIG8uX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7fTtyZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO30vKipcbiAqIFRoZSBDU1MgcGFyc2VyIHRocm93cyB0aGlzIGVycm9yIGZvciBicm9rZW4gQ1NTLlxuICpcbiAqIEN1c3RvbSBwYXJzZXJzIGNhbiB0aHJvdyB0aGlzIGVycm9yIGZvciBicm9rZW4gY3VzdG9tIHN5bnRheCB1c2luZ1xuICogdGhlIHtAbGluayBOb2RlI2Vycm9yfSBtZXRob2QuXG4gKlxuICogUG9zdENTUyB3aWxsIHVzZSB0aGUgaW5wdXQgc291cmNlIG1hcCB0byBkZXRlY3QgdGhlIG9yaWdpbmFsIGVycm9yIGxvY2F0aW9uLlxuICogSWYgeW91IHdyb3RlIGEgU2FzcyBmaWxlLCBjb21waWxlZCBpdCB0byBDU1MgYW5kIHRoZW4gcGFyc2VkIGl0IHdpdGggUG9zdENTUyxcbiAqIFBvc3RDU1Mgd2lsbCBzaG93IHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpbiB0aGUgU2FzcyBmaWxlLlxuICpcbiAqIElmIHlvdSBuZWVkIHRoZSBwb3NpdGlvbiBpbiB0aGUgUG9zdENTUyBpbnB1dFxuICogKGUuZy4sIHRvIGRlYnVnIHRoZSBwcmV2aW91cyBjb21waWxlciksIHVzZSBgZXJyb3IuaW5wdXQuZmlsZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENhdGNoaW5nIGFuZCBjaGVja2luZyBzeW50YXggZXJyb3JcbiAqIHRyeSB7XG4gKiAgIHBvc3Rjc3MucGFyc2UoJ2F7JylcbiAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gKiAgIGlmIChlcnJvci5uYW1lID09PSAnQ3NzU3ludGF4RXJyb3InKSB7XG4gKiAgICAgZXJyb3IgLy89PiBDc3NTeW50YXhFcnJvclxuICogICB9XG4gKiB9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJhaXNpbmcgZXJyb3IgZnJvbSBwbHVnaW5cbiAqIHRocm93IG5vZGUuZXJyb3IoJ1Vua25vd24gdmFyaWFibGUnLCB7IHBsdWdpbjogJ3Bvc3Rjc3MtdmFycycgfSlcbiAqL3ZhciBDc3NTeW50YXhFcnJvcj0vKiNfX1BVUkVfXyovZnVuY3Rpb24oX0Vycm9yKXtfaW5oZXJpdHNMb29zZShDc3NTeW50YXhFcnJvcixfRXJyb3IpOy8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAgRXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW5lXSAgIFNvdXJjZSBsaW5lIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2x1bW5dIFNvdXJjZSBjb2x1bW4gb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZV0gU291cmNlIGNvZGUgb2YgdGhlIGJyb2tlbiBmaWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGVdICAgQWJzb2x1dGUgcGF0aCB0byB0aGUgYnJva2VuIGZpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGx1Z2luXSBQb3N0Q1NTIHBsdWdpbiBuYW1lLCBpZiBlcnJvciBjYW1lIGZyb20gcGx1Z2luLlxuICAgKi9mdW5jdGlvbiBDc3NTeW50YXhFcnJvcihtZXNzYWdlLGxpbmUsY29sdW1uLHNvdXJjZSxmaWxlLHBsdWdpbil7dmFyIF90aGlzO190aGlzPV9FcnJvci5jYWxsKHRoaXMsbWVzc2FnZSl8fHRoaXM7LyoqXG4gICAgICogQWx3YXlzIGVxdWFsIHRvIGAnQ3NzU3ludGF4RXJyb3InYC4gWW91IHNob3VsZCBhbHdheXMgY2hlY2sgZXJyb3IgdHlwZVxuICAgICAqIGJ5IGBlcnJvci5uYW1lID09PSAnQ3NzU3ludGF4RXJyb3InYFxuICAgICAqIGluc3RlYWQgb2YgYGVycm9yIGluc3RhbmNlb2YgQ3NzU3ludGF4RXJyb3JgLFxuICAgICAqIGJlY2F1c2UgbnBtIGNvdWxkIGhhdmUgc2V2ZXJhbCBQb3N0Q1NTIHZlcnNpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaWYgKGVycm9yLm5hbWUgPT09ICdDc3NTeW50YXhFcnJvcicpIHtcbiAgICAgKiAgIGVycm9yIC8vPT4gQ3NzU3ludGF4RXJyb3JcbiAgICAgKiB9XG4gICAgICovX3RoaXMubmFtZT0nQ3NzU3ludGF4RXJyb3InOy8qKlxuICAgICAqIEVycm9yIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBlcnJvci5tZXNzYWdlIC8vPT4gJ1VuY2xvc2VkIGJsb2NrJ1xuICAgICAqL190aGlzLnJlYXNvbj1tZXNzYWdlO2lmKGZpbGUpey8qKlxuICAgICAgICogQWJzb2x1dGUgcGF0aCB0byB0aGUgYnJva2VuIGZpbGUuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogZXJyb3IuZmlsZSAgICAgICAvLz0+ICdhLnNhc3MnXG4gICAgICAgKiBlcnJvci5pbnB1dC5maWxlIC8vPT4gJ2EuY3NzJ1xuICAgICAgICovX3RoaXMuZmlsZT1maWxlO31pZihzb3VyY2Upey8qKlxuICAgICAgICogU291cmNlIGNvZGUgb2YgdGhlIGJyb2tlbiBmaWxlLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGVycm9yLnNvdXJjZSAgICAgICAvLz0+ICdhIHsgYiB7fSB9J1xuICAgICAgICogZXJyb3IuaW5wdXQuY29sdW1uIC8vPT4gJ2EgYiB7IH0nXG4gICAgICAgKi9fdGhpcy5zb3VyY2U9c291cmNlO31pZihwbHVnaW4pey8qKlxuICAgICAgICogUGx1Z2luIG5hbWUsIGlmIGVycm9yIGNhbWUgZnJvbSBwbHVnaW4uXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogZXJyb3IucGx1Z2luIC8vPT4gJ3Bvc3Rjc3MtdmFycydcbiAgICAgICAqL190aGlzLnBsdWdpbj1wbHVnaW47fWlmKHR5cGVvZiBsaW5lIT09J3VuZGVmaW5lZCcmJnR5cGVvZiBjb2x1bW4hPT0ndW5kZWZpbmVkJyl7LyoqXG4gICAgICAgKiBTb3VyY2UgbGluZSBvZiB0aGUgZXJyb3IuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogZXJyb3IubGluZSAgICAgICAvLz0+IDJcbiAgICAgICAqIGVycm9yLmlucHV0LmxpbmUgLy89PiA0XG4gICAgICAgKi9fdGhpcy5saW5lPWxpbmU7LyoqXG4gICAgICAgKiBTb3VyY2UgY29sdW1uIG9mIHRoZSBlcnJvci5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBlcnJvci5jb2x1bW4gICAgICAgLy89PiAxXG4gICAgICAgKiBlcnJvci5pbnB1dC5jb2x1bW4gLy89PiA0XG4gICAgICAgKi9fdGhpcy5jb2x1bW49Y29sdW1uO31fdGhpcy5zZXRNZXNzYWdlKCk7aWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Upe0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLENzc1N5bnRheEVycm9yKTt9cmV0dXJuIF90aGlzO312YXIgX3Byb3RvPUNzc1N5bnRheEVycm9yLnByb3RvdHlwZTtfcHJvdG8uc2V0TWVzc2FnZT1mdW5jdGlvbiBzZXRNZXNzYWdlKCl7LyoqXG4gICAgICogRnVsbCBlcnJvciB0ZXh0IGluIHRoZSBHTlUgZXJyb3IgZm9ybWF0XG4gICAgICogd2l0aCBwbHVnaW4sIGZpbGUsIGxpbmUgYW5kIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGVycm9yLm1lc3NhZ2UgLy89PiAnYS5jc3M6MToxOiBVbmNsb3NlZCBibG9jaydcbiAgICAgKi90aGlzLm1lc3NhZ2U9dGhpcy5wbHVnaW4/dGhpcy5wbHVnaW4rJzogJzonJzt0aGlzLm1lc3NhZ2UrPXRoaXMuZmlsZT90aGlzLmZpbGU6Jzxjc3MgaW5wdXQ+JztpZih0eXBlb2YgdGhpcy5saW5lIT09J3VuZGVmaW5lZCcpe3RoaXMubWVzc2FnZSs9JzonK3RoaXMubGluZSsnOicrdGhpcy5jb2x1bW47fXRoaXMubWVzc2FnZSs9JzogJyt0aGlzLnJlYXNvbjt9LyoqXG4gICAqIFJldHVybnMgYSBmZXcgbGluZXMgb2YgQ1NTIHNvdXJjZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IuXG4gICAqXG4gICAqIElmIHRoZSBDU1MgaGFzIGFuIGlucHV0IHNvdXJjZSBtYXAgd2l0aG91dCBgc291cmNlQ29udGVudGAsXG4gICAqIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbY29sb3JdIFdoZXRoZXIgYXJyb3cgd2lsbCBiZSBjb2xvcmVkIHJlZCBieSB0ZXJtaW5hbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgY29kZXMuIEJ5IGRlZmF1bHQsIFBvc3RDU1Mgd2lsbCBkZXRlY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yIHN1cHBvcnQgYnkgYHByb2Nlc3Muc3Rkb3V0LmlzVFRZYFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIGBwcm9jZXNzLmVudi5OT0RFX0RJU0FCTEVfQ09MT1JTYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZXJyb3Iuc2hvd1NvdXJjZUNvZGUoKSAvLz0+IFwiICA0IHwgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgNSB8IGEge1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgID4gNiB8ICAgYmFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgIHwgICBeXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICA3IHwgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgOCB8IGIge1wiXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRmV3IGxpbmVzIG9mIENTUyBzb3VyY2UgdGhhdCBjYXVzZWQgdGhlIGVycm9yLlxuICAgKi87X3Byb3RvLnNob3dTb3VyY2VDb2RlPWZ1bmN0aW9uIHNob3dTb3VyY2VDb2RlKGNvbG9yKXt2YXIgX3RoaXMyPXRoaXM7aWYoIXRoaXMuc291cmNlKXJldHVybicnO3ZhciBjc3M9dGhpcy5zb3VyY2U7aWYoX3Rlcm1pbmFsSGlnaGxpZ2h0W1wiZGVmYXVsdFwiXSl7aWYodHlwZW9mIGNvbG9yPT09J3VuZGVmaW5lZCcpY29sb3I9X3N1cHBvcnRzQ29sb3JbXCJkZWZhdWx0XCJdLnN0ZG91dDtpZihjb2xvciljc3M9KDAsX3Rlcm1pbmFsSGlnaGxpZ2h0W1wiZGVmYXVsdFwiXSkoY3NzKTt9dmFyIGxpbmVzPWNzcy5zcGxpdCgvXFxyP1xcbi8pO3ZhciBzdGFydD1NYXRoLm1heCh0aGlzLmxpbmUtMywwKTt2YXIgZW5kPU1hdGgubWluKHRoaXMubGluZSsyLGxpbmVzLmxlbmd0aCk7dmFyIG1heFdpZHRoPVN0cmluZyhlbmQpLmxlbmd0aDtmdW5jdGlvbiBtYXJrKHRleHQpe2lmKGNvbG9yJiZfY2hhbGtbXCJkZWZhdWx0XCJdLnJlZCl7cmV0dXJuIF9jaGFsa1tcImRlZmF1bHRcIl0ucmVkLmJvbGQodGV4dCk7fXJldHVybiB0ZXh0O31mdW5jdGlvbiBhc2lkZSh0ZXh0KXtpZihjb2xvciYmX2NoYWxrW1wiZGVmYXVsdFwiXS5ncmF5KXtyZXR1cm4gX2NoYWxrW1wiZGVmYXVsdFwiXS5ncmF5KHRleHQpO31yZXR1cm4gdGV4dDt9cmV0dXJuIGxpbmVzLnNsaWNlKHN0YXJ0LGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsaW5kZXgpe3ZhciBudW1iZXI9c3RhcnQrMStpbmRleDt2YXIgZ3V0dGVyPScgJysoJyAnK251bWJlcikuc2xpY2UoLW1heFdpZHRoKSsnIHwgJztpZihudW1iZXI9PT1fdGhpczIubGluZSl7dmFyIHNwYWNpbmc9YXNpZGUoZ3V0dGVyLnJlcGxhY2UoL1xcZC9nLCcgJykpK2xpbmUuc2xpY2UoMCxfdGhpczIuY29sdW1uLTEpLnJlcGxhY2UoL1teXFx0XS9nLCcgJyk7cmV0dXJuIG1hcmsoJz4nKSthc2lkZShndXR0ZXIpK2xpbmUrJ1xcbiAnK3NwYWNpbmcrbWFyaygnXicpO31yZXR1cm4nICcrYXNpZGUoZ3V0dGVyKStsaW5lO30pLmpvaW4oJ1xcbicpO30vKipcbiAgICogUmV0dXJucyBlcnJvciBwb3NpdGlvbiwgbWVzc2FnZSBhbmQgc291cmNlIGNvZGUgb2YgdGhlIGJyb2tlbiBwYXJ0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlcnJvci50b1N0cmluZygpIC8vPT4gXCJDc3NTeW50YXhFcnJvcjogYXBwLmNzczoxOjE6IFVuY2xvc2VkIGJsb2NrXG4gICAqICAgICAgICAgICAgICAgICAgLy8gICAgPiAxIHwgYSB7XG4gICAqICAgICAgICAgICAgICAgICAgLy8gICAgICAgIHwgXlwiXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRXJyb3IgcG9zaXRpb24sIG1lc3NhZ2UgYW5kIHNvdXJjZSBjb2RlLlxuICAgKi87X3Byb3RvLnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7dmFyIGNvZGU9dGhpcy5zaG93U291cmNlQ29kZSgpO2lmKGNvZGUpe2NvZGU9J1xcblxcbicrY29kZSsnXFxuJzt9cmV0dXJuIHRoaXMubmFtZSsnOiAnK3RoaXMubWVzc2FnZStjb2RlO30vKipcbiAgICogQG1lbWJlcm9mIENzc1N5bnRheEVycm9yI1xuICAgKiBAbWVtYmVyIHtJbnB1dH0gaW5wdXQgSW5wdXQgb2JqZWN0IHdpdGggUG9zdENTUyBpbnRlcm5hbCBpbmZvcm1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgYWJvdXQgaW5wdXQgZmlsZS4gSWYgaW5wdXQgaGFzIHNvdXJjZSBtYXBcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGZyb20gcHJldmlvdXMgdG9vbCwgUG9zdENTUyB3aWxsIHVzZSBvcmlnaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgIChmb3IgZXhhbXBsZSwgU2Fzcykgc291cmNlLiBZb3UgY2FuIHVzZSB0aGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZ2V0IFBvc3RDU1MgaW5wdXQgc291cmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlcnJvci5pbnB1dC5maWxlIC8vPT4gJ2EuY3NzJ1xuICAgKiBlcnJvci5maWxlICAgICAgIC8vPT4gJ2Euc2FzcydcbiAgICovO3JldHVybiBDc3NTeW50YXhFcnJvcjt9KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTt2YXIgX2RlZmF1bHQ9Q3NzU3ludGF4RXJyb3I7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7XCIuL3Rlcm1pbmFsLWhpZ2hsaWdodFwiOjIsXCJjaGFsa1wiOjIsXCJzdXBwb3J0cy1jb2xvclwiOjJ9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfbm9kZT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25vZGVcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fWZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLHN1cGVyQ2xhc3Mpe3N1YkNsYXNzLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3I9c3ViQ2xhc3M7c3ViQ2xhc3MuX19wcm90b19fPXN1cGVyQ2xhc3M7fS8qKlxuICogUmVwcmVzZW50cyBhIENTUyBkZWNsYXJhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBOb2RlXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHsgY29sb3I6IGJsYWNrIH0nKVxuICogY29uc3QgZGVjbCA9IHJvb3QuZmlyc3QuZmlyc3RcbiAqIGRlY2wudHlwZSAgICAgICAvLz0+ICdkZWNsJ1xuICogZGVjbC50b1N0cmluZygpIC8vPT4gJyBjb2xvcjogYmxhY2snXG4gKi92YXIgRGVjbGFyYXRpb249LyojX19QVVJFX18qL2Z1bmN0aW9uKF9Ob2RlKXtfaW5oZXJpdHNMb29zZShEZWNsYXJhdGlvbixfTm9kZSk7ZnVuY3Rpb24gRGVjbGFyYXRpb24oZGVmYXVsdHMpe3ZhciBfdGhpcztfdGhpcz1fTm9kZS5jYWxsKHRoaXMsZGVmYXVsdHMpfHx0aGlzO190aGlzLnR5cGU9J2RlY2wnO3JldHVybiBfdGhpczt9LyoqXG4gICAqIEBtZW1iZXJvZiBEZWNsYXJhdGlvbiNcbiAgICogQG1lbWJlciB7c3RyaW5nfSBwcm9wIFRoZSBkZWNsYXJhdGlvbuKAmXMgcHJvcGVydHkgbmFtZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EgeyBjb2xvcjogYmxhY2sgfScpXG4gICAqIGNvbnN0IGRlY2wgPSByb290LmZpcnN0LmZpcnN0XG4gICAqIGRlY2wucHJvcCAvLz0+ICdjb2xvcidcbiAgICovIC8qKlxuICAgKiBAbWVtYmVyb2YgRGVjbGFyYXRpb24jXG4gICAqIEBtZW1iZXIge3N0cmluZ30gdmFsdWUgVGhlIGRlY2xhcmF0aW9u4oCZcyB2YWx1ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EgeyBjb2xvcjogYmxhY2sgfScpXG4gICAqIGNvbnN0IGRlY2wgPSByb290LmZpcnN0LmZpcnN0XG4gICAqIGRlY2wudmFsdWUgLy89PiAnYmxhY2snXG4gICAqLyAvKipcbiAgICogQG1lbWJlcm9mIERlY2xhcmF0aW9uI1xuICAgKiBAbWVtYmVyIHtib29sZWFufSBpbXBvcnRhbnQgYHRydWVgIGlmIHRoZSBkZWNsYXJhdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIGFuICFpbXBvcnRhbnQgYW5ub3RhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EgeyBjb2xvcjogYmxhY2sgIWltcG9ydGFudDsgY29sb3I6IHJlZCB9JylcbiAgICogcm9vdC5maXJzdC5maXJzdC5pbXBvcnRhbnQgLy89PiB0cnVlXG4gICAqIHJvb3QuZmlyc3QubGFzdC5pbXBvcnRhbnQgIC8vPT4gdW5kZWZpbmVkXG4gICAqLyAvKipcbiAgICogQG1lbWJlcm9mIERlY2xhcmF0aW9uI1xuICAgKiBAbWVtYmVyIHtvYmplY3R9IHJhd3MgSW5mb3JtYXRpb24gdG8gZ2VuZXJhdGUgYnl0ZS10by1ieXRlIGVxdWFsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBub2RlIHN0cmluZyBhcyBpdCB3YXMgaW4gdGhlIG9yaWdpbiBpbnB1dC5cbiAgICpcbiAgICogRXZlcnkgcGFyc2VyIHNhdmVzIGl0cyBvd24gcHJvcGVydGllcyxcbiAgICogYnV0IHRoZSBkZWZhdWx0IENTUyBwYXJzZXIgdXNlczpcbiAgICpcbiAgICogKiBgYmVmb3JlYDogdGhlIHNwYWNlIHN5bWJvbHMgYmVmb3JlIHRoZSBub2RlLiBJdCBhbHNvIHN0b3JlcyBgKmBcbiAgICogICBhbmQgYF9gIHN5bWJvbHMgYmVmb3JlIHRoZSBkZWNsYXJhdGlvbiAoSUUgaGFjaykuXG4gICAqICogYGJldHdlZW5gOiB0aGUgc3ltYm9scyBiZXR3ZWVuIHRoZSBwcm9wZXJ0eSBhbmQgdmFsdWVcbiAgICogICBmb3IgZGVjbGFyYXRpb25zLlxuICAgKiAqIGBpbXBvcnRhbnRgOiB0aGUgY29udGVudCBvZiB0aGUgaW1wb3J0YW50IHN0YXRlbWVudCxcbiAgICogICBpZiBpdCBpcyBub3QganVzdCBgIWltcG9ydGFudGAuXG4gICAqXG4gICAqIFBvc3RDU1MgY2xlYW5zIGRlY2xhcmF0aW9uIGZyb20gY29tbWVudHMgYW5kIGV4dHJhIHNwYWNlcyxcbiAgICogYnV0IGl0IHN0b3JlcyBvcmlnaW4gY29udGVudCBpbiByYXdzIHByb3BlcnRpZXMuXG4gICAqIEFzIHN1Y2gsIGlmIHlvdSBkb27igJl0IGNoYW5nZSBhIGRlY2xhcmF0aW9u4oCZcyB2YWx1ZSxcbiAgICogUG9zdENTUyB3aWxsIHVzZSB0aGUgcmF3IHZhbHVlIHdpdGggY29tbWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHtcXG4gIGNvbG9yOmJsYWNrXFxufScpXG4gICAqIHJvb3QuZmlyc3QuZmlyc3QucmF3cyAvLz0+IHsgYmVmb3JlOiAnXFxuICAnLCBiZXR3ZWVuOiAnOicgfVxuICAgKi9yZXR1cm4gRGVjbGFyYXRpb247fShfbm9kZVtcImRlZmF1bHRcIl0pO3ZhciBfZGVmYXVsdD1EZWNsYXJhdGlvbjtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vbm9kZVwiOjQ4fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX3BhdGg9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicGF0aFwiKSk7dmFyIF9jc3NTeW50YXhFcnJvcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nzcy1zeW50YXgtZXJyb3JcIikpO3ZhciBfcHJldmlvdXNNYXA9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wcmV2aW91cy1tYXBcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fWZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpO3JldHVybiBDb25zdHJ1Y3Rvcjt9dmFyIHNlcXVlbmNlPTA7LyoqXG4gKiBSZXByZXNlbnRzIHRoZSBzb3VyY2UgQ1NTLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByb290ICA9IHBvc3Rjc3MucGFyc2UoY3NzLCB7IGZyb206IGZpbGUgfSlcbiAqIGNvbnN0IGlucHV0ID0gcm9vdC5zb3VyY2UuaW5wdXRcbiAqL3ZhciBJbnB1dD0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXsvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzcyAgICBJbnB1dCBDU1Mgc291cmNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIHtAbGluayBQcm9jZXNzb3IjcHJvY2Vzc30gb3B0aW9ucy5cbiAgICovZnVuY3Rpb24gSW5wdXQoY3NzLG9wdHMpe2lmKG9wdHM9PT12b2lkIDApe29wdHM9e307fWlmKGNzcz09PW51bGx8fF90eXBlb2YoY3NzKT09PSdvYmplY3QnJiYhY3NzLnRvU3RyaW5nKXt0aHJvdyBuZXcgRXJyb3IoXCJQb3N0Q1NTIHJlY2VpdmVkIFwiK2NzcytcIiBpbnN0ZWFkIG9mIENTUyBzdHJpbmdcIik7fS8qKlxuICAgICAqIElucHV0IENTUyBzb3VyY2VcbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGlucHV0ID0gcG9zdGNzcy5wYXJzZSgnYXt9JywgeyBmcm9tOiBmaWxlIH0pLmlucHV0XG4gICAgICogaW5wdXQuY3NzIC8vPT4gXCJhe31cIlxuICAgICAqL3RoaXMuY3NzPWNzcy50b1N0cmluZygpO2lmKHRoaXMuY3NzWzBdPT09XCJcXHVGRUZGXCJ8fHRoaXMuY3NzWzBdPT09XCJcXHVGRkZFXCIpe3RoaXMuaGFzQk9NPXRydWU7dGhpcy5jc3M9dGhpcy5jc3Muc2xpY2UoMSk7fWVsc2V7dGhpcy5oYXNCT009ZmFsc2U7fWlmKG9wdHMuZnJvbSl7aWYoL15cXHcrOlxcL1xcLy8udGVzdChvcHRzLmZyb20pfHxfcGF0aFtcImRlZmF1bHRcIl0uaXNBYnNvbHV0ZShvcHRzLmZyb20pKXsvKipcbiAgICAgICAgICogVGhlIGFic29sdXRlIHBhdGggdG8gdGhlIENTUyBzb3VyY2UgZmlsZSBkZWZpbmVkXG4gICAgICAgICAqIHdpdGggdGhlIGBmcm9tYCBvcHRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKGNzcywgeyBmcm9tOiAnYS5jc3MnIH0pXG4gICAgICAgICAqIHJvb3Quc291cmNlLmlucHV0LmZpbGUgLy89PiAnL2hvbWUvYWkvYS5jc3MnXG4gICAgICAgICAqL3RoaXMuZmlsZT1vcHRzLmZyb207fWVsc2V7dGhpcy5maWxlPV9wYXRoW1wiZGVmYXVsdFwiXS5yZXNvbHZlKG9wdHMuZnJvbSk7fX12YXIgbWFwPW5ldyBfcHJldmlvdXNNYXBbXCJkZWZhdWx0XCJdKHRoaXMuY3NzLG9wdHMpO2lmKG1hcC50ZXh0KXsvKipcbiAgICAgICAqIFRoZSBpbnB1dCBzb3VyY2UgbWFwIHBhc3NlZCBmcm9tIGEgY29tcGlsYXRpb24gc3RlcCBiZWZvcmUgUG9zdENTU1xuICAgICAgICogKGZvciBleGFtcGxlLCBmcm9tIFNhc3MgY29tcGlsZXIpLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtQcmV2aW91c01hcH1cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogcm9vdC5zb3VyY2UuaW5wdXQubWFwLmNvbnN1bWVyKCkuc291cmNlcyAvLz0+IFsnYS5zYXNzJ11cbiAgICAgICAqL3RoaXMubWFwPW1hcDt2YXIgZmlsZT1tYXAuY29uc3VtZXIoKS5maWxlO2lmKCF0aGlzLmZpbGUmJmZpbGUpdGhpcy5maWxlPXRoaXMubWFwUmVzb2x2ZShmaWxlKTt9aWYoIXRoaXMuZmlsZSl7c2VxdWVuY2UrPTE7LyoqXG4gICAgICAgKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBDU1Mgc291cmNlLiBJdCB3aWxsIGJlIGNyZWF0ZWQgaWYgYGZyb21gIG9wdGlvblxuICAgICAgICogaXMgbm90IHByb3ZpZGVkIChiZWNhdXNlIFBvc3RDU1MgZG9lcyBub3Qga25vdyB0aGUgZmlsZSBwYXRoKS5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZShjc3MpXG4gICAgICAgKiByb290LnNvdXJjZS5pbnB1dC5maWxlIC8vPT4gdW5kZWZpbmVkXG4gICAgICAgKiByb290LnNvdXJjZS5pbnB1dC5pZCAgIC8vPT4gXCI8aW5wdXQgY3NzIDE+XCJcbiAgICAgICAqL3RoaXMuaWQ9JzxpbnB1dCBjc3MgJytzZXF1ZW5jZSsnPic7fWlmKHRoaXMubWFwKXRoaXMubWFwLmZpbGU9dGhpcy5mcm9tO312YXIgX3Byb3RvPUlucHV0LnByb3RvdHlwZTtfcHJvdG8uZXJyb3I9ZnVuY3Rpb24gZXJyb3IobWVzc2FnZSxsaW5lLGNvbHVtbixvcHRzKXtpZihvcHRzPT09dm9pZCAwKXtvcHRzPXt9O312YXIgcmVzdWx0O3ZhciBvcmlnaW49dGhpcy5vcmlnaW4obGluZSxjb2x1bW4pO2lmKG9yaWdpbil7cmVzdWx0PW5ldyBfY3NzU3ludGF4RXJyb3JbXCJkZWZhdWx0XCJdKG1lc3NhZ2Usb3JpZ2luLmxpbmUsb3JpZ2luLmNvbHVtbixvcmlnaW4uc291cmNlLG9yaWdpbi5maWxlLG9wdHMucGx1Z2luKTt9ZWxzZXtyZXN1bHQ9bmV3IF9jc3NTeW50YXhFcnJvcltcImRlZmF1bHRcIl0obWVzc2FnZSxsaW5lLGNvbHVtbix0aGlzLmNzcyx0aGlzLmZpbGUsb3B0cy5wbHVnaW4pO31yZXN1bHQuaW5wdXQ9e2xpbmU6bGluZSxjb2x1bW46Y29sdW1uLHNvdXJjZTp0aGlzLmNzc307aWYodGhpcy5maWxlKXJlc3VsdC5pbnB1dC5maWxlPXRoaXMuZmlsZTtyZXR1cm4gcmVzdWx0O30vKipcbiAgICogUmVhZHMgdGhlIGlucHV0IHNvdXJjZSBtYXAgYW5kIHJldHVybnMgYSBzeW1ib2wgcG9zaXRpb25cbiAgICogaW4gdGhlIGlucHV0IHNvdXJjZSAoZS5nLiwgaW4gYSBTYXNzIGZpbGUgdGhhdCB3YXMgY29tcGlsZWRcbiAgICogdG8gQ1NTIGJlZm9yZSBiZWluZyBwYXNzZWQgdG8gUG9zdENTUykuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lICAgTGluZSBpbiBpbnB1dCBDU1MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gQ29sdW1uIGluIGlucHV0IENTUy5cbiAgICpcbiAgICogQHJldHVybiB7ZmlsZVBvc2l0aW9ufSBQb3NpdGlvbiBpbiBpbnB1dCBzb3VyY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3Quc291cmNlLmlucHV0Lm9yaWdpbigxLCAxKSAvLz0+IHsgZmlsZTogJ2EuY3NzJywgbGluZTogMywgY29sdW1uOiAxIH1cbiAgICovO19wcm90by5vcmlnaW49ZnVuY3Rpb24gb3JpZ2luKGxpbmUsY29sdW1uKXtpZighdGhpcy5tYXApcmV0dXJuIGZhbHNlO3ZhciBjb25zdW1lcj10aGlzLm1hcC5jb25zdW1lcigpO3ZhciBmcm9tPWNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe2xpbmU6bGluZSxjb2x1bW46Y29sdW1ufSk7aWYoIWZyb20uc291cmNlKXJldHVybiBmYWxzZTt2YXIgcmVzdWx0PXtmaWxlOnRoaXMubWFwUmVzb2x2ZShmcm9tLnNvdXJjZSksbGluZTpmcm9tLmxpbmUsY29sdW1uOmZyb20uY29sdW1ufTt2YXIgc291cmNlPWNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoZnJvbS5zb3VyY2UpO2lmKHNvdXJjZSlyZXN1bHQuc291cmNlPXNvdXJjZTtyZXR1cm4gcmVzdWx0O307X3Byb3RvLm1hcFJlc29sdmU9ZnVuY3Rpb24gbWFwUmVzb2x2ZShmaWxlKXtpZigvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKXtyZXR1cm4gZmlsZTt9cmV0dXJuIF9wYXRoW1wiZGVmYXVsdFwiXS5yZXNvbHZlKHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdHx8Jy4nLGZpbGUpO30vKipcbiAgICogVGhlIENTUyBzb3VyY2UgaWRlbnRpZmllci4gQ29udGFpbnMge0BsaW5rIElucHV0I2ZpbGV9IGlmIHRoZSB1c2VyXG4gICAqIHNldCB0aGUgYGZyb21gIG9wdGlvbiwgb3Ige0BsaW5rIElucHV0I2lkfSBpZiB0aGV5IGRpZCBub3QuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKGNzcywgeyBmcm9tOiAnYS5jc3MnIH0pXG4gICAqIHJvb3Quc291cmNlLmlucHV0LmZyb20gLy89PiBcIi9ob21lL2FpL2EuY3NzXCJcbiAgICpcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoY3NzKVxuICAgKiByb290LnNvdXJjZS5pbnB1dC5mcm9tIC8vPT4gXCI8aW5wdXQgY3NzIDE+XCJcbiAgICovO19jcmVhdGVDbGFzcyhJbnB1dCxbe2tleTpcImZyb21cIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuZmlsZXx8dGhpcy5pZDt9fV0pO3JldHVybiBJbnB1dDt9KCk7dmFyIF9kZWZhdWx0PUlucHV0Oy8qKlxuICogQHR5cGVkZWYgIHtvYmplY3R9IGZpbGVQb3NpdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGUgICBQYXRoIHRvIGZpbGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZSAgIFNvdXJjZSBsaW5lIGluIGZpbGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29sdW1uIFNvdXJjZSBjb2x1bW4gaW4gZmlsZS5cbiAqL2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se1wiLi9jc3Mtc3ludGF4LWVycm9yXCI6NDIsXCIuL3ByZXZpb3VzLW1hcFwiOjUyLFwicGF0aFwiOjM4fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihwcm9jZXNzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9tYXBHZW5lcmF0b3I9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tYXAtZ2VuZXJhdG9yXCIpKTt2YXIgX3N0cmluZ2lmeTI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZnlcIikpO3ZhciBfd2Fybk9uY2U9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi93YXJuLW9uY2VcIikpO3ZhciBfcmVzdWx0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0XCIpKTt2YXIgX3BhcnNlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFyc2VcIikpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e1wiZGVmYXVsdFwiOm9ian07fWZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpO3JldHVybiBDb25zdHJ1Y3Rvcjt9ZnVuY3Rpb24gaXNQcm9taXNlKG9iail7cmV0dXJuIF90eXBlb2Yob2JqKT09PSdvYmplY3QnJiZ0eXBlb2Ygb2JqLnRoZW49PT0nZnVuY3Rpb24nO30vKipcbiAqIEEgUHJvbWlzZSBwcm94eSBmb3IgdGhlIHJlc3VsdCBvZiBQb3N0Q1NTIHRyYW5zZm9ybWF0aW9ucy5cbiAqXG4gKiBBIGBMYXp5UmVzdWx0YCBpbnN0YW5jZSBpcyByZXR1cm5lZCBieSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBsYXp5ID0gcG9zdGNzcyhbYXV0b3ByZWZpeGVyXSkucHJvY2Vzcyhjc3MpXG4gKi92YXIgTGF6eVJlc3VsdD0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXtmdW5jdGlvbiBMYXp5UmVzdWx0KHByb2Nlc3Nvcixjc3Msb3B0cyl7dGhpcy5zdHJpbmdpZmllZD1mYWxzZTt0aGlzLnByb2Nlc3NlZD1mYWxzZTt2YXIgcm9vdDtpZihfdHlwZW9mKGNzcyk9PT0nb2JqZWN0JyYmY3NzIT09bnVsbCYmY3NzLnR5cGU9PT0ncm9vdCcpe3Jvb3Q9Y3NzO31lbHNlIGlmKGNzcyBpbnN0YW5jZW9mIExhenlSZXN1bHR8fGNzcyBpbnN0YW5jZW9mIF9yZXN1bHRbXCJkZWZhdWx0XCJdKXtyb290PWNzcy5yb290O2lmKGNzcy5tYXApe2lmKHR5cGVvZiBvcHRzLm1hcD09PSd1bmRlZmluZWQnKW9wdHMubWFwPXt9O2lmKCFvcHRzLm1hcC5pbmxpbmUpb3B0cy5tYXAuaW5saW5lPWZhbHNlO29wdHMubWFwLnByZXY9Y3NzLm1hcDt9fWVsc2V7dmFyIHBhcnNlcj1fcGFyc2VbXCJkZWZhdWx0XCJdO2lmKG9wdHMuc3ludGF4KXBhcnNlcj1vcHRzLnN5bnRheC5wYXJzZTtpZihvcHRzLnBhcnNlcilwYXJzZXI9b3B0cy5wYXJzZXI7aWYocGFyc2VyLnBhcnNlKXBhcnNlcj1wYXJzZXIucGFyc2U7dHJ5e3Jvb3Q9cGFyc2VyKGNzcyxvcHRzKTt9Y2F0Y2goZXJyb3Ipe3RoaXMuZXJyb3I9ZXJyb3I7fX10aGlzLnJlc3VsdD1uZXcgX3Jlc3VsdFtcImRlZmF1bHRcIl0ocHJvY2Vzc29yLHJvb3Qsb3B0cyk7fS8qKlxuICAgKiBSZXR1cm5zIGEge0BsaW5rIFByb2Nlc3Nvcn0gaW5zdGFuY2UsIHdoaWNoIHdpbGwgYmUgdXNlZFxuICAgKiBmb3IgQ1NTIHRyYW5zZm9ybWF0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge1Byb2Nlc3Nvcn1cbiAgICovdmFyIF9wcm90bz1MYXp5UmVzdWx0LnByb3RvdHlwZTsvKipcbiAgICogUHJvY2Vzc2VzIGlucHV0IENTUyB0aHJvdWdoIHN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICogYW5kIGNhbGxzIHtAbGluayBSZXN1bHQjd2FybmluZ3MoKX0uXG4gICAqXG4gICAqIEByZXR1cm4ge1dhcm5pbmdbXX0gV2FybmluZ3MgZnJvbSBwbHVnaW5zLlxuICAgKi9fcHJvdG8ud2FybmluZ3M9ZnVuY3Rpb24gd2FybmluZ3MoKXtyZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKTt9LyoqXG4gICAqIEFsaWFzIGZvciB0aGUge0BsaW5rIExhenlSZXN1bHQjY3NzfSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbGF6eSArICcnID09PSBsYXp5LmNzc1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE91dHB1dCBDU1MuXG4gICAqLztfcHJvdG8udG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5jc3M7fS8qKlxuICAgKiBQcm9jZXNzZXMgaW5wdXQgQ1NTIHRocm91Z2ggc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91cyBwbHVnaW5zXG4gICAqIGFuZCBjYWxscyBgb25GdWxmaWxsZWRgIHdpdGggYSBSZXN1bHQgaW5zdGFuY2UuIElmIGEgcGx1Z2luIHRocm93c1xuICAgKiBhbiBlcnJvciwgdGhlIGBvblJlamVjdGVkYCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkLlxuICAgKlxuICAgKiBJdCBpbXBsZW1lbnRzIHN0YW5kYXJkIFByb21pc2UgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0ge29uRnVsZmlsbGVkfSBvbkZ1bGZpbGxlZCBDYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gYWxsIHBsdWdpbnMgd2lsbCBmaW5pc2ggd29yay5cbiAgICogQHBhcmFtIHtvblJlamVjdGVkfSAgb25SZWplY3RlZCAgQ2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbiBhbnkgZXJyb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2UgQVBJIHRvIG1ha2UgcXVldWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHBvc3Rjc3MoW2F1dG9wcmVmaXhlcl0pLnByb2Nlc3MoY3NzLCB7IGZyb206IGNzc1BhdGggfSkudGhlbihyZXN1bHQgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHJlc3VsdC5jc3MpXG4gICAqIH0pXG4gICAqLztfcHJvdG8udGhlbj1mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLG9uUmVqZWN0ZWQpe2lmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nKXtpZighKCdmcm9tJ2luIHRoaXMub3B0cykpeygwLF93YXJuT25jZVtcImRlZmF1bHRcIl0pKCdXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwICcrJ2FuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoICcrJ29yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLicpO319cmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLG9uUmVqZWN0ZWQpO30vKipcbiAgICogUHJvY2Vzc2VzIGlucHV0IENTUyB0aHJvdWdoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgcGx1Z2luc1xuICAgKiBhbmQgY2FsbHMgb25SZWplY3RlZCBmb3IgZWFjaCBlcnJvciB0aHJvd24gaW4gYW55IHBsdWdpbi5cbiAgICpcbiAgICogSXQgaW1wbGVtZW50cyBzdGFuZGFyZCBQcm9taXNlIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtvblJlamVjdGVkfSBvblJlamVjdGVkIENhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb24gYW55IGVycm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIEFQSSB0byBtYWtlIHF1ZXVlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwb3N0Y3NzKFthdXRvcHJlZml4ZXJdKS5wcm9jZXNzKGNzcykudGhlbihyZXN1bHQgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHJlc3VsdC5jc3MpXG4gICAqIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICogICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgKiB9KVxuICAgKi87X3Byb3RvW1wiY2F0Y2hcIl09ZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0ZWQpe3JldHVybiB0aGlzLmFzeW5jKClbXCJjYXRjaFwiXShvblJlamVjdGVkKTt9LyoqXG4gICAqIFByb2Nlc3NlcyBpbnB1dCBDU1MgdGhyb3VnaCBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICogYW5kIGNhbGxzIG9uRmluYWxseSBvbiBhbnkgZXJyb3Igb3Igd2hlbiBhbGwgcGx1Z2lucyB3aWxsIGZpbmlzaCB3b3JrLlxuICAgKlxuICAgKiBJdCBpbXBsZW1lbnRzIHN0YW5kYXJkIFByb21pc2UgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0ge29uRmluYWxseX0gb25GaW5hbGx5IENhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb24gYW55IGVycm9yIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiBhbGwgcGx1Z2lucyB3aWxsIGZpbmlzaCB3b3JrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIEFQSSB0byBtYWtlIHF1ZXVlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwb3N0Y3NzKFthdXRvcHJlZml4ZXJdKS5wcm9jZXNzKGNzcykuZmluYWxseSgoKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2coJ3Byb2Nlc3NpbmcgZW5kZWQnKVxuICAgKiB9KVxuICAgKi87X3Byb3RvW1wiZmluYWxseVwiXT1mdW5jdGlvbiBfZmluYWxseShvbkZpbmFsbHkpe3JldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksb25GaW5hbGx5KTt9O19wcm90by5oYW5kbGVFcnJvcj1mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcixwbHVnaW4pe3RyeXt0aGlzLmVycm9yPWVycm9yO2lmKGVycm9yLm5hbWU9PT0nQ3NzU3ludGF4RXJyb3InJiYhZXJyb3IucGx1Z2luKXtlcnJvci5wbHVnaW49cGx1Z2luLnBvc3Rjc3NQbHVnaW47ZXJyb3Iuc2V0TWVzc2FnZSgpO31lbHNlIGlmKHBsdWdpbi5wb3N0Y3NzVmVyc2lvbil7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe3ZhciBwbHVnaW5OYW1lPXBsdWdpbi5wb3N0Y3NzUGx1Z2luO3ZhciBwbHVnaW5WZXI9cGx1Z2luLnBvc3Rjc3NWZXJzaW9uO3ZhciBydW50aW1lVmVyPXRoaXMucmVzdWx0LnByb2Nlc3Nvci52ZXJzaW9uO3ZhciBhPXBsdWdpblZlci5zcGxpdCgnLicpO3ZhciBiPXJ1bnRpbWVWZXIuc3BsaXQoJy4nKTtpZihhWzBdIT09YlswXXx8cGFyc2VJbnQoYVsxXSk+cGFyc2VJbnQoYlsxXSkpe2NvbnNvbGUuZXJyb3IoJ1Vua25vd24gZXJyb3IgZnJvbSBQb3N0Q1NTIHBsdWdpbi4gWW91ciBjdXJyZW50IFBvc3RDU1MgJysndmVyc2lvbiBpcyAnK3J1bnRpbWVWZXIrJywgYnV0ICcrcGx1Z2luTmFtZSsnIHVzZXMgJytwbHVnaW5WZXIrJy4gUGVyaGFwcyB0aGlzIGlzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yIGJlbG93LicpO319fX1jYXRjaChlcnIpe2lmKGNvbnNvbGUmJmNvbnNvbGUuZXJyb3IpY29uc29sZS5lcnJvcihlcnIpO319O19wcm90by5hc3luY1RpY2s9ZnVuY3Rpb24gYXN5bmNUaWNrKHJlc29sdmUscmVqZWN0KXt2YXIgX3RoaXM9dGhpcztpZih0aGlzLnBsdWdpbj49dGhpcy5wcm9jZXNzb3IucGx1Z2lucy5sZW5ndGgpe3RoaXMucHJvY2Vzc2VkPXRydWU7cmV0dXJuIHJlc29sdmUoKTt9dHJ5e3ZhciBwbHVnaW49dGhpcy5wcm9jZXNzb3IucGx1Z2luc1t0aGlzLnBsdWdpbl07dmFyIHByb21pc2U9dGhpcy5ydW4ocGx1Z2luKTt0aGlzLnBsdWdpbis9MTtpZihpc1Byb21pc2UocHJvbWlzZSkpe3Byb21pc2UudGhlbihmdW5jdGlvbigpe190aGlzLmFzeW5jVGljayhyZXNvbHZlLHJlamVjdCk7fSlbXCJjYXRjaFwiXShmdW5jdGlvbihlcnJvcil7X3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IscGx1Z2luKTtfdGhpcy5wcm9jZXNzZWQ9dHJ1ZTtyZWplY3QoZXJyb3IpO30pO31lbHNle3RoaXMuYXN5bmNUaWNrKHJlc29sdmUscmVqZWN0KTt9fWNhdGNoKGVycm9yKXt0aGlzLnByb2Nlc3NlZD10cnVlO3JlamVjdChlcnJvcik7fX07X3Byb3RvLmFzeW5jPWZ1bmN0aW9uIGFzeW5jKCl7dmFyIF90aGlzMj10aGlzO2lmKHRoaXMucHJvY2Vzc2VkKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2lmKF90aGlzMi5lcnJvcil7cmVqZWN0KF90aGlzMi5lcnJvcik7fWVsc2V7cmVzb2x2ZShfdGhpczIuc3RyaW5naWZ5KCkpO319KTt9aWYodGhpcy5wcm9jZXNzaW5nKXtyZXR1cm4gdGhpcy5wcm9jZXNzaW5nO310aGlzLnByb2Nlc3Npbmc9bmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe2lmKF90aGlzMi5lcnJvcilyZXR1cm4gcmVqZWN0KF90aGlzMi5lcnJvcik7X3RoaXMyLnBsdWdpbj0wO190aGlzMi5hc3luY1RpY2socmVzb2x2ZSxyZWplY3QpO30pLnRoZW4oZnVuY3Rpb24oKXtfdGhpczIucHJvY2Vzc2VkPXRydWU7cmV0dXJuIF90aGlzMi5zdHJpbmdpZnkoKTt9KTtyZXR1cm4gdGhpcy5wcm9jZXNzaW5nO307X3Byb3RvLnN5bmM9ZnVuY3Rpb24gc3luYygpe2lmKHRoaXMucHJvY2Vzc2VkKXJldHVybiB0aGlzLnJlc3VsdDt0aGlzLnByb2Nlc3NlZD10cnVlO2lmKHRoaXMucHJvY2Vzc2luZyl7dGhyb3cgbmV3IEVycm9yKCdVc2UgcHJvY2Vzcyhjc3MpLnRoZW4oY2IpIHRvIHdvcmsgd2l0aCBhc3luYyBwbHVnaW5zJyk7fWlmKHRoaXMuZXJyb3IpdGhyb3cgdGhpcy5lcnJvcjtmb3IodmFyIF9pdGVyYXRvcj10aGlzLnJlc3VsdC5wcm9jZXNzb3IucGx1Z2lucyxfaXNBcnJheT1BcnJheS5pc0FycmF5KF9pdGVyYXRvciksX2k9MCxfaXRlcmF0b3I9X2lzQXJyYXk/X2l0ZXJhdG9yOl9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY7aWYoX2lzQXJyYXkpe2lmKF9pPj1faXRlcmF0b3IubGVuZ3RoKWJyZWFrO19yZWY9X2l0ZXJhdG9yW19pKytdO31lbHNle19pPV9pdGVyYXRvci5uZXh0KCk7aWYoX2kuZG9uZSlicmVhaztfcmVmPV9pLnZhbHVlO312YXIgcGx1Z2luPV9yZWY7dmFyIHByb21pc2U9dGhpcy5ydW4ocGx1Z2luKTtpZihpc1Byb21pc2UocHJvbWlzZSkpe3Rocm93IG5ldyBFcnJvcignVXNlIHByb2Nlc3MoY3NzKS50aGVuKGNiKSB0byB3b3JrIHdpdGggYXN5bmMgcGx1Z2lucycpO319cmV0dXJuIHRoaXMucmVzdWx0O307X3Byb3RvLnJ1bj1mdW5jdGlvbiBydW4ocGx1Z2luKXt0aGlzLnJlc3VsdC5sYXN0UGx1Z2luPXBsdWdpbjt0cnl7cmV0dXJuIHBsdWdpbih0aGlzLnJlc3VsdC5yb290LHRoaXMucmVzdWx0KTt9Y2F0Y2goZXJyb3Ipe3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IscGx1Z2luKTt0aHJvdyBlcnJvcjt9fTtfcHJvdG8uc3RyaW5naWZ5PWZ1bmN0aW9uIHN0cmluZ2lmeSgpe2lmKHRoaXMuc3RyaW5naWZpZWQpcmV0dXJuIHRoaXMucmVzdWx0O3RoaXMuc3RyaW5naWZpZWQ9dHJ1ZTt0aGlzLnN5bmMoKTt2YXIgb3B0cz10aGlzLnJlc3VsdC5vcHRzO3ZhciBzdHI9X3N0cmluZ2lmeTJbXCJkZWZhdWx0XCJdO2lmKG9wdHMuc3ludGF4KXN0cj1vcHRzLnN5bnRheC5zdHJpbmdpZnk7aWYob3B0cy5zdHJpbmdpZmllcilzdHI9b3B0cy5zdHJpbmdpZmllcjtpZihzdHIuc3RyaW5naWZ5KXN0cj1zdHIuc3RyaW5naWZ5O3ZhciBtYXA9bmV3IF9tYXBHZW5lcmF0b3JbXCJkZWZhdWx0XCJdKHN0cix0aGlzLnJlc3VsdC5yb290LHRoaXMucmVzdWx0Lm9wdHMpO3ZhciBkYXRhPW1hcC5nZW5lcmF0ZSgpO3RoaXMucmVzdWx0LmNzcz1kYXRhWzBdO3RoaXMucmVzdWx0Lm1hcD1kYXRhWzFdO3JldHVybiB0aGlzLnJlc3VsdDt9O19jcmVhdGVDbGFzcyhMYXp5UmVzdWx0LFt7a2V5OlwicHJvY2Vzc29yXCIsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7fS8qKlxuICAgICAqIE9wdGlvbnMgZnJvbSB0aGUge0BsaW5rIFByb2Nlc3NvciNwcm9jZXNzfSBjYWxsLlxuICAgICAqXG4gICAgICogQHR5cGUge3Byb2Nlc3NPcHRpb25zfVxuICAgICAqL30se2tleTpcIm9wdHNcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7fS8qKlxuICAgICAqIFByb2Nlc3NlcyBpbnB1dCBDU1MgdGhyb3VnaCBzeW5jaHJvbm91cyBwbHVnaW5zLCBjb252ZXJ0cyBgUm9vdGBcbiAgICAgKiB0byBhIENTUyBzdHJpbmcgYW5kIHJldHVybnMge0BsaW5rIFJlc3VsdCNjc3N9LlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSB3aWxsIG9ubHkgd29yayB3aXRoIHN5bmNocm9ub3VzIHBsdWdpbnMuXG4gICAgICogSWYgdGhlIHByb2Nlc3NvciBjb250YWlucyBhbnkgYXN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICAgKiBpdCB3aWxsIHRocm93IGFuIGVycm9yLiBUaGlzIGlzIHdoeSB0aGlzIG1ldGhvZCBpcyBvbmx5XG4gICAgICogZm9yIGRlYnVnIHB1cnBvc2UsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB7QGxpbmsgTGF6eVJlc3VsdCN0aGVufS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHNlZSBSZXN1bHQjY3NzXG4gICAgICovfSx7a2V5OlwiY3NzXCIsZ2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNzczt9LyoqXG4gICAgICogQW4gYWxpYXMgZm9yIHRoZSBgY3NzYCBwcm9wZXJ0eS4gVXNlIGl0IHdpdGggc3ludGF4ZXNcbiAgICAgKiB0aGF0IGdlbmVyYXRlIG5vbi1DU1Mgb3V0cHV0LlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSB3aWxsIG9ubHkgd29yayB3aXRoIHN5bmNocm9ub3VzIHBsdWdpbnMuXG4gICAgICogSWYgdGhlIHByb2Nlc3NvciBjb250YWlucyBhbnkgYXN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICAgKiBpdCB3aWxsIHRocm93IGFuIGVycm9yLiBUaGlzIGlzIHdoeSB0aGlzIG1ldGhvZCBpcyBvbmx5XG4gICAgICogZm9yIGRlYnVnIHB1cnBvc2UsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB7QGxpbmsgTGF6eVJlc3VsdCN0aGVufS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHNlZSBSZXN1bHQjY29udGVudFxuICAgICAqL30se2tleTpcImNvbnRlbnRcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY29udGVudDt9LyoqXG4gICAgICogUHJvY2Vzc2VzIGlucHV0IENTUyB0aHJvdWdoIHN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICAgKiBhbmQgcmV0dXJucyB7QGxpbmsgUmVzdWx0I21hcH0uXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IHdpbGwgb25seSB3b3JrIHdpdGggc3luY2hyb25vdXMgcGx1Z2lucy5cbiAgICAgKiBJZiB0aGUgcHJvY2Vzc29yIGNvbnRhaW5zIGFueSBhc3luY2hyb25vdXMgcGx1Z2luc1xuICAgICAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgaXMgd2h5IHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAgICAgKiBmb3IgZGVidWcgcHVycG9zZSwgeW91IHNob3VsZCBhbHdheXMgdXNlIHtAbGluayBMYXp5UmVzdWx0I3RoZW59LlxuICAgICAqXG4gICAgICogQHR5cGUge1NvdXJjZU1hcEdlbmVyYXRvcn1cbiAgICAgKiBAc2VlIFJlc3VsdCNtYXBcbiAgICAgKi99LHtrZXk6XCJtYXBcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkubWFwO30vKipcbiAgICAgKiBQcm9jZXNzZXMgaW5wdXQgQ1NTIHRocm91Z2ggc3luY2hyb25vdXMgcGx1Z2luc1xuICAgICAqIGFuZCByZXR1cm5zIHtAbGluayBSZXN1bHQjcm9vdH0uXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3BlcnR5IHdpbGwgb25seSB3b3JrIHdpdGggc3luY2hyb25vdXMgcGx1Z2lucy4gSWYgdGhlIHByb2Nlc3NvclxuICAgICAqIGNvbnRhaW5zIGFueSBhc3luY2hyb25vdXMgcGx1Z2lucyBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB3aHkgdGhpcyBtZXRob2QgaXMgb25seSBmb3IgZGVidWcgcHVycG9zZSxcbiAgICAgKiB5b3Ugc2hvdWxkIGFsd2F5cyB1c2Uge0BsaW5rIExhenlSZXN1bHQjdGhlbn0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Um9vdH1cbiAgICAgKiBAc2VlIFJlc3VsdCNyb290XG4gICAgICovfSx7a2V5Olwicm9vdFwiLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5zeW5jKCkucm9vdDt9LyoqXG4gICAgICogUHJvY2Vzc2VzIGlucHV0IENTUyB0aHJvdWdoIHN5bmNocm9ub3VzIHBsdWdpbnNcbiAgICAgKiBhbmQgcmV0dXJucyB7QGxpbmsgUmVzdWx0I21lc3NhZ2VzfS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgd2lsbCBvbmx5IHdvcmsgd2l0aCBzeW5jaHJvbm91cyBwbHVnaW5zLiBJZiB0aGUgcHJvY2Vzc29yXG4gICAgICogY29udGFpbnMgYW55IGFzeW5jaHJvbm91cyBwbHVnaW5zIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHdoeSB0aGlzIG1ldGhvZCBpcyBvbmx5IGZvciBkZWJ1ZyBwdXJwb3NlLFxuICAgICAqIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB7QGxpbmsgTGF6eVJlc3VsdCN0aGVufS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNZXNzYWdlW119XG4gICAgICogQHNlZSBSZXN1bHQjbWVzc2FnZXNcbiAgICAgKi99LHtrZXk6XCJtZXNzYWdlc1wiLGdldDpmdW5jdGlvbiBnZXQoKXtyZXR1cm4gdGhpcy5zeW5jKCkubWVzc2FnZXM7fX1dKTtyZXR1cm4gTGF6eVJlc3VsdDt9KCk7dmFyIF9kZWZhdWx0PUxhenlSZXN1bHQ7LyoqXG4gKiBAY2FsbGJhY2sgb25GdWxmaWxsZWRcbiAqIEBwYXJhbSB7UmVzdWx0fSByZXN1bHRcbiAqLyAvKipcbiAqIEBjYWxsYmFjayBvblJlamVjdGVkXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICovZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpO30se1wiLi9tYXAtZ2VuZXJhdG9yXCI6NDcsXCIuL3BhcnNlXCI6NDksXCIuL3Jlc3VsdFwiOjU0LFwiLi9zdHJpbmdpZnlcIjo1OCxcIi4vd2Fybi1vbmNlXCI6NjEsXCJfcHJvY2Vzc1wiOjYzfV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDsvKipcbiAqIENvbnRhaW5zIGhlbHBlcnMgZm9yIHNhZmVseSBzcGxpdHRpbmcgbGlzdHMgb2YgQ1NTIHZhbHVlcyxcbiAqIHByZXNlcnZpbmcgcGFyZW50aGVzZXMgYW5kIHF1b3Rlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbGlzdCA9IHBvc3Rjc3MubGlzdFxuICpcbiAqIEBuYW1lc3BhY2UgbGlzdFxuICovdmFyIGxpc3Q9e3NwbGl0OmZ1bmN0aW9uIHNwbGl0KHN0cmluZyxzZXBhcmF0b3JzLGxhc3Qpe3ZhciBhcnJheT1bXTt2YXIgY3VycmVudD0nJzt2YXIgc3BsaXQ9ZmFsc2U7dmFyIGZ1bmM9MDt2YXIgcXVvdGU9ZmFsc2U7dmFyIGVzY2FwZT1mYWxzZTtmb3IodmFyIGk9MDtpPHN0cmluZy5sZW5ndGg7aSsrKXt2YXIgbGV0dGVyPXN0cmluZ1tpXTtpZihxdW90ZSl7aWYoZXNjYXBlKXtlc2NhcGU9ZmFsc2U7fWVsc2UgaWYobGV0dGVyPT09J1xcXFwnKXtlc2NhcGU9dHJ1ZTt9ZWxzZSBpZihsZXR0ZXI9PT1xdW90ZSl7cXVvdGU9ZmFsc2U7fX1lbHNlIGlmKGxldHRlcj09PSdcIid8fGxldHRlcj09PSdcXCcnKXtxdW90ZT1sZXR0ZXI7fWVsc2UgaWYobGV0dGVyPT09JygnKXtmdW5jKz0xO31lbHNlIGlmKGxldHRlcj09PScpJyl7aWYoZnVuYz4wKWZ1bmMtPTE7fWVsc2UgaWYoZnVuYz09PTApe2lmKHNlcGFyYXRvcnMuaW5kZXhPZihsZXR0ZXIpIT09LTEpc3BsaXQ9dHJ1ZTt9aWYoc3BsaXQpe2lmKGN1cnJlbnQhPT0nJylhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtjdXJyZW50PScnO3NwbGl0PWZhbHNlO31lbHNle2N1cnJlbnQrPWxldHRlcjt9fWlmKGxhc3R8fGN1cnJlbnQhPT0nJylhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtyZXR1cm4gYXJyYXk7fSwvKipcbiAgICogU2FmZWx5IHNwbGl0cyBzcGFjZS1zZXBhcmF0ZWQgdmFsdWVzIChzdWNoIGFzIHRob3NlIGZvciBgYmFja2dyb3VuZGAsXG4gICAqIGBib3JkZXItcmFkaXVzYCwgYW5kIG90aGVyIHNob3J0aGFuZCBwcm9wZXJ0aWVzKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTcGFjZS1zZXBhcmF0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gU3BsaXQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwb3N0Y3NzLmxpc3Quc3BhY2UoJzFweCBjYWxjKDEwJSArIDFweCknKSAvLz0+IFsnMXB4JywgJ2NhbGMoMTAlICsgMXB4KSddXG4gICAqL3NwYWNlOmZ1bmN0aW9uIHNwYWNlKHN0cmluZyl7dmFyIHNwYWNlcz1bJyAnLCdcXG4nLCdcXHQnXTtyZXR1cm4gbGlzdC5zcGxpdChzdHJpbmcsc3BhY2VzKTt9LC8qKlxuICAgKiBTYWZlbHkgc3BsaXRzIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXMgKHN1Y2ggYXMgdGhvc2UgZm9yIGB0cmFuc2l0aW9uLSpgXG4gICAqIGFuZCBgYmFja2dyb3VuZGAgcHJvcGVydGllcykuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQ29tbWEtc2VwYXJhdGVkIHZhbHVlcy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nW119IFNwbGl0IHZhbHVlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy5saXN0LmNvbW1hKCdibGFjaywgbGluZWFyLWdyYWRpZW50KHdoaXRlLCBibGFjayknKVxuICAgKiAvLz0+IFsnYmxhY2snLCAnbGluZWFyLWdyYWRpZW50KHdoaXRlLCBibGFjayknXVxuICAgKi9jb21tYTpmdW5jdGlvbiBjb21tYShzdHJpbmcpe3JldHVybiBsaXN0LnNwbGl0KHN0cmluZyxbJywnXSx0cnVlKTt9fTt2YXIgX2RlZmF1bHQ9bGlzdDtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHt9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKEJ1ZmZlcil7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfc291cmNlTWFwPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInNvdXJjZS1tYXBcIikpO3ZhciBfcGF0aD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwYXRoXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O312YXIgTWFwR2VuZXJhdG9yPS8qI19fUFVSRV9fKi9mdW5jdGlvbigpe2Z1bmN0aW9uIE1hcEdlbmVyYXRvcihzdHJpbmdpZnkscm9vdCxvcHRzKXt0aGlzLnN0cmluZ2lmeT1zdHJpbmdpZnk7dGhpcy5tYXBPcHRzPW9wdHMubWFwfHx7fTt0aGlzLnJvb3Q9cm9vdDt0aGlzLm9wdHM9b3B0czt9dmFyIF9wcm90bz1NYXBHZW5lcmF0b3IucHJvdG90eXBlO19wcm90by5pc01hcD1mdW5jdGlvbiBpc01hcCgpe2lmKHR5cGVvZiB0aGlzLm9wdHMubWFwIT09J3VuZGVmaW5lZCcpe3JldHVybiEhdGhpcy5vcHRzLm1hcDt9cmV0dXJuIHRoaXMucHJldmlvdXMoKS5sZW5ndGg+MDt9O19wcm90by5wcmV2aW91cz1mdW5jdGlvbiBwcmV2aW91cygpe3ZhciBfdGhpcz10aGlzO2lmKCF0aGlzLnByZXZpb3VzTWFwcyl7dGhpcy5wcmV2aW91c01hcHM9W107dGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZSl7aWYobm9kZS5zb3VyY2UmJm5vZGUuc291cmNlLmlucHV0Lm1hcCl7dmFyIG1hcD1ub2RlLnNvdXJjZS5pbnB1dC5tYXA7aWYoX3RoaXMucHJldmlvdXNNYXBzLmluZGV4T2YobWFwKT09PS0xKXtfdGhpcy5wcmV2aW91c01hcHMucHVzaChtYXApO319fSk7fXJldHVybiB0aGlzLnByZXZpb3VzTWFwczt9O19wcm90by5pc0lubGluZT1mdW5jdGlvbiBpc0lubGluZSgpe2lmKHR5cGVvZiB0aGlzLm1hcE9wdHMuaW5saW5lIT09J3VuZGVmaW5lZCcpe3JldHVybiB0aGlzLm1hcE9wdHMuaW5saW5lO312YXIgYW5ub3RhdGlvbj10aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtpZih0eXBlb2YgYW5ub3RhdGlvbiE9PSd1bmRlZmluZWQnJiZhbm5vdGF0aW9uIT09dHJ1ZSl7cmV0dXJuIGZhbHNlO31pZih0aGlzLnByZXZpb3VzKCkubGVuZ3RoKXtyZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaSl7cmV0dXJuIGkuaW5saW5lO30pO31yZXR1cm4gdHJ1ZTt9O19wcm90by5pc1NvdXJjZXNDb250ZW50PWZ1bmN0aW9uIGlzU291cmNlc0NvbnRlbnQoKXtpZih0eXBlb2YgdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50IT09J3VuZGVmaW5lZCcpe3JldHVybiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQ7fWlmKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpe3JldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpKXtyZXR1cm4gaS53aXRoQ29udGVudCgpO30pO31yZXR1cm4gdHJ1ZTt9O19wcm90by5jbGVhckFubm90YXRpb249ZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9uKCl7aWYodGhpcy5tYXBPcHRzLmFubm90YXRpb249PT1mYWxzZSlyZXR1cm47dmFyIG5vZGU7Zm9yKHZhciBpPXRoaXMucm9vdC5ub2Rlcy5sZW5ndGgtMTtpPj0wO2ktLSl7bm9kZT10aGlzLnJvb3Qubm9kZXNbaV07aWYobm9kZS50eXBlIT09J2NvbW1lbnQnKWNvbnRpbnVlO2lmKG5vZGUudGV4dC5pbmRleE9mKCcjIHNvdXJjZU1hcHBpbmdVUkw9Jyk9PT0wKXt0aGlzLnJvb3QucmVtb3ZlQ2hpbGQoaSk7fX19O19wcm90by5zZXRTb3VyY2VzQ29udGVudD1mdW5jdGlvbiBzZXRTb3VyY2VzQ29udGVudCgpe3ZhciBfdGhpczI9dGhpczt2YXIgYWxyZWFkeT17fTt0aGlzLnJvb3Qud2FsayhmdW5jdGlvbihub2RlKXtpZihub2RlLnNvdXJjZSl7dmFyIGZyb209bm9kZS5zb3VyY2UuaW5wdXQuZnJvbTtpZihmcm9tJiYhYWxyZWFkeVtmcm9tXSl7YWxyZWFkeVtmcm9tXT10cnVlO3ZhciByZWxhdGl2ZT1fdGhpczIucmVsYXRpdmUoZnJvbSk7X3RoaXMyLm1hcC5zZXRTb3VyY2VDb250ZW50KHJlbGF0aXZlLG5vZGUuc291cmNlLmlucHV0LmNzcyk7fX19KTt9O19wcm90by5hcHBseVByZXZNYXBzPWZ1bmN0aW9uIGFwcGx5UHJldk1hcHMoKXtmb3IodmFyIF9pdGVyYXRvcj10aGlzLnByZXZpb3VzKCksX2lzQXJyYXk9QXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLF9pPTAsX2l0ZXJhdG9yPV9pc0FycmF5P19pdGVyYXRvcjpfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspe3ZhciBfcmVmO2lmKF9pc0FycmF5KXtpZihfaT49X2l0ZXJhdG9yLmxlbmd0aClicmVhaztfcmVmPV9pdGVyYXRvcltfaSsrXTt9ZWxzZXtfaT1faXRlcmF0b3IubmV4dCgpO2lmKF9pLmRvbmUpYnJlYWs7X3JlZj1faS52YWx1ZTt9dmFyIHByZXY9X3JlZjt2YXIgZnJvbT10aGlzLnJlbGF0aXZlKHByZXYuZmlsZSk7dmFyIHJvb3Q9cHJldi5yb290fHxfcGF0aFtcImRlZmF1bHRcIl0uZGlybmFtZShwcmV2LmZpbGUpO3ZhciBtYXA9dm9pZCAwO2lmKHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudD09PWZhbHNlKXttYXA9bmV3IF9zb3VyY2VNYXBbXCJkZWZhdWx0XCJdLlNvdXJjZU1hcENvbnN1bWVyKHByZXYudGV4dCk7aWYobWFwLnNvdXJjZXNDb250ZW50KXttYXAuc291cmNlc0NvbnRlbnQ9bWFwLnNvdXJjZXNDb250ZW50Lm1hcChmdW5jdGlvbigpe3JldHVybiBudWxsO30pO319ZWxzZXttYXA9cHJldi5jb25zdW1lcigpO310aGlzLm1hcC5hcHBseVNvdXJjZU1hcChtYXAsZnJvbSx0aGlzLnJlbGF0aXZlKHJvb3QpKTt9fTtfcHJvdG8uaXNBbm5vdGF0aW9uPWZ1bmN0aW9uIGlzQW5ub3RhdGlvbigpe2lmKHRoaXMuaXNJbmxpbmUoKSl7cmV0dXJuIHRydWU7fWlmKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiE9PSd1bmRlZmluZWQnKXtyZXR1cm4gdGhpcy5tYXBPcHRzLmFubm90YXRpb247fWlmKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpe3JldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpKXtyZXR1cm4gaS5hbm5vdGF0aW9uO30pO31yZXR1cm4gdHJ1ZTt9O19wcm90by50b0Jhc2U2ND1mdW5jdGlvbiB0b0Jhc2U2NChzdHIpe2lmKEJ1ZmZlcil7cmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO31yZXR1cm4gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTt9O19wcm90by5hZGRBbm5vdGF0aW9uPWZ1bmN0aW9uIGFkZEFubm90YXRpb24oKXt2YXIgY29udGVudDtpZih0aGlzLmlzSW5saW5lKCkpe2NvbnRlbnQ9J2RhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyt0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpO31lbHNlIGlmKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbj09PSdzdHJpbmcnKXtjb250ZW50PXRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO31lbHNle2NvbnRlbnQ9dGhpcy5vdXRwdXRGaWxlKCkrJy5tYXAnO312YXIgZW9sPSdcXG4nO2lmKHRoaXMuY3NzLmluZGV4T2YoJ1xcclxcbicpIT09LTEpZW9sPSdcXHJcXG4nO3RoaXMuY3NzKz1lb2wrJy8qIyBzb3VyY2VNYXBwaW5nVVJMPScrY29udGVudCsnICovJzt9O19wcm90by5vdXRwdXRGaWxlPWZ1bmN0aW9uIG91dHB1dEZpbGUoKXtpZih0aGlzLm9wdHMudG8pe3JldHVybiB0aGlzLnJlbGF0aXZlKHRoaXMub3B0cy50byk7fWlmKHRoaXMub3B0cy5mcm9tKXtyZXR1cm4gdGhpcy5yZWxhdGl2ZSh0aGlzLm9wdHMuZnJvbSk7fXJldHVybid0by5jc3MnO307X3Byb3RvLmdlbmVyYXRlTWFwPWZ1bmN0aW9uIGdlbmVyYXRlTWFwKCl7dGhpcy5nZW5lcmF0ZVN0cmluZygpO2lmKHRoaXMuaXNTb3VyY2VzQ29udGVudCgpKXRoaXMuc2V0U291cmNlc0NvbnRlbnQoKTtpZih0aGlzLnByZXZpb3VzKCkubGVuZ3RoPjApdGhpcy5hcHBseVByZXZNYXBzKCk7aWYodGhpcy5pc0Fubm90YXRpb24oKSl0aGlzLmFkZEFubm90YXRpb24oKTtpZih0aGlzLmlzSW5saW5lKCkpe3JldHVyblt0aGlzLmNzc107fXJldHVyblt0aGlzLmNzcyx0aGlzLm1hcF07fTtfcHJvdG8ucmVsYXRpdmU9ZnVuY3Rpb24gcmVsYXRpdmUoZmlsZSl7aWYoZmlsZS5pbmRleE9mKCc8Jyk9PT0wKXJldHVybiBmaWxlO2lmKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpcmV0dXJuIGZpbGU7dmFyIGZyb209dGhpcy5vcHRzLnRvP19wYXRoW1wiZGVmYXVsdFwiXS5kaXJuYW1lKHRoaXMub3B0cy50byk6Jy4nO2lmKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbj09PSdzdHJpbmcnKXtmcm9tPV9wYXRoW1wiZGVmYXVsdFwiXS5kaXJuYW1lKF9wYXRoW1wiZGVmYXVsdFwiXS5yZXNvbHZlKGZyb20sdGhpcy5tYXBPcHRzLmFubm90YXRpb24pKTt9ZmlsZT1fcGF0aFtcImRlZmF1bHRcIl0ucmVsYXRpdmUoZnJvbSxmaWxlKTtpZihfcGF0aFtcImRlZmF1bHRcIl0uc2VwPT09J1xcXFwnKXtyZXR1cm4gZmlsZS5yZXBsYWNlKC9cXFxcL2csJy8nKTt9cmV0dXJuIGZpbGU7fTtfcHJvdG8uc291cmNlUGF0aD1mdW5jdGlvbiBzb3VyY2VQYXRoKG5vZGUpe2lmKHRoaXMubWFwT3B0cy5mcm9tKXtyZXR1cm4gdGhpcy5tYXBPcHRzLmZyb207fXJldHVybiB0aGlzLnJlbGF0aXZlKG5vZGUuc291cmNlLmlucHV0LmZyb20pO307X3Byb3RvLmdlbmVyYXRlU3RyaW5nPWZ1bmN0aW9uIGdlbmVyYXRlU3RyaW5nKCl7dmFyIF90aGlzMz10aGlzO3RoaXMuY3NzPScnO3RoaXMubWFwPW5ldyBfc291cmNlTWFwW1wiZGVmYXVsdFwiXS5Tb3VyY2VNYXBHZW5lcmF0b3Ioe2ZpbGU6dGhpcy5vdXRwdXRGaWxlKCl9KTt2YXIgbGluZT0xO3ZhciBjb2x1bW49MTt2YXIgbGluZXMsbGFzdDt0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsZnVuY3Rpb24oc3RyLG5vZGUsdHlwZSl7X3RoaXMzLmNzcys9c3RyO2lmKG5vZGUmJnR5cGUhPT0nZW5kJyl7aWYobm9kZS5zb3VyY2UmJm5vZGUuc291cmNlLnN0YXJ0KXtfdGhpczMubWFwLmFkZE1hcHBpbmcoe3NvdXJjZTpfdGhpczMuc291cmNlUGF0aChub2RlKSxnZW5lcmF0ZWQ6e2xpbmU6bGluZSxjb2x1bW46Y29sdW1uLTF9LG9yaWdpbmFsOntsaW5lOm5vZGUuc291cmNlLnN0YXJ0LmxpbmUsY29sdW1uOm5vZGUuc291cmNlLnN0YXJ0LmNvbHVtbi0xfX0pO31lbHNle190aGlzMy5tYXAuYWRkTWFwcGluZyh7c291cmNlOic8bm8gc291cmNlPicsb3JpZ2luYWw6e2xpbmU6MSxjb2x1bW46MH0sZ2VuZXJhdGVkOntsaW5lOmxpbmUsY29sdW1uOmNvbHVtbi0xfX0pO319bGluZXM9c3RyLm1hdGNoKC9cXG4vZyk7aWYobGluZXMpe2xpbmUrPWxpbmVzLmxlbmd0aDtsYXN0PXN0ci5sYXN0SW5kZXhPZignXFxuJyk7Y29sdW1uPXN0ci5sZW5ndGgtbGFzdDt9ZWxzZXtjb2x1bW4rPXN0ci5sZW5ndGg7fWlmKG5vZGUmJnR5cGUhPT0nc3RhcnQnKXt2YXIgcD1ub2RlLnBhcmVudHx8e3Jhd3M6e319O2lmKG5vZGUudHlwZSE9PSdkZWNsJ3x8bm9kZSE9PXAubGFzdHx8cC5yYXdzLnNlbWljb2xvbil7aWYobm9kZS5zb3VyY2UmJm5vZGUuc291cmNlLmVuZCl7X3RoaXMzLm1hcC5hZGRNYXBwaW5nKHtzb3VyY2U6X3RoaXMzLnNvdXJjZVBhdGgobm9kZSksZ2VuZXJhdGVkOntsaW5lOmxpbmUsY29sdW1uOmNvbHVtbi0yfSxvcmlnaW5hbDp7bGluZTpub2RlLnNvdXJjZS5lbmQubGluZSxjb2x1bW46bm9kZS5zb3VyY2UuZW5kLmNvbHVtbi0xfX0pO31lbHNle190aGlzMy5tYXAuYWRkTWFwcGluZyh7c291cmNlOic8bm8gc291cmNlPicsb3JpZ2luYWw6e2xpbmU6MSxjb2x1bW46MH0sZ2VuZXJhdGVkOntsaW5lOmxpbmUsY29sdW1uOmNvbHVtbi0xfX0pO319fX0pO307X3Byb3RvLmdlbmVyYXRlPWZ1bmN0aW9uIGdlbmVyYXRlKCl7dGhpcy5jbGVhckFubm90YXRpb24oKTtpZih0aGlzLmlzTWFwKCkpe3JldHVybiB0aGlzLmdlbmVyYXRlTWFwKCk7fXZhciByZXN1bHQ9Jyc7dGhpcy5zdHJpbmdpZnkodGhpcy5yb290LGZ1bmN0aW9uKGkpe3Jlc3VsdCs9aTt9KTtyZXR1cm5bcmVzdWx0XTt9O3JldHVybiBNYXBHZW5lcmF0b3I7fSgpO3ZhciBfZGVmYXVsdD1NYXBHZW5lcmF0b3I7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKTt9LHtcImJ1ZmZlclwiOjMsXCJwYXRoXCI6MzgsXCJzb3VyY2UtbWFwXCI6Nzh9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3Mpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2Nzc1N5bnRheEVycm9yPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY3NzLXN5bnRheC1lcnJvclwiKSk7dmFyIF9zdHJpbmdpZmllcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmaWVyXCIpKTt2YXIgX3N0cmluZ2lmeT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeVwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gY2xvbmVOb2RlKG9iaixwYXJlbnQpe3ZhciBjbG9uZWQ9bmV3IG9iai5jb25zdHJ1Y3RvcigpO2Zvcih2YXIgaSBpbiBvYmope2lmKCFvYmouaGFzT3duUHJvcGVydHkoaSkpY29udGludWU7dmFyIHZhbHVlPW9ialtpXTt2YXIgdHlwZT1fdHlwZW9mKHZhbHVlKTtpZihpPT09J3BhcmVudCcmJnR5cGU9PT0nb2JqZWN0Jyl7aWYocGFyZW50KWNsb25lZFtpXT1wYXJlbnQ7fWVsc2UgaWYoaT09PSdzb3VyY2UnKXtjbG9uZWRbaV09dmFsdWU7fWVsc2UgaWYodmFsdWUgaW5zdGFuY2VvZiBBcnJheSl7Y2xvbmVkW2ldPXZhbHVlLm1hcChmdW5jdGlvbihqKXtyZXR1cm4gY2xvbmVOb2RlKGosY2xvbmVkKTt9KTt9ZWxzZXtpZih0eXBlPT09J29iamVjdCcmJnZhbHVlIT09bnVsbCl2YWx1ZT1jbG9uZU5vZGUodmFsdWUpO2Nsb25lZFtpXT12YWx1ZTt9fXJldHVybiBjbG9uZWQ7fS8qKlxuICogQWxsIG5vZGUgY2xhc3NlcyBpbmhlcml0IHRoZSBmb2xsb3dpbmcgY29tbW9uIG1ldGhvZHMuXG4gKlxuICogQGFic3RyYWN0XG4gKi92YXIgTm9kZT0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXsvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IFtkZWZhdWx0c10gVmFsdWUgZm9yIG5vZGUgcHJvcGVydGllcy5cbiAgICovZnVuY3Rpb24gTm9kZShkZWZhdWx0cyl7aWYoZGVmYXVsdHM9PT12b2lkIDApe2RlZmF1bHRzPXt9O310aGlzLnJhd3M9e307aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe2lmKF90eXBlb2YoZGVmYXVsdHMpIT09J29iamVjdCcmJnR5cGVvZiBkZWZhdWx0cyE9PSd1bmRlZmluZWQnKXt0aHJvdyBuZXcgRXJyb3IoJ1Bvc3RDU1Mgbm9kZXMgY29uc3RydWN0b3IgYWNjZXB0cyBvYmplY3QsIG5vdCAnK0pTT04uc3RyaW5naWZ5KGRlZmF1bHRzKSk7fX1mb3IodmFyIG5hbWUgaW4gZGVmYXVsdHMpe3RoaXNbbmFtZV09ZGVmYXVsdHNbbmFtZV07fX0vKipcbiAgICogUmV0dXJucyBhIGBDc3NTeW50YXhFcnJvcmAgaW5zdGFuY2UgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgcG9zaXRpb25cbiAgICogb2YgdGhlIG5vZGUgaW4gdGhlIHNvdXJjZSwgc2hvd2luZyBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBhbmQgYWxzb1xuICAgKiBhIHNtYWxsIGV4Y2VycHQgdG8gZmFjaWxpdGF0ZSBkZWJ1Z2dpbmcuXG4gICAqXG4gICAqIElmIHByZXNlbnQsIGFuIGlucHV0IHNvdXJjZSBtYXAgd2lsbCBiZSB1c2VkIHRvIGdldCB0aGUgb3JpZ2luYWwgcG9zaXRpb25cbiAgICogb2YgdGhlIHNvdXJjZSwgZXZlbiBmcm9tIGEgcHJldmlvdXMgY29tcGlsYXRpb24gc3RlcFxuICAgKiAoZS5nLiwgZnJvbSBTYXNzIGNvbXBpbGF0aW9uKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgcHJvZHVjZXMgdmVyeSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlICAgICBFcnJvciBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAgICAgIE9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnBsdWdpbiBQbHVnaW4gbmFtZSB0aGF0IGNyZWF0ZWQgdGhpcyBlcnJvci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3RDU1Mgd2lsbCBzZXQgaXQgYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud29yZCAgIEEgd29yZCBpbnNpZGUgYSBub2Rl4oCZcyBzdHJpbmcgdGhhdCBzaG91bGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGhpZ2hsaWdodGVkIGFzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5pbmRleCAgQW4gaW5kZXggaW5zaWRlIGEgbm9kZeKAmXMgc3RyaW5nIHRoYXQgc2hvdWxkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBoaWdobGlnaHRlZCBhcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7Q3NzU3ludGF4RXJyb3J9IEVycm9yIG9iamVjdCB0byB0aHJvdyBpdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKCF2YXJpYWJsZXNbbmFtZV0pIHtcbiAgICogICB0aHJvdyBkZWNsLmVycm9yKCdVbmtub3duIHZhcmlhYmxlICcgKyBuYW1lLCB7IHdvcmQ6IG5hbWUgfSlcbiAgICogICAvLyBDc3NTeW50YXhFcnJvcjogcG9zdGNzcy12YXJzOmEuc2Fzczo0OjM6IFVua25vd24gdmFyaWFibGUgJGJsYWNrXG4gICAqICAgLy8gICBjb2xvcjogJGJsYWNrXG4gICAqICAgLy8gYVxuICAgKiAgIC8vICAgICAgICAgIF5cbiAgICogICAvLyAgIGJhY2tncm91bmQ6IHdoaXRlXG4gICAqIH1cbiAgICovdmFyIF9wcm90bz1Ob2RlLnByb3RvdHlwZTtfcHJvdG8uZXJyb3I9ZnVuY3Rpb24gZXJyb3IobWVzc2FnZSxvcHRzKXtpZihvcHRzPT09dm9pZCAwKXtvcHRzPXt9O31pZih0aGlzLnNvdXJjZSl7dmFyIHBvcz10aGlzLnBvc2l0aW9uQnkob3B0cyk7cmV0dXJuIHRoaXMuc291cmNlLmlucHV0LmVycm9yKG1lc3NhZ2UscG9zLmxpbmUscG9zLmNvbHVtbixvcHRzKTt9cmV0dXJuIG5ldyBfY3NzU3ludGF4RXJyb3JbXCJkZWZhdWx0XCJdKG1lc3NhZ2UpO30vKipcbiAgICogVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIGZvciB7QGxpbmsgUmVzdWx0I3dhcm59LlxuICAgKlxuICAgKiBAcGFyYW0ge1Jlc3VsdH0gcmVzdWx0ICAgICAgVGhlIHtAbGluayBSZXN1bHR9IGluc3RhbmNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgd2FybmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgICAgICAgIFdhcm5pbmcgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAgICAgIE9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMucGx1Z2luIFBsdWdpbiBuYW1lIHRoYXQgY3JlYXRlZCB0aGlzIHdhcm5pbmcuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3N0Q1NTIHdpbGwgc2V0IGl0IGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndvcmQgICBBIHdvcmQgaW5zaWRlIGEgbm9kZeKAmXMgc3RyaW5nIHRoYXQgc2hvdWxkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBoaWdobGlnaHRlZCBhcyB0aGUgc291cmNlIG9mIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5pbmRleCAgQW4gaW5kZXggaW5zaWRlIGEgbm9kZeKAmXMgc3RyaW5nIHRoYXQgc2hvdWxkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBoaWdobGlnaHRlZCBhcyB0aGUgc291cmNlIG9mIHRoZSB3YXJuaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXYXJuaW5nfSBDcmVhdGVkIHdhcm5pbmcgb2JqZWN0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBwbHVnaW4gPSBwb3N0Y3NzLnBsdWdpbigncG9zdGNzcy1kZXByZWNhdGVkJywgKCkgPT4ge1xuICAgKiAgIHJldHVybiAocm9vdCwgcmVzdWx0KSA9PiB7XG4gICAqICAgICByb290LndhbGtEZWNscygnYmFkJywgZGVjbCA9PiB7XG4gICAqICAgICAgIGRlY2wud2FybihyZXN1bHQsICdEZXByZWNhdGVkIHByb3BlcnR5IGJhZCcpXG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICovO19wcm90by53YXJuPWZ1bmN0aW9uIHdhcm4ocmVzdWx0LHRleHQsb3B0cyl7dmFyIGRhdGE9e25vZGU6dGhpc307Zm9yKHZhciBpIGluIG9wdHMpe2RhdGFbaV09b3B0c1tpXTt9cmV0dXJuIHJlc3VsdC53YXJuKHRleHQsZGF0YSk7fS8qKlxuICAgKiBSZW1vdmVzIHRoZSBub2RlIGZyb20gaXRzIHBhcmVudCBhbmQgY2xlYW5zIHRoZSBwYXJlbnQgcHJvcGVydGllc1xuICAgKiBmcm9tIHRoZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmIChkZWNsLnByb3AubWF0Y2goL14td2Via2l0LS8pKSB7XG4gICAqICAgZGVjbC5yZW1vdmUoKVxuICAgKiB9XG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IE5vZGUgdG8gbWFrZSBjYWxscyBjaGFpbi5cbiAgICovO19wcm90by5yZW1vdmU9ZnVuY3Rpb24gcmVtb3ZlKCl7aWYodGhpcy5wYXJlbnQpe3RoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO310aGlzLnBhcmVudD11bmRlZmluZWQ7cmV0dXJuIHRoaXM7fS8qKlxuICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5naWZpZXJ8c3ludGF4fSBbc3RyaW5naWZpZXJdIEEgc3ludGF4IHRvIHVzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBzdHJpbmcgZ2VuZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBDU1Mgc3RyaW5nIG9mIHRoaXMgbm9kZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy5ydWxlKHsgc2VsZWN0b3I6ICdhJyB9KS50b1N0cmluZygpIC8vPT4gXCJhIHt9XCJcbiAgICovO19wcm90by50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZmllcil7aWYoc3RyaW5naWZpZXI9PT12b2lkIDApe3N0cmluZ2lmaWVyPV9zdHJpbmdpZnlbXCJkZWZhdWx0XCJdO31pZihzdHJpbmdpZmllci5zdHJpbmdpZnkpc3RyaW5naWZpZXI9c3RyaW5naWZpZXIuc3RyaW5naWZ5O3ZhciByZXN1bHQ9Jyc7c3RyaW5naWZpZXIodGhpcyxmdW5jdGlvbihpKXtyZXN1bHQrPWk7fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIFJldHVybnMgYW4gZXhhY3QgY2xvbmUgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIFRoZSByZXN1bHRpbmcgY2xvbmVkIG5vZGUgYW5kIGl0cyAoY2xvbmVkKSBjaGlsZHJlbiB3aWxsIHJldGFpblxuICAgKiBjb2RlIHN0eWxlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3ZlcnJpZGVzXSBOZXcgcHJvcGVydGllcyB0byBvdmVycmlkZSBpbiB0aGUgY2xvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGRlY2wucmF3cy5iZWZvcmUgICAgLy89PiBcIlxcbiAgXCJcbiAgICogY29uc3QgY2xvbmVkID0gZGVjbC5jbG9uZSh7IHByb3A6ICctbW96LScgKyBkZWNsLnByb3AgfSlcbiAgICogY2xvbmVkLnJhd3MuYmVmb3JlICAvLz0+IFwiXFxuICBcIlxuICAgKiBjbG9uZWQudG9TdHJpbmcoKSAgIC8vPT4gLW1vei10cmFuc2Zvcm06IHNjYWxlKDApXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IENsb25lIG9mIHRoZSBub2RlLlxuICAgKi87X3Byb3RvLmNsb25lPWZ1bmN0aW9uIGNsb25lKG92ZXJyaWRlcyl7aWYob3ZlcnJpZGVzPT09dm9pZCAwKXtvdmVycmlkZXM9e307fXZhciBjbG9uZWQ9Y2xvbmVOb2RlKHRoaXMpO2Zvcih2YXIgbmFtZSBpbiBvdmVycmlkZXMpe2Nsb25lZFtuYW1lXT1vdmVycmlkZXNbbmFtZV07fXJldHVybiBjbG9uZWQ7fS8qKlxuICAgKiBTaG9ydGN1dCB0byBjbG9uZSB0aGUgbm9kZSBhbmQgaW5zZXJ0IHRoZSByZXN1bHRpbmcgY2xvbmVkIG5vZGVcbiAgICogYmVmb3JlIHRoZSBjdXJyZW50IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3ZlcnJpZGVzXSBNZXcgcHJvcGVydGllcyB0byBvdmVycmlkZSBpbiB0aGUgY2xvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGRlY2wuY2xvbmVCZWZvcmUoeyBwcm9wOiAnLW1vei0nICsgZGVjbC5wcm9wIH0pXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IE5ldyBub2RlXG4gICAqLztfcHJvdG8uY2xvbmVCZWZvcmU9ZnVuY3Rpb24gY2xvbmVCZWZvcmUob3ZlcnJpZGVzKXtpZihvdmVycmlkZXM9PT12b2lkIDApe292ZXJyaWRlcz17fTt9dmFyIGNsb25lZD10aGlzLmNsb25lKG92ZXJyaWRlcyk7dGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsY2xvbmVkKTtyZXR1cm4gY2xvbmVkO30vKipcbiAgICogU2hvcnRjdXQgdG8gY2xvbmUgdGhlIG5vZGUgYW5kIGluc2VydCB0aGUgcmVzdWx0aW5nIGNsb25lZCBub2RlXG4gICAqIGFmdGVyIHRoZSBjdXJyZW50IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3ZlcnJpZGVzXSBOZXcgcHJvcGVydGllcyB0byBvdmVycmlkZSBpbiB0aGUgY2xvbmUuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IE5ldyBub2RlLlxuICAgKi87X3Byb3RvLmNsb25lQWZ0ZXI9ZnVuY3Rpb24gY2xvbmVBZnRlcihvdmVycmlkZXMpe2lmKG92ZXJyaWRlcz09PXZvaWQgMCl7b3ZlcnJpZGVzPXt9O312YXIgY2xvbmVkPXRoaXMuY2xvbmUob3ZlcnJpZGVzKTt0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLGNsb25lZCk7cmV0dXJuIGNsb25lZDt9LyoqXG4gICAqIEluc2VydHMgbm9kZShzKSBiZWZvcmUgdGhlIGN1cnJlbnQgbm9kZSBhbmQgcmVtb3ZlcyB0aGUgY3VycmVudCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLk5vZGV9IG5vZGVzIE1vZGUocykgdG8gcmVwbGFjZSBjdXJyZW50IG9uZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKGF0cnVsZS5uYW1lID09PSAnbWl4aW4nKSB7XG4gICAqICAgYXRydWxlLnJlcGxhY2VXaXRoKG1peGluUnVsZXNbYXRydWxlLnBhcmFtc10pXG4gICAqIH1cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gQ3VycmVudCBub2RlIHRvIG1ldGhvZHMgY2hhaW4uXG4gICAqLztfcHJvdG8ucmVwbGFjZVdpdGg9ZnVuY3Rpb24gcmVwbGFjZVdpdGgoKXtpZih0aGlzLnBhcmVudCl7Zm9yKHZhciBfbGVuPWFyZ3VtZW50cy5sZW5ndGgsbm9kZXM9bmV3IEFycmF5KF9sZW4pLF9rZXk9MDtfa2V5PF9sZW47X2tleSsrKXtub2Rlc1tfa2V5XT1hcmd1bWVudHNbX2tleV07fWZvcih2YXIgX2k9MCxfbm9kZXM9bm9kZXM7X2k8X25vZGVzLmxlbmd0aDtfaSsrKXt2YXIgbm9kZT1fbm9kZXNbX2ldO3RoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLG5vZGUpO310aGlzLnJlbW92ZSgpO31yZXR1cm4gdGhpczt9LyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgY2hpbGQgb2YgdGhlIG5vZGXigJlzIHBhcmVudC5cbiAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgY3VycmVudCBub2RlIGlzIHRoZSBsYXN0IGNoaWxkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfHVuZGVmaW5lZH0gTmV4dCBub2RlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAoY29tbWVudC50ZXh0ID09PSAnZGVsZXRlIG5leHQnKSB7XG4gICAqICAgY29uc3QgbmV4dCA9IGNvbW1lbnQubmV4dCgpXG4gICAqICAgaWYgKG5leHQpIHtcbiAgICogICAgIG5leHQucmVtb3ZlKClcbiAgICogICB9XG4gICAqIH1cbiAgICovO19wcm90by5uZXh0PWZ1bmN0aW9uIG5leHQoKXtpZighdGhpcy5wYXJlbnQpcmV0dXJuIHVuZGVmaW5lZDt2YXIgaW5kZXg9dGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7cmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4KzFdO30vKipcbiAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgY2hpbGQgb2YgdGhlIG5vZGXigJlzIHBhcmVudC5cbiAgICogUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgY3VycmVudCBub2RlIGlzIHRoZSBmaXJzdCBjaGlsZC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IFByZXZpb3VzIG5vZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGFubm90YXRpb24gPSBkZWNsLnByZXYoKVxuICAgKiBpZiAoYW5ub3RhdGlvbi50eXBlID09PSAnY29tbWVudCcpIHtcbiAgICogICByZWFkQW5ub3RhdGlvbihhbm5vdGF0aW9uLnRleHQpXG4gICAqIH1cbiAgICovO19wcm90by5wcmV2PWZ1bmN0aW9uIHByZXYoKXtpZighdGhpcy5wYXJlbnQpcmV0dXJuIHVuZGVmaW5lZDt2YXIgaW5kZXg9dGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7cmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4LTFdO30vKipcbiAgICogSW5zZXJ0IG5ldyBub2RlIGJlZm9yZSBjdXJyZW50IG5vZGUgdG8gY3VycmVudCBub2Rl4oCZcyBwYXJlbnQuXG4gICAqXG4gICAqIEp1c3QgYWxpYXMgZm9yIGBub2RlLnBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgYWRkKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZXxvYmplY3R8c3RyaW5nfE5vZGVbXX0gYWRkIE5ldyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGlzIG5vZGUgZm9yIG1ldGhvZHMgY2hhaW4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGRlY2wuYmVmb3JlKCdjb250ZW50OiBcIlwiJylcbiAgICovO19wcm90by5iZWZvcmU9ZnVuY3Rpb24gYmVmb3JlKGFkZCl7dGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsYWRkKTtyZXR1cm4gdGhpczt9LyoqXG4gICAqIEluc2VydCBuZXcgbm9kZSBhZnRlciBjdXJyZW50IG5vZGUgdG8gY3VycmVudCBub2Rl4oCZcyBwYXJlbnQuXG4gICAqXG4gICAqIEp1c3QgYWxpYXMgZm9yIGBub2RlLnBhcmVudC5pbnNlcnRBZnRlcihub2RlLCBhZGQpYC5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfG9iamVjdHxzdHJpbmd8Tm9kZVtdfSBhZGQgTmV3IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRoaXMgbm9kZSBmb3IgbWV0aG9kcyBjaGFpbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZGVjbC5hZnRlcignY29sb3I6IGJsYWNrJylcbiAgICovO19wcm90by5hZnRlcj1mdW5jdGlvbiBhZnRlcihhZGQpe3RoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsYWRkKTtyZXR1cm4gdGhpczt9O19wcm90by50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7dmFyIGZpeGVkPXt9O2Zvcih2YXIgbmFtZSBpbiB0aGlzKXtpZighdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSljb250aW51ZTtpZihuYW1lPT09J3BhcmVudCcpY29udGludWU7dmFyIHZhbHVlPXRoaXNbbmFtZV07aWYodmFsdWUgaW5zdGFuY2VvZiBBcnJheSl7Zml4ZWRbbmFtZV09dmFsdWUubWFwKGZ1bmN0aW9uKGkpe2lmKF90eXBlb2YoaSk9PT0nb2JqZWN0JyYmaS50b0pTT04pe3JldHVybiBpLnRvSlNPTigpO31lbHNle3JldHVybiBpO319KTt9ZWxzZSBpZihfdHlwZW9mKHZhbHVlKT09PSdvYmplY3QnJiZ2YWx1ZS50b0pTT04pe2ZpeGVkW25hbWVdPXZhbHVlLnRvSlNPTigpO31lbHNle2ZpeGVkW25hbWVdPXZhbHVlO319cmV0dXJuIGZpeGVkO30vKipcbiAgICogUmV0dXJucyBhIHtAbGluayBOb2RlI3Jhd3N9IHZhbHVlLiBJZiB0aGUgbm9kZSBpcyBtaXNzaW5nXG4gICAqIHRoZSBjb2RlIHN0eWxlIHByb3BlcnR5IChiZWNhdXNlIHRoZSBub2RlIHdhcyBtYW51YWxseSBidWlsdCBvciBjbG9uZWQpLFxuICAgKiBQb3N0Q1NTIHdpbGwgdHJ5IHRvIGF1dG9kZXRlY3QgdGhlIGNvZGUgc3R5bGUgcHJvcGVydHkgYnkgbG9va2luZ1xuICAgKiBhdCBvdGhlciBub2RlcyBpbiB0aGUgdHJlZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgICAgICAgICAgTmFtZSBvZiBjb2RlIHN0eWxlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RlZmF1bHRUeXBlXSBOYW1lIG9mIGRlZmF1bHQgdmFsdWUsIGl0IGNhbiBiZSBtaXNzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGhlIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHByb3AuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhIHsgYmFja2dyb3VuZDogd2hpdGUgfScpXG4gICAqIHJvb3Qubm9kZXNbMF0uYXBwZW5kKHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdibGFjaycgfSlcbiAgICogcm9vdC5ub2Rlc1swXS5ub2Rlc1sxXS5yYXdzLmJlZm9yZSAgIC8vPT4gdW5kZWZpbmVkXG4gICAqIHJvb3Qubm9kZXNbMF0ubm9kZXNbMV0ucmF3KCdiZWZvcmUnKSAvLz0+ICcgJ1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvZGUgc3R5bGUgdmFsdWUuXG4gICAqLztfcHJvdG8ucmF3PWZ1bmN0aW9uIHJhdyhwcm9wLGRlZmF1bHRUeXBlKXt2YXIgc3RyPW5ldyBfc3RyaW5naWZpZXJbXCJkZWZhdWx0XCJdKCk7cmV0dXJuIHN0ci5yYXcodGhpcyxwcm9wLGRlZmF1bHRUeXBlKTt9LyoqXG4gICAqIEZpbmRzIHRoZSBSb290IGluc3RhbmNlIG9mIHRoZSBub2Rl4oCZcyB0cmVlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByb290Lm5vZGVzWzBdLm5vZGVzWzBdLnJvb3QoKSA9PT0gcm9vdFxuICAgKlxuICAgKiBAcmV0dXJuIHtSb290fSBSb290IHBhcmVudC5cbiAgICovO19wcm90by5yb290PWZ1bmN0aW9uIHJvb3QoKXt2YXIgcmVzdWx0PXRoaXM7d2hpbGUocmVzdWx0LnBhcmVudCl7cmVzdWx0PXJlc3VsdC5wYXJlbnQ7fXJldHVybiByZXN1bHQ7fS8qKlxuICAgKiBDbGVhciB0aGUgY29kZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwQmV0d2Vlbl0gS2VlcCB0aGUgcmF3cy5iZXR3ZWVuIHN5bWJvbHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5yYXdzLmJlZm9yZSAgLy89PiAnICdcbiAgICogbm9kZS5jbGVhblJhd3MoKVxuICAgKiBub2RlLnJhd3MuYmVmb3JlICAvLz0+IHVuZGVmaW5lZFxuICAgKi87X3Byb3RvLmNsZWFuUmF3cz1mdW5jdGlvbiBjbGVhblJhd3Moa2VlcEJldHdlZW4pe2RlbGV0ZSB0aGlzLnJhd3MuYmVmb3JlO2RlbGV0ZSB0aGlzLnJhd3MuYWZ0ZXI7aWYoIWtlZXBCZXR3ZWVuKWRlbGV0ZSB0aGlzLnJhd3MuYmV0d2Vlbjt9O19wcm90by5wb3NpdGlvbkluc2lkZT1mdW5jdGlvbiBwb3NpdGlvbkluc2lkZShpbmRleCl7dmFyIHN0cmluZz10aGlzLnRvU3RyaW5nKCk7dmFyIGNvbHVtbj10aGlzLnNvdXJjZS5zdGFydC5jb2x1bW47dmFyIGxpbmU9dGhpcy5zb3VyY2Uuc3RhcnQubGluZTtmb3IodmFyIGk9MDtpPGluZGV4O2krKyl7aWYoc3RyaW5nW2ldPT09J1xcbicpe2NvbHVtbj0xO2xpbmUrPTE7fWVsc2V7Y29sdW1uKz0xO319cmV0dXJue2xpbmU6bGluZSxjb2x1bW46Y29sdW1ufTt9O19wcm90by5wb3NpdGlvbkJ5PWZ1bmN0aW9uIHBvc2l0aW9uQnkob3B0cyl7dmFyIHBvcz10aGlzLnNvdXJjZS5zdGFydDtpZihvcHRzLmluZGV4KXtwb3M9dGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4KTt9ZWxzZSBpZihvcHRzLndvcmQpe3ZhciBpbmRleD10aGlzLnRvU3RyaW5nKCkuaW5kZXhPZihvcHRzLndvcmQpO2lmKGluZGV4IT09LTEpcG9zPXRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgpO31yZXR1cm4gcG9zO30vKipcbiAgICogQG1lbWJlcm9mIE5vZGUjXG4gICAqIEBtZW1iZXIge3N0cmluZ30gdHlwZSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBub2Rl4oCZcyB0eXBlLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgUG9zc2libGUgdmFsdWVzIGFyZSBgcm9vdGAsIGBhdHJ1bGVgLCBgcnVsZWAsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBgZGVjbGAsIG9yIGBjb21tZW50YC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy5kZWNsKHsgcHJvcDogJ2NvbG9yJywgdmFsdWU6ICdibGFjaycgfSkudHlwZSAvLz0+ICdkZWNsJ1xuICAgKi8gLyoqXG4gICAqIEBtZW1iZXJvZiBOb2RlI1xuICAgKiBAbWVtYmVyIHtDb250YWluZXJ9IHBhcmVudCBUaGUgbm9kZeKAmXMgcGFyZW50IG5vZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJvb3Qubm9kZXNbMF0ucGFyZW50ID09PSByb290XG4gICAqLyAvKipcbiAgICogQG1lbWJlcm9mIE5vZGUjXG4gICAqIEBtZW1iZXIge3NvdXJjZX0gc291cmNlIFRoZSBpbnB1dCBzb3VyY2Ugb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGluIHNvdXJjZSBtYXAgZ2VuZXJhdGlvbi5cbiAgICpcbiAgICogSWYgeW91IGNyZWF0ZSBhIG5vZGUgbWFudWFsbHkgKGUuZy4sIHdpdGggYHBvc3Rjc3MuZGVjbCgpYCksXG4gICAqIHRoYXQgbm9kZSB3aWxsIG5vdCBoYXZlIGEgYHNvdXJjZWAgcHJvcGVydHkgYW5kIHdpbGwgYmUgYWJzZW50XG4gICAqIGZyb20gdGhlIHNvdXJjZSBtYXAuIEZvciB0aGlzIHJlYXNvbiwgdGhlIHBsdWdpbiBkZXZlbG9wZXIgc2hvdWxkXG4gICAqIGNvbnNpZGVyIGNsb25pbmcgbm9kZXMgdG8gY3JlYXRlIG5ldyBvbmVzIChpbiB3aGljaCBjYXNlIHRoZSBuZXcgbm9kZeKAmXNcbiAgICogc291cmNlIHdpbGwgcmVmZXJlbmNlIHRoZSBvcmlnaW5hbCwgY2xvbmVkIG5vZGUpIG9yIHNldHRpbmdcbiAgICogdGhlIGBzb3VyY2VgIHByb3BlcnR5IG1hbnVhbGx5LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBCYWRcbiAgICogY29uc3QgcHJlZml4ZWQgPSBwb3N0Y3NzLmRlY2woe1xuICAgKiAgIHByb3A6ICctbW96LScgKyBkZWNsLnByb3AsXG4gICAqICAgdmFsdWU6IGRlY2wudmFsdWVcbiAgICogfSlcbiAgICpcbiAgICogLy8gR29vZFxuICAgKiBjb25zdCBwcmVmaXhlZCA9IGRlY2wuY2xvbmUoeyBwcm9wOiAnLW1vei0nICsgZGVjbC5wcm9wIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpZiAoYXRydWxlLm5hbWUgPT09ICdhZGQtbGluaycpIHtcbiAgICogICBjb25zdCBydWxlID0gcG9zdGNzcy5ydWxlKHsgc2VsZWN0b3I6ICdhJywgc291cmNlOiBhdHJ1bGUuc291cmNlIH0pXG4gICAqICAgYXRydWxlLnBhcmVudC5pbnNlcnRCZWZvcmUoYXRydWxlLCBydWxlKVxuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBkZWNsLnNvdXJjZS5pbnB1dC5mcm9tIC8vPT4gJy9ob21lL2FpL2Euc2FzcydcbiAgICogZGVjbC5zb3VyY2Uuc3RhcnQgICAgICAvLz0+IHsgbGluZTogMTAsIGNvbHVtbjogMiB9XG4gICAqIGRlY2wuc291cmNlLmVuZCAgICAgICAgLy89PiB7IGxpbmU6IDEwLCBjb2x1bW46IDEyIH1cbiAgICovIC8qKlxuICAgKiBAbWVtYmVyb2YgTm9kZSNcbiAgICogQG1lbWJlciB7b2JqZWN0fSByYXdzIEluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGJ5dGUtdG8tYnl0ZSBlcXVhbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgbm9kZSBzdHJpbmcgYXMgaXQgd2FzIGluIHRoZSBvcmlnaW4gaW5wdXQuXG4gICAqXG4gICAqIEV2ZXJ5IHBhcnNlciBzYXZlcyBpdHMgb3duIHByb3BlcnRpZXMsXG4gICAqIGJ1dCB0aGUgZGVmYXVsdCBDU1MgcGFyc2VyIHVzZXM6XG4gICAqXG4gICAqICogYGJlZm9yZWA6IHRoZSBzcGFjZSBzeW1ib2xzIGJlZm9yZSB0aGUgbm9kZS4gSXQgYWxzbyBzdG9yZXMgYCpgXG4gICAqICAgYW5kIGBfYCBzeW1ib2xzIGJlZm9yZSB0aGUgZGVjbGFyYXRpb24gKElFIGhhY2spLlxuICAgKiAqIGBhZnRlcmA6IHRoZSBzcGFjZSBzeW1ib2xzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoZSBub2RlXG4gICAqICAgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAgICogKiBgYmV0d2VlbmA6IHRoZSBzeW1ib2xzIGJldHdlZW4gdGhlIHByb3BlcnR5IGFuZCB2YWx1ZVxuICAgKiAgIGZvciBkZWNsYXJhdGlvbnMsIHNlbGVjdG9yIGFuZCBge2AgZm9yIHJ1bGVzLCBvciBsYXN0IHBhcmFtZXRlclxuICAgKiAgIGFuZCBge2AgZm9yIGF0LXJ1bGVzLlxuICAgKiAqIGBzZW1pY29sb25gOiBjb250YWlucyB0cnVlIGlmIHRoZSBsYXN0IGNoaWxkIGhhc1xuICAgKiAgIGFuIChvcHRpb25hbCkgc2VtaWNvbG9uLlxuICAgKiAqIGBhZnRlck5hbWVgOiB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgYXQtcnVsZSBuYW1lIGFuZCBpdHMgcGFyYW1ldGVycy5cbiAgICogKiBgbGVmdGA6IHRoZSBzcGFjZSBzeW1ib2xzIGJldHdlZW4gYC8qYCBhbmQgdGhlIGNvbW1lbnTigJlzIHRleHQuXG4gICAqICogYHJpZ2h0YDogdGhlIHNwYWNlIHN5bWJvbHMgYmV0d2VlbiB0aGUgY29tbWVudOKAmXMgdGV4dFxuICAgKiAgIGFuZCA8Y29kZT4qJiM0Nzs8L2NvZGU+LlxuICAgKiAqIGBpbXBvcnRhbnRgOiB0aGUgY29udGVudCBvZiB0aGUgaW1wb3J0YW50IHN0YXRlbWVudCxcbiAgICogICBpZiBpdCBpcyBub3QganVzdCBgIWltcG9ydGFudGAuXG4gICAqXG4gICAqIFBvc3RDU1MgY2xlYW5zIHNlbGVjdG9ycywgZGVjbGFyYXRpb24gdmFsdWVzIGFuZCBhdC1ydWxlIHBhcmFtZXRlcnNcbiAgICogZnJvbSBjb21tZW50cyBhbmQgZXh0cmEgc3BhY2VzLCBidXQgaXQgc3RvcmVzIG9yaWdpbiBjb250ZW50IGluIHJhd3NcbiAgICogcHJvcGVydGllcy4gQXMgc3VjaCwgaWYgeW91IGRvbuKAmXQgY2hhbmdlIGEgZGVjbGFyYXRpb27igJlzIHZhbHVlLFxuICAgKiBQb3N0Q1NTIHdpbGwgdXNlIHRoZSByYXcgdmFsdWUgd2l0aCBjb21tZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2Ege1xcbiAgY29sb3I6YmxhY2tcXG59JylcbiAgICogcm9vdC5maXJzdC5maXJzdC5yYXdzIC8vPT4geyBiZWZvcmU6ICdcXG4gICcsIGJldHdlZW46ICc6JyB9XG4gICAqLztyZXR1cm4gTm9kZTt9KCk7dmFyIF9kZWZhdWx0PU5vZGU7LyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBwb3NpdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmUgICBTb3VyY2UgbGluZSBpbiBmaWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbHVtbiBTb3VyY2UgY29sdW1uIGluIGZpbGUuXG4gKi8gLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBzb3VyY2VcbiAqIEBwcm9wZXJ0eSB7SW5wdXR9IGlucHV0ICAgIHtAbGluayBJbnB1dH0gd2l0aCBpbnB1dCBmaWxlXG4gKiBAcHJvcGVydHkge3Bvc2l0aW9ufSBzdGFydCBUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIG5vZGXigJlzIHNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7cG9zaXRpb259IGVuZCAgIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIG5vZGXigJlzIHNvdXJjZS5cbiAqL2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKTt9LHtcIi4vY3NzLXN5bnRheC1lcnJvclwiOjQyLFwiLi9zdHJpbmdpZmllclwiOjU3LFwiLi9zdHJpbmdpZnlcIjo1OCxcIl9wcm9jZXNzXCI6NjN9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3Mpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX3BhcnNlcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlclwiKSk7dmFyIF9pbnB1dD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lucHV0XCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O31mdW5jdGlvbiBwYXJzZShjc3Msb3B0cyl7dmFyIGlucHV0PW5ldyBfaW5wdXRbXCJkZWZhdWx0XCJdKGNzcyxvcHRzKTt2YXIgcGFyc2VyPW5ldyBfcGFyc2VyW1wiZGVmYXVsdFwiXShpbnB1dCk7dHJ5e3BhcnNlci5wYXJzZSgpO31jYXRjaChlKXtpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7aWYoZS5uYW1lPT09J0Nzc1N5bnRheEVycm9yJyYmb3B0cyYmb3B0cy5mcm9tKXtpZigvXFwuc2NzcyQvaS50ZXN0KG9wdHMuZnJvbSkpe2UubWVzc2FnZSs9J1xcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggJysndGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7ICcrJ3RyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyJzt9ZWxzZSBpZigvXFwuc2Fzcy9pLnRlc3Qob3B0cy5mcm9tKSl7ZS5tZXNzYWdlKz0nXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCAnKyd0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgJysndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXInO31lbHNlIGlmKC9cXC5sZXNzJC9pLnRlc3Qob3B0cy5mcm9tKSl7ZS5tZXNzYWdlKz0nXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCAnKyd0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgJysndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXInO319fXRocm93IGU7fXJldHVybiBwYXJzZXIucm9vdDt9dmFyIF9kZWZhdWx0PXBhcnNlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKTt9LHtcIi4vaW5wdXRcIjo0NCxcIi4vcGFyc2VyXCI6NTAsXCJfcHJvY2Vzc1wiOjYzfV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2RlY2xhcmF0aW9uPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGVjbGFyYXRpb25cIikpO3ZhciBfdG9rZW5pemU9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi90b2tlbml6ZVwiKSk7dmFyIF9jb21tZW50PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbWVudFwiKSk7dmFyIF9hdFJ1bGU9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9hdC1ydWxlXCIpKTt2YXIgX3Jvb3Q9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb290XCIpKTt2YXIgX3J1bGU9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ydWxlXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O312YXIgUGFyc2VyPS8qI19fUFVSRV9fKi9mdW5jdGlvbigpe2Z1bmN0aW9uIFBhcnNlcihpbnB1dCl7dGhpcy5pbnB1dD1pbnB1dDt0aGlzLnJvb3Q9bmV3IF9yb290W1wiZGVmYXVsdFwiXSgpO3RoaXMuY3VycmVudD10aGlzLnJvb3Q7dGhpcy5zcGFjZXM9Jyc7dGhpcy5zZW1pY29sb249ZmFsc2U7dGhpcy5jcmVhdGVUb2tlbml6ZXIoKTt0aGlzLnJvb3Quc291cmNlPXtpbnB1dDppbnB1dCxzdGFydDp7bGluZToxLGNvbHVtbjoxfX07fXZhciBfcHJvdG89UGFyc2VyLnByb3RvdHlwZTtfcHJvdG8uY3JlYXRlVG9rZW5pemVyPWZ1bmN0aW9uIGNyZWF0ZVRva2VuaXplcigpe3RoaXMudG9rZW5pemVyPSgwLF90b2tlbml6ZVtcImRlZmF1bHRcIl0pKHRoaXMuaW5wdXQpO307X3Byb3RvLnBhcnNlPWZ1bmN0aW9uIHBhcnNlKCl7dmFyIHRva2VuO3doaWxlKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSl7dG9rZW49dGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7c3dpdGNoKHRva2VuWzBdKXtjYXNlJ3NwYWNlJzp0aGlzLnNwYWNlcys9dG9rZW5bMV07YnJlYWs7Y2FzZSc7Jzp0aGlzLmZyZWVTZW1pY29sb24odG9rZW4pO2JyZWFrO2Nhc2UnfSc6dGhpcy5lbmQodG9rZW4pO2JyZWFrO2Nhc2UnY29tbWVudCc6dGhpcy5jb21tZW50KHRva2VuKTticmVhaztjYXNlJ2F0LXdvcmQnOnRoaXMuYXRydWxlKHRva2VuKTticmVhaztjYXNlJ3snOnRoaXMuZW1wdHlSdWxlKHRva2VuKTticmVhaztkZWZhdWx0OnRoaXMub3RoZXIodG9rZW4pO2JyZWFrO319dGhpcy5lbmRGaWxlKCk7fTtfcHJvdG8uY29tbWVudD1mdW5jdGlvbiBjb21tZW50KHRva2VuKXt2YXIgbm9kZT1uZXcgX2NvbW1lbnRbXCJkZWZhdWx0XCJdKCk7dGhpcy5pbml0KG5vZGUsdG9rZW5bMl0sdG9rZW5bM10pO25vZGUuc291cmNlLmVuZD17bGluZTp0b2tlbls0XSxjb2x1bW46dG9rZW5bNV19O3ZhciB0ZXh0PXRva2VuWzFdLnNsaWNlKDIsLTIpO2lmKC9eXFxzKiQvLnRlc3QodGV4dCkpe25vZGUudGV4dD0nJztub2RlLnJhd3MubGVmdD10ZXh0O25vZGUucmF3cy5yaWdodD0nJzt9ZWxzZXt2YXIgbWF0Y2g9dGV4dC5tYXRjaCgvXihcXHMqKShbXl0qW15cXHNdKShcXHMqKSQvKTtub2RlLnRleHQ9bWF0Y2hbMl07bm9kZS5yYXdzLmxlZnQ9bWF0Y2hbMV07bm9kZS5yYXdzLnJpZ2h0PW1hdGNoWzNdO319O19wcm90by5lbXB0eVJ1bGU9ZnVuY3Rpb24gZW1wdHlSdWxlKHRva2VuKXt2YXIgbm9kZT1uZXcgX3J1bGVbXCJkZWZhdWx0XCJdKCk7dGhpcy5pbml0KG5vZGUsdG9rZW5bMl0sdG9rZW5bM10pO25vZGUuc2VsZWN0b3I9Jyc7bm9kZS5yYXdzLmJldHdlZW49Jyc7dGhpcy5jdXJyZW50PW5vZGU7fTtfcHJvdG8ub3RoZXI9ZnVuY3Rpb24gb3RoZXIoc3RhcnQpe3ZhciBlbmQ9ZmFsc2U7dmFyIHR5cGU9bnVsbDt2YXIgY29sb249ZmFsc2U7dmFyIGJyYWNrZXQ9bnVsbDt2YXIgYnJhY2tldHM9W107dmFyIHRva2Vucz1bXTt2YXIgdG9rZW49c3RhcnQ7d2hpbGUodG9rZW4pe3R5cGU9dG9rZW5bMF07dG9rZW5zLnB1c2godG9rZW4pO2lmKHR5cGU9PT0nKCd8fHR5cGU9PT0nWycpe2lmKCFicmFja2V0KWJyYWNrZXQ9dG9rZW47YnJhY2tldHMucHVzaCh0eXBlPT09JygnPycpJzonXScpO31lbHNlIGlmKGJyYWNrZXRzLmxlbmd0aD09PTApe2lmKHR5cGU9PT0nOycpe2lmKGNvbG9uKXt0aGlzLmRlY2wodG9rZW5zKTtyZXR1cm47fWVsc2V7YnJlYWs7fX1lbHNlIGlmKHR5cGU9PT0neycpe3RoaXMucnVsZSh0b2tlbnMpO3JldHVybjt9ZWxzZSBpZih0eXBlPT09J30nKXt0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSk7ZW5kPXRydWU7YnJlYWs7fWVsc2UgaWYodHlwZT09PSc6Jyl7Y29sb249dHJ1ZTt9fWVsc2UgaWYodHlwZT09PWJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aC0xXSl7YnJhY2tldHMucG9wKCk7aWYoYnJhY2tldHMubGVuZ3RoPT09MClicmFja2V0PW51bGw7fXRva2VuPXRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO31pZih0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSllbmQ9dHJ1ZTtpZihicmFja2V0cy5sZW5ndGg+MCl0aGlzLnVuY2xvc2VkQnJhY2tldChicmFja2V0KTtpZihlbmQmJmNvbG9uKXt3aGlsZSh0b2tlbnMubGVuZ3RoKXt0b2tlbj10b2tlbnNbdG9rZW5zLmxlbmd0aC0xXVswXTtpZih0b2tlbiE9PSdzcGFjZScmJnRva2VuIT09J2NvbW1lbnQnKWJyZWFrO3RoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKTt9dGhpcy5kZWNsKHRva2Vucyk7fWVsc2V7dGhpcy51bmtub3duV29yZCh0b2tlbnMpO319O19wcm90by5ydWxlPWZ1bmN0aW9uIHJ1bGUodG9rZW5zKXt0b2tlbnMucG9wKCk7dmFyIG5vZGU9bmV3IF9ydWxlW1wiZGVmYXVsdFwiXSgpO3RoaXMuaW5pdChub2RlLHRva2Vuc1swXVsyXSx0b2tlbnNbMF1bM10pO25vZGUucmF3cy5iZXR3ZWVuPXRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucyk7dGhpcy5yYXcobm9kZSwnc2VsZWN0b3InLHRva2Vucyk7dGhpcy5jdXJyZW50PW5vZGU7fTtfcHJvdG8uZGVjbD1mdW5jdGlvbiBkZWNsKHRva2Vucyl7dmFyIG5vZGU9bmV3IF9kZWNsYXJhdGlvbltcImRlZmF1bHRcIl0oKTt0aGlzLmluaXQobm9kZSk7dmFyIGxhc3Q9dG9rZW5zW3Rva2Vucy5sZW5ndGgtMV07aWYobGFzdFswXT09PSc7Jyl7dGhpcy5zZW1pY29sb249dHJ1ZTt0b2tlbnMucG9wKCk7fWlmKGxhc3RbNF0pe25vZGUuc291cmNlLmVuZD17bGluZTpsYXN0WzRdLGNvbHVtbjpsYXN0WzVdfTt9ZWxzZXtub2RlLnNvdXJjZS5lbmQ9e2xpbmU6bGFzdFsyXSxjb2x1bW46bGFzdFszXX07fXdoaWxlKHRva2Vuc1swXVswXSE9PSd3b3JkJyl7aWYodG9rZW5zLmxlbmd0aD09PTEpdGhpcy51bmtub3duV29yZCh0b2tlbnMpO25vZGUucmF3cy5iZWZvcmUrPXRva2Vucy5zaGlmdCgpWzFdO31ub2RlLnNvdXJjZS5zdGFydD17bGluZTp0b2tlbnNbMF1bMl0sY29sdW1uOnRva2Vuc1swXVszXX07bm9kZS5wcm9wPScnO3doaWxlKHRva2Vucy5sZW5ndGgpe3ZhciB0eXBlPXRva2Vuc1swXVswXTtpZih0eXBlPT09JzonfHx0eXBlPT09J3NwYWNlJ3x8dHlwZT09PSdjb21tZW50Jyl7YnJlYWs7fW5vZGUucHJvcCs9dG9rZW5zLnNoaWZ0KClbMV07fW5vZGUucmF3cy5iZXR3ZWVuPScnO3ZhciB0b2tlbjt3aGlsZSh0b2tlbnMubGVuZ3RoKXt0b2tlbj10b2tlbnMuc2hpZnQoKTtpZih0b2tlblswXT09PSc6Jyl7bm9kZS5yYXdzLmJldHdlZW4rPXRva2VuWzFdO2JyZWFrO31lbHNle2lmKHRva2VuWzBdPT09J3dvcmQnJiYvXFx3Ly50ZXN0KHRva2VuWzFdKSl7dGhpcy51bmtub3duV29yZChbdG9rZW5dKTt9bm9kZS5yYXdzLmJldHdlZW4rPXRva2VuWzFdO319aWYobm9kZS5wcm9wWzBdPT09J18nfHxub2RlLnByb3BbMF09PT0nKicpe25vZGUucmF3cy5iZWZvcmUrPW5vZGUucHJvcFswXTtub2RlLnByb3A9bm9kZS5wcm9wLnNsaWNlKDEpO31ub2RlLnJhd3MuYmV0d2Vlbis9dGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCh0b2tlbnMpO3RoaXMucHJlY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKTtmb3IodmFyIGk9dG9rZW5zLmxlbmd0aC0xO2k+MDtpLS0pe3Rva2VuPXRva2Vuc1tpXTtpZih0b2tlblsxXS50b0xvd2VyQ2FzZSgpPT09JyFpbXBvcnRhbnQnKXtub2RlLmltcG9ydGFudD10cnVlO3ZhciBzdHJpbmc9dGhpcy5zdHJpbmdGcm9tKHRva2VucyxpKTtzdHJpbmc9dGhpcy5zcGFjZXNGcm9tRW5kKHRva2Vucykrc3RyaW5nO2lmKHN0cmluZyE9PScgIWltcG9ydGFudCcpbm9kZS5yYXdzLmltcG9ydGFudD1zdHJpbmc7YnJlYWs7fWVsc2UgaWYodG9rZW5bMV0udG9Mb3dlckNhc2UoKT09PSdpbXBvcnRhbnQnKXt2YXIgY2FjaGU9dG9rZW5zLnNsaWNlKDApO3ZhciBzdHI9Jyc7Zm9yKHZhciBqPWk7aj4wO2otLSl7dmFyIF90eXBlPWNhY2hlW2pdWzBdO2lmKHN0ci50cmltKCkuaW5kZXhPZignIScpPT09MCYmX3R5cGUhPT0nc3BhY2UnKXticmVhazt9c3RyPWNhY2hlLnBvcCgpWzFdK3N0cjt9aWYoc3RyLnRyaW0oKS5pbmRleE9mKCchJyk9PT0wKXtub2RlLmltcG9ydGFudD10cnVlO25vZGUucmF3cy5pbXBvcnRhbnQ9c3RyO3Rva2Vucz1jYWNoZTt9fWlmKHRva2VuWzBdIT09J3NwYWNlJyYmdG9rZW5bMF0hPT0nY29tbWVudCcpe2JyZWFrO319dGhpcy5yYXcobm9kZSwndmFsdWUnLHRva2Vucyk7aWYobm9kZS52YWx1ZS5pbmRleE9mKCc6JykhPT0tMSl0aGlzLmNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7fTtfcHJvdG8uYXRydWxlPWZ1bmN0aW9uIGF0cnVsZSh0b2tlbil7dmFyIG5vZGU9bmV3IF9hdFJ1bGVbXCJkZWZhdWx0XCJdKCk7bm9kZS5uYW1lPXRva2VuWzFdLnNsaWNlKDEpO2lmKG5vZGUubmFtZT09PScnKXt0aGlzLnVubmFtZWRBdHJ1bGUobm9kZSx0b2tlbik7fXRoaXMuaW5pdChub2RlLHRva2VuWzJdLHRva2VuWzNdKTt2YXIgcHJldjt2YXIgc2hpZnQ7dmFyIGxhc3Q9ZmFsc2U7dmFyIG9wZW49ZmFsc2U7dmFyIHBhcmFtcz1bXTt3aGlsZSghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpe3Rva2VuPXRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO2lmKHRva2VuWzBdPT09JzsnKXtub2RlLnNvdXJjZS5lbmQ9e2xpbmU6dG9rZW5bMl0sY29sdW1uOnRva2VuWzNdfTt0aGlzLnNlbWljb2xvbj10cnVlO2JyZWFrO31lbHNlIGlmKHRva2VuWzBdPT09J3snKXtvcGVuPXRydWU7YnJlYWs7fWVsc2UgaWYodG9rZW5bMF09PT0nfScpe2lmKHBhcmFtcy5sZW5ndGg+MCl7c2hpZnQ9cGFyYW1zLmxlbmd0aC0xO3ByZXY9cGFyYW1zW3NoaWZ0XTt3aGlsZShwcmV2JiZwcmV2WzBdPT09J3NwYWNlJyl7cHJldj1wYXJhbXNbLS1zaGlmdF07fWlmKHByZXYpe25vZGUuc291cmNlLmVuZD17bGluZTpwcmV2WzRdLGNvbHVtbjpwcmV2WzVdfTt9fXRoaXMuZW5kKHRva2VuKTticmVhazt9ZWxzZXtwYXJhbXMucHVzaCh0b2tlbik7fWlmKHRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXtsYXN0PXRydWU7YnJlYWs7fX1ub2RlLnJhd3MuYmV0d2Vlbj10aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZChwYXJhbXMpO2lmKHBhcmFtcy5sZW5ndGgpe25vZGUucmF3cy5hZnRlck5hbWU9dGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydChwYXJhbXMpO3RoaXMucmF3KG5vZGUsJ3BhcmFtcycscGFyYW1zKTtpZihsYXN0KXt0b2tlbj1wYXJhbXNbcGFyYW1zLmxlbmd0aC0xXTtub2RlLnNvdXJjZS5lbmQ9e2xpbmU6dG9rZW5bNF0sY29sdW1uOnRva2VuWzVdfTt0aGlzLnNwYWNlcz1ub2RlLnJhd3MuYmV0d2Vlbjtub2RlLnJhd3MuYmV0d2Vlbj0nJzt9fWVsc2V7bm9kZS5yYXdzLmFmdGVyTmFtZT0nJztub2RlLnBhcmFtcz0nJzt9aWYob3Blbil7bm9kZS5ub2Rlcz1bXTt0aGlzLmN1cnJlbnQ9bm9kZTt9fTtfcHJvdG8uZW5kPWZ1bmN0aW9uIGVuZCh0b2tlbil7aWYodGhpcy5jdXJyZW50Lm5vZGVzJiZ0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKXt0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb249dGhpcy5zZW1pY29sb247fXRoaXMuc2VtaWNvbG9uPWZhbHNlO3RoaXMuY3VycmVudC5yYXdzLmFmdGVyPSh0aGlzLmN1cnJlbnQucmF3cy5hZnRlcnx8JycpK3RoaXMuc3BhY2VzO3RoaXMuc3BhY2VzPScnO2lmKHRoaXMuY3VycmVudC5wYXJlbnQpe3RoaXMuY3VycmVudC5zb3VyY2UuZW5kPXtsaW5lOnRva2VuWzJdLGNvbHVtbjp0b2tlblszXX07dGhpcy5jdXJyZW50PXRoaXMuY3VycmVudC5wYXJlbnQ7fWVsc2V7dGhpcy51bmV4cGVjdGVkQ2xvc2UodG9rZW4pO319O19wcm90by5lbmRGaWxlPWZ1bmN0aW9uIGVuZEZpbGUoKXtpZih0aGlzLmN1cnJlbnQucGFyZW50KXRoaXMudW5jbG9zZWRCbG9jaygpO2lmKHRoaXMuY3VycmVudC5ub2RlcyYmdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCl7dGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uPXRoaXMuc2VtaWNvbG9uO310aGlzLmN1cnJlbnQucmF3cy5hZnRlcj0odGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXJ8fCcnKSt0aGlzLnNwYWNlczt9O19wcm90by5mcmVlU2VtaWNvbG9uPWZ1bmN0aW9uIGZyZWVTZW1pY29sb24odG9rZW4pe3RoaXMuc3BhY2VzKz10b2tlblsxXTtpZih0aGlzLmN1cnJlbnQubm9kZXMpe3ZhciBwcmV2PXRoaXMuY3VycmVudC5ub2Rlc1t0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoLTFdO2lmKHByZXYmJnByZXYudHlwZT09PSdydWxlJyYmIXByZXYucmF3cy5vd25TZW1pY29sb24pe3ByZXYucmF3cy5vd25TZW1pY29sb249dGhpcy5zcGFjZXM7dGhpcy5zcGFjZXM9Jyc7fX19Ly8gSGVscGVyc1xuO19wcm90by5pbml0PWZ1bmN0aW9uIGluaXQobm9kZSxsaW5lLGNvbHVtbil7dGhpcy5jdXJyZW50LnB1c2gobm9kZSk7bm9kZS5zb3VyY2U9e3N0YXJ0OntsaW5lOmxpbmUsY29sdW1uOmNvbHVtbn0saW5wdXQ6dGhpcy5pbnB1dH07bm9kZS5yYXdzLmJlZm9yZT10aGlzLnNwYWNlczt0aGlzLnNwYWNlcz0nJztpZihub2RlLnR5cGUhPT0nY29tbWVudCcpdGhpcy5zZW1pY29sb249ZmFsc2U7fTtfcHJvdG8ucmF3PWZ1bmN0aW9uIHJhdyhub2RlLHByb3AsdG9rZW5zKXt2YXIgdG9rZW4sdHlwZTt2YXIgbGVuZ3RoPXRva2Vucy5sZW5ndGg7dmFyIHZhbHVlPScnO3ZhciBjbGVhbj10cnVlO3ZhciBuZXh0LHByZXY7dmFyIHBhdHRlcm49L14oWy58I10pPyhbXFx3XSkrL2k7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSs9MSl7dG9rZW49dG9rZW5zW2ldO3R5cGU9dG9rZW5bMF07aWYodHlwZT09PSdjb21tZW50JyYmbm9kZS50eXBlPT09J3J1bGUnKXtwcmV2PXRva2Vuc1tpLTFdO25leHQ9dG9rZW5zW2krMV07aWYocHJldlswXSE9PSdzcGFjZScmJm5leHRbMF0hPT0nc3BhY2UnJiZwYXR0ZXJuLnRlc3QocHJldlsxXSkmJnBhdHRlcm4udGVzdChuZXh0WzFdKSl7dmFsdWUrPXRva2VuWzFdO31lbHNle2NsZWFuPWZhbHNlO31jb250aW51ZTt9aWYodHlwZT09PSdjb21tZW50J3x8dHlwZT09PSdzcGFjZScmJmk9PT1sZW5ndGgtMSl7Y2xlYW49ZmFsc2U7fWVsc2V7dmFsdWUrPXRva2VuWzFdO319aWYoIWNsZWFuKXt2YXIgcmF3PXRva2Vucy5yZWR1Y2UoZnVuY3Rpb24oYWxsLGkpe3JldHVybiBhbGwraVsxXTt9LCcnKTtub2RlLnJhd3NbcHJvcF09e3ZhbHVlOnZhbHVlLHJhdzpyYXd9O31ub2RlW3Byb3BdPXZhbHVlO307X3Byb3RvLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZD1mdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKXt2YXIgbGFzdFRva2VuVHlwZTt2YXIgc3BhY2VzPScnO3doaWxlKHRva2Vucy5sZW5ndGgpe2xhc3RUb2tlblR5cGU9dG9rZW5zW3Rva2Vucy5sZW5ndGgtMV1bMF07aWYobGFzdFRva2VuVHlwZSE9PSdzcGFjZScmJmxhc3RUb2tlblR5cGUhPT0nY29tbWVudCcpYnJlYWs7c3BhY2VzPXRva2Vucy5wb3AoKVsxXStzcGFjZXM7fXJldHVybiBzcGFjZXM7fTtfcHJvdG8uc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQ9ZnVuY3Rpb24gc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQodG9rZW5zKXt2YXIgbmV4dDt2YXIgc3BhY2VzPScnO3doaWxlKHRva2Vucy5sZW5ndGgpe25leHQ9dG9rZW5zWzBdWzBdO2lmKG5leHQhPT0nc3BhY2UnJiZuZXh0IT09J2NvbW1lbnQnKWJyZWFrO3NwYWNlcys9dG9rZW5zLnNoaWZ0KClbMV07fXJldHVybiBzcGFjZXM7fTtfcHJvdG8uc3BhY2VzRnJvbUVuZD1mdW5jdGlvbiBzcGFjZXNGcm9tRW5kKHRva2Vucyl7dmFyIGxhc3RUb2tlblR5cGU7dmFyIHNwYWNlcz0nJzt3aGlsZSh0b2tlbnMubGVuZ3RoKXtsYXN0VG9rZW5UeXBlPXRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdWzBdO2lmKGxhc3RUb2tlblR5cGUhPT0nc3BhY2UnKWJyZWFrO3NwYWNlcz10b2tlbnMucG9wKClbMV0rc3BhY2VzO31yZXR1cm4gc3BhY2VzO307X3Byb3RvLnN0cmluZ0Zyb209ZnVuY3Rpb24gc3RyaW5nRnJvbSh0b2tlbnMsZnJvbSl7dmFyIHJlc3VsdD0nJztmb3IodmFyIGk9ZnJvbTtpPHRva2Vucy5sZW5ndGg7aSsrKXtyZXN1bHQrPXRva2Vuc1tpXVsxXTt9dG9rZW5zLnNwbGljZShmcm9tLHRva2Vucy5sZW5ndGgtZnJvbSk7cmV0dXJuIHJlc3VsdDt9O19wcm90by5jb2xvbj1mdW5jdGlvbiBjb2xvbih0b2tlbnMpe3ZhciBicmFja2V0cz0wO3ZhciB0b2tlbix0eXBlLHByZXY7Zm9yKHZhciBpPTA7aTx0b2tlbnMubGVuZ3RoO2krKyl7dG9rZW49dG9rZW5zW2ldO3R5cGU9dG9rZW5bMF07aWYodHlwZT09PScoJyl7YnJhY2tldHMrPTE7fWlmKHR5cGU9PT0nKScpe2JyYWNrZXRzLT0xO31pZihicmFja2V0cz09PTAmJnR5cGU9PT0nOicpe2lmKCFwcmV2KXt0aGlzLmRvdWJsZUNvbG9uKHRva2VuKTt9ZWxzZSBpZihwcmV2WzBdPT09J3dvcmQnJiZwcmV2WzFdPT09J3Byb2dpZCcpe2NvbnRpbnVlO31lbHNle3JldHVybiBpO319cHJldj10b2tlbjt9cmV0dXJuIGZhbHNlO30vLyBFcnJvcnNcbjtfcHJvdG8udW5jbG9zZWRCcmFja2V0PWZ1bmN0aW9uIHVuY2xvc2VkQnJhY2tldChicmFja2V0KXt0aHJvdyB0aGlzLmlucHV0LmVycm9yKCdVbmNsb3NlZCBicmFja2V0JyxicmFja2V0WzJdLGJyYWNrZXRbM10pO307X3Byb3RvLnVua25vd25Xb3JkPWZ1bmN0aW9uIHVua25vd25Xb3JkKHRva2Vucyl7dGhyb3cgdGhpcy5pbnB1dC5lcnJvcignVW5rbm93biB3b3JkJyx0b2tlbnNbMF1bMl0sdG9rZW5zWzBdWzNdKTt9O19wcm90by51bmV4cGVjdGVkQ2xvc2U9ZnVuY3Rpb24gdW5leHBlY3RlZENsb3NlKHRva2VuKXt0aHJvdyB0aGlzLmlucHV0LmVycm9yKCdVbmV4cGVjdGVkIH0nLHRva2VuWzJdLHRva2VuWzNdKTt9O19wcm90by51bmNsb3NlZEJsb2NrPWZ1bmN0aW9uIHVuY2xvc2VkQmxvY2soKXt2YXIgcG9zPXRoaXMuY3VycmVudC5zb3VyY2Uuc3RhcnQ7dGhyb3cgdGhpcy5pbnB1dC5lcnJvcignVW5jbG9zZWQgYmxvY2snLHBvcy5saW5lLHBvcy5jb2x1bW4pO307X3Byb3RvLmRvdWJsZUNvbG9uPWZ1bmN0aW9uIGRvdWJsZUNvbG9uKHRva2VuKXt0aHJvdyB0aGlzLmlucHV0LmVycm9yKCdEb3VibGUgY29sb24nLHRva2VuWzJdLHRva2VuWzNdKTt9O19wcm90by51bm5hbWVkQXRydWxlPWZ1bmN0aW9uIHVubmFtZWRBdHJ1bGUobm9kZSx0b2tlbil7dGhyb3cgdGhpcy5pbnB1dC5lcnJvcignQXQtcnVsZSB3aXRob3V0IG5hbWUnLHRva2VuWzJdLHRva2VuWzNdKTt9O19wcm90by5wcmVjaGVja01pc3NlZFNlbWljb2xvbj1mdW5jdGlvbiBwcmVjaGVja01pc3NlZFNlbWljb2xvbigpLyogdG9rZW5zICovey8vIEhvb2sgZm9yIFNhZmUgUGFyc2VyXG59O19wcm90by5jaGVja01pc3NlZFNlbWljb2xvbj1mdW5jdGlvbiBjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpe3ZhciBjb2xvbj10aGlzLmNvbG9uKHRva2Vucyk7aWYoY29sb249PT1mYWxzZSlyZXR1cm47dmFyIGZvdW5kZWQ9MDt2YXIgdG9rZW47Zm9yKHZhciBqPWNvbG9uLTE7aj49MDtqLS0pe3Rva2VuPXRva2Vuc1tqXTtpZih0b2tlblswXSE9PSdzcGFjZScpe2ZvdW5kZWQrPTE7aWYoZm91bmRlZD09PTIpYnJlYWs7fX10aHJvdyB0aGlzLmlucHV0LmVycm9yKCdNaXNzZWQgc2VtaWNvbG9uJyx0b2tlblsyXSx0b2tlblszXSk7fTtyZXR1cm4gUGFyc2VyO30oKTtleHBvcnRzW1wiZGVmYXVsdFwiXT1QYXJzZXI7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7XCIuL2F0LXJ1bGVcIjozOSxcIi4vY29tbWVudFwiOjQwLFwiLi9kZWNsYXJhdGlvblwiOjQzLFwiLi9yb290XCI6NTUsXCIuL3J1bGVcIjo1NixcIi4vdG9rZW5pemVcIjo1OX1dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIF9kZWNsYXJhdGlvbj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2RlY2xhcmF0aW9uXCIpKTt2YXIgX3Byb2Nlc3Nvcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Byb2Nlc3NvclwiKSk7dmFyIF9zdHJpbmdpZnk9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZnlcIikpO3ZhciBfY29tbWVudD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRcIikpO3ZhciBfYXRSdWxlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYXQtcnVsZVwiKSk7dmFyIF92ZW5kb3I9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92ZW5kb3JcIikpO3ZhciBfcGFyc2U9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZVwiKSk7dmFyIF9saXN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGlzdFwiKSk7dmFyIF9ydWxlPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcnVsZVwiKSk7dmFyIF9yb290PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm9vdFwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9LyoqXG4gKiBDcmVhdGUgYSBuZXcge0BsaW5rIFByb2Nlc3Nvcn0gaW5zdGFuY2UgdGhhdCB3aWxsIGFwcGx5IGBwbHVnaW5zYFxuICogYXMgQ1NTIHByb2Nlc3NvcnMuXG4gKlxuICogQHBhcmFtIHtBcnJheS48UGx1Z2lufHBsdWdpbkZ1bmN0aW9uPnxQcm9jZXNzb3J9IHBsdWdpbnMgUG9zdENTUyBwbHVnaW5zLlxuICogICAgICAgIFNlZSB7QGxpbmsgUHJvY2Vzc29yI3VzZX0gZm9yIHBsdWdpbiBmb3JtYXQuXG4gKlxuICogQHJldHVybiB7UHJvY2Vzc29yfSBQcm9jZXNzb3IgdG8gcHJvY2VzcyBtdWx0aXBsZSBDU1MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBwb3N0Y3NzIGZyb20gJ3Bvc3Rjc3MnXG4gKlxuICogcG9zdGNzcyhwbHVnaW5zKS5wcm9jZXNzKGNzcywgeyBmcm9tLCB0byB9KS50aGVuKHJlc3VsdCA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdC5jc3MpXG4gKiB9KVxuICpcbiAqIEBuYW1lc3BhY2UgcG9zdGNzc1xuICovZnVuY3Rpb24gcG9zdGNzcygpe2Zvcih2YXIgX2xlbj1hcmd1bWVudHMubGVuZ3RoLHBsdWdpbnM9bmV3IEFycmF5KF9sZW4pLF9rZXk9MDtfa2V5PF9sZW47X2tleSsrKXtwbHVnaW5zW19rZXldPWFyZ3VtZW50c1tfa2V5XTt9aWYocGx1Z2lucy5sZW5ndGg9PT0xJiZBcnJheS5pc0FycmF5KHBsdWdpbnNbMF0pKXtwbHVnaW5zPXBsdWdpbnNbMF07fXJldHVybiBuZXcgX3Byb2Nlc3NvcltcImRlZmF1bHRcIl0ocGx1Z2lucyk7fS8qKlxuICogQ3JlYXRlcyBhIFBvc3RDU1MgcGx1Z2luIHdpdGggYSBzdGFuZGFyZCBBUEkuXG4gKlxuICogVGhlIG5ld2x5LXdyYXBwZWQgZnVuY3Rpb24gd2lsbCBwcm92aWRlIGJvdGggdGhlIG5hbWUgYW5kIFBvc3RDU1NcbiAqIHZlcnNpb24gb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcHJvY2Vzc29yID0gcG9zdGNzcyhbcmVwbGFjZV0pXG4gKiBwcm9jZXNzb3IucGx1Z2luc1swXS5wb3N0Y3NzUGx1Z2luICAvLz0+ICdwb3N0Y3NzLXJlcGxhY2UnXG4gKiBwcm9jZXNzb3IucGx1Z2luc1swXS5wb3N0Y3NzVmVyc2lvbiAvLz0+ICc2LjAuMCdcbiAqIGBgYFxuICpcbiAqIFRoZSBwbHVnaW4gZnVuY3Rpb24gcmVjZWl2ZXMgMiBhcmd1bWVudHM6IHtAbGluayBSb290fVxuICogYW5kIHtAbGluayBSZXN1bHR9IGluc3RhbmNlLiBUaGUgZnVuY3Rpb24gc2hvdWxkIG11dGF0ZSB0aGUgcHJvdmlkZWRcbiAqIGBSb290YCBub2RlLiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGNyZWF0ZSBhIG5ldyBgUm9vdGAgbm9kZVxuICogYW5kIG92ZXJyaWRlIHRoZSBgcmVzdWx0LnJvb3RgIHByb3BlcnR5LlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBjbGVhbmVyID0gcG9zdGNzcy5wbHVnaW4oJ3Bvc3Rjc3MtY2xlYW5lcicsICgpID0+IHtcbiAqICAgcmV0dXJuIChyb290LCByZXN1bHQpID0+IHtcbiAqICAgICByZXN1bHQucm9vdCA9IHBvc3Rjc3Mucm9vdCgpXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBBcyBhIGNvbnZlbmllbmNlLCBwbHVnaW5zIGFsc28gZXhwb3NlIGEgYHByb2Nlc3NgIG1ldGhvZCBzbyB0aGF0IHlvdSBjYW4gdXNlXG4gKiB0aGVtIGFzIHN0YW5kYWxvbmUgdG9vbHMuXG4gKlxuICogYGBganNcbiAqIGNsZWFuZXIucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzLCBwbHVnaW5PcHRzKVxuICogLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvOlxuICogcG9zdGNzcyhbIGNsZWFuZXIocGx1Z2luT3B0cykgXSkucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzKVxuICogYGBgXG4gKlxuICogQXN5bmNocm9ub3VzIHBsdWdpbnMgc2hvdWxkIHJldHVybiBhIGBQcm9taXNlYCBpbnN0YW5jZS5cbiAqXG4gKiBgYGBqc1xuICogcG9zdGNzcy5wbHVnaW4oJ3Bvc3Rjc3MtaW1wb3J0JywgKCkgPT4ge1xuICogICByZXR1cm4gKHJvb3QsIHJlc3VsdCkgPT4ge1xuICogICAgIHJldHVybiBuZXcgUHJvbWlzZSggKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICogICAgICAgZnMucmVhZEZpbGUoJ2Jhc2UuY3NzJywgKGJhc2UpID0+IHtcbiAqICAgICAgICAgcm9vdC5wcmVwZW5kKGJhc2UpXG4gKiAgICAgICAgIHJlc29sdmUoKVxuICogICAgICAgfSlcbiAqICAgICB9KVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogQWRkIHdhcm5pbmdzIHVzaW5nIHRoZSB7QGxpbmsgTm9kZSN3YXJufSBtZXRob2QuXG4gKiBTZW5kIGRhdGEgdG8gb3RoZXIgcGx1Z2lucyB1c2luZyB0aGUge0BsaW5rIFJlc3VsdCNtZXNzYWdlc30gYXJyYXkuXG4gKlxuICogYGBganNcbiAqIHBvc3Rjc3MucGx1Z2luKCdwb3N0Y3NzLWNhbml1c2UtdGVzdCcsICgpID0+IHtcbiAqICAgcmV0dXJuIChyb290LCByZXN1bHQpID0+IHtcbiAqICAgICByb290LndhbGtEZWNscyhkZWNsID0+IHtcbiAqICAgICAgIGlmICghY2FuaXVzZS5zdXBwb3J0KGRlY2wucHJvcCkpIHtcbiAqICAgICAgICAgZGVjbC53YXJuKHJlc3VsdCwgJ1NvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgJyArIGRlY2wucHJvcClcbiAqICAgICAgIH1cbiAqICAgICB9KVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgICAgUG9zdENTUyBwbHVnaW4gbmFtZS4gU2FtZSBhcyBpbiBgbmFtZWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5IGluIGBwYWNrYWdlLmpzb25gLiBJdCB3aWxsIGJlIHNhdmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBgcGx1Z2luLnBvc3Rjc3NQbHVnaW5gIHByb3BlcnR5LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaW5pdGlhbGl6ZXIgV2lsbCByZWNlaXZlIHBsdWdpbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgc2hvdWxkIHJldHVybiB7QGxpbmsgcGx1Z2luRnVuY3Rpb259XG4gKlxuICogQHJldHVybiB7UGx1Z2lufSBQb3N0Q1NTIHBsdWdpbi5cbiAqL3Bvc3Rjc3MucGx1Z2luPWZ1bmN0aW9uIHBsdWdpbihuYW1lLGluaXRpYWxpemVyKXtmdW5jdGlvbiBjcmVhdG9yKCl7dmFyIHRyYW5zZm9ybWVyPWluaXRpYWxpemVyLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpO3RyYW5zZm9ybWVyLnBvc3Rjc3NQbHVnaW49bmFtZTt0cmFuc2Zvcm1lci5wb3N0Y3NzVmVyc2lvbj1uZXcgX3Byb2Nlc3NvcltcImRlZmF1bHRcIl0oKS52ZXJzaW9uO3JldHVybiB0cmFuc2Zvcm1lcjt9dmFyIGNhY2hlO09iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdG9yLCdwb3N0Y3NzJyx7Z2V0OmZ1bmN0aW9uIGdldCgpe2lmKCFjYWNoZSljYWNoZT1jcmVhdG9yKCk7cmV0dXJuIGNhY2hlO319KTtjcmVhdG9yLnByb2Nlc3M9ZnVuY3Rpb24oY3NzLHByb2Nlc3NPcHRzLHBsdWdpbk9wdHMpe3JldHVybiBwb3N0Y3NzKFtjcmVhdG9yKHBsdWdpbk9wdHMpXSkucHJvY2Vzcyhjc3MscHJvY2Vzc09wdHMpO307cmV0dXJuIGNyZWF0b3I7fTsvKipcbiAqIERlZmF1bHQgZnVuY3Rpb24gdG8gY29udmVydCBhIG5vZGUgdHJlZSBpbnRvIGEgQ1NTIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgICAgICAgU3RhcnQgbm9kZSBmb3Igc3RyaW5naWZpbmcuIFVzdWFsbHkge0BsaW5rIFJvb3R9LlxuICogQHBhcmFtIHtidWlsZGVyfSBidWlsZGVyIEZ1bmN0aW9uIHRvIGNvbmNhdGVuYXRlIENTUyBmcm9tIG5vZGXigJlzIHBhcnRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgZ2VuZXJhdGUgc3RyaW5nIGFuZCBzb3VyY2UgbWFwLlxuICpcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9wb3N0Y3NzLnN0cmluZ2lmeT1fc3RyaW5naWZ5W1wiZGVmYXVsdFwiXTsvKipcbiAqIFBhcnNlcyBzb3VyY2UgY3NzIGFuZCByZXR1cm5zIGEgbmV3IHtAbGluayBSb290fSBub2RlLFxuICogd2hpY2ggY29udGFpbnMgdGhlIHNvdXJjZSBDU1Mgbm9kZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8dG9TdHJpbmd9IGNzcyAgIFN0cmluZyB3aXRoIGlucHV0IENTUyBvciBhbnkgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0b1N0cmluZygpIG1ldGhvZCwgbGlrZSBhIEJ1ZmZlclxuICogQHBhcmFtIHtwcm9jZXNzT3B0aW9uc30gW29wdHNdIE9wdGlvbnMgd2l0aCBvbmx5IGBmcm9tYCBhbmQgYG1hcGAga2V5cy5cbiAqXG4gKiBAcmV0dXJuIHtSb290fSBQb3N0Q1NTIEFTVC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2ltcGxlIENTUyBjb25jYXRlbmF0aW9uIHdpdGggc291cmNlIG1hcCBzdXBwb3J0XG4gKiBjb25zdCByb290MSA9IHBvc3Rjc3MucGFyc2UoY3NzMSwgeyBmcm9tOiBmaWxlMSB9KVxuICogY29uc3Qgcm9vdDIgPSBwb3N0Y3NzLnBhcnNlKGNzczIsIHsgZnJvbTogZmlsZTIgfSlcbiAqIHJvb3QxLmFwcGVuZChyb290MikudG9SZXN1bHQoKS5jc3NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL3Bvc3Rjc3MucGFyc2U9X3BhcnNlW1wiZGVmYXVsdFwiXTsvKipcbiAqIENvbnRhaW5zIHRoZSB7QGxpbmsgdmVuZG9yfSBtb2R1bGUuXG4gKlxuICogQHR5cGUge3ZlbmRvcn1cbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy52ZW5kb3IudW5wcmVmaXhlZCgnLW1vei10YWInKSAvLz0+IFsndGFiJ11cbiAqL3Bvc3Rjc3MudmVuZG9yPV92ZW5kb3JbXCJkZWZhdWx0XCJdOy8qKlxuICogQ29udGFpbnMgdGhlIHtAbGluayBsaXN0fSBtb2R1bGUuXG4gKlxuICogQG1lbWJlciB7bGlzdH1cbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy5saXN0LnNwYWNlKCc1cHggY2FsYygxMCUgKyA1cHgpJykgLy89PiBbJzVweCcsICdjYWxjKDEwJSArIDVweCknXVxuICovcG9zdGNzcy5saXN0PV9saXN0W1wiZGVmYXVsdFwiXTsvKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIENvbW1lbnR9IG5vZGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtkZWZhdWx0c10gUHJvcGVydGllcyBmb3IgdGhlIG5ldyBub2RlLlxuICpcbiAqIEByZXR1cm4ge0NvbW1lbnR9IE5ldyBjb21tZW50IG5vZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy5jb21tZW50KHsgdGV4dDogJ3Rlc3QnIH0pXG4gKi9wb3N0Y3NzLmNvbW1lbnQ9ZnVuY3Rpb24oZGVmYXVsdHMpe3JldHVybiBuZXcgX2NvbW1lbnRbXCJkZWZhdWx0XCJdKGRlZmF1bHRzKTt9Oy8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQXRSdWxlfSBub2RlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGVmYXVsdHNdIFByb3BlcnRpZXMgZm9yIHRoZSBuZXcgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtBdFJ1bGV9IG5ldyBhdC1ydWxlIG5vZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogcG9zdGNzcy5hdFJ1bGUoeyBuYW1lOiAnY2hhcnNldCcgfSkudG9TdHJpbmcoKSAvLz0+IFwiQGNoYXJzZXRcIlxuICovcG9zdGNzcy5hdFJ1bGU9ZnVuY3Rpb24oZGVmYXVsdHMpe3JldHVybiBuZXcgX2F0UnVsZVtcImRlZmF1bHRcIl0oZGVmYXVsdHMpO307LyoqXG4gKiBDcmVhdGVzIGEgbmV3IHtAbGluayBEZWNsYXJhdGlvbn0gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW2RlZmF1bHRzXSBQcm9wZXJ0aWVzIGZvciB0aGUgbmV3IG5vZGUuXG4gKlxuICogQHJldHVybiB7RGVjbGFyYXRpb259IG5ldyBkZWNsYXJhdGlvbiBub2RlXG4gKlxuICogQGV4YW1wbGVcbiAqIHBvc3Rjc3MuZGVjbCh7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAncmVkJyB9KS50b1N0cmluZygpIC8vPT4gXCJjb2xvcjogcmVkXCJcbiAqL3Bvc3Rjc3MuZGVjbD1mdW5jdGlvbihkZWZhdWx0cyl7cmV0dXJuIG5ldyBfZGVjbGFyYXRpb25bXCJkZWZhdWx0XCJdKGRlZmF1bHRzKTt9Oy8qKlxuICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUnVsZX0gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW2RlZmF1bHRzXSBQcm9wZXJ0aWVzIGZvciB0aGUgbmV3IG5vZGUuXG4gKlxuICogQHJldHVybiB7UnVsZX0gbmV3IHJ1bGUgbm9kZVxuICpcbiAqIEBleGFtcGxlXG4gKiBwb3N0Y3NzLnJ1bGUoeyBzZWxlY3RvcjogJ2EnIH0pLnRvU3RyaW5nKCkgLy89PiBcImEge1xcbn1cIlxuICovcG9zdGNzcy5ydWxlPWZ1bmN0aW9uKGRlZmF1bHRzKXtyZXR1cm4gbmV3IF9ydWxlW1wiZGVmYXVsdFwiXShkZWZhdWx0cyk7fTsvKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFJvb3R9IG5vZGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtkZWZhdWx0c10gUHJvcGVydGllcyBmb3IgdGhlIG5ldyBub2RlLlxuICpcbiAqIEByZXR1cm4ge1Jvb3R9IG5ldyByb290IG5vZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIHBvc3Rjc3Mucm9vdCh7IGFmdGVyOiAnXFxuJyB9KS50b1N0cmluZygpIC8vPT4gXCJcXG5cIlxuICovcG9zdGNzcy5yb290PWZ1bmN0aW9uKGRlZmF1bHRzKXtyZXR1cm4gbmV3IF9yb290W1wiZGVmYXVsdFwiXShkZWZhdWx0cyk7fTt2YXIgX2RlZmF1bHQ9cG9zdGNzcztleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vYXQtcnVsZVwiOjM5LFwiLi9jb21tZW50XCI6NDAsXCIuL2RlY2xhcmF0aW9uXCI6NDMsXCIuL2xpc3RcIjo0NixcIi4vcGFyc2VcIjo0OSxcIi4vcHJvY2Vzc29yXCI6NTMsXCIuL3Jvb3RcIjo1NSxcIi4vcnVsZVwiOjU2LFwiLi9zdHJpbmdpZnlcIjo1OCxcIi4vdmVuZG9yXCI6NjB9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKEJ1ZmZlcil7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfc291cmNlTWFwPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInNvdXJjZS1tYXBcIikpO3ZhciBfcGF0aD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwYXRoXCIpKTt2YXIgX2ZzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImZzXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O31mdW5jdGlvbiBmcm9tQmFzZTY0KHN0cil7aWYoQnVmZmVyKXtyZXR1cm4gQnVmZmVyLmZyb20oc3RyLCdiYXNlNjQnKS50b1N0cmluZygpO31lbHNle3JldHVybiB3aW5kb3cuYXRvYihzdHIpO319LyoqXG4gKiBTb3VyY2UgbWFwIGluZm9ybWF0aW9uIGZyb20gaW5wdXQgQ1NTLlxuICogRm9yIGV4YW1wbGUsIHNvdXJjZSBtYXAgYWZ0ZXIgU2FzcyBjb21waWxlci5cbiAqXG4gKiBUaGlzIGNsYXNzIHdpbGwgYXV0b21hdGljYWxseSBmaW5kIHNvdXJjZSBtYXAgaW4gaW5wdXQgQ1NTIG9yIGluIGZpbGUgc3lzdGVtXG4gKiBuZWFyIGlucHV0IGZpbGUgKGFjY29yZGluZyBgZnJvbWAgb3B0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoY3NzLCB7IGZyb206ICdhLnNhc3MuY3NzJyB9KVxuICogcm9vdC5pbnB1dC5tYXAgLy89PiBQcmV2aW91c01hcFxuICovdmFyIFByZXZpb3VzTWFwPS8qI19fUFVSRV9fKi9mdW5jdGlvbigpey8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICBjc3MgICAgSW5wdXQgQ1NTIHNvdXJjZS5cbiAgICogQHBhcmFtIHtwcm9jZXNzT3B0aW9uc30gW29wdHNdIHtAbGluayBQcm9jZXNzb3IjcHJvY2Vzc30gb3B0aW9ucy5cbiAgICovZnVuY3Rpb24gUHJldmlvdXNNYXAoY3NzLG9wdHMpe3RoaXMubG9hZEFubm90YXRpb24oY3NzKTsvKipcbiAgICAgKiBXYXMgc291cmNlIG1hcCBpbmxpbmVkIGJ5IGRhdGEtdXJpIHRvIGlucHV0IENTUy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL3RoaXMuaW5saW5lPXRoaXMuc3RhcnRXaXRoKHRoaXMuYW5ub3RhdGlvbiwnZGF0YTonKTt2YXIgcHJldj1vcHRzLm1hcD9vcHRzLm1hcC5wcmV2OnVuZGVmaW5lZDt2YXIgdGV4dD10aGlzLmxvYWRNYXAob3B0cy5mcm9tLHByZXYpO2lmKHRleHQpdGhpcy50ZXh0PXRleHQ7fS8qKlxuICAgKiBDcmVhdGUgYSBpbnN0YW5jZSBvZiBgU291cmNlTWFwR2VuZXJhdG9yYCBjbGFzc1xuICAgKiBmcm9tIHRoZSBgc291cmNlLW1hcGAgbGlicmFyeSB0byB3b3JrIHdpdGggc291cmNlIG1hcCBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogSXQgaXMgbGF6eSBtZXRob2QsIHNvIGl0IHdpbGwgY3JlYXRlIG9iamVjdCBvbmx5IG9uIGZpcnN0IGNhbGxcbiAgICogYW5kIHRoZW4gaXQgd2lsbCB1c2UgY2FjaGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1NvdXJjZU1hcEdlbmVyYXRvcn0gT2JqZWN0IHdpdGggc291cmNlIG1hcCBpbmZvcm1hdGlvbi5cbiAgICovdmFyIF9wcm90bz1QcmV2aW91c01hcC5wcm90b3R5cGU7X3Byb3RvLmNvbnN1bWVyPWZ1bmN0aW9uIGNvbnN1bWVyKCl7aWYoIXRoaXMuY29uc3VtZXJDYWNoZSl7dGhpcy5jb25zdW1lckNhY2hlPW5ldyBfc291cmNlTWFwW1wiZGVmYXVsdFwiXS5Tb3VyY2VNYXBDb25zdW1lcih0aGlzLnRleHQpO31yZXR1cm4gdGhpcy5jb25zdW1lckNhY2hlO30vKipcbiAgICogRG9lcyBzb3VyY2UgbWFwIGNvbnRhaW5zIGBzb3VyY2VzQ29udGVudGAgd2l0aCBpbnB1dCBzb3VyY2UgdGV4dC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgYHNvdXJjZXNDb250ZW50YCBwcmVzZW50LlxuICAgKi87X3Byb3RvLndpdGhDb250ZW50PWZ1bmN0aW9uIHdpdGhDb250ZW50KCl7cmV0dXJuISEodGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50JiZ0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQubGVuZ3RoPjApO307X3Byb3RvLnN0YXJ0V2l0aD1mdW5jdGlvbiBzdGFydFdpdGgoc3RyaW5nLHN0YXJ0KXtpZighc3RyaW5nKXJldHVybiBmYWxzZTtyZXR1cm4gc3RyaW5nLnN1YnN0cigwLHN0YXJ0Lmxlbmd0aCk9PT1zdGFydDt9O19wcm90by5sb2FkQW5ub3RhdGlvbj1mdW5jdGlvbiBsb2FkQW5ub3RhdGlvbihjc3Mpe3ZhciBtYXRjaD1jc3MubWF0Y2goL1xcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9KC4qKVxccypcXCpcXC8vKTtpZihtYXRjaCl0aGlzLmFubm90YXRpb249bWF0Y2hbMV0udHJpbSgpO307X3Byb3RvLmRlY29kZUlubGluZT1mdW5jdGlvbiBkZWNvZGVJbmxpbmUodGV4dCl7dmFyIGJhc2VDaGFyc2V0VXJpPS9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC87dmFyIGJhc2VVcmk9L15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtiYXNlNjQsLzt2YXIgdXJpPSdkYXRhOmFwcGxpY2F0aW9uL2pzb24sJztpZih0aGlzLnN0YXJ0V2l0aCh0ZXh0LHVyaSkpe3JldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIodXJpLmxlbmd0aCkpO31pZihiYXNlQ2hhcnNldFVyaS50ZXN0KHRleHQpfHxiYXNlVXJpLnRlc3QodGV4dCkpe3JldHVybiBmcm9tQmFzZTY0KHRleHQuc3Vic3RyKFJlZ0V4cC5sYXN0TWF0Y2gubGVuZ3RoKSk7fXZhciBlbmNvZGluZz10ZXh0Lm1hdGNoKC9kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW14sXSspLC8pWzFdO3Rocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc291cmNlIG1hcCBlbmNvZGluZyAnK2VuY29kaW5nKTt9O19wcm90by5sb2FkTWFwPWZ1bmN0aW9uIGxvYWRNYXAoZmlsZSxwcmV2KXtpZihwcmV2PT09ZmFsc2UpcmV0dXJuIGZhbHNlO2lmKHByZXYpe2lmKHR5cGVvZiBwcmV2PT09J3N0cmluZycpe3JldHVybiBwcmV2O31lbHNlIGlmKHR5cGVvZiBwcmV2PT09J2Z1bmN0aW9uJyl7dmFyIHByZXZQYXRoPXByZXYoZmlsZSk7aWYocHJldlBhdGgmJl9mc1tcImRlZmF1bHRcIl0uZXhpc3RzU3luYyYmX2ZzW1wiZGVmYXVsdFwiXS5leGlzdHNTeW5jKHByZXZQYXRoKSl7cmV0dXJuIF9mc1tcImRlZmF1bHRcIl0ucmVhZEZpbGVTeW5jKHByZXZQYXRoLCd1dGYtOCcpLnRvU3RyaW5nKCkudHJpbSgpO31lbHNle3Rocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvYWQgcHJldmlvdXMgc291cmNlIG1hcDogJytwcmV2UGF0aC50b1N0cmluZygpKTt9fWVsc2UgaWYocHJldiBpbnN0YW5jZW9mIF9zb3VyY2VNYXBbXCJkZWZhdWx0XCJdLlNvdXJjZU1hcENvbnN1bWVyKXtyZXR1cm4gX3NvdXJjZU1hcFtcImRlZmF1bHRcIl0uU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKTt9ZWxzZSBpZihwcmV2IGluc3RhbmNlb2YgX3NvdXJjZU1hcFtcImRlZmF1bHRcIl0uU291cmNlTWFwR2VuZXJhdG9yKXtyZXR1cm4gcHJldi50b1N0cmluZygpO31lbHNlIGlmKHRoaXMuaXNNYXAocHJldikpe3JldHVybiBKU09OLnN0cmluZ2lmeShwcmV2KTt9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByZXZpb3VzIHNvdXJjZSBtYXAgZm9ybWF0OiAnK3ByZXYudG9TdHJpbmcoKSk7fX1lbHNlIGlmKHRoaXMuaW5saW5lKXtyZXR1cm4gdGhpcy5kZWNvZGVJbmxpbmUodGhpcy5hbm5vdGF0aW9uKTt9ZWxzZSBpZih0aGlzLmFubm90YXRpb24pe3ZhciBtYXA9dGhpcy5hbm5vdGF0aW9uO2lmKGZpbGUpbWFwPV9wYXRoW1wiZGVmYXVsdFwiXS5qb2luKF9wYXRoW1wiZGVmYXVsdFwiXS5kaXJuYW1lKGZpbGUpLG1hcCk7dGhpcy5yb290PV9wYXRoW1wiZGVmYXVsdFwiXS5kaXJuYW1lKG1hcCk7aWYoX2ZzW1wiZGVmYXVsdFwiXS5leGlzdHNTeW5jJiZfZnNbXCJkZWZhdWx0XCJdLmV4aXN0c1N5bmMobWFwKSl7cmV0dXJuIF9mc1tcImRlZmF1bHRcIl0ucmVhZEZpbGVTeW5jKG1hcCwndXRmLTgnKS50b1N0cmluZygpLnRyaW0oKTt9ZWxzZXtyZXR1cm4gZmFsc2U7fX19O19wcm90by5pc01hcD1mdW5jdGlvbiBpc01hcChtYXApe2lmKF90eXBlb2YobWFwKSE9PSdvYmplY3QnKXJldHVybiBmYWxzZTtyZXR1cm4gdHlwZW9mIG1hcC5tYXBwaW5ncz09PSdzdHJpbmcnfHx0eXBlb2YgbWFwLl9tYXBwaW5ncz09PSdzdHJpbmcnO307cmV0dXJuIFByZXZpb3VzTWFwO30oKTt2YXIgX2RlZmF1bHQ9UHJldmlvdXNNYXA7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKTt9LHtcImJ1ZmZlclwiOjMsXCJmc1wiOjIsXCJwYXRoXCI6MzgsXCJzb3VyY2UtbWFwXCI6Nzh9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3Mpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2xhenlSZXN1bHQ9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9sYXp5LXJlc3VsdFwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9LyoqXG4gKiBDb250YWlucyBwbHVnaW5zIHRvIHByb2Nlc3MgQ1NTLiBDcmVhdGUgb25lIGBQcm9jZXNzb3JgIGluc3RhbmNlLFxuICogaW5pdGlhbGl6ZSBpdHMgcGx1Z2lucywgYW5kIHRoZW4gdXNlIHRoYXQgaW5zdGFuY2Ugb24gbnVtZXJvdXMgQ1NTIGZpbGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwcm9jZXNzb3IgPSBwb3N0Y3NzKFthdXRvcHJlZml4ZXIsIHByZWNzc10pXG4gKiBwcm9jZXNzb3IucHJvY2Vzcyhjc3MxKS50aGVuKHJlc3VsdCA9PiBjb25zb2xlLmxvZyhyZXN1bHQuY3NzKSlcbiAqIHByb2Nlc3Nvci5wcm9jZXNzKGNzczIpLnRoZW4ocmVzdWx0ID0+IGNvbnNvbGUubG9nKHJlc3VsdC5jc3MpKVxuICovdmFyIFByb2Nlc3Nvcj0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXsvKipcbiAgICogQHBhcmFtIHtBcnJheS48UGx1Z2lufHBsdWdpbkZ1bmN0aW9uPnxQcm9jZXNzb3J9IHBsdWdpbnMgUG9zdENTUyBwbHVnaW5zLlxuICAgKiAgICAgICAgU2VlIHtAbGluayBQcm9jZXNzb3IjdXNlfSBmb3IgcGx1Z2luIGZvcm1hdC5cbiAgICovZnVuY3Rpb24gUHJvY2Vzc29yKHBsdWdpbnMpe2lmKHBsdWdpbnM9PT12b2lkIDApe3BsdWdpbnM9W107fS8qKlxuICAgICAqIEN1cnJlbnQgUG9zdENTUyB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaWYgKHJlc3VsdC5wcm9jZXNzb3IudmVyc2lvbi5zcGxpdCgnLicpWzBdICE9PSAnNicpIHtcbiAgICAgKiAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwbHVnaW4gd29ya3Mgb25seSB3aXRoIFBvc3RDU1MgNicpXG4gICAgICogfVxuICAgICAqL3RoaXMudmVyc2lvbj0nNy4wLjI3JzsvKipcbiAgICAgKiBQbHVnaW5zIGFkZGVkIHRvIHRoaXMgcHJvY2Vzc29yLlxuICAgICAqXG4gICAgICogQHR5cGUge3BsdWdpbkZ1bmN0aW9uW119XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHByb2Nlc3NvciA9IHBvc3Rjc3MoW2F1dG9wcmVmaXhlciwgcHJlY3NzXSlcbiAgICAgKiBwcm9jZXNzb3IucGx1Z2lucy5sZW5ndGggLy89PiAyXG4gICAgICovdGhpcy5wbHVnaW5zPXRoaXMubm9ybWFsaXplKHBsdWdpbnMpO30vKipcbiAgICogQWRkcyBhIHBsdWdpbiB0byBiZSB1c2VkIGFzIGEgQ1NTIHByb2Nlc3Nvci5cbiAgICpcbiAgICogUG9zdENTUyBwbHVnaW4gY2FuIGJlIGluIDQgZm9ybWF0czpcbiAgICogKiBBIHBsdWdpbiBjcmVhdGVkIGJ5IHtAbGluayBwb3N0Y3NzLnBsdWdpbn0gbWV0aG9kLlxuICAgKiAqIEEgZnVuY3Rpb24uIFBvc3RDU1Mgd2lsbCBwYXNzIHRoZSBmdW5jdGlvbiBhIEB7bGluayBSb290fVxuICAgKiAgIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgY3VycmVudCB7QGxpbmsgUmVzdWx0fSBpbnN0YW5jZVxuICAgKiAgIGFzIHRoZSBzZWNvbmQuXG4gICAqICogQW4gb2JqZWN0IHdpdGggYSBgcG9zdGNzc2AgbWV0aG9kLiBQb3N0Q1NTIHdpbGwgdXNlIHRoYXQgbWV0aG9kXG4gICAqICAgYXMgZGVzY3JpYmVkIGluICMyLlxuICAgKiAqIEFub3RoZXIge0BsaW5rIFByb2Nlc3Nvcn0gaW5zdGFuY2UuIFBvc3RDU1Mgd2lsbCBjb3B5IHBsdWdpbnNcbiAgICogICBmcm9tIHRoYXQgaW5zdGFuY2UgaW50byB0aGlzIG9uZS5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYWxzbyBiZSBhZGRlZCBieSBwYXNzaW5nIHRoZW0gYXMgYXJndW1lbnRzIHdoZW4gY3JlYXRpbmdcbiAgICogYSBgcG9zdGNzc2AgaW5zdGFuY2UgKHNlZSBbYHBvc3Rjc3MocGx1Z2lucylgXSkuXG4gICAqXG4gICAqIEFzeW5jaHJvbm91cyBwbHVnaW5zIHNob3VsZCByZXR1cm4gYSBgUHJvbWlzZWAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UGx1Z2lufHBsdWdpbkZ1bmN0aW9ufFByb2Nlc3Nvcn0gcGx1Z2luIFBvc3RDU1MgcGx1Z2luXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIHtAbGluayBQcm9jZXNzb3J9XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggcGx1Z2lucy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcHJvY2Vzc29yID0gcG9zdGNzcygpXG4gICAqICAgLnVzZShhdXRvcHJlZml4ZXIpXG4gICAqICAgLnVzZShwcmVjc3MpXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb2Nlc3Nlc30gQ3VycmVudCBwcm9jZXNzb3IgdG8gbWFrZSBtZXRob2RzIGNoYWluLlxuICAgKi92YXIgX3Byb3RvPVByb2Nlc3Nvci5wcm90b3R5cGU7X3Byb3RvLnVzZT1mdW5jdGlvbiB1c2UocGx1Z2luKXt0aGlzLnBsdWdpbnM9dGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbcGx1Z2luXSkpO3JldHVybiB0aGlzO30vKipcbiAgICogUGFyc2VzIHNvdXJjZSBDU1MgYW5kIHJldHVybnMgYSB7QGxpbmsgTGF6eVJlc3VsdH0gUHJvbWlzZSBwcm94eS5cbiAgICogQmVjYXVzZSBzb21lIHBsdWdpbnMgY2FuIGJlIGFzeW5jaHJvbm91cyBpdCBkb2VzbuKAmXQgbWFrZVxuICAgKiBhbnkgdHJhbnNmb3JtYXRpb25zLiBUcmFuc2Zvcm1hdGlvbnMgd2lsbCBiZSBhcHBsaWVkXG4gICAqIGluIHRoZSB7QGxpbmsgTGF6eVJlc3VsdH0gbWV0aG9kcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8dG9TdHJpbmd8UmVzdWx0fSBjc3MgU3RyaW5nIHdpdGggaW5wdXQgQ1NTIG9yIGFueSBvYmplY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBhIGB0b1N0cmluZygpYCBtZXRob2QsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpa2UgYSBCdWZmZXIuIE9wdGlvbmFsbHksIHNlbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSB7QGxpbmsgUmVzdWx0fSBpbnN0YW5jZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIHByb2Nlc3NvciB3aWxsIHRha2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHtAbGluayBSb290fSBmcm9tIGl0LlxuICAgKiBAcGFyYW0ge3Byb2Nlc3NPcHRpb25zfSBbb3B0c10gICAgICBPcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMYXp5UmVzdWx0fSBQcm9taXNlIHByb3h5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwcm9jZXNzb3IucHJvY2Vzcyhjc3MsIHsgZnJvbTogJ2EuY3NzJywgdG86ICdhLm91dC5jc3MnIH0pXG4gICAqICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICogICAgICBjb25zb2xlLmxvZyhyZXN1bHQuY3NzKVxuICAgKiAgIH0pXG4gICAqLztfcHJvdG8ucHJvY2Vzcz1mdW5jdGlvbihfcHJvY2Vzcyl7ZnVuY3Rpb24gcHJvY2VzcyhfeCl7cmV0dXJuIF9wcm9jZXNzLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt9cHJvY2Vzcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBfcHJvY2Vzcy50b1N0cmluZygpO307cmV0dXJuIHByb2Nlc3M7fShmdW5jdGlvbihjc3Msb3B0cyl7aWYob3B0cz09PXZvaWQgMCl7b3B0cz17fTt9aWYodGhpcy5wbHVnaW5zLmxlbmd0aD09PTAmJm9wdHMucGFyc2VyPT09b3B0cy5zdHJpbmdpZmllcil7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe2lmKHR5cGVvZiBjb25zb2xlIT09J3VuZGVmaW5lZCcmJmNvbnNvbGUud2Fybil7Y29uc29sZS53YXJuKCdZb3UgZGlkIG5vdCBzZXQgYW55IHBsdWdpbnMsIHBhcnNlciwgb3Igc3RyaW5naWZpZXIuICcrJ1JpZ2h0IG5vdywgUG9zdENTUyBkb2VzIG5vdGhpbmcuIFBpY2sgcGx1Z2lucyBmb3IgeW91ciBjYXNlICcrJ29uIGh0dHBzOi8vd3d3LnBvc3Rjc3MucGFydHMvIGFuZCB1c2UgdGhlbSBpbiBwb3N0Y3NzLmNvbmZpZy5qcy4nKTt9fX1yZXR1cm4gbmV3IF9sYXp5UmVzdWx0W1wiZGVmYXVsdFwiXSh0aGlzLGNzcyxvcHRzKTt9KTtfcHJvdG8ubm9ybWFsaXplPWZ1bmN0aW9uIG5vcm1hbGl6ZShwbHVnaW5zKXt2YXIgbm9ybWFsaXplZD1bXTtmb3IodmFyIF9pdGVyYXRvcj1wbHVnaW5zLF9pc0FycmF5PUFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSxfaT0wLF9pdGVyYXRvcj1faXNBcnJheT9faXRlcmF0b3I6X2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KXt2YXIgX3JlZjtpZihfaXNBcnJheSl7aWYoX2k+PV9pdGVyYXRvci5sZW5ndGgpYnJlYWs7X3JlZj1faXRlcmF0b3JbX2krK107fWVsc2V7X2k9X2l0ZXJhdG9yLm5leHQoKTtpZihfaS5kb25lKWJyZWFrO19yZWY9X2kudmFsdWU7fXZhciBpPV9yZWY7aWYoaS5wb3N0Y3NzKWk9aS5wb3N0Y3NzO2lmKF90eXBlb2YoaSk9PT0nb2JqZWN0JyYmQXJyYXkuaXNBcnJheShpLnBsdWdpbnMpKXtub3JtYWxpemVkPW5vcm1hbGl6ZWQuY29uY2F0KGkucGx1Z2lucyk7fWVsc2UgaWYodHlwZW9mIGk9PT0nZnVuY3Rpb24nKXtub3JtYWxpemVkLnB1c2goaSk7fWVsc2UgaWYoX3R5cGVvZihpKT09PSdvYmplY3QnJiYoaS5wYXJzZXx8aS5zdHJpbmdpZnkpKXtpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7dGhyb3cgbmV3IEVycm9yKCdQb3N0Q1NTIHN5bnRheGVzIGNhbm5vdCBiZSB1c2VkIGFzIHBsdWdpbnMuIEluc3RlYWQsIHBsZWFzZSB1c2UgJysnb25lIG9mIHRoZSBzeW50YXgvcGFyc2VyL3N0cmluZ2lmaWVyIG9wdGlvbnMgYXMgb3V0bGluZWQgJysnaW4geW91ciBQb3N0Q1NTIHJ1bm5lciBkb2N1bWVudGF0aW9uLicpO319ZWxzZXt0aHJvdyBuZXcgRXJyb3IoaSsnIGlzIG5vdCBhIFBvc3RDU1MgcGx1Z2luJyk7fX1yZXR1cm4gbm9ybWFsaXplZDt9O3JldHVybiBQcm9jZXNzb3I7fSgpO3ZhciBfZGVmYXVsdD1Qcm9jZXNzb3I7LyoqXG4gKiBAY2FsbGJhY2sgYnVpbGRlclxuICogQHBhcmFtIHtzdHJpbmd9IHBhcnQgICAgICAgICAgUGFydCBvZiBnZW5lcmF0ZWQgQ1NTIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gKiBAcGFyYW0ge05vZGV9ICAgbm9kZSAgICAgICAgICBBU1Qgbm9kZS5cbiAqIEBwYXJhbSB7XCJzdGFydFwifFwiZW5kXCJ9IFt0eXBlXSBOb2Rl4oCZcyBwYXJ0IHR5cGUuXG4gKi8gLyoqXG4gKiBAY2FsbGJhY2sgcGFyc2VyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8dG9TdHJpbmd9IGNzcyAgIFN0cmluZyB3aXRoIGlucHV0IENTUyBvciBhbnkgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0b1N0cmluZygpIG1ldGhvZCwgbGlrZSBhIEJ1ZmZlci5cbiAqIEBwYXJhbSB7cHJvY2Vzc09wdGlvbnN9IFtvcHRzXSBPcHRpb25zIHdpdGggb25seSBgZnJvbWAgYW5kIGBtYXBgIGtleXMuXG4gKlxuICogQHJldHVybiB7Um9vdH0gUG9zdENTUyBBU1RcbiAqLyAvKipcbiAqIEBjYWxsYmFjayBzdHJpbmdpZmllclxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICAgICBTdGFydCBub2RlIGZvciBzdHJpbmdpZmluZy4gVXN1YWxseSB7QGxpbmsgUm9vdH0uXG4gKiBAcGFyYW0ge2J1aWxkZXJ9IGJ1aWxkZXIgRnVuY3Rpb24gdG8gY29uY2F0ZW5hdGUgQ1NTIGZyb20gbm9kZeKAmXMgcGFydHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBnZW5lcmF0ZSBzdHJpbmcgYW5kIHNvdXJjZSBtYXAuXG4gKlxuICogQHJldHVybiB7dm9pZH1cbiAqLyAvKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IHN5bnRheFxuICogQHByb3BlcnR5IHtwYXJzZXJ9IHBhcnNlICAgICAgICAgIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIEFTVCBieSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge3N0cmluZ2lmaWVyfSBzdHJpbmdpZnkgRnVuY3Rpb24gdG8gZ2VuZXJhdGUgc3RyaW5nIGJ5IEFTVC5cbiAqLyAvKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IHRvU3RyaW5nXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB0b1N0cmluZ1xuICovIC8qKlxuICogQGNhbGxiYWNrIHBsdWdpbkZ1bmN0aW9uXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgICAgIFBhcnNlZCBpbnB1dCBDU1MuXG4gKiBAcGFyYW0ge1Jlc3VsdH0gcmVzdWx0IFJlc3VsdCB0byBzZXQgd2FybmluZ3Mgb3IgY2hlY2sgb3RoZXIgcGx1Z2lucy5cbiAqLyAvKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFBsdWdpblxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcG9zdGNzcyBQb3N0Q1NTIHBsdWdpbiBmdW5jdGlvbi5cbiAqLyAvKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IHByb2Nlc3NPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZnJvbSAgICAgICAgICAgICBUaGUgcGF0aCBvZiB0aGUgQ1NTIHNvdXJjZSBmaWxlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWW91IHNob3VsZCBhbHdheXMgc2V0IGBmcm9tYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlY2F1c2UgaXQgaXMgdXNlZCBpbiBzb3VyY2UgbWFwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uIGFuZCBzeW50YXggZXJyb3IgbWVzc2FnZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG8gICAgICAgICAgICAgICBUaGUgcGF0aCB3aGVyZSB5b3XigJlsbCBwdXQgdGhlIG91dHB1dFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1NTIGZpbGUuIFlvdSBzaG91bGQgYWx3YXlzIHNldCBgdG9gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBnZW5lcmF0ZSBjb3JyZWN0IHNvdXJjZSBtYXBzLlxuICogQHByb3BlcnR5IHtwYXJzZXJ9IHBhcnNlciAgICAgICAgICAgRnVuY3Rpb24gdG8gZ2VuZXJhdGUgQVNUIGJ5IHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5naWZpZXJ9IHN0cmluZ2lmaWVyIENsYXNzIHRvIGdlbmVyYXRlIHN0cmluZyBieSBBU1QuXG4gKiBAcHJvcGVydHkge3N5bnRheH0gc3ludGF4ICAgICAgICAgICBPYmplY3Qgd2l0aCBgcGFyc2VgIGFuZCBgc3RyaW5naWZ5YC5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBtYXAgICAgICAgICAgICAgIFNvdXJjZSBtYXAgb3B0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFwLmlubGluZSAgICAgICAgICAgICAgICAgICAgRG9lcyBzb3VyY2UgbWFwIHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBlbWJlZGRlZCBpbiB0aGUgb3V0cHV0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENTUyBhcyBhIGJhc2U2NC1lbmNvZGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R8ZmFsc2V8ZnVuY3Rpb259IG1hcC5wcmV2IFNvdXJjZSBtYXAgY29udGVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIGEgcHJldmlvdXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZyBzdGVwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmb3IgZXhhbXBsZSwgU2FzcykuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvc3RDU1Mgd2lsbCB0cnkgdG8gZmluZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyBtYXAgYXV0b21hdGljYWxseSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc28geW91IGNvdWxkIGRpc2FibGUgaXQgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZhbHNlYCB2YWx1ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFwLnNvdXJjZXNDb250ZW50ICAgICAgICAgICAgRG9lcyBQb3N0Q1NTIHNob3VsZCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9yaWdpbiBjb250ZW50IHRvIG1hcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGZhbHNlfSBtYXAuYW5ub3RhdGlvbiAgICAgICAgICAgRG9lcyBQb3N0Q1NTIHNob3VsZCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbiBjb21tZW50IHRvIG1hcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXAuZnJvbSAgICAgICAgICAgICAgICAgICAgICAgT3ZlcnJpZGUgYGZyb21gIGluIG1hcOKAmXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlc2AuXG4gKi9leHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSk7fSx7XCIuL2xhenktcmVzdWx0XCI6NDUsXCJfcHJvY2Vzc1wiOjYzfV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX3dhcm5pbmc9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi93YXJuaW5nXCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntcImRlZmF1bHRcIjpvYmp9O31mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpO2lmKHN0YXRpY1Byb3BzKV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7fS8qKlxuICogUHJvdmlkZXMgdGhlIHJlc3VsdCBvZiB0aGUgUG9zdENTUyB0cmFuc2Zvcm1hdGlvbnMuXG4gKlxuICogQSBSZXN1bHQgaW5zdGFuY2UgaXMgcmV0dXJuZWQgYnkge0BsaW5rIExhenlSZXN1bHQjdGhlbn1cbiAqIG9yIHtAbGluayBSb290I3RvUmVzdWx0fSBtZXRob2RzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBwb3N0Y3NzKFthdXRvcHJlZml4ZXJdKS5wcm9jZXNzKGNzcykudGhlbihyZXN1bHQgPT4ge1xuICogIGNvbnNvbGUubG9nKHJlc3VsdC5jc3MpXG4gKiB9KVxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZXN1bHQyID0gcG9zdGNzcy5wYXJzZShjc3MpLnRvUmVzdWx0KClcbiAqL3ZhciBSZXN1bHQ9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7LyoqXG4gICAqIEBwYXJhbSB7UHJvY2Vzc29yfSBwcm9jZXNzb3IgUHJvY2Vzc29yIHVzZWQgZm9yIHRoaXMgdHJhbnNmb3JtYXRpb24uXG4gICAqIEBwYXJhbSB7Um9vdH0gICAgICByb290ICAgICAgUm9vdCBub2RlIGFmdGVyIGFsbCB0cmFuc2Zvcm1hdGlvbnMuXG4gICAqIEBwYXJhbSB7cHJvY2Vzc09wdGlvbnN9IG9wdHMgT3B0aW9ucyBmcm9tIHRoZSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Ige0BsaW5rIFJvb3QjdG9SZXN1bHR9LlxuICAgKi9mdW5jdGlvbiBSZXN1bHQocHJvY2Vzc29yLHJvb3Qsb3B0cyl7LyoqXG4gICAgICogVGhlIFByb2Nlc3NvciBpbnN0YW5jZSB1c2VkIGZvciB0aGlzIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge1Byb2Nlc3Nvcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogZm9yIChjb25zdCBwbHVnaW4gb2YgcmVzdWx0LnByb2Nlc3Nvci5wbHVnaW5zKSB7XG4gICAgICogICBpZiAocGx1Z2luLnBvc3Rjc3NQbHVnaW4gPT09ICdwb3N0Y3NzLWJhZCcpIHtcbiAgICAgKiAgICAgdGhyb3cgJ3Bvc3Rjc3MtZ29vZCBpcyBpbmNvbXBhdGlibGUgd2l0aCBwb3N0Y3NzLWJhZCdcbiAgICAgKiAgIH1cbiAgICAgKiB9KVxuICAgICAqL3RoaXMucHJvY2Vzc29yPXByb2Nlc3NvcjsvKipcbiAgICAgKiBDb250YWlucyBtZXNzYWdlcyBmcm9tIHBsdWdpbnMgKGUuZy4sIHdhcm5pbmdzIG9yIGN1c3RvbSBtZXNzYWdlcykuXG4gICAgICogRWFjaCBtZXNzYWdlIHNob3VsZCBoYXZlIHR5cGUgYW5kIHBsdWdpbiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHR5cGUge01lc3NhZ2VbXX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcG9zdGNzcy5wbHVnaW4oJ3Bvc3Rjc3MtbWluLWJyb3dzZXInLCAoKSA9PiB7XG4gICAgICogICByZXR1cm4gKHJvb3QsIHJlc3VsdCkgPT4ge1xuICAgICAqICAgICBjb25zdCBicm93c2VycyA9IGRldGVjdE1pbkJyb3dzZXJzQnlDYW5JVXNlKHJvb3QpXG4gICAgICogICAgIHJlc3VsdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgKiAgICAgICB0eXBlOiAnbWluLWJyb3dzZXInLFxuICAgICAqICAgICAgIHBsdWdpbjogJ3Bvc3Rjc3MtbWluLWJyb3dzZXInLFxuICAgICAqICAgICAgIGJyb3dzZXJzXG4gICAgICogICAgIH0pXG4gICAgICogICB9XG4gICAgICogfSlcbiAgICAgKi90aGlzLm1lc3NhZ2VzPVtdOy8qKlxuICAgICAqIFJvb3Qgbm9kZSBhZnRlciBhbGwgdHJhbnNmb3JtYXRpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUge1Jvb3R9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHJvb3QudG9SZXN1bHQoKS5yb290ID09PSByb290XG4gICAgICovdGhpcy5yb290PXJvb3Q7LyoqXG4gICAgICogT3B0aW9ucyBmcm9tIHRoZSB7QGxpbmsgUHJvY2Vzc29yI3Byb2Nlc3N9IG9yIHtAbGluayBSb290I3RvUmVzdWx0fSBjYWxsXG4gICAgICogdGhhdCBwcm9kdWNlZCB0aGlzIFJlc3VsdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtwcm9jZXNzT3B0aW9uc31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcm9vdC50b1Jlc3VsdChvcHRzKS5vcHRzID09PSBvcHRzXG4gICAgICovdGhpcy5vcHRzPW9wdHM7LyoqXG4gICAgICogQSBDU1Mgc3RyaW5nIHJlcHJlc2VudGluZyBvZiB7QGxpbmsgUmVzdWx0I3Jvb3R9LlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcG9zdGNzcy5wYXJzZSgnYXt9JykudG9SZXN1bHQoKS5jc3MgLy89PiBcImF7fVwiXG4gICAgICovdGhpcy5jc3M9dW5kZWZpbmVkOy8qKlxuICAgICAqIEFuIGluc3RhbmNlIG9mIGBTb3VyY2VNYXBHZW5lcmF0b3JgIGNsYXNzIGZyb20gdGhlIGBzb3VyY2UtbWFwYCBsaWJyYXJ5LFxuICAgICAqIHJlcHJlc2VudGluZyBjaGFuZ2VzIHRvIHRoZSB7QGxpbmsgUmVzdWx0I3Jvb3R9IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHR5cGUge1NvdXJjZU1hcEdlbmVyYXRvcn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcmVzdWx0Lm1hcC50b0pTT04oKSAvLz0+IHsgdmVyc2lvbjogMywgZmlsZTogJ2EuY3NzJywg4oCmIH1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaWYgKHJlc3VsdC5tYXApIHtcbiAgICAgKiAgIGZzLndyaXRlRmlsZVN5bmMocmVzdWx0Lm9wdHMudG8gKyAnLm1hcCcsIHJlc3VsdC5tYXAudG9TdHJpbmcoKSlcbiAgICAgKiB9XG4gICAgICovdGhpcy5tYXA9dW5kZWZpbmVkO30vKipcbiAgICogUmV0dXJucyBmb3IgQHtsaW5rIFJlc3VsdCNjc3N9IGNvbnRlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHJlc3VsdCArICcnID09PSByZXN1bHQuY3NzXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGluZyBvZiB7QGxpbmsgUmVzdWx0I3Jvb3R9LlxuICAgKi92YXIgX3Byb3RvPVJlc3VsdC5wcm90b3R5cGU7X3Byb3RvLnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY3NzO30vKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgV2FybmluZ30gYW5kIGFkZHMgaXRcbiAgICogdG8ge0BsaW5rIFJlc3VsdCNtZXNzYWdlc30uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICAgICAgICBXYXJuaW5nIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gICAgICBXYXJuaW5nIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Tm9kZX0gICBvcHRzLm5vZGUgICBDU1Mgbm9kZSB0aGF0IGNhdXNlZCB0aGUgd2FybmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud29yZCAgIFdvcmQgaW4gQ1NTIHNvdXJjZSB0aGF0IGNhdXNlZCB0aGUgd2FybmluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuaW5kZXggIEluZGV4IGluIENTUyBub2RlIHN0cmluZyB0aGF0IGNhdXNlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnBsdWdpbiBOYW1lIG9mIHRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdhcm5pbmcuIHtAbGluayBSZXN1bHQjd2Fybn0gZmlsbHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgcHJvcGVydHkgYXV0b21hdGljYWxseS5cbiAgICpcbiAgICogQHJldHVybiB7V2FybmluZ30gQ3JlYXRlZCB3YXJuaW5nLlxuICAgKi87X3Byb3RvLndhcm49ZnVuY3Rpb24gd2Fybih0ZXh0LG9wdHMpe2lmKG9wdHM9PT12b2lkIDApe29wdHM9e307fWlmKCFvcHRzLnBsdWdpbil7aWYodGhpcy5sYXN0UGx1Z2luJiZ0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbil7b3B0cy5wbHVnaW49dGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW47fX12YXIgd2FybmluZz1uZXcgX3dhcm5pbmdbXCJkZWZhdWx0XCJdKHRleHQsb3B0cyk7dGhpcy5tZXNzYWdlcy5wdXNoKHdhcm5pbmcpO3JldHVybiB3YXJuaW5nO30vKipcbiAgICAgKiBSZXR1cm5zIHdhcm5pbmdzIGZyb20gcGx1Z2lucy4gRmlsdGVycyB7QGxpbmsgV2FybmluZ30gaW5zdGFuY2VzXG4gICAgICogZnJvbSB7QGxpbmsgUmVzdWx0I21lc3NhZ2VzfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcmVzdWx0Lndhcm5pbmdzKCkuZm9yRWFjaCh3YXJuID0+IHtcbiAgICAgKiAgIGNvbnNvbGUud2Fybih3YXJuLnRvU3RyaW5nKCkpXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dhcm5pbmdbXX0gV2FybmluZ3MgZnJvbSBwbHVnaW5zLlxuICAgICAqLztfcHJvdG8ud2FybmluZ3M9ZnVuY3Rpb24gd2FybmluZ3MoKXtyZXR1cm4gdGhpcy5tZXNzYWdlcy5maWx0ZXIoZnVuY3Rpb24oaSl7cmV0dXJuIGkudHlwZT09PSd3YXJuaW5nJzt9KTt9LyoqXG4gICAqIEFuIGFsaWFzIGZvciB0aGUge0BsaW5rIFJlc3VsdCNjc3N9IHByb3BlcnR5LlxuICAgKiBVc2UgaXQgd2l0aCBzeW50YXhlcyB0aGF0IGdlbmVyYXRlIG5vbi1DU1Mgb3V0cHV0LlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiByZXN1bHQuY3NzID09PSByZXN1bHQuY29udGVudFxuICAgKi87X2NyZWF0ZUNsYXNzKFJlc3VsdCxbe2tleTpcImNvbnRlbnRcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIHRoaXMuY3NzO319XSk7cmV0dXJuIFJlc3VsdDt9KCk7dmFyIF9kZWZhdWx0PVJlc3VsdDsvKipcbiAqIEB0eXBlZGVmICB7b2JqZWN0fSBNZXNzYWdlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAgIE1lc3NhZ2UgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwbHVnaW4gU291cmNlIFBvc3RDU1MgcGx1Z2luIG5hbWUuXG4gKi9leHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vd2FybmluZ1wiOjYyfV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2NvbnRhaW5lcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnRhaW5lclwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3Msc3VwZXJDbGFzcyl7c3ViQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO3N1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1zdWJDbGFzcztzdWJDbGFzcy5fX3Byb3RvX189c3VwZXJDbGFzczt9LyoqXG4gKiBSZXByZXNlbnRzIGEgQ1NTIGZpbGUgYW5kIGNvbnRhaW5zIGFsbCBpdHMgcGFyc2VkIG5vZGVzLlxuICpcbiAqIEBleHRlbmRzIENvbnRhaW5lclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYXtjb2xvcjpibGFja30gYnt6LWluZGV4OjJ9JylcbiAqIHJvb3QudHlwZSAgICAgICAgIC8vPT4gJ3Jvb3QnXG4gKiByb290Lm5vZGVzLmxlbmd0aCAvLz0+IDJcbiAqL3ZhciBSb290PS8qI19fUFVSRV9fKi9mdW5jdGlvbihfQ29udGFpbmVyKXtfaW5oZXJpdHNMb29zZShSb290LF9Db250YWluZXIpO2Z1bmN0aW9uIFJvb3QoZGVmYXVsdHMpe3ZhciBfdGhpcztfdGhpcz1fQ29udGFpbmVyLmNhbGwodGhpcyxkZWZhdWx0cyl8fHRoaXM7X3RoaXMudHlwZT0ncm9vdCc7aWYoIV90aGlzLm5vZGVzKV90aGlzLm5vZGVzPVtdO3JldHVybiBfdGhpczt9dmFyIF9wcm90bz1Sb290LnByb3RvdHlwZTtfcHJvdG8ucmVtb3ZlQ2hpbGQ9ZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQsaWdub3JlKXt2YXIgaW5kZXg9dGhpcy5pbmRleChjaGlsZCk7aWYoIWlnbm9yZSYmaW5kZXg9PT0wJiZ0aGlzLm5vZGVzLmxlbmd0aD4xKXt0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlPXRoaXMubm9kZXNbaW5kZXhdLnJhd3MuYmVmb3JlO31yZXR1cm4gX0NvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLGNoaWxkKTt9O19wcm90by5ub3JtYWxpemU9ZnVuY3Rpb24gbm9ybWFsaXplKGNoaWxkLHNhbXBsZSx0eXBlKXt2YXIgbm9kZXM9X0NvbnRhaW5lci5wcm90b3R5cGUubm9ybWFsaXplLmNhbGwodGhpcyxjaGlsZCk7aWYoc2FtcGxlKXtpZih0eXBlPT09J3ByZXBlbmQnKXtpZih0aGlzLm5vZGVzLmxlbmd0aD4xKXtzYW1wbGUucmF3cy5iZWZvcmU9dGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZTt9ZWxzZXtkZWxldGUgc2FtcGxlLnJhd3MuYmVmb3JlO319ZWxzZSBpZih0aGlzLmZpcnN0IT09c2FtcGxlKXtmb3IodmFyIF9pdGVyYXRvcj1ub2RlcyxfaXNBcnJheT1BcnJheS5pc0FycmF5KF9pdGVyYXRvciksX2k9MCxfaXRlcmF0b3I9X2lzQXJyYXk/X2l0ZXJhdG9yOl9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oyl7dmFyIF9yZWY7aWYoX2lzQXJyYXkpe2lmKF9pPj1faXRlcmF0b3IubGVuZ3RoKWJyZWFrO19yZWY9X2l0ZXJhdG9yW19pKytdO31lbHNle19pPV9pdGVyYXRvci5uZXh0KCk7aWYoX2kuZG9uZSlicmVhaztfcmVmPV9pLnZhbHVlO312YXIgbm9kZT1fcmVmO25vZGUucmF3cy5iZWZvcmU9c2FtcGxlLnJhd3MuYmVmb3JlO319fXJldHVybiBub2Rlczt9LyoqXG4gICAqIFJldHVybnMgYSB7QGxpbmsgUmVzdWx0fSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIHJvb3TigJlzIENTUy5cbiAgICpcbiAgICogQHBhcmFtIHtwcm9jZXNzT3B0aW9uc30gW29wdHNdIE9wdGlvbnMgd2l0aCBvbmx5IGB0b2AgYW5kIGBtYXBgIGtleXMuXG4gICAqXG4gICAqIEByZXR1cm4ge1Jlc3VsdH0gUmVzdWx0IHdpdGggY3VycmVudCByb2904oCZcyBDU1MuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QxID0gcG9zdGNzcy5wYXJzZShjc3MxLCB7IGZyb206ICdhLmNzcycgfSlcbiAgICogY29uc3Qgcm9vdDIgPSBwb3N0Y3NzLnBhcnNlKGNzczIsIHsgZnJvbTogJ2IuY3NzJyB9KVxuICAgKiByb290MS5hcHBlbmQocm9vdDIpXG4gICAqIGNvbnN0IHJlc3VsdCA9IHJvb3QxLnRvUmVzdWx0KHsgdG86ICdhbGwuY3NzJywgbWFwOiB0cnVlIH0pXG4gICAqLztfcHJvdG8udG9SZXN1bHQ9ZnVuY3Rpb24gdG9SZXN1bHQob3B0cyl7aWYob3B0cz09PXZvaWQgMCl7b3B0cz17fTt9dmFyIExhenlSZXN1bHQ9cmVxdWlyZSgnLi9sYXp5LXJlc3VsdCcpO3ZhciBQcm9jZXNzb3I9cmVxdWlyZSgnLi9wcm9jZXNzb3InKTt2YXIgbGF6eT1uZXcgTGF6eVJlc3VsdChuZXcgUHJvY2Vzc29yKCksdGhpcyxvcHRzKTtyZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTt9LyoqXG4gICAqIEBtZW1iZXJvZiBSb290I1xuICAgKiBAbWVtYmVyIHtvYmplY3R9IHJhd3MgSW5mb3JtYXRpb24gdG8gZ2VuZXJhdGUgYnl0ZS10by1ieXRlIGVxdWFsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBub2RlIHN0cmluZyBhcyBpdCB3YXMgaW4gdGhlIG9yaWdpbiBpbnB1dC5cbiAgICpcbiAgICogRXZlcnkgcGFyc2VyIHNhdmVzIGl0cyBvd24gcHJvcGVydGllcyxcbiAgICogYnV0IHRoZSBkZWZhdWx0IENTUyBwYXJzZXIgdXNlczpcbiAgICpcbiAgICogKiBgYWZ0ZXJgOiB0aGUgc3BhY2Ugc3ltYm9scyBhZnRlciB0aGUgbGFzdCBjaGlsZCB0byB0aGUgZW5kIG9mIGZpbGUuXG4gICAqICogYHNlbWljb2xvbmA6IGlzIHRoZSBsYXN0IGNoaWxkIGhhcyBhbiAob3B0aW9uYWwpIHNlbWljb2xvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogcG9zdGNzcy5wYXJzZSgnYSB7fVxcbicpLnJhd3MgLy89PiB7IGFmdGVyOiAnXFxuJyB9XG4gICAqIHBvc3Rjc3MucGFyc2UoJ2Ege30nKS5yYXdzICAgLy89PiB7IGFmdGVyOiAnJyB9XG4gICAqLztyZXR1cm4gUm9vdDt9KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTt2YXIgX2RlZmF1bHQ9Um9vdDtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vY29udGFpbmVyXCI6NDEsXCIuL2xhenktcmVzdWx0XCI6NDUsXCIuL3Byb2Nlc3NvclwiOjUzfV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgX2NvbnRhaW5lcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnRhaW5lclwiKSk7dmFyIF9saXN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGlzdFwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fGZhbHNlO2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlPXRydWU7aWYoXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvcilkZXNjcmlwdG9yLndyaXRhYmxlPXRydWU7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKTt9fWZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtpZihwcm90b1Byb3BzKV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO31mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcyxzdXBlckNsYXNzKXtzdWJDbGFzcy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7c3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yPXN1YkNsYXNzO3N1YkNsYXNzLl9fcHJvdG9fXz1zdXBlckNsYXNzO30vKipcbiAqIFJlcHJlc2VudHMgYSBDU1MgcnVsZTogYSBzZWxlY3RvciBmb2xsb3dlZCBieSBhIGRlY2xhcmF0aW9uIGJsb2NrLlxuICpcbiAqIEBleHRlbmRzIENvbnRhaW5lclxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYXt9JylcbiAqIGNvbnN0IHJ1bGUgPSByb290LmZpcnN0XG4gKiBydWxlLnR5cGUgICAgICAgLy89PiAncnVsZSdcbiAqIHJ1bGUudG9TdHJpbmcoKSAvLz0+ICdhe30nXG4gKi92YXIgUnVsZT0vKiNfX1BVUkVfXyovZnVuY3Rpb24oX0NvbnRhaW5lcil7X2luaGVyaXRzTG9vc2UoUnVsZSxfQ29udGFpbmVyKTtmdW5jdGlvbiBSdWxlKGRlZmF1bHRzKXt2YXIgX3RoaXM7X3RoaXM9X0NvbnRhaW5lci5jYWxsKHRoaXMsZGVmYXVsdHMpfHx0aGlzO190aGlzLnR5cGU9J3J1bGUnO2lmKCFfdGhpcy5ub2RlcylfdGhpcy5ub2Rlcz1bXTtyZXR1cm4gX3RoaXM7fS8qKlxuICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBydWxl4oCZcyBpbmRpdmlkdWFsIHNlbGVjdG9ycy5cbiAgICogR3JvdXBzIG9mIHNlbGVjdG9ycyBhcmUgc3BsaXQgYXQgY29tbWFzLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnBhcnNlKCdhLCBiIHsgfScpXG4gICAqIGNvbnN0IHJ1bGUgPSByb290LmZpcnN0XG4gICAqXG4gICAqIHJ1bGUuc2VsZWN0b3IgIC8vPT4gJ2EsIGInXG4gICAqIHJ1bGUuc2VsZWN0b3JzIC8vPT4gWydhJywgJ2InXVxuICAgKlxuICAgKiBydWxlLnNlbGVjdG9ycyA9IFsnYScsICdzdHJvbmcnXVxuICAgKiBydWxlLnNlbGVjdG9yIC8vPT4gJ2EsIHN0cm9uZydcbiAgICovX2NyZWF0ZUNsYXNzKFJ1bGUsW3trZXk6XCJzZWxlY3RvcnNcIixnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuIF9saXN0W1wiZGVmYXVsdFwiXS5jb21tYSh0aGlzLnNlbGVjdG9yKTt9LHNldDpmdW5jdGlvbiBzZXQodmFsdWVzKXt2YXIgbWF0Y2g9dGhpcy5zZWxlY3Rvcj90aGlzLnNlbGVjdG9yLm1hdGNoKC8sXFxzKi8pOm51bGw7dmFyIHNlcD1tYXRjaD9tYXRjaFswXTonLCcrdGhpcy5yYXcoJ2JldHdlZW4nLCdiZWZvcmVPcGVuJyk7dGhpcy5zZWxlY3Rvcj12YWx1ZXMuam9pbihzZXApO30vKipcbiAgICAgKiBAbWVtYmVyb2YgUnVsZSNcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBydWxl4oCZcyBmdWxsIHNlbGVjdG9yIHJlcHJlc2VudGVkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgcm9vdCA9IHBvc3Rjc3MucGFyc2UoJ2EsIGIgeyB9JylcbiAgICAgKiBjb25zdCBydWxlID0gcm9vdC5maXJzdFxuICAgICAqIHJ1bGUuc2VsZWN0b3IgLy89PiAnYSwgYidcbiAgICAgKi8gLyoqXG4gICAgICogQG1lbWJlcm9mIFJ1bGUjXG4gICAgICogQG1lbWJlciB7b2JqZWN0fSByYXdzIEluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGJ5dGUtdG8tYnl0ZSBlcXVhbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBub2RlIHN0cmluZyBhcyBpdCB3YXMgaW4gdGhlIG9yaWdpbiBpbnB1dC5cbiAgICAgKlxuICAgICAqIEV2ZXJ5IHBhcnNlciBzYXZlcyBpdHMgb3duIHByb3BlcnRpZXMsXG4gICAgICogYnV0IHRoZSBkZWZhdWx0IENTUyBwYXJzZXIgdXNlczpcbiAgICAgKlxuICAgICAqICogYGJlZm9yZWA6IHRoZSBzcGFjZSBzeW1ib2xzIGJlZm9yZSB0aGUgbm9kZS4gSXQgYWxzbyBzdG9yZXMgYCpgXG4gICAgICogICBhbmQgYF9gIHN5bWJvbHMgYmVmb3JlIHRoZSBkZWNsYXJhdGlvbiAoSUUgaGFjaykuXG4gICAgICogKiBgYWZ0ZXJgOiB0aGUgc3BhY2Ugc3ltYm9scyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgbm9kZVxuICAgICAqICAgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAgICAgKiAqIGBiZXR3ZWVuYDogdGhlIHN5bWJvbHMgYmV0d2VlbiB0aGUgcHJvcGVydHkgYW5kIHZhbHVlXG4gICAgICogICBmb3IgZGVjbGFyYXRpb25zLCBzZWxlY3RvciBhbmQgYHtgIGZvciBydWxlcywgb3IgbGFzdCBwYXJhbWV0ZXJcbiAgICAgKiAgIGFuZCBge2AgZm9yIGF0LXJ1bGVzLlxuICAgICAqICogYHNlbWljb2xvbmA6IGNvbnRhaW5zIGB0cnVlYCBpZiB0aGUgbGFzdCBjaGlsZCBoYXNcbiAgICAgKiAgIGFuIChvcHRpb25hbCkgc2VtaWNvbG9uLlxuICAgICAqICogYG93blNlbWljb2xvbmA6IGNvbnRhaW5zIGB0cnVlYCBpZiB0aGVyZSBpcyBzZW1pY29sb24gYWZ0ZXIgcnVsZS5cbiAgICAgKlxuICAgICAqIFBvc3RDU1MgY2xlYW5zIHNlbGVjdG9ycyBmcm9tIGNvbW1lbnRzIGFuZCBleHRyYSBzcGFjZXMsXG4gICAgICogYnV0IGl0IHN0b3JlcyBvcmlnaW4gY29udGVudCBpbiByYXdzIHByb3BlcnRpZXMuXG4gICAgICogQXMgc3VjaCwgaWYgeW91IGRvbuKAmXQgY2hhbmdlIGEgZGVjbGFyYXRpb27igJlzIHZhbHVlLFxuICAgICAqIFBvc3RDU1Mgd2lsbCB1c2UgdGhlIHJhdyB2YWx1ZSB3aXRoIGNvbW1lbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCByb290ID0gcG9zdGNzcy5wYXJzZSgnYSB7XFxuICBjb2xvcjpibGFja1xcbn0nKVxuICAgICAqIHJvb3QuZmlyc3QuZmlyc3QucmF3cyAvLz0+IHsgYmVmb3JlOiAnJywgYmV0d2VlbjogJyAnLCBhZnRlcjogJ1xcbicgfVxuICAgICAqL31dKTtyZXR1cm4gUnVsZTt9KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTt2YXIgX2RlZmF1bHQ9UnVsZTtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHtcIi4vY29udGFpbmVyXCI6NDEsXCIuL2xpc3RcIjo0Nn1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIERFRkFVTFRfUkFXPXtjb2xvbjonOiAnLGluZGVudDonICAgICcsYmVmb3JlRGVjbDonXFxuJyxiZWZvcmVSdWxlOidcXG4nLGJlZm9yZU9wZW46JyAnLGJlZm9yZUNsb3NlOidcXG4nLGJlZm9yZUNvbW1lbnQ6J1xcbicsYWZ0ZXI6J1xcbicsZW1wdHlCb2R5OicnLGNvbW1lbnRMZWZ0OicgJyxjb21tZW50UmlnaHQ6JyAnLHNlbWljb2xvbjpmYWxzZX07ZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpe3JldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKStzdHIuc2xpY2UoMSk7fXZhciBTdHJpbmdpZmllcj0vKiNfX1BVUkVfXyovZnVuY3Rpb24oKXtmdW5jdGlvbiBTdHJpbmdpZmllcihidWlsZGVyKXt0aGlzLmJ1aWxkZXI9YnVpbGRlcjt9dmFyIF9wcm90bz1TdHJpbmdpZmllci5wcm90b3R5cGU7X3Byb3RvLnN0cmluZ2lmeT1mdW5jdGlvbiBzdHJpbmdpZnkobm9kZSxzZW1pY29sb24pe3RoaXNbbm9kZS50eXBlXShub2RlLHNlbWljb2xvbik7fTtfcHJvdG8ucm9vdD1mdW5jdGlvbiByb290KG5vZGUpe3RoaXMuYm9keShub2RlKTtpZihub2RlLnJhd3MuYWZ0ZXIpdGhpcy5idWlsZGVyKG5vZGUucmF3cy5hZnRlcik7fTtfcHJvdG8uY29tbWVudD1mdW5jdGlvbiBjb21tZW50KG5vZGUpe3ZhciBsZWZ0PXRoaXMucmF3KG5vZGUsJ2xlZnQnLCdjb21tZW50TGVmdCcpO3ZhciByaWdodD10aGlzLnJhdyhub2RlLCdyaWdodCcsJ2NvbW1lbnRSaWdodCcpO3RoaXMuYnVpbGRlcignLyonK2xlZnQrbm9kZS50ZXh0K3JpZ2h0KycqLycsbm9kZSk7fTtfcHJvdG8uZGVjbD1mdW5jdGlvbiBkZWNsKG5vZGUsc2VtaWNvbG9uKXt2YXIgYmV0d2Vlbj10aGlzLnJhdyhub2RlLCdiZXR3ZWVuJywnY29sb24nKTt2YXIgc3RyaW5nPW5vZGUucHJvcCtiZXR3ZWVuK3RoaXMucmF3VmFsdWUobm9kZSwndmFsdWUnKTtpZihub2RlLmltcG9ydGFudCl7c3RyaW5nKz1ub2RlLnJhd3MuaW1wb3J0YW50fHwnICFpbXBvcnRhbnQnO31pZihzZW1pY29sb24pc3RyaW5nKz0nOyc7dGhpcy5idWlsZGVyKHN0cmluZyxub2RlKTt9O19wcm90by5ydWxlPWZ1bmN0aW9uIHJ1bGUobm9kZSl7dGhpcy5ibG9jayhub2RlLHRoaXMucmF3VmFsdWUobm9kZSwnc2VsZWN0b3InKSk7aWYobm9kZS5yYXdzLm93blNlbWljb2xvbil7dGhpcy5idWlsZGVyKG5vZGUucmF3cy5vd25TZW1pY29sb24sbm9kZSwnZW5kJyk7fX07X3Byb3RvLmF0cnVsZT1mdW5jdGlvbiBhdHJ1bGUobm9kZSxzZW1pY29sb24pe3ZhciBuYW1lPSdAJytub2RlLm5hbWU7dmFyIHBhcmFtcz1ub2RlLnBhcmFtcz90aGlzLnJhd1ZhbHVlKG5vZGUsJ3BhcmFtcycpOicnO2lmKHR5cGVvZiBub2RlLnJhd3MuYWZ0ZXJOYW1lIT09J3VuZGVmaW5lZCcpe25hbWUrPW5vZGUucmF3cy5hZnRlck5hbWU7fWVsc2UgaWYocGFyYW1zKXtuYW1lKz0nICc7fWlmKG5vZGUubm9kZXMpe3RoaXMuYmxvY2sobm9kZSxuYW1lK3BhcmFtcyk7fWVsc2V7dmFyIGVuZD0obm9kZS5yYXdzLmJldHdlZW58fCcnKSsoc2VtaWNvbG9uPyc7JzonJyk7dGhpcy5idWlsZGVyKG5hbWUrcGFyYW1zK2VuZCxub2RlKTt9fTtfcHJvdG8uYm9keT1mdW5jdGlvbiBib2R5KG5vZGUpe3ZhciBsYXN0PW5vZGUubm9kZXMubGVuZ3RoLTE7d2hpbGUobGFzdD4wKXtpZihub2RlLm5vZGVzW2xhc3RdLnR5cGUhPT0nY29tbWVudCcpYnJlYWs7bGFzdC09MTt9dmFyIHNlbWljb2xvbj10aGlzLnJhdyhub2RlLCdzZW1pY29sb24nKTtmb3IodmFyIGk9MDtpPG5vZGUubm9kZXMubGVuZ3RoO2krKyl7dmFyIGNoaWxkPW5vZGUubm9kZXNbaV07dmFyIGJlZm9yZT10aGlzLnJhdyhjaGlsZCwnYmVmb3JlJyk7aWYoYmVmb3JlKXRoaXMuYnVpbGRlcihiZWZvcmUpO3RoaXMuc3RyaW5naWZ5KGNoaWxkLGxhc3QhPT1pfHxzZW1pY29sb24pO319O19wcm90by5ibG9jaz1mdW5jdGlvbiBibG9jayhub2RlLHN0YXJ0KXt2YXIgYmV0d2Vlbj10aGlzLnJhdyhub2RlLCdiZXR3ZWVuJywnYmVmb3JlT3BlbicpO3RoaXMuYnVpbGRlcihzdGFydCtiZXR3ZWVuKyd7Jyxub2RlLCdzdGFydCcpO3ZhciBhZnRlcjtpZihub2RlLm5vZGVzJiZub2RlLm5vZGVzLmxlbmd0aCl7dGhpcy5ib2R5KG5vZGUpO2FmdGVyPXRoaXMucmF3KG5vZGUsJ2FmdGVyJyk7fWVsc2V7YWZ0ZXI9dGhpcy5yYXcobm9kZSwnYWZ0ZXInLCdlbXB0eUJvZHknKTt9aWYoYWZ0ZXIpdGhpcy5idWlsZGVyKGFmdGVyKTt0aGlzLmJ1aWxkZXIoJ30nLG5vZGUsJ2VuZCcpO307X3Byb3RvLnJhdz1mdW5jdGlvbiByYXcobm9kZSxvd24sZGV0ZWN0KXt2YXIgdmFsdWU7aWYoIWRldGVjdClkZXRlY3Q9b3duOy8vIEFscmVhZHkgaGFkXG5pZihvd24pe3ZhbHVlPW5vZGUucmF3c1tvd25dO2lmKHR5cGVvZiB2YWx1ZSE9PSd1bmRlZmluZWQnKXJldHVybiB2YWx1ZTt9dmFyIHBhcmVudD1ub2RlLnBhcmVudDsvLyBIYWNrIGZvciBmaXJzdCBydWxlIGluIENTU1xuaWYoZGV0ZWN0PT09J2JlZm9yZScpe2lmKCFwYXJlbnR8fHBhcmVudC50eXBlPT09J3Jvb3QnJiZwYXJlbnQuZmlyc3Q9PT1ub2RlKXtyZXR1cm4nJzt9fS8vIEZsb2F0aW5nIGNoaWxkIHdpdGhvdXQgcGFyZW50XG5pZighcGFyZW50KXJldHVybiBERUZBVUxUX1JBV1tkZXRlY3RdOy8vIERldGVjdCBzdHlsZSBieSBvdGhlciBub2Rlc1xudmFyIHJvb3Q9bm9kZS5yb290KCk7aWYoIXJvb3QucmF3Q2FjaGUpcm9vdC5yYXdDYWNoZT17fTtpZih0eXBlb2Ygcm9vdC5yYXdDYWNoZVtkZXRlY3RdIT09J3VuZGVmaW5lZCcpe3JldHVybiByb290LnJhd0NhY2hlW2RldGVjdF07fWlmKGRldGVjdD09PSdiZWZvcmUnfHxkZXRlY3Q9PT0nYWZ0ZXInKXtyZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlLGRldGVjdCk7fWVsc2V7dmFyIG1ldGhvZD0ncmF3JytjYXBpdGFsaXplKGRldGVjdCk7aWYodGhpc1ttZXRob2RdKXt2YWx1ZT10aGlzW21ldGhvZF0ocm9vdCxub2RlKTt9ZWxzZXtyb290LndhbGsoZnVuY3Rpb24oaSl7dmFsdWU9aS5yYXdzW293bl07aWYodHlwZW9mIHZhbHVlIT09J3VuZGVmaW5lZCcpcmV0dXJuIGZhbHNlO30pO319aWYodHlwZW9mIHZhbHVlPT09J3VuZGVmaW5lZCcpdmFsdWU9REVGQVVMVF9SQVdbZGV0ZWN0XTtyb290LnJhd0NhY2hlW2RldGVjdF09dmFsdWU7cmV0dXJuIHZhbHVlO307X3Byb3RvLnJhd1NlbWljb2xvbj1mdW5jdGlvbiByYXdTZW1pY29sb24ocm9vdCl7dmFyIHZhbHVlO3Jvb3Qud2FsayhmdW5jdGlvbihpKXtpZihpLm5vZGVzJiZpLm5vZGVzLmxlbmd0aCYmaS5sYXN0LnR5cGU9PT0nZGVjbCcpe3ZhbHVlPWkucmF3cy5zZW1pY29sb247aWYodHlwZW9mIHZhbHVlIT09J3VuZGVmaW5lZCcpcmV0dXJuIGZhbHNlO319KTtyZXR1cm4gdmFsdWU7fTtfcHJvdG8ucmF3RW1wdHlCb2R5PWZ1bmN0aW9uIHJhd0VtcHR5Qm9keShyb290KXt2YXIgdmFsdWU7cm9vdC53YWxrKGZ1bmN0aW9uKGkpe2lmKGkubm9kZXMmJmkubm9kZXMubGVuZ3RoPT09MCl7dmFsdWU9aS5yYXdzLmFmdGVyO2lmKHR5cGVvZiB2YWx1ZSE9PSd1bmRlZmluZWQnKXJldHVybiBmYWxzZTt9fSk7cmV0dXJuIHZhbHVlO307X3Byb3RvLnJhd0luZGVudD1mdW5jdGlvbiByYXdJbmRlbnQocm9vdCl7aWYocm9vdC5yYXdzLmluZGVudClyZXR1cm4gcm9vdC5yYXdzLmluZGVudDt2YXIgdmFsdWU7cm9vdC53YWxrKGZ1bmN0aW9uKGkpe3ZhciBwPWkucGFyZW50O2lmKHAmJnAhPT1yb290JiZwLnBhcmVudCYmcC5wYXJlbnQ9PT1yb290KXtpZih0eXBlb2YgaS5yYXdzLmJlZm9yZSE9PSd1bmRlZmluZWQnKXt2YXIgcGFydHM9aS5yYXdzLmJlZm9yZS5zcGxpdCgnXFxuJyk7dmFsdWU9cGFydHNbcGFydHMubGVuZ3RoLTFdO3ZhbHVlPXZhbHVlLnJlcGxhY2UoL1teXFxzXS9nLCcnKTtyZXR1cm4gZmFsc2U7fX19KTtyZXR1cm4gdmFsdWU7fTtfcHJvdG8ucmF3QmVmb3JlQ29tbWVudD1mdW5jdGlvbiByYXdCZWZvcmVDb21tZW50KHJvb3Qsbm9kZSl7dmFyIHZhbHVlO3Jvb3Qud2Fsa0NvbW1lbnRzKGZ1bmN0aW9uKGkpe2lmKHR5cGVvZiBpLnJhd3MuYmVmb3JlIT09J3VuZGVmaW5lZCcpe3ZhbHVlPWkucmF3cy5iZWZvcmU7aWYodmFsdWUuaW5kZXhPZignXFxuJykhPT0tMSl7dmFsdWU9dmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCcnKTt9cmV0dXJuIGZhbHNlO319KTtpZih0eXBlb2YgdmFsdWU9PT0ndW5kZWZpbmVkJyl7dmFsdWU9dGhpcy5yYXcobm9kZSxudWxsLCdiZWZvcmVEZWNsJyk7fWVsc2UgaWYodmFsdWUpe3ZhbHVlPXZhbHVlLnJlcGxhY2UoL1teXFxzXS9nLCcnKTt9cmV0dXJuIHZhbHVlO307X3Byb3RvLnJhd0JlZm9yZURlY2w9ZnVuY3Rpb24gcmF3QmVmb3JlRGVjbChyb290LG5vZGUpe3ZhciB2YWx1ZTtyb290LndhbGtEZWNscyhmdW5jdGlvbihpKXtpZih0eXBlb2YgaS5yYXdzLmJlZm9yZSE9PSd1bmRlZmluZWQnKXt2YWx1ZT1pLnJhd3MuYmVmb3JlO2lmKHZhbHVlLmluZGV4T2YoJ1xcbicpIT09LTEpe3ZhbHVlPXZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywnJyk7fXJldHVybiBmYWxzZTt9fSk7aWYodHlwZW9mIHZhbHVlPT09J3VuZGVmaW5lZCcpe3ZhbHVlPXRoaXMucmF3KG5vZGUsbnVsbCwnYmVmb3JlUnVsZScpO31lbHNlIGlmKHZhbHVlKXt2YWx1ZT12YWx1ZS5yZXBsYWNlKC9bXlxcc10vZywnJyk7fXJldHVybiB2YWx1ZTt9O19wcm90by5yYXdCZWZvcmVSdWxlPWZ1bmN0aW9uIHJhd0JlZm9yZVJ1bGUocm9vdCl7dmFyIHZhbHVlO3Jvb3Qud2FsayhmdW5jdGlvbihpKXtpZihpLm5vZGVzJiYoaS5wYXJlbnQhPT1yb290fHxyb290LmZpcnN0IT09aSkpe2lmKHR5cGVvZiBpLnJhd3MuYmVmb3JlIT09J3VuZGVmaW5lZCcpe3ZhbHVlPWkucmF3cy5iZWZvcmU7aWYodmFsdWUuaW5kZXhPZignXFxuJykhPT0tMSl7dmFsdWU9dmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCcnKTt9cmV0dXJuIGZhbHNlO319fSk7aWYodmFsdWUpdmFsdWU9dmFsdWUucmVwbGFjZSgvW15cXHNdL2csJycpO3JldHVybiB2YWx1ZTt9O19wcm90by5yYXdCZWZvcmVDbG9zZT1mdW5jdGlvbiByYXdCZWZvcmVDbG9zZShyb290KXt2YXIgdmFsdWU7cm9vdC53YWxrKGZ1bmN0aW9uKGkpe2lmKGkubm9kZXMmJmkubm9kZXMubGVuZ3RoPjApe2lmKHR5cGVvZiBpLnJhd3MuYWZ0ZXIhPT0ndW5kZWZpbmVkJyl7dmFsdWU9aS5yYXdzLmFmdGVyO2lmKHZhbHVlLmluZGV4T2YoJ1xcbicpIT09LTEpe3ZhbHVlPXZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywnJyk7fXJldHVybiBmYWxzZTt9fX0pO2lmKHZhbHVlKXZhbHVlPXZhbHVlLnJlcGxhY2UoL1teXFxzXS9nLCcnKTtyZXR1cm4gdmFsdWU7fTtfcHJvdG8ucmF3QmVmb3JlT3Blbj1mdW5jdGlvbiByYXdCZWZvcmVPcGVuKHJvb3Qpe3ZhciB2YWx1ZTtyb290LndhbGsoZnVuY3Rpb24oaSl7aWYoaS50eXBlIT09J2RlY2wnKXt2YWx1ZT1pLnJhd3MuYmV0d2VlbjtpZih0eXBlb2YgdmFsdWUhPT0ndW5kZWZpbmVkJylyZXR1cm4gZmFsc2U7fX0pO3JldHVybiB2YWx1ZTt9O19wcm90by5yYXdDb2xvbj1mdW5jdGlvbiByYXdDb2xvbihyb290KXt2YXIgdmFsdWU7cm9vdC53YWxrRGVjbHMoZnVuY3Rpb24oaSl7aWYodHlwZW9mIGkucmF3cy5iZXR3ZWVuIT09J3VuZGVmaW5lZCcpe3ZhbHVlPWkucmF3cy5iZXR3ZWVuLnJlcGxhY2UoL1teXFxzOl0vZywnJyk7cmV0dXJuIGZhbHNlO319KTtyZXR1cm4gdmFsdWU7fTtfcHJvdG8uYmVmb3JlQWZ0ZXI9ZnVuY3Rpb24gYmVmb3JlQWZ0ZXIobm9kZSxkZXRlY3Qpe3ZhciB2YWx1ZTtpZihub2RlLnR5cGU9PT0nZGVjbCcpe3ZhbHVlPXRoaXMucmF3KG5vZGUsbnVsbCwnYmVmb3JlRGVjbCcpO31lbHNlIGlmKG5vZGUudHlwZT09PSdjb21tZW50Jyl7dmFsdWU9dGhpcy5yYXcobm9kZSxudWxsLCdiZWZvcmVDb21tZW50Jyk7fWVsc2UgaWYoZGV0ZWN0PT09J2JlZm9yZScpe3ZhbHVlPXRoaXMucmF3KG5vZGUsbnVsbCwnYmVmb3JlUnVsZScpO31lbHNle3ZhbHVlPXRoaXMucmF3KG5vZGUsbnVsbCwnYmVmb3JlQ2xvc2UnKTt9dmFyIGJ1Zj1ub2RlLnBhcmVudDt2YXIgZGVwdGg9MDt3aGlsZShidWYmJmJ1Zi50eXBlIT09J3Jvb3QnKXtkZXB0aCs9MTtidWY9YnVmLnBhcmVudDt9aWYodmFsdWUuaW5kZXhPZignXFxuJykhPT0tMSl7dmFyIGluZGVudD10aGlzLnJhdyhub2RlLG51bGwsJ2luZGVudCcpO2lmKGluZGVudC5sZW5ndGgpe2Zvcih2YXIgc3RlcD0wO3N0ZXA8ZGVwdGg7c3RlcCsrKXt2YWx1ZSs9aW5kZW50O319fXJldHVybiB2YWx1ZTt9O19wcm90by5yYXdWYWx1ZT1mdW5jdGlvbiByYXdWYWx1ZShub2RlLHByb3Ape3ZhciB2YWx1ZT1ub2RlW3Byb3BdO3ZhciByYXc9bm9kZS5yYXdzW3Byb3BdO2lmKHJhdyYmcmF3LnZhbHVlPT09dmFsdWUpe3JldHVybiByYXcucmF3O31yZXR1cm4gdmFsdWU7fTtyZXR1cm4gU3RyaW5naWZpZXI7fSgpO3ZhciBfZGVmYXVsdD1TdHJpbmdpZmllcjtleHBvcnRzW1wiZGVmYXVsdFwiXT1fZGVmYXVsdDttb2R1bGUuZXhwb3J0cz1leHBvcnRzW1wiZGVmYXVsdFwiXTt9LHt9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0c1tcImRlZmF1bHRcIl09dm9pZCAwO3ZhciBfc3RyaW5naWZpZXI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZmllclwiKSk7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7XCJkZWZhdWx0XCI6b2JqfTt9ZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsYnVpbGRlcil7dmFyIHN0cj1uZXcgX3N0cmluZ2lmaWVyW1wiZGVmYXVsdFwiXShidWlsZGVyKTtzdHIuc3RyaW5naWZ5KG5vZGUpO312YXIgX2RlZmF1bHQ9c3RyaW5naWZ5O2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se1wiLi9zdHJpbmdpZmllclwiOjU3fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXRva2VuaXplcjt2YXIgU0lOR0xFX1FVT1RFPSdcXCcnLmNoYXJDb2RlQXQoMCk7dmFyIERPVUJMRV9RVU9URT0nXCInLmNoYXJDb2RlQXQoMCk7dmFyIEJBQ0tTTEFTSD0nXFxcXCcuY2hhckNvZGVBdCgwKTt2YXIgU0xBU0g9Jy8nLmNoYXJDb2RlQXQoMCk7dmFyIE5FV0xJTkU9J1xcbicuY2hhckNvZGVBdCgwKTt2YXIgU1BBQ0U9JyAnLmNoYXJDb2RlQXQoMCk7dmFyIEZFRUQ9J1xcZicuY2hhckNvZGVBdCgwKTt2YXIgVEFCPSdcXHQnLmNoYXJDb2RlQXQoMCk7dmFyIENSPSdcXHInLmNoYXJDb2RlQXQoMCk7dmFyIE9QRU5fU1FVQVJFPSdbJy5jaGFyQ29kZUF0KDApO3ZhciBDTE9TRV9TUVVBUkU9J10nLmNoYXJDb2RlQXQoMCk7dmFyIE9QRU5fUEFSRU5USEVTRVM9JygnLmNoYXJDb2RlQXQoMCk7dmFyIENMT1NFX1BBUkVOVEhFU0VTPScpJy5jaGFyQ29kZUF0KDApO3ZhciBPUEVOX0NVUkxZPSd7Jy5jaGFyQ29kZUF0KDApO3ZhciBDTE9TRV9DVVJMWT0nfScuY2hhckNvZGVBdCgwKTt2YXIgU0VNSUNPTE9OPSc7Jy5jaGFyQ29kZUF0KDApO3ZhciBBU1RFUklTSz0nKicuY2hhckNvZGVBdCgwKTt2YXIgQ09MT049JzonLmNoYXJDb2RlQXQoMCk7dmFyIEFUPSdAJy5jaGFyQ29kZUF0KDApO3ZhciBSRV9BVF9FTkQ9L1sgXFxuXFx0XFxyXFxme30oKSdcIlxcXFw7L1tcXF0jXS9nO3ZhciBSRV9XT1JEX0VORD0vWyBcXG5cXHRcXHJcXGYoKXt9OjtAISdcIlxcXFxcXF1bI118XFwvKD89XFwqKS9nO3ZhciBSRV9CQURfQlJBQ0tFVD0vLltcXFxcLyhcIidcXG5dLzt2YXIgUkVfSEVYX0VTQ0FQRT0vW2EtZjAtOV0vaTtmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsb3B0aW9ucyl7aWYob3B0aW9ucz09PXZvaWQgMCl7b3B0aW9ucz17fTt9dmFyIGNzcz1pbnB1dC5jc3MudmFsdWVPZigpO3ZhciBpZ25vcmU9b3B0aW9ucy5pZ25vcmVFcnJvcnM7dmFyIGNvZGUsbmV4dCxxdW90ZSxsaW5lcyxsYXN0LGNvbnRlbnQsZXNjYXBlO3ZhciBuZXh0TGluZSxuZXh0T2Zmc2V0LGVzY2FwZWQsZXNjYXBlUG9zLHByZXYsbixjdXJyZW50VG9rZW47dmFyIGxlbmd0aD1jc3MubGVuZ3RoO3ZhciBvZmZzZXQ9LTE7dmFyIGxpbmU9MTt2YXIgcG9zPTA7dmFyIGJ1ZmZlcj1bXTt2YXIgcmV0dXJuZWQ9W107ZnVuY3Rpb24gcG9zaXRpb24oKXtyZXR1cm4gcG9zO31mdW5jdGlvbiB1bmNsb3NlZCh3aGF0KXt0aHJvdyBpbnB1dC5lcnJvcignVW5jbG9zZWQgJyt3aGF0LGxpbmUscG9zLW9mZnNldCk7fWZ1bmN0aW9uIGVuZE9mRmlsZSgpe3JldHVybiByZXR1cm5lZC5sZW5ndGg9PT0wJiZwb3M+PWxlbmd0aDt9ZnVuY3Rpb24gbmV4dFRva2VuKG9wdHMpe2lmKHJldHVybmVkLmxlbmd0aClyZXR1cm4gcmV0dXJuZWQucG9wKCk7aWYocG9zPj1sZW5ndGgpcmV0dXJuO3ZhciBpZ25vcmVVbmNsb3NlZD1vcHRzP29wdHMuaWdub3JlVW5jbG9zZWQ6ZmFsc2U7Y29kZT1jc3MuY2hhckNvZGVBdChwb3MpO2lmKGNvZGU9PT1ORVdMSU5FfHxjb2RlPT09RkVFRHx8Y29kZT09PUNSJiZjc3MuY2hhckNvZGVBdChwb3MrMSkhPT1ORVdMSU5FKXtvZmZzZXQ9cG9zO2xpbmUrPTE7fXN3aXRjaChjb2RlKXtjYXNlIE5FV0xJTkU6Y2FzZSBTUEFDRTpjYXNlIFRBQjpjYXNlIENSOmNhc2UgRkVFRDpuZXh0PXBvcztkb3tuZXh0Kz0xO2NvZGU9Y3NzLmNoYXJDb2RlQXQobmV4dCk7aWYoY29kZT09PU5FV0xJTkUpe29mZnNldD1uZXh0O2xpbmUrPTE7fX13aGlsZShjb2RlPT09U1BBQ0V8fGNvZGU9PT1ORVdMSU5FfHxjb2RlPT09VEFCfHxjb2RlPT09Q1J8fGNvZGU9PT1GRUVEKTtjdXJyZW50VG9rZW49WydzcGFjZScsY3NzLnNsaWNlKHBvcyxuZXh0KV07cG9zPW5leHQtMTticmVhaztjYXNlIE9QRU5fU1FVQVJFOmNhc2UgQ0xPU0VfU1FVQVJFOmNhc2UgT1BFTl9DVVJMWTpjYXNlIENMT1NFX0NVUkxZOmNhc2UgQ09MT046Y2FzZSBTRU1JQ09MT046Y2FzZSBDTE9TRV9QQVJFTlRIRVNFUzp2YXIgY29udHJvbENoYXI9U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtjdXJyZW50VG9rZW49W2NvbnRyb2xDaGFyLGNvbnRyb2xDaGFyLGxpbmUscG9zLW9mZnNldF07YnJlYWs7Y2FzZSBPUEVOX1BBUkVOVEhFU0VTOnByZXY9YnVmZmVyLmxlbmd0aD9idWZmZXIucG9wKClbMV06Jyc7bj1jc3MuY2hhckNvZGVBdChwb3MrMSk7aWYocHJldj09PSd1cmwnJiZuIT09U0lOR0xFX1FVT1RFJiZuIT09RE9VQkxFX1FVT1RFJiZuIT09U1BBQ0UmJm4hPT1ORVdMSU5FJiZuIT09VEFCJiZuIT09RkVFRCYmbiE9PUNSKXtuZXh0PXBvcztkb3tlc2NhcGVkPWZhbHNlO25leHQ9Y3NzLmluZGV4T2YoJyknLG5leHQrMSk7aWYobmV4dD09PS0xKXtpZihpZ25vcmV8fGlnbm9yZVVuY2xvc2VkKXtuZXh0PXBvczticmVhazt9ZWxzZXt1bmNsb3NlZCgnYnJhY2tldCcpO319ZXNjYXBlUG9zPW5leHQ7d2hpbGUoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zLTEpPT09QkFDS1NMQVNIKXtlc2NhcGVQb3MtPTE7ZXNjYXBlZD0hZXNjYXBlZDt9fXdoaWxlKGVzY2FwZWQpO2N1cnJlbnRUb2tlbj1bJ2JyYWNrZXRzJyxjc3Muc2xpY2UocG9zLG5leHQrMSksbGluZSxwb3Mtb2Zmc2V0LGxpbmUsbmV4dC1vZmZzZXRdO3Bvcz1uZXh0O31lbHNle25leHQ9Y3NzLmluZGV4T2YoJyknLHBvcysxKTtjb250ZW50PWNzcy5zbGljZShwb3MsbmV4dCsxKTtpZihuZXh0PT09LTF8fFJFX0JBRF9CUkFDS0VULnRlc3QoY29udGVudCkpe2N1cnJlbnRUb2tlbj1bJygnLCcoJyxsaW5lLHBvcy1vZmZzZXRdO31lbHNle2N1cnJlbnRUb2tlbj1bJ2JyYWNrZXRzJyxjb250ZW50LGxpbmUscG9zLW9mZnNldCxsaW5lLG5leHQtb2Zmc2V0XTtwb3M9bmV4dDt9fWJyZWFrO2Nhc2UgU0lOR0xFX1FVT1RFOmNhc2UgRE9VQkxFX1FVT1RFOnF1b3RlPWNvZGU9PT1TSU5HTEVfUVVPVEU/J1xcJyc6J1wiJztuZXh0PXBvcztkb3tlc2NhcGVkPWZhbHNlO25leHQ9Y3NzLmluZGV4T2YocXVvdGUsbmV4dCsxKTtpZihuZXh0PT09LTEpe2lmKGlnbm9yZXx8aWdub3JlVW5jbG9zZWQpe25leHQ9cG9zKzE7YnJlYWs7fWVsc2V7dW5jbG9zZWQoJ3N0cmluZycpO319ZXNjYXBlUG9zPW5leHQ7d2hpbGUoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zLTEpPT09QkFDS1NMQVNIKXtlc2NhcGVQb3MtPTE7ZXNjYXBlZD0hZXNjYXBlZDt9fXdoaWxlKGVzY2FwZWQpO2NvbnRlbnQ9Y3NzLnNsaWNlKHBvcyxuZXh0KzEpO2xpbmVzPWNvbnRlbnQuc3BsaXQoJ1xcbicpO2xhc3Q9bGluZXMubGVuZ3RoLTE7aWYobGFzdD4wKXtuZXh0TGluZT1saW5lK2xhc3Q7bmV4dE9mZnNldD1uZXh0LWxpbmVzW2xhc3RdLmxlbmd0aDt9ZWxzZXtuZXh0TGluZT1saW5lO25leHRPZmZzZXQ9b2Zmc2V0O31jdXJyZW50VG9rZW49WydzdHJpbmcnLGNzcy5zbGljZShwb3MsbmV4dCsxKSxsaW5lLHBvcy1vZmZzZXQsbmV4dExpbmUsbmV4dC1uZXh0T2Zmc2V0XTtvZmZzZXQ9bmV4dE9mZnNldDtsaW5lPW5leHRMaW5lO3Bvcz1uZXh0O2JyZWFrO2Nhc2UgQVQ6UkVfQVRfRU5ELmxhc3RJbmRleD1wb3MrMTtSRV9BVF9FTkQudGVzdChjc3MpO2lmKFJFX0FUX0VORC5sYXN0SW5kZXg9PT0wKXtuZXh0PWNzcy5sZW5ndGgtMTt9ZWxzZXtuZXh0PVJFX0FUX0VORC5sYXN0SW5kZXgtMjt9Y3VycmVudFRva2VuPVsnYXQtd29yZCcsY3NzLnNsaWNlKHBvcyxuZXh0KzEpLGxpbmUscG9zLW9mZnNldCxsaW5lLG5leHQtb2Zmc2V0XTtwb3M9bmV4dDticmVhaztjYXNlIEJBQ0tTTEFTSDpuZXh0PXBvcztlc2NhcGU9dHJ1ZTt3aGlsZShjc3MuY2hhckNvZGVBdChuZXh0KzEpPT09QkFDS1NMQVNIKXtuZXh0Kz0xO2VzY2FwZT0hZXNjYXBlO31jb2RlPWNzcy5jaGFyQ29kZUF0KG5leHQrMSk7aWYoZXNjYXBlJiZjb2RlIT09U0xBU0gmJmNvZGUhPT1TUEFDRSYmY29kZSE9PU5FV0xJTkUmJmNvZGUhPT1UQUImJmNvZGUhPT1DUiYmY29kZSE9PUZFRUQpe25leHQrPTE7aWYoUkVfSEVYX0VTQ0FQRS50ZXN0KGNzcy5jaGFyQXQobmV4dCkpKXt3aGlsZShSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0KzEpKSl7bmV4dCs9MTt9aWYoY3NzLmNoYXJDb2RlQXQobmV4dCsxKT09PVNQQUNFKXtuZXh0Kz0xO319fWN1cnJlbnRUb2tlbj1bJ3dvcmQnLGNzcy5zbGljZShwb3MsbmV4dCsxKSxsaW5lLHBvcy1vZmZzZXQsbGluZSxuZXh0LW9mZnNldF07cG9zPW5leHQ7YnJlYWs7ZGVmYXVsdDppZihjb2RlPT09U0xBU0gmJmNzcy5jaGFyQ29kZUF0KHBvcysxKT09PUFTVEVSSVNLKXtuZXh0PWNzcy5pbmRleE9mKCcqLycscG9zKzIpKzE7aWYobmV4dD09PTApe2lmKGlnbm9yZXx8aWdub3JlVW5jbG9zZWQpe25leHQ9Y3NzLmxlbmd0aDt9ZWxzZXt1bmNsb3NlZCgnY29tbWVudCcpO319Y29udGVudD1jc3Muc2xpY2UocG9zLG5leHQrMSk7bGluZXM9Y29udGVudC5zcGxpdCgnXFxuJyk7bGFzdD1saW5lcy5sZW5ndGgtMTtpZihsYXN0PjApe25leHRMaW5lPWxpbmUrbGFzdDtuZXh0T2Zmc2V0PW5leHQtbGluZXNbbGFzdF0ubGVuZ3RoO31lbHNle25leHRMaW5lPWxpbmU7bmV4dE9mZnNldD1vZmZzZXQ7fWN1cnJlbnRUb2tlbj1bJ2NvbW1lbnQnLGNvbnRlbnQsbGluZSxwb3Mtb2Zmc2V0LG5leHRMaW5lLG5leHQtbmV4dE9mZnNldF07b2Zmc2V0PW5leHRPZmZzZXQ7bGluZT1uZXh0TGluZTtwb3M9bmV4dDt9ZWxzZXtSRV9XT1JEX0VORC5sYXN0SW5kZXg9cG9zKzE7UkVfV09SRF9FTkQudGVzdChjc3MpO2lmKFJFX1dPUkRfRU5ELmxhc3RJbmRleD09PTApe25leHQ9Y3NzLmxlbmd0aC0xO31lbHNle25leHQ9UkVfV09SRF9FTkQubGFzdEluZGV4LTI7fWN1cnJlbnRUb2tlbj1bJ3dvcmQnLGNzcy5zbGljZShwb3MsbmV4dCsxKSxsaW5lLHBvcy1vZmZzZXQsbGluZSxuZXh0LW9mZnNldF07YnVmZmVyLnB1c2goY3VycmVudFRva2VuKTtwb3M9bmV4dDt9YnJlYWs7fXBvcysrO3JldHVybiBjdXJyZW50VG9rZW47fWZ1bmN0aW9uIGJhY2sodG9rZW4pe3JldHVybmVkLnB1c2godG9rZW4pO31yZXR1cm57YmFjazpiYWNrLG5leHRUb2tlbjpuZXh0VG9rZW4sZW5kT2ZGaWxlOmVuZE9mRmlsZSxwb3NpdGlvbjpwb3NpdGlvbn07fW1vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7LyoqXG4gKiBDb250YWlucyBoZWxwZXJzIGZvciB3b3JraW5nIHdpdGggdmVuZG9yIHByZWZpeGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB2ZW5kb3IgPSBwb3N0Y3NzLnZlbmRvclxuICpcbiAqIEBuYW1lc3BhY2UgdmVuZG9yXG4gKi92YXIgdmVuZG9yPXsvKipcbiAgICogUmV0dXJucyB0aGUgdmVuZG9yIHByZWZpeCBleHRyYWN0ZWQgZnJvbSBhbiBpbnB1dCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFN0cmluZyB3aXRoIG9yIHdpdGhvdXQgdmVuZG9yIHByZWZpeC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSB2ZW5kb3IgcHJlZml4IG9yIGVtcHR5IHN0cmluZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBwb3N0Y3NzLnZlbmRvci5wcmVmaXgoJy1tb3otdGFiLXNpemUnKSAvLz0+ICctbW96LSdcbiAgICogcG9zdGNzcy52ZW5kb3IucHJlZml4KCd0YWItc2l6ZScpICAgICAgLy89PiAnJ1xuICAgKi9wcmVmaXg6ZnVuY3Rpb24gcHJlZml4KHByb3Ape3ZhciBtYXRjaD1wcm9wLm1hdGNoKC9eKC1cXHcrLSkvKTtpZihtYXRjaCl7cmV0dXJuIG1hdGNoWzBdO31yZXR1cm4nJzt9LC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlucHV0IHN0cmluZyBzdHJpcHBlZCBvZiBpdHMgdmVuZG9yIHByZWZpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFN0cmluZyB3aXRoIG9yIHdpdGhvdXQgdmVuZG9yIHByZWZpeC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIG5hbWUgd2l0aG91dCB2ZW5kb3IgcHJlZml4ZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHBvc3Rjc3MudmVuZG9yLnVucHJlZml4ZWQoJy1tb3otdGFiLXNpemUnKSAvLz0+ICd0YWItc2l6ZSdcbiAgICAgKi91bnByZWZpeGVkOmZ1bmN0aW9uIHVucHJlZml4ZWQocHJvcCl7cmV0dXJuIHByb3AucmVwbGFjZSgvXi1cXHcrLS8sJycpO319O3ZhciBfZGVmYXVsdD12ZW5kb3I7ZXhwb3J0c1tcImRlZmF1bHRcIl09X2RlZmF1bHQ7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0c1tcImRlZmF1bHRcIl07fSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHNbXCJkZWZhdWx0XCJdPXdhcm5PbmNlO3ZhciBwcmludGVkPXt9O2Z1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2Upe2lmKHByaW50ZWRbbWVzc2FnZV0pcmV0dXJuO3ByaW50ZWRbbWVzc2FnZV09dHJ1ZTtpZih0eXBlb2YgY29uc29sZSE9PSd1bmRlZmluZWQnJiZjb25zb2xlLndhcm4pe2NvbnNvbGUud2FybihtZXNzYWdlKTt9fW1vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se31dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzW1wiZGVmYXVsdFwiXT12b2lkIDA7LyoqXG4gKiBSZXByZXNlbnRzIGEgcGx1Z2lu4oCZcyB3YXJuaW5nLiBJdCBjYW4gYmUgY3JlYXRlZCB1c2luZyB7QGxpbmsgTm9kZSN3YXJufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaWYgKGRlY2wuaW1wb3J0YW50KSB7XG4gKiAgIGRlY2wud2FybihyZXN1bHQsICdBdm9pZCAhaW1wb3J0YW50JywgeyB3b3JkOiAnIWltcG9ydGFudCcgfSlcbiAqIH1cbiAqL3ZhciBXYXJuaW5nPS8qI19fUFVSRV9fKi9mdW5jdGlvbigpey8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgICAgICAgV2FybmluZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdICAgICAgV2FybmluZyBvcHRpb25zLlxuICAgKiBAcGFyYW0ge05vZGV9ICAgb3B0cy5ub2RlICAgQ1NTIG5vZGUgdGhhdCBjYXVzZWQgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndvcmQgICBXb3JkIGluIENTUyBzb3VyY2UgdGhhdCBjYXVzZWQgdGhlIHdhcm5pbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmluZGV4ICBJbmRleCBpbiBDU1Mgbm9kZSBzdHJpbmcgdGhhdCBjYXVzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB3YXJuaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5wbHVnaW4gTmFtZSBvZiB0aGUgcGx1Z2luIHRoYXQgY3JlYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3YXJuaW5nLiB7QGxpbmsgUmVzdWx0I3dhcm59IGZpbGxzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHByb3BlcnR5IGF1dG9tYXRpY2FsbHkuXG4gICAqL2Z1bmN0aW9uIFdhcm5pbmcodGV4dCxvcHRzKXtpZihvcHRzPT09dm9pZCAwKXtvcHRzPXt9O30vKipcbiAgICAgKiBUeXBlIHRvIGZpbHRlciB3YXJuaW5ncyBmcm9tIHtAbGluayBSZXN1bHQjbWVzc2FnZXN9LlxuICAgICAqIEFsd2F5cyBlcXVhbCB0byBgXCJ3YXJuaW5nXCJgLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgbm9uV2FybmluZyA9IHJlc3VsdC5tZXNzYWdlcy5maWx0ZXIoaSA9PiBpLnR5cGUgIT09ICd3YXJuaW5nJylcbiAgICAgKi90aGlzLnR5cGU9J3dhcm5pbmcnOy8qKlxuICAgICAqIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB3YXJuaW5nLnRleHQgLy89PiAnVHJ5IHRvIGF2b2lkICFpbXBvcnRhbnQnXG4gICAgICovdGhpcy50ZXh0PXRleHQ7aWYob3B0cy5ub2RlJiZvcHRzLm5vZGUuc291cmNlKXt2YXIgcG9zPW9wdHMubm9kZS5wb3NpdGlvbkJ5KG9wdHMpOy8qKlxuICAgICAgICogTGluZSBpbiB0aGUgaW5wdXQgZmlsZSB3aXRoIHRoaXMgd2FybmluZ+KAmXMgc291cmNlLlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogd2FybmluZy5saW5lIC8vPT4gNVxuICAgICAgICovdGhpcy5saW5lPXBvcy5saW5lOy8qKlxuICAgICAgICogQ29sdW1uIGluIHRoZSBpbnB1dCBmaWxlIHdpdGggdGhpcyB3YXJuaW5n4oCZcyBzb3VyY2UuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogd2FybmluZy5jb2x1bW4gLy89PiA2XG4gICAgICAgKi90aGlzLmNvbHVtbj1wb3MuY29sdW1uO31mb3IodmFyIG9wdCBpbiBvcHRzKXt0aGlzW29wdF09b3B0c1tvcHRdO319LyoqXG4gICAqIFJldHVybnMgYSB3YXJuaW5nIHBvc2l0aW9uIGFuZCBtZXNzYWdlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB3YXJuaW5nLnRvU3RyaW5nKCkgLy89PiAncG9zdGNzcy1saW50OmEuY3NzOjEwOjE0OiBBdm9pZCAhaW1wb3J0YW50J1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFdhcm5pbmcgcG9zaXRpb24gYW5kIG1lc3NhZ2UuXG4gICAqL3ZhciBfcHJvdG89V2FybmluZy5wcm90b3R5cGU7X3Byb3RvLnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7aWYodGhpcy5ub2RlKXtyZXR1cm4gdGhpcy5ub2RlLmVycm9yKHRoaXMudGV4dCx7cGx1Z2luOnRoaXMucGx1Z2luLGluZGV4OnRoaXMuaW5kZXgsd29yZDp0aGlzLndvcmR9KS5tZXNzYWdlO31pZih0aGlzLnBsdWdpbil7cmV0dXJuIHRoaXMucGx1Z2luKyc6ICcrdGhpcy50ZXh0O31yZXR1cm4gdGhpcy50ZXh0O30vKipcbiAgICogQG1lbWJlcm9mIFdhcm5pbmcjXG4gICAqIEBtZW1iZXIge3N0cmluZ30gcGx1Z2luIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgZmlsbCB0aGlzIHByb3BlcnR5IGF1dG9tYXRpY2FsbHkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2FybmluZy4gV2hlbiB5b3UgY2FsbCB7QGxpbmsgTm9kZSN3YXJufVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB3YXJuaW5nLnBsdWdpbiAvLz0+ICdwb3N0Y3NzLWltcG9ydGFudCdcbiAgICovIC8qKlxuICAgKiBAbWVtYmVyb2YgV2FybmluZyNcbiAgICogQG1lbWJlciB7Tm9kZX0gbm9kZSBDb250YWlucyB0aGUgQ1NTIG5vZGUgdGhhdCBjYXVzZWQgdGhlIHdhcm5pbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHdhcm5pbmcubm9kZS50b1N0cmluZygpIC8vPT4gJ2NvbG9yOiB3aGl0ZSAhaW1wb3J0YW50J1xuICAgKi87cmV0dXJuIFdhcm5pbmc7fSgpO3ZhciBfZGVmYXVsdD1XYXJuaW5nO2V4cG9ydHNbXCJkZWZhdWx0XCJdPV9kZWZhdWx0O21vZHVsZS5leHBvcnRzPWV4cG9ydHNbXCJkZWZhdWx0XCJdO30se31dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzPW1vZHVsZS5leHBvcnRzPXt9Oy8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxudmFyIGNhY2hlZFNldFRpbWVvdXQ7dmFyIGNhY2hlZENsZWFyVGltZW91dDtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7fWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO30oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT0nZnVuY3Rpb24nKXtjYWNoZWRTZXRUaW1lb3V0PXNldFRpbWVvdXQ7fWVsc2V7Y2FjaGVkU2V0VGltZW91dD1kZWZhdWx0U2V0VGltb3V0O319Y2F0Y2goZSl7Y2FjaGVkU2V0VGltZW91dD1kZWZhdWx0U2V0VGltb3V0O310cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PSdmdW5jdGlvbicpe2NhY2hlZENsZWFyVGltZW91dD1jbGVhclRpbWVvdXQ7fWVsc2V7Y2FjaGVkQ2xlYXJUaW1lb3V0PWRlZmF1bHRDbGVhclRpbWVvdXQ7fX1jYXRjaChlKXtjYWNoZWRDbGVhclRpbWVvdXQ9ZGVmYXVsdENsZWFyVGltZW91dDt9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bil7aWYoY2FjaGVkU2V0VGltZW91dD09PXNldFRpbWVvdXQpey8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xucmV0dXJuIHNldFRpbWVvdXQoZnVuLDApO30vLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuaWYoKGNhY2hlZFNldFRpbWVvdXQ9PT1kZWZhdWx0U2V0VGltb3V0fHwhY2FjaGVkU2V0VGltZW91dCkmJnNldFRpbWVvdXQpe2NhY2hlZFNldFRpbWVvdXQ9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChmdW4sMCk7fXRyeXsvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG5yZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sMCk7fWNhdGNoKGUpe3RyeXsvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbnJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCxmdW4sMCk7fWNhdGNoKGUpey8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG5yZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsZnVuLDApO319fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpe2lmKGNhY2hlZENsZWFyVGltZW91dD09PWNsZWFyVGltZW91dCl7Ly9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5yZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7fS8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbmlmKChjYWNoZWRDbGVhclRpbWVvdXQ9PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhY2FjaGVkQ2xlYXJUaW1lb3V0KSYmY2xlYXJUaW1lb3V0KXtjYWNoZWRDbGVhclRpbWVvdXQ9Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTt9dHJ5ey8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbnJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTt9Y2F0Y2goZSl7dHJ5ey8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbnJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLG1hcmtlcik7fWNhdGNoKGUpey8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxucmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsbWFya2VyKTt9fX12YXIgcXVldWU9W107dmFyIGRyYWluaW5nPWZhbHNlO3ZhciBjdXJyZW50UXVldWU7dmFyIHF1ZXVlSW5kZXg9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIWRyYWluaW5nfHwhY3VycmVudFF1ZXVlKXtyZXR1cm47fWRyYWluaW5nPWZhbHNlO2lmKGN1cnJlbnRRdWV1ZS5sZW5ndGgpe3F1ZXVlPWN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO31lbHNle3F1ZXVlSW5kZXg9LTE7fWlmKHF1ZXVlLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpO319ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKGRyYWluaW5nKXtyZXR1cm47fXZhciB0aW1lb3V0PXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtkcmFpbmluZz10cnVlO3ZhciBsZW49cXVldWUubGVuZ3RoO3doaWxlKGxlbil7Y3VycmVudFF1ZXVlPXF1ZXVlO3F1ZXVlPVtdO3doaWxlKCsrcXVldWVJbmRleDxsZW4pe2lmKGN1cnJlbnRRdWV1ZSl7Y3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO319cXVldWVJbmRleD0tMTtsZW49cXVldWUubGVuZ3RoO31jdXJyZW50UXVldWU9bnVsbDtkcmFpbmluZz1mYWxzZTtydW5DbGVhclRpbWVvdXQodGltZW91dCk7fXByb2Nlc3MubmV4dFRpY2s9ZnVuY3Rpb24oZnVuKXt2YXIgYXJncz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgaT0xO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe2FyZ3NbaS0xXT1hcmd1bWVudHNbaV07fX1xdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1bixhcmdzKSk7aWYocXVldWUubGVuZ3RoPT09MSYmIWRyYWluaW5nKXtydW5UaW1lb3V0KGRyYWluUXVldWUpO319Oy8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLGFycmF5KXt0aGlzLmZ1bj1mdW47dGhpcy5hcnJheT1hcnJheTt9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KTt9O3Byb2Nlc3MudGl0bGU9J2Jyb3dzZXInO3Byb2Nlc3MuYnJvd3Nlcj10cnVlO3Byb2Nlc3MuZW52PXt9O3Byb2Nlc3MuYXJndj1bXTtwcm9jZXNzLnZlcnNpb249Jyc7Ly8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe31wcm9jZXNzLm9uPW5vb3A7cHJvY2Vzcy5hZGRMaXN0ZW5lcj1ub29wO3Byb2Nlc3Mub25jZT1ub29wO3Byb2Nlc3Mub2ZmPW5vb3A7cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcj1ub29wO3Byb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7cHJvY2Vzcy5lbWl0PW5vb3A7cHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXI9bm9vcDtwcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDtwcm9jZXNzLmxpc3RlbmVycz1mdW5jdGlvbihuYW1lKXtyZXR1cm5bXTt9O3Byb2Nlc3MuYmluZGluZz1mdW5jdGlvbihuYW1lKXt0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7fTtwcm9jZXNzLmN3ZD1mdW5jdGlvbigpe3JldHVybicvJzt9O3Byb2Nlc3MuY2hkaXI9ZnVuY3Rpb24oZGlyKXt0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO307cHJvY2Vzcy51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwO307fSx7fV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpey8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovOyhmdW5jdGlvbihyb290KXsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovdmFyIGZyZWVFeHBvcnRzPV90eXBlb2YoZXhwb3J0cyk9PSdvYmplY3QnJiZleHBvcnRzJiYhZXhwb3J0cy5ub2RlVHlwZSYmZXhwb3J0czt2YXIgZnJlZU1vZHVsZT1fdHlwZW9mKG1vZHVsZSk9PSdvYmplY3QnJiZtb2R1bGUmJiFtb2R1bGUubm9kZVR5cGUmJm1vZHVsZTt2YXIgZnJlZUdsb2JhbD1fdHlwZW9mKGdsb2JhbCk9PSdvYmplY3QnJiZnbG9iYWw7aWYoZnJlZUdsb2JhbC5nbG9iYWw9PT1mcmVlR2xvYmFsfHxmcmVlR2xvYmFsLndpbmRvdz09PWZyZWVHbG9iYWx8fGZyZWVHbG9iYWwuc2VsZj09PWZyZWVHbG9iYWwpe3Jvb3Q9ZnJlZUdsb2JhbDt9LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL3ZhciBwdW55Y29kZSwvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovbWF4SW50PTIxNDc0ODM2NDcsLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL2Jhc2U9MzYsdE1pbj0xLHRNYXg9MjYsc2tldz0zOCxkYW1wPTcwMCxpbml0aWFsQmlhcz03Mixpbml0aWFsTj0xMjgsLy8gMHg4MFxuZGVsaW1pdGVyPSctJywvLyAnXFx4MkQnXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL3JlZ2V4UHVueWNvZGU9L154bi0tLyxyZWdleE5vbkFTQ0lJPS9bXlxceDIwLVxceDdFXS8sLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcbnJlZ2V4U2VwYXJhdG9ycz0vW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcbi8qKiBFcnJvciBtZXNzYWdlcyAqL2Vycm9ycz17J292ZXJmbG93JzonT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLCdub3QtYmFzaWMnOidJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJywnaW52YWxpZC1pbnB1dCc6J0ludmFsaWQgaW5wdXQnfSwvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovYmFzZU1pbnVzVE1pbj1iYXNlLXRNaW4sZmxvb3I9TWF0aC5mbG9vcixzdHJpbmdGcm9tQ2hhckNvZGU9U3RyaW5nLmZyb21DaGFyQ29kZSwvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICova2V5Oy8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLyAvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL2Z1bmN0aW9uIGVycm9yKHR5cGUpe3Rocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7fS8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovZnVuY3Rpb24gbWFwKGFycmF5LGZuKXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDt2YXIgcmVzdWx0PVtdO3doaWxlKGxlbmd0aC0tKXtyZXN1bHRbbGVuZ3RoXT1mbihhcnJheVtsZW5ndGhdKTt9cmV0dXJuIHJlc3VsdDt9LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9mdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLGZuKXt2YXIgcGFydHM9c3RyaW5nLnNwbGl0KCdAJyk7dmFyIHJlc3VsdD0nJztpZihwYXJ0cy5sZW5ndGg+MSl7Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuLy8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cbnJlc3VsdD1wYXJ0c1swXSsnQCc7c3RyaW5nPXBhcnRzWzFdO30vLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5zdHJpbmc9c3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCdcXHgyRScpO3ZhciBsYWJlbHM9c3RyaW5nLnNwbGl0KCcuJyk7dmFyIGVuY29kZWQ9bWFwKGxhYmVscyxmbikuam9pbignLicpO3JldHVybiByZXN1bHQrZW5jb2RlZDt9LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL2Z1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKXt2YXIgb3V0cHV0PVtdLGNvdW50ZXI9MCxsZW5ndGg9c3RyaW5nLmxlbmd0aCx2YWx1ZSxleHRyYTt3aGlsZShjb3VudGVyPGxlbmd0aCl7dmFsdWU9c3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtpZih2YWx1ZT49MHhEODAwJiZ2YWx1ZTw9MHhEQkZGJiZjb3VudGVyPGxlbmd0aCl7Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5leHRyYT1zdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO2lmKChleHRyYSYweEZDMDApPT0weERDMDApey8vIGxvdyBzdXJyb2dhdGVcbm91dHB1dC5wdXNoKCgodmFsdWUmMHgzRkYpPDwxMCkrKGV4dHJhJjB4M0ZGKSsweDEwMDAwKTt9ZWxzZXsvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuLy8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5vdXRwdXQucHVzaCh2YWx1ZSk7Y291bnRlci0tO319ZWxzZXtvdXRwdXQucHVzaCh2YWx1ZSk7fX1yZXR1cm4gb3V0cHV0O30vKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSl7cmV0dXJuIG1hcChhcnJheSxmdW5jdGlvbih2YWx1ZSl7dmFyIG91dHB1dD0nJztpZih2YWx1ZT4weEZGRkYpe3ZhbHVlLT0weDEwMDAwO291dHB1dCs9c3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlPj4+MTAmMHgzRkZ8MHhEODAwKTt2YWx1ZT0weERDMDB8dmFsdWUmMHgzRkY7fW91dHB1dCs9c3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtyZXR1cm4gb3V0cHV0O30pLmpvaW4oJycpO30vKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCl7aWYoY29kZVBvaW50LTQ4PDEwKXtyZXR1cm4gY29kZVBvaW50LTIyO31pZihjb2RlUG9pbnQtNjU8MjYpe3JldHVybiBjb2RlUG9pbnQtNjU7fWlmKGNvZGVQb2ludC05NzwyNil7cmV0dXJuIGNvZGVQb2ludC05Nzt9cmV0dXJuIGJhc2U7fS8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LGZsYWcpey8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG4vLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbnJldHVybiBkaWdpdCsyMis3NSooZGlnaXQ8MjYpLSgoZmxhZyE9MCk8PDUpO30vKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovZnVuY3Rpb24gYWRhcHQoZGVsdGEsbnVtUG9pbnRzLGZpcnN0VGltZSl7dmFyIGs9MDtkZWx0YT1maXJzdFRpbWU/Zmxvb3IoZGVsdGEvZGFtcCk6ZGVsdGE+PjE7ZGVsdGErPWZsb29yKGRlbHRhL251bVBvaW50cyk7Zm9yKDsvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhPmJhc2VNaW51c1RNaW4qdE1heD4+MTtrKz1iYXNlKXtkZWx0YT1mbG9vcihkZWx0YS9iYXNlTWludXNUTWluKTt9cmV0dXJuIGZsb29yKGsrKGJhc2VNaW51c1RNaW4rMSkqZGVsdGEvKGRlbHRhK3NrZXcpKTt9LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovZnVuY3Rpb24gZGVjb2RlKGlucHV0KXsvLyBEb24ndCB1c2UgVUNTLTJcbnZhciBvdXRwdXQ9W10saW5wdXRMZW5ndGg9aW5wdXQubGVuZ3RoLG91dCxpPTAsbj1pbml0aWFsTixiaWFzPWluaXRpYWxCaWFzLGJhc2ljLGosaW5kZXgsb2xkaSx3LGssZGlnaXQsdCwvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9iYXNlTWludXNUOy8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuLy8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcbi8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuYmFzaWM9aW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtpZihiYXNpYzwwKXtiYXNpYz0wO31mb3Ioaj0wO2o8YmFzaWM7KytqKXsvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcbmlmKGlucHV0LmNoYXJDb2RlQXQoaik+PTB4ODApe2Vycm9yKCdub3QtYmFzaWMnKTt9b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7fS8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcbi8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5mb3IoaW5kZXg9YmFzaWM+MD9iYXNpYysxOjA7aW5kZXg8aW5wdXRMZW5ndGg7KS8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi97Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuLy8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuLy8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcbi8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG4vLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuZm9yKG9sZGk9aSx3PTEsaz1iYXNlOzsvKiBubyBjb25kaXRpb24gKi9rKz1iYXNlKXtpZihpbmRleD49aW5wdXRMZW5ndGgpe2Vycm9yKCdpbnZhbGlkLWlucHV0Jyk7fWRpZ2l0PWJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtpZihkaWdpdD49YmFzZXx8ZGlnaXQ+Zmxvb3IoKG1heEludC1pKS93KSl7ZXJyb3IoJ292ZXJmbG93Jyk7fWkrPWRpZ2l0Knc7dD1rPD1iaWFzP3RNaW46az49Ymlhcyt0TWF4P3RNYXg6ay1iaWFzO2lmKGRpZ2l0PHQpe2JyZWFrO31iYXNlTWludXNUPWJhc2UtdDtpZih3PmZsb29yKG1heEludC9iYXNlTWludXNUKSl7ZXJyb3IoJ292ZXJmbG93Jyk7fXcqPWJhc2VNaW51c1Q7fW91dD1vdXRwdXQubGVuZ3RoKzE7Ymlhcz1hZGFwdChpLW9sZGksb3V0LG9sZGk9PTApOy8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG4vLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuaWYoZmxvb3IoaS9vdXQpPm1heEludC1uKXtlcnJvcignb3ZlcmZsb3cnKTt9bis9Zmxvb3IoaS9vdXQpO2klPW91dDsvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5vdXRwdXQuc3BsaWNlKGkrKywwLG4pO31yZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO30vKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9mdW5jdGlvbiBlbmNvZGUoaW5wdXQpe3ZhciBuLGRlbHRhLGhhbmRsZWRDUENvdW50LGJhc2ljTGVuZ3RoLGJpYXMsaixtLHEsayx0LGN1cnJlbnRWYWx1ZSxvdXRwdXQ9W10sLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9pbnB1dExlbmd0aCwvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9oYW5kbGVkQ1BDb3VudFBsdXNPbmUsYmFzZU1pbnVzVCxxTWludXNUOy8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcbmlucHV0PXVjczJkZWNvZGUoaW5wdXQpOy8vIENhY2hlIHRoZSBsZW5ndGhcbmlucHV0TGVuZ3RoPWlucHV0Lmxlbmd0aDsvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxubj1pbml0aWFsTjtkZWx0YT0wO2JpYXM9aW5pdGlhbEJpYXM7Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuZm9yKGo9MDtqPGlucHV0TGVuZ3RoOysrail7Y3VycmVudFZhbHVlPWlucHV0W2pdO2lmKGN1cnJlbnRWYWx1ZTwweDgwKXtvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7fX1oYW5kbGVkQ1BDb3VudD1iYXNpY0xlbmd0aD1vdXRwdXQubGVuZ3RoOy8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuLy8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuLy8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5pZihiYXNpY0xlbmd0aCl7b3V0cHV0LnB1c2goZGVsaW1pdGVyKTt9Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxud2hpbGUoaGFuZGxlZENQQ291bnQ8aW5wdXRMZW5ndGgpey8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcbi8vIGxhcmdlciBvbmU6XG5mb3IobT1tYXhJbnQsaj0wO2o8aW5wdXRMZW5ndGg7KytqKXtjdXJyZW50VmFsdWU9aW5wdXRbal07aWYoY3VycmVudFZhbHVlPj1uJiZjdXJyZW50VmFsdWU8bSl7bT1jdXJyZW50VmFsdWU7fX0vLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG4vLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuaGFuZGxlZENQQ291bnRQbHVzT25lPWhhbmRsZWRDUENvdW50KzE7aWYobS1uPmZsb29yKChtYXhJbnQtZGVsdGEpL2hhbmRsZWRDUENvdW50UGx1c09uZSkpe2Vycm9yKCdvdmVyZmxvdycpO31kZWx0YSs9KG0tbikqaGFuZGxlZENQQ291bnRQbHVzT25lO249bTtmb3Ioaj0wO2o8aW5wdXRMZW5ndGg7KytqKXtjdXJyZW50VmFsdWU9aW5wdXRbal07aWYoY3VycmVudFZhbHVlPG4mJisrZGVsdGE+bWF4SW50KXtlcnJvcignb3ZlcmZsb3cnKTt9aWYoY3VycmVudFZhbHVlPT1uKXsvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuZm9yKHE9ZGVsdGEsaz1iYXNlOzsvKiBubyBjb25kaXRpb24gKi9rKz1iYXNlKXt0PWs8PWJpYXM/dE1pbjprPj1iaWFzK3RNYXg/dE1heDprLWJpYXM7aWYocTx0KXticmVhazt9cU1pbnVzVD1xLXQ7YmFzZU1pbnVzVD1iYXNlLXQ7b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0K3FNaW51c1QlYmFzZU1pbnVzVCwwKSkpO3E9Zmxvb3IocU1pbnVzVC9iYXNlTWludXNUKTt9b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLDApKSk7Ymlhcz1hZGFwdChkZWx0YSxoYW5kbGVkQ1BDb3VudFBsdXNPbmUsaGFuZGxlZENQQ291bnQ9PWJhc2ljTGVuZ3RoKTtkZWx0YT0wOysraGFuZGxlZENQQ291bnQ7fX0rK2RlbHRhOysrbjt9cmV0dXJuIG91dHB1dC5qb2luKCcnKTt9LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KXtyZXR1cm4gbWFwRG9tYWluKGlucHV0LGZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpP2RlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSk6c3RyaW5nO30pO30vKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9mdW5jdGlvbiB0b0FTQ0lJKGlucHV0KXtyZXR1cm4gbWFwRG9tYWluKGlucHV0LGZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpPyd4bi0tJytlbmNvZGUoc3RyaW5nKTpzdHJpbmc7fSk7fS8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLyAvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovcHVueWNvZGU9ey8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi8ndmVyc2lvbic6JzEuNC4xJywvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovJ3VjczInOnsnZGVjb2RlJzp1Y3MyZGVjb2RlLCdlbmNvZGUnOnVjczJlbmNvZGV9LCdkZWNvZGUnOmRlY29kZSwnZW5jb2RlJzplbmNvZGUsJ3RvQVNDSUknOnRvQVNDSUksJ3RvVW5pY29kZSc6dG9Vbmljb2RlfTsvKiogRXhwb3NlIGBwdW55Y29kZWAgKi8gLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG4vLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5pZih0eXBlb2YgZGVmaW5lPT0nZnVuY3Rpb24nJiZfdHlwZW9mKGRlZmluZS5hbWQpPT0nb2JqZWN0JyYmZGVmaW5lLmFtZCl7ZGVmaW5lKCdwdW55Y29kZScsZnVuY3Rpb24oKXtyZXR1cm4gcHVueWNvZGU7fSk7fWVsc2UgaWYoZnJlZUV4cG9ydHMmJmZyZWVNb2R1bGUpe2lmKG1vZHVsZS5leHBvcnRzPT1mcmVlRXhwb3J0cyl7Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuZnJlZU1vZHVsZS5leHBvcnRzPXB1bnljb2RlO31lbHNley8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5mb3Ioa2V5IGluIHB1bnljb2RlKXtwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpJiYoZnJlZUV4cG9ydHNba2V5XT1wdW55Y29kZVtrZXldKTt9fX1lbHNley8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcbnJvb3QucHVueWNvZGU9cHVueWNvZGU7fX0pKHRoaXMpO30pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIj9nbG9iYWw6dHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KTt9LHt9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7Ly8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7Ly8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLHByb3Ape3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLHByb3ApO31tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihxcyxzZXAsZXEsb3B0aW9ucyl7c2VwPXNlcHx8JyYnO2VxPWVxfHwnPSc7dmFyIG9iaj17fTtpZih0eXBlb2YgcXMhPT0nc3RyaW5nJ3x8cXMubGVuZ3RoPT09MCl7cmV0dXJuIG9iajt9dmFyIHJlZ2V4cD0vXFwrL2c7cXM9cXMuc3BsaXQoc2VwKTt2YXIgbWF4S2V5cz0xMDAwO2lmKG9wdGlvbnMmJnR5cGVvZiBvcHRpb25zLm1heEtleXM9PT0nbnVtYmVyJyl7bWF4S2V5cz1vcHRpb25zLm1heEtleXM7fXZhciBsZW49cXMubGVuZ3RoOy8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuaWYobWF4S2V5cz4wJiZsZW4+bWF4S2V5cyl7bGVuPW1heEtleXM7fWZvcih2YXIgaT0wO2k8bGVuOysraSl7dmFyIHg9cXNbaV0ucmVwbGFjZShyZWdleHAsJyUyMCcpLGlkeD14LmluZGV4T2YoZXEpLGtzdHIsdnN0cixrLHY7aWYoaWR4Pj0wKXtrc3RyPXguc3Vic3RyKDAsaWR4KTt2c3RyPXguc3Vic3RyKGlkeCsxKTt9ZWxzZXtrc3RyPXg7dnN0cj0nJzt9az1kZWNvZGVVUklDb21wb25lbnQoa3N0cik7dj1kZWNvZGVVUklDb21wb25lbnQodnN0cik7aWYoIWhhc093blByb3BlcnR5KG9iaixrKSl7b2JqW2tdPXY7fWVsc2UgaWYoaXNBcnJheShvYmpba10pKXtvYmpba10ucHVzaCh2KTt9ZWxzZXtvYmpba109W29ialtrXSx2XTt9fXJldHVybiBvYmo7fTt2YXIgaXNBcnJheT1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih4cyl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cyk9PT0nW29iamVjdCBBcnJheV0nO307fSx7fV0sNjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO3ZhciBzdHJpbmdpZnlQcmltaXRpdmU9ZnVuY3Rpb24gc3RyaW5naWZ5UHJpbWl0aXZlKHYpe3N3aXRjaChfdHlwZW9mKHYpKXtjYXNlJ3N0cmluZyc6cmV0dXJuIHY7Y2FzZSdib29sZWFuJzpyZXR1cm4gdj8ndHJ1ZSc6J2ZhbHNlJztjYXNlJ251bWJlcic6cmV0dXJuIGlzRmluaXRlKHYpP3Y6Jyc7ZGVmYXVsdDpyZXR1cm4nJzt9fTttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihvYmosc2VwLGVxLG5hbWUpe3NlcD1zZXB8fCcmJztlcT1lcXx8Jz0nO2lmKG9iaj09PW51bGwpe29iaj11bmRlZmluZWQ7fWlmKF90eXBlb2Yob2JqKT09PSdvYmplY3QnKXtyZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSxmdW5jdGlvbihrKXt2YXIga3M9ZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkrZXE7aWYoaXNBcnJheShvYmpba10pKXtyZXR1cm4gbWFwKG9ialtrXSxmdW5jdGlvbih2KXtyZXR1cm4ga3MrZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7fSkuam9pbihzZXApO31lbHNle3JldHVybiBrcytlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO319KS5qb2luKHNlcCk7fWlmKCFuYW1lKXJldHVybicnO3JldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKStlcStlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO307dmFyIGlzQXJyYXk9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oeHMpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpPT09J1tvYmplY3QgQXJyYXldJzt9O2Z1bmN0aW9uIG1hcCh4cyxmKXtpZih4cy5tYXApcmV0dXJuIHhzLm1hcChmKTt2YXIgcmVzPVtdO2Zvcih2YXIgaT0wO2k8eHMubGVuZ3RoO2krKyl7cmVzLnB1c2goZih4c1tpXSxpKSk7fXJldHVybiByZXM7fXZhciBvYmplY3RLZXlzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihvYmope3ZhciByZXM9W107Zm9yKHZhciBrZXkgaW4gb2JqKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLGtleSkpcmVzLnB1c2goa2V5KTt9cmV0dXJuIHJlczt9O30se31dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsndXNlIHN0cmljdCc7ZXhwb3J0cy5kZWNvZGU9ZXhwb3J0cy5wYXJzZT1yZXF1aXJlKCcuL2RlY29kZScpO2V4cG9ydHMuZW5jb2RlPWV4cG9ydHMuc3RyaW5naWZ5PXJlcXVpcmUoJy4vZW5jb2RlJyk7fSx7XCIuL2RlY29kZVwiOjY1LFwiLi9lbmNvZGVcIjo2Nn1dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovIC8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi92YXIgdXRpbD1yZXF1aXJlKCcuL3V0aWwnKTt2YXIgaGFzPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIGhhc05hdGl2ZU1hcD10eXBlb2YgTWFwIT09XCJ1bmRlZmluZWRcIjsvKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9mdW5jdGlvbiBBcnJheVNldCgpe3RoaXMuX2FycmF5PVtdO3RoaXMuX3NldD1oYXNOYXRpdmVNYXA/bmV3IE1hcCgpOk9iamVjdC5jcmVhdGUobnVsbCk7fS8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9BcnJheVNldC5mcm9tQXJyYXk9ZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSxhQWxsb3dEdXBsaWNhdGVzKXt2YXIgc2V0PW5ldyBBcnJheVNldCgpO2Zvcih2YXIgaT0wLGxlbj1hQXJyYXkubGVuZ3RoO2k8bGVuO2krKyl7c2V0LmFkZChhQXJyYXlbaV0sYUFsbG93RHVwbGljYXRlcyk7fXJldHVybiBzZXQ7fTsvKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL0FycmF5U2V0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKXtyZXR1cm4gaGFzTmF0aXZlTWFwP3RoaXMuX3NldC5zaXplOk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO307LyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL0FycmF5U2V0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsYUFsbG93RHVwbGljYXRlcyl7dmFyIHNTdHI9aGFzTmF0aXZlTWFwP2FTdHI6dXRpbC50b1NldFN0cmluZyhhU3RyKTt2YXIgaXNEdXBsaWNhdGU9aGFzTmF0aXZlTWFwP3RoaXMuaGFzKGFTdHIpOmhhcy5jYWxsKHRoaXMuX3NldCxzU3RyKTt2YXIgaWR4PXRoaXMuX2FycmF5Lmxlbmd0aDtpZighaXNEdXBsaWNhdGV8fGFBbGxvd0R1cGxpY2F0ZXMpe3RoaXMuX2FycmF5LnB1c2goYVN0cik7fWlmKCFpc0R1cGxpY2F0ZSl7aWYoaGFzTmF0aXZlTWFwKXt0aGlzLl9zZXQuc2V0KGFTdHIsaWR4KTt9ZWxzZXt0aGlzLl9zZXRbc1N0cl09aWR4O319fTsvKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9BcnJheVNldC5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKXtpZihoYXNOYXRpdmVNYXApe3JldHVybiB0aGlzLl9zZXQuaGFzKGFTdHIpO31lbHNle3ZhciBzU3RyPXV0aWwudG9TZXRTdHJpbmcoYVN0cik7cmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCxzU3RyKTt9fTsvKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKXtpZihoYXNOYXRpdmVNYXApe3ZhciBpZHg9dGhpcy5fc2V0LmdldChhU3RyKTtpZihpZHg+PTApe3JldHVybiBpZHg7fX1lbHNle3ZhciBzU3RyPXV0aWwudG9TZXRTdHJpbmcoYVN0cik7aWYoaGFzLmNhbGwodGhpcy5fc2V0LHNTdHIpKXtyZXR1cm4gdGhpcy5fc2V0W3NTdHJdO319dGhyb3cgbmV3IEVycm9yKCdcIicrYVN0cisnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7fTsvKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovQXJyYXlTZXQucHJvdG90eXBlLmF0PWZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpe2lmKGFJZHg+PTAmJmFJZHg8dGhpcy5fYXJyYXkubGVuZ3RoKXtyZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07fXRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcrYUlkeCk7fTsvKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL0FycmF5U2V0LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKXtyZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTt9O2V4cG9ydHMuQXJyYXlTZXQ9QXJyYXlTZXQ7fSx7XCIuL3V0aWxcIjo3N31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovIC8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi92YXIgYmFzZTY0PXJlcXVpcmUoJy4vYmFzZTY0Jyk7Ly8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG52YXIgVkxRX0JBU0VfU0hJRlQ9NTsvLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFPTE8PFZMUV9CQVNFX1NISUZUOy8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSz1WTFFfQkFTRS0xOy8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQ9VkxRX0JBU0U7LyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKXtyZXR1cm4gYVZhbHVlPDA/KC1hVmFsdWU8PDEpKzE6KGFWYWx1ZTw8MSkrMDt9LyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpe3ZhciBpc05lZ2F0aXZlPShhVmFsdWUmMSk9PT0xO3ZhciBzaGlmdGVkPWFWYWx1ZT4+MTtyZXR1cm4gaXNOZWdhdGl2ZT8tc2hpZnRlZDpzaGlmdGVkO30vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9leHBvcnRzLmVuY29kZT1mdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSl7dmFyIGVuY29kZWQ9XCJcIjt2YXIgZGlnaXQ7dmFyIHZscT10b1ZMUVNpZ25lZChhVmFsdWUpO2Rve2RpZ2l0PXZscSZWTFFfQkFTRV9NQVNLO3ZscT4+Pj1WTFFfQkFTRV9TSElGVDtpZih2bHE+MCl7Ly8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG5kaWdpdHw9VkxRX0NPTlRJTlVBVElPTl9CSVQ7fWVuY29kZWQrPWJhc2U2NC5lbmNvZGUoZGlnaXQpO313aGlsZSh2bHE+MCk7cmV0dXJuIGVuY29kZWQ7fTsvKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovZXhwb3J0cy5kZWNvZGU9ZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLGFJbmRleCxhT3V0UGFyYW0pe3ZhciBzdHJMZW49YVN0ci5sZW5ndGg7dmFyIHJlc3VsdD0wO3ZhciBzaGlmdD0wO3ZhciBjb250aW51YXRpb24sZGlnaXQ7ZG97aWYoYUluZGV4Pj1zdHJMZW4pe3Rocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTt9ZGlnaXQ9YmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtpZihkaWdpdD09PS0xKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIrYVN0ci5jaGFyQXQoYUluZGV4LTEpKTt9Y29udGludWF0aW9uPSEhKGRpZ2l0JlZMUV9DT05USU5VQVRJT05fQklUKTtkaWdpdCY9VkxRX0JBU0VfTUFTSztyZXN1bHQ9cmVzdWx0KyhkaWdpdDw8c2hpZnQpO3NoaWZ0Kz1WTFFfQkFTRV9TSElGVDt9d2hpbGUoY29udGludWF0aW9uKTthT3V0UGFyYW0udmFsdWU9ZnJvbVZMUVNpZ25lZChyZXN1bHQpO2FPdXRQYXJhbS5yZXN0PWFJbmRleDt9O30se1wiLi9iYXNlNjRcIjo3MH1dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovIC8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi92YXIgaW50VG9DaGFyTWFwPSdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7LyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovZXhwb3J0cy5lbmNvZGU9ZnVuY3Rpb24obnVtYmVyKXtpZigwPD1udW1iZXImJm51bWJlcjxpbnRUb0NoYXJNYXAubGVuZ3RoKXtyZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07fXRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiK251bWJlcik7fTsvKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9leHBvcnRzLmRlY29kZT1mdW5jdGlvbihjaGFyQ29kZSl7dmFyIGJpZ0E9NjU7Ly8gJ0EnXG52YXIgYmlnWj05MDsvLyAnWidcbnZhciBsaXR0bGVBPTk3Oy8vICdhJ1xudmFyIGxpdHRsZVo9MTIyOy8vICd6J1xudmFyIHplcm89NDg7Ly8gJzAnXG52YXIgbmluZT01NzsvLyAnOSdcbnZhciBwbHVzPTQzOy8vICcrJ1xudmFyIHNsYXNoPTQ3Oy8vICcvJ1xudmFyIGxpdHRsZU9mZnNldD0yNjt2YXIgbnVtYmVyT2Zmc2V0PTUyOy8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbmlmKGJpZ0E8PWNoYXJDb2RlJiZjaGFyQ29kZTw9YmlnWil7cmV0dXJuIGNoYXJDb2RlLWJpZ0E7fS8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG5pZihsaXR0bGVBPD1jaGFyQ29kZSYmY2hhckNvZGU8PWxpdHRsZVope3JldHVybiBjaGFyQ29kZS1saXR0bGVBK2xpdHRsZU9mZnNldDt9Ly8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuaWYoemVybzw9Y2hhckNvZGUmJmNoYXJDb2RlPD1uaW5lKXtyZXR1cm4gY2hhckNvZGUtemVybytudW1iZXJPZmZzZXQ7fS8vIDYyOiArXG5pZihjaGFyQ29kZT09cGx1cyl7cmV0dXJuIDYyO30vLyA2MzogL1xuaWYoY2hhckNvZGU9PXNsYXNoKXtyZXR1cm4gNjM7fS8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxucmV0dXJuLTE7fTt9LHt9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORD0xO2V4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQ9MjsvKipcbiAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqL2Z1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LGFIaWdoLGFOZWVkbGUsYUhheXN0YWNrLGFDb21wYXJlLGFCaWFzKXsvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuLy9cbi8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4vL1xuLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4vL1xuLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3Rcbi8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbnZhciBtaWQ9TWF0aC5mbG9vcigoYUhpZ2gtYUxvdykvMikrYUxvdzt2YXIgY21wPWFDb21wYXJlKGFOZWVkbGUsYUhheXN0YWNrW21pZF0sdHJ1ZSk7aWYoY21wPT09MCl7Ly8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxucmV0dXJuIG1pZDt9ZWxzZSBpZihjbXA+MCl7Ly8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG5pZihhSGlnaC1taWQ+MSl7Ly8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG5yZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCxhSGlnaCxhTmVlZGxlLGFIYXlzdGFjayxhQ29tcGFyZSxhQmlhcyk7fS8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbmlmKGFCaWFzPT1leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKXtyZXR1cm4gYUhpZ2g8YUhheXN0YWNrLmxlbmd0aD9hSGlnaDotMTt9ZWxzZXtyZXR1cm4gbWlkO319ZWxzZXsvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbmlmKG1pZC1hTG93PjEpey8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxucmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LG1pZCxhTmVlZGxlLGFIYXlzdGFjayxhQ29tcGFyZSxhQmlhcyk7fS8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG5pZihhQmlhcz09ZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCl7cmV0dXJuIG1pZDt9ZWxzZXtyZXR1cm4gYUxvdzwwPy0xOmFMb3c7fX19LyoqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICpcbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKi9leHBvcnRzLnNlYXJjaD1mdW5jdGlvbiBzZWFyY2goYU5lZWRsZSxhSGF5c3RhY2ssYUNvbXBhcmUsYUJpYXMpe2lmKGFIYXlzdGFjay5sZW5ndGg9PT0wKXtyZXR1cm4tMTt9dmFyIGluZGV4PXJlY3Vyc2l2ZVNlYXJjaCgtMSxhSGF5c3RhY2subGVuZ3RoLGFOZWVkbGUsYUhheXN0YWNrLGFDb21wYXJlLGFCaWFzfHxleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtpZihpbmRleDwwKXtyZXR1cm4tMTt9Ly8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4vLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4vLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG53aGlsZShpbmRleC0xPj0wKXtpZihhQ29tcGFyZShhSGF5c3RhY2tbaW5kZXhdLGFIYXlzdGFja1tpbmRleC0xXSx0cnVlKSE9PTApe2JyZWFrO30tLWluZGV4O31yZXR1cm4gaW5kZXg7fTt9LHt9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovdmFyIHV0aWw9cmVxdWlyZSgnLi91dGlsJyk7LyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL2Z1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsbWFwcGluZ0Ipey8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxudmFyIGxpbmVBPW1hcHBpbmdBLmdlbmVyYXRlZExpbmU7dmFyIGxpbmVCPW1hcHBpbmdCLmdlbmVyYXRlZExpbmU7dmFyIGNvbHVtbkE9bWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO3ZhciBjb2x1bW5CPW1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtyZXR1cm4gbGluZUI+bGluZUF8fGxpbmVCPT1saW5lQSYmY29sdW1uQj49Y29sdW1uQXx8dXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSxtYXBwaW5nQik8PTA7fS8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL2Z1bmN0aW9uIE1hcHBpbmdMaXN0KCl7dGhpcy5fYXJyYXk9W107dGhpcy5fc29ydGVkPXRydWU7Ly8gU2VydmVzIGFzIGluZmltdW1cbnRoaXMuX2xhc3Q9e2dlbmVyYXRlZExpbmU6LTEsZ2VuZXJhdGVkQ29sdW1uOjB9O30vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL01hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2g9ZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssYVRoaXNBcmcpe3RoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLGFUaGlzQXJnKTt9Oy8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZyl7aWYoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LGFNYXBwaW5nKSl7dGhpcy5fbGFzdD1hTWFwcGluZzt0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTt9ZWxzZXt0aGlzLl9zb3J0ZWQ9ZmFsc2U7dGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7fX07LyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpe2lmKCF0aGlzLl9zb3J0ZWQpe3RoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7dGhpcy5fc29ydGVkPXRydWU7fXJldHVybiB0aGlzLl9hcnJheTt9O2V4cG9ydHMuTWFwcGluZ0xpc3Q9TWFwcGluZ0xpc3Q7fSx7XCIuL3V0aWxcIjo3N31dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovIC8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi8gLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovZnVuY3Rpb24gc3dhcChhcnkseCx5KXt2YXIgdGVtcD1hcnlbeF07YXJ5W3hdPWFyeVt5XTthcnlbeV09dGVtcDt9LyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL2Z1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LGhpZ2gpe3JldHVybiBNYXRoLnJvdW5kKGxvdytNYXRoLnJhbmRvbSgpKihoaWdoLWxvdykpO30vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL2Z1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSxjb21wYXJhdG9yLHAscil7Ly8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4vLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4vLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5pZihwPHIpey8vICgxKSBQYXJ0aXRpb25pbmcuXG4vL1xuLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4vLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbi8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG4vLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG52YXIgcGl2b3RJbmRleD1yYW5kb21JbnRJblJhbmdlKHAscik7dmFyIGk9cC0xO3N3YXAoYXJ5LHBpdm90SW5kZXgscik7dmFyIHBpdm90PWFyeVtyXTsvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbi8vIHRydWU6XG4vL1xuLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuLy9cbi8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG5mb3IodmFyIGo9cDtqPHI7aisrKXtpZihjb21wYXJhdG9yKGFyeVtqXSxwaXZvdCk8PTApe2krPTE7c3dhcChhcnksaSxqKTt9fXN3YXAoYXJ5LGkrMSxqKTt2YXIgcT1pKzE7Ly8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuZG9RdWlja1NvcnQoYXJ5LGNvbXBhcmF0b3IscCxxLTEpO2RvUXVpY2tTb3J0KGFyeSxjb21wYXJhdG9yLHErMSxyKTt9fS8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL2V4cG9ydHMucXVpY2tTb3J0PWZ1bmN0aW9uKGFyeSxjb21wYXJhdG9yKXtkb1F1aWNrU29ydChhcnksY29tcGFyYXRvciwwLGFyeS5sZW5ndGgtMSk7fTt9LHt9XSw3NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovdmFyIHV0aWw9cmVxdWlyZSgnLi91dGlsJyk7dmFyIGJpbmFyeVNlYXJjaD1yZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTt2YXIgQXJyYXlTZXQ9cmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDt2YXIgYmFzZTY0VkxRPXJlcXVpcmUoJy4vYmFzZTY0LXZscScpO3ZhciBxdWlja1NvcnQ9cmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O2Z1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsYVNvdXJjZU1hcFVSTCl7dmFyIHNvdXJjZU1hcD1hU291cmNlTWFwO2lmKHR5cGVvZiBhU291cmNlTWFwPT09J3N0cmluZycpe3NvdXJjZU1hcD11dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7fXJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMhPW51bGw/bmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsYVNvdXJjZU1hcFVSTCk6bmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLGFTb3VyY2VNYXBVUkwpO31Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwPWZ1bmN0aW9uKGFTb3VyY2VNYXAsYVNvdXJjZU1hcFVSTCl7cmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLGFTb3VyY2VNYXBVUkwpO307LyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb249MzsvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbi8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4vLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbi8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuLy9cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4vL1xuLy8gICAgIHtcbi8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbi8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4vLyAgICAgICAgICAgICBjb2RlLlxuLy8gICAgIH1cbi8vXG4vLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4vLyBgbnVsbGAuXG4vL1xuLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbi8vXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzPW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwnX2dlbmVyYXRlZE1hcHBpbmdzJyx7Y29uZmlndXJhYmxlOnRydWUsZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbiBnZXQoKXtpZighdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKXt0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLHRoaXMuc291cmNlUm9vdCk7fXJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7fX0pO1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3M9bnVsbDtPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCdfb3JpZ2luYWxNYXBwaW5ncycse2NvbmZpZ3VyYWJsZTp0cnVlLGVudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24gZ2V0KCl7aWYoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKXt0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLHRoaXMuc291cmNlUm9vdCk7fXJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nczt9fSk7U291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0cixpbmRleCl7dmFyIGM9YVN0ci5jaGFyQXQoaW5kZXgpO3JldHVybiBjPT09XCI7XCJ8fGM9PT1cIixcIjt9Oy8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0cixhU291cmNlUm9vdCl7dGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTt9O1NvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUj0xO1NvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSPTI7U291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQ9MTtTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORD0yOy8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjayxhQ29udGV4dCxhT3JkZXIpe3ZhciBjb250ZXh0PWFDb250ZXh0fHxudWxsO3ZhciBvcmRlcj1hT3JkZXJ8fFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjt2YXIgbWFwcGluZ3M7c3dpdGNoKG9yZGVyKXtjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjptYXBwaW5ncz10aGlzLl9nZW5lcmF0ZWRNYXBwaW5nczticmVhaztjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOm1hcHBpbmdzPXRoaXMuX29yaWdpbmFsTWFwcGluZ3M7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7fXZhciBzb3VyY2VSb290PXRoaXMuc291cmNlUm9vdDttYXBwaW5ncy5tYXAoZnVuY3Rpb24obWFwcGluZyl7dmFyIHNvdXJjZT1tYXBwaW5nLnNvdXJjZT09PW51bGw/bnVsbDp0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtzb3VyY2U9dXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3Qsc291cmNlLHRoaXMuX3NvdXJjZU1hcFVSTCk7cmV0dXJue3NvdXJjZTpzb3VyY2UsZ2VuZXJhdGVkTGluZTptYXBwaW5nLmdlbmVyYXRlZExpbmUsZ2VuZXJhdGVkQ29sdW1uOm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLG9yaWdpbmFsTGluZTptYXBwaW5nLm9yaWdpbmFsTGluZSxvcmlnaW5hbENvbHVtbjptYXBwaW5nLm9yaWdpbmFsQ29sdW1uLG5hbWU6bWFwcGluZy5uYW1lPT09bnVsbD9udWxsOnRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSl9O30sdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssY29udGV4dCk7fTsvKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3I9ZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKXt2YXIgbGluZT11dGlsLmdldEFyZyhhQXJncywnbGluZScpOy8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbi8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbnZhciBuZWVkbGU9e3NvdXJjZTp1dGlsLmdldEFyZyhhQXJncywnc291cmNlJyksb3JpZ2luYWxMaW5lOmxpbmUsb3JpZ2luYWxDb2x1bW46dXRpbC5nZXRBcmcoYUFyZ3MsJ2NvbHVtbicsMCl9O25lZWRsZS5zb3VyY2U9dGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO2lmKG5lZWRsZS5zb3VyY2U8MCl7cmV0dXJuW107fXZhciBtYXBwaW5ncz1bXTt2YXIgaW5kZXg9dGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXCJvcmlnaW5hbExpbmVcIixcIm9yaWdpbmFsQ29sdW1uXCIsdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO2lmKGluZGV4Pj0wKXt2YXIgbWFwcGluZz10aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtpZihhQXJncy5jb2x1bW49PT11bmRlZmluZWQpe3ZhciBvcmlnaW5hbExpbmU9bWFwcGluZy5vcmlnaW5hbExpbmU7Ly8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbi8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4vLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4vLyB0aGUgbGluZSB3ZSBmb3VuZC5cbndoaWxlKG1hcHBpbmcmJm1hcHBpbmcub3JpZ2luYWxMaW5lPT09b3JpZ2luYWxMaW5lKXttYXBwaW5ncy5wdXNoKHtsaW5lOnV0aWwuZ2V0QXJnKG1hcHBpbmcsJ2dlbmVyYXRlZExpbmUnLG51bGwpLGNvbHVtbjp1dGlsLmdldEFyZyhtYXBwaW5nLCdnZW5lcmF0ZWRDb2x1bW4nLG51bGwpLGxhc3RDb2x1bW46dXRpbC5nZXRBcmcobWFwcGluZywnbGFzdEdlbmVyYXRlZENvbHVtbicsbnVsbCl9KTttYXBwaW5nPXRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07fX1lbHNle3ZhciBvcmlnaW5hbENvbHVtbj1tYXBwaW5nLm9yaWdpbmFsQ29sdW1uOy8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4vLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbi8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3Jcbi8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxud2hpbGUobWFwcGluZyYmbWFwcGluZy5vcmlnaW5hbExpbmU9PT1saW5lJiZtYXBwaW5nLm9yaWdpbmFsQ29sdW1uPT1vcmlnaW5hbENvbHVtbil7bWFwcGluZ3MucHVzaCh7bGluZTp1dGlsLmdldEFyZyhtYXBwaW5nLCdnZW5lcmF0ZWRMaW5lJyxudWxsKSxjb2x1bW46dXRpbC5nZXRBcmcobWFwcGluZywnZ2VuZXJhdGVkQ29sdW1uJyxudWxsKSxsYXN0Q29sdW1uOnV0aWwuZ2V0QXJnKG1hcHBpbmcsJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLG51bGwpfSk7bWFwcGluZz10aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO319fXJldHVybiBtYXBwaW5nczt9O2V4cG9ydHMuU291cmNlTWFwQ29uc3VtZXI9U291cmNlTWFwQ29uc3VtZXI7LyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLGFTb3VyY2VNYXBVUkwpe3ZhciBzb3VyY2VNYXA9YVNvdXJjZU1hcDtpZih0eXBlb2YgYVNvdXJjZU1hcD09PSdzdHJpbmcnKXtzb3VyY2VNYXA9dXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO312YXIgdmVyc2lvbj11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3ZlcnNpb24nKTt2YXIgc291cmNlcz11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3NvdXJjZXMnKTsvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4vLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxudmFyIG5hbWVzPXV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwnbmFtZXMnLFtdKTt2YXIgc291cmNlUm9vdD11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3NvdXJjZVJvb3QnLG51bGwpO3ZhciBzb3VyY2VzQ29udGVudD11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3NvdXJjZXNDb250ZW50JyxudWxsKTt2YXIgbWFwcGluZ3M9dXRpbC5nZXRBcmcoc291cmNlTWFwLCdtYXBwaW5ncycpO3ZhciBmaWxlPXV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwnZmlsZScsbnVsbCk7Ly8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4vLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuaWYodmVyc2lvbiE9dGhpcy5fdmVyc2lvbil7dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnK3ZlcnNpb24pO31pZihzb3VyY2VSb290KXtzb3VyY2VSb290PXV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO31zb3VyY2VzPXNvdXJjZXMubWFwKFN0cmluZykvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2Zcbi8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuLm1hcCh1dGlsLm5vcm1hbGl6ZSkvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbi8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbi5tYXAoZnVuY3Rpb24oc291cmNlKXtyZXR1cm4gc291cmNlUm9vdCYmdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpJiZ1dGlsLmlzQWJzb2x1dGUoc291cmNlKT91dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3Qsc291cmNlKTpzb3VyY2U7fSk7Ly8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbi8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbi8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbnRoaXMuX25hbWVzPUFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSx0cnVlKTt0aGlzLl9zb3VyY2VzPUFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLHRydWUpO3RoaXMuX2Fic29sdXRlU291cmNlcz10aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24ocyl7cmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LHMsYVNvdXJjZU1hcFVSTCk7fSk7dGhpcy5zb3VyY2VSb290PXNvdXJjZVJvb3Q7dGhpcy5zb3VyY2VzQ29udGVudD1zb3VyY2VzQ29udGVudDt0aGlzLl9tYXBwaW5ncz1tYXBwaW5nczt0aGlzLl9zb3VyY2VNYXBVUkw9YVNvdXJjZU1hcFVSTDt0aGlzLmZpbGU9ZmlsZTt9QmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyPVNvdXJjZU1hcENvbnN1bWVyOy8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kU291cmNlSW5kZXg9ZnVuY3Rpb24oYVNvdXJjZSl7dmFyIHJlbGF0aXZlU291cmNlPWFTb3VyY2U7aWYodGhpcy5zb3VyY2VSb290IT1udWxsKXtyZWxhdGl2ZVNvdXJjZT11dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCxyZWxhdGl2ZVNvdXJjZSk7fWlmKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSl7cmV0dXJuIHRoaXMuX3NvdXJjZXMuaW5kZXhPZihyZWxhdGl2ZVNvdXJjZSk7fS8vIE1heWJlIGFTb3VyY2UgaXMgYW4gYWJzb2x1dGUgVVJMIGFzIHJldHVybmVkIGJ5IHxzb3VyY2VzfC4gIEluXG4vLyB0aGlzIGNhc2Ugd2UgY2FuJ3Qgc2ltcGx5IHVuZG8gdGhlIHRyYW5zZm9ybS5cbnZhciBpO2ZvcihpPTA7aTx0aGlzLl9hYnNvbHV0ZVNvdXJjZXMubGVuZ3RoOysraSl7aWYodGhpcy5fYWJzb2x1dGVTb3VyY2VzW2ldPT1hU291cmNlKXtyZXR1cm4gaTt9fXJldHVybi0xO307LyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHBhcmFtIFN0cmluZyBhU291cmNlTWFwVVJMXG4gKiAgICAgICAgVGhlIFVSTCBhdCB3aGljaCB0aGUgc291cmNlIG1hcCBjYW4gYmUgZm91bmQgKG9wdGlvbmFsKVxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCxhU291cmNlTWFwVVJMKXt2YXIgc21jPU9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO3ZhciBuYW1lcz1zbWMuX25hbWVzPUFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksdHJ1ZSk7dmFyIHNvdXJjZXM9c21jLl9zb3VyY2VzPUFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSx0cnVlKTtzbWMuc291cmNlUm9vdD1hU291cmNlTWFwLl9zb3VyY2VSb290O3NtYy5zb3VyY2VzQ29udGVudD1hU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksc21jLnNvdXJjZVJvb3QpO3NtYy5maWxlPWFTb3VyY2VNYXAuX2ZpbGU7c21jLl9zb3VyY2VNYXBVUkw9YVNvdXJjZU1hcFVSTDtzbWMuX2Fic29sdXRlU291cmNlcz1zbWMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbihzKXtyZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNtYy5zb3VyY2VSb290LHMsYVNvdXJjZU1hcFVSTCk7fSk7Ly8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2Vcbi8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbi8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cbnZhciBnZW5lcmF0ZWRNYXBwaW5ncz1hU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTt2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzPXNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzPVtdO3ZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncz1zbWMuX19vcmlnaW5hbE1hcHBpbmdzPVtdO2Zvcih2YXIgaT0wLGxlbmd0aD1nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7aTxsZW5ndGg7aSsrKXt2YXIgc3JjTWFwcGluZz1nZW5lcmF0ZWRNYXBwaW5nc1tpXTt2YXIgZGVzdE1hcHBpbmc9bmV3IE1hcHBpbmcoKTtkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lPXNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW49c3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47aWYoc3JjTWFwcGluZy5zb3VyY2Upe2Rlc3RNYXBwaW5nLnNvdXJjZT1zb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO2Rlc3RNYXBwaW5nLm9yaWdpbmFsTGluZT1zcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbj1zcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO2lmKHNyY01hcHBpbmcubmFtZSl7ZGVzdE1hcHBpbmcubmFtZT1uYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7fWRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO31kZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7fXF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO3JldHVybiBzbWM7fTsvKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uPTM7LyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCdzb3VyY2VzJyx7Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMuc2xpY2UoKTt9fSk7LyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9mdW5jdGlvbiBNYXBwaW5nKCl7dGhpcy5nZW5lcmF0ZWRMaW5lPTA7dGhpcy5nZW5lcmF0ZWRDb2x1bW49MDt0aGlzLnNvdXJjZT1udWxsO3RoaXMub3JpZ2luYWxMaW5lPW51bGw7dGhpcy5vcmlnaW5hbENvbHVtbj1udWxsO3RoaXMubmFtZT1udWxsO30vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0cixhU291cmNlUm9vdCl7dmFyIGdlbmVyYXRlZExpbmU9MTt2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW49MDt2YXIgcHJldmlvdXNPcmlnaW5hbExpbmU9MDt2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbj0wO3ZhciBwcmV2aW91c1NvdXJjZT0wO3ZhciBwcmV2aW91c05hbWU9MDt2YXIgbGVuZ3RoPWFTdHIubGVuZ3RoO3ZhciBpbmRleD0wO3ZhciBjYWNoZWRTZWdtZW50cz17fTt2YXIgdGVtcD17fTt2YXIgb3JpZ2luYWxNYXBwaW5ncz1bXTt2YXIgZ2VuZXJhdGVkTWFwcGluZ3M9W107dmFyIG1hcHBpbmcsc3RyLHNlZ21lbnQsZW5kLHZhbHVlO3doaWxlKGluZGV4PGxlbmd0aCl7aWYoYVN0ci5jaGFyQXQoaW5kZXgpPT09JzsnKXtnZW5lcmF0ZWRMaW5lKys7aW5kZXgrKztwcmV2aW91c0dlbmVyYXRlZENvbHVtbj0wO31lbHNlIGlmKGFTdHIuY2hhckF0KGluZGV4KT09PScsJyl7aW5kZXgrKzt9ZWxzZXttYXBwaW5nPW5ldyBNYXBwaW5nKCk7bWFwcGluZy5nZW5lcmF0ZWRMaW5lPWdlbmVyYXRlZExpbmU7Ly8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4vLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbi8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4vLyBzZWdtZW50IGFnYWluLlxuZm9yKGVuZD1pbmRleDtlbmQ8bGVuZ3RoO2VuZCsrKXtpZih0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsZW5kKSl7YnJlYWs7fX1zdHI9YVN0ci5zbGljZShpbmRleCxlbmQpO3NlZ21lbnQ9Y2FjaGVkU2VnbWVudHNbc3RyXTtpZihzZWdtZW50KXtpbmRleCs9c3RyLmxlbmd0aDt9ZWxzZXtzZWdtZW50PVtdO3doaWxlKGluZGV4PGVuZCl7YmFzZTY0VkxRLmRlY29kZShhU3RyLGluZGV4LHRlbXApO3ZhbHVlPXRlbXAudmFsdWU7aW5kZXg9dGVtcC5yZXN0O3NlZ21lbnQucHVzaCh2YWx1ZSk7fWlmKHNlZ21lbnQubGVuZ3RoPT09Mil7dGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO31pZihzZWdtZW50Lmxlbmd0aD09PTMpe3Rocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTt9Y2FjaGVkU2VnbWVudHNbc3RyXT1zZWdtZW50O30vLyBHZW5lcmF0ZWQgY29sdW1uLlxubWFwcGluZy5nZW5lcmF0ZWRDb2x1bW49cHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4rc2VnbWVudFswXTtwcmV2aW91c0dlbmVyYXRlZENvbHVtbj1tYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtpZihzZWdtZW50Lmxlbmd0aD4xKXsvLyBPcmlnaW5hbCBzb3VyY2UuXG5tYXBwaW5nLnNvdXJjZT1wcmV2aW91c1NvdXJjZStzZWdtZW50WzFdO3ByZXZpb3VzU291cmNlKz1zZWdtZW50WzFdOy8vIE9yaWdpbmFsIGxpbmUuXG5tYXBwaW5nLm9yaWdpbmFsTGluZT1wcmV2aW91c09yaWdpbmFsTGluZStzZWdtZW50WzJdO3ByZXZpb3VzT3JpZ2luYWxMaW5lPW1hcHBpbmcub3JpZ2luYWxMaW5lOy8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxubWFwcGluZy5vcmlnaW5hbExpbmUrPTE7Ly8gT3JpZ2luYWwgY29sdW1uLlxubWFwcGluZy5vcmlnaW5hbENvbHVtbj1wcmV2aW91c09yaWdpbmFsQ29sdW1uK3NlZ21lbnRbM107cHJldmlvdXNPcmlnaW5hbENvbHVtbj1tYXBwaW5nLm9yaWdpbmFsQ29sdW1uO2lmKHNlZ21lbnQubGVuZ3RoPjQpey8vIE9yaWdpbmFsIG5hbWUuXG5tYXBwaW5nLm5hbWU9cHJldmlvdXNOYW1lK3NlZ21lbnRbNF07cHJldmlvdXNOYW1lKz1zZWdtZW50WzRdO319Z2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtpZih0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmU9PT0nbnVtYmVyJyl7b3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO319fXF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncyx1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTt0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M9Z2VuZXJhdGVkTWFwcGluZ3M7cXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7dGhpcy5fX29yaWdpbmFsTWFwcGluZ3M9b3JpZ2luYWxNYXBwaW5nczt9Oy8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsYU1hcHBpbmdzLGFMaW5lTmFtZSxhQ29sdW1uTmFtZSxhQ29tcGFyYXRvcixhQmlhcyl7Ly8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbi8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4vLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5pZihhTmVlZGxlW2FMaW5lTmFtZV08PTApe3Rocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICcrYU5lZWRsZVthTGluZU5hbWVdKTt9aWYoYU5lZWRsZVthQ29sdW1uTmFtZV08MCl7dGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnK2FOZWVkbGVbYUNvbHVtbk5hbWVdKTt9cmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSxhTWFwcGluZ3MsYUNvbXBhcmF0b3IsYUJpYXMpO307LyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnM9ZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCl7Zm9yKHZhciBpbmRleD0wO2luZGV4PHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsrK2luZGV4KXt2YXIgbWFwcGluZz10aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07Ly8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4vLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbi8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4vLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbmlmKGluZGV4KzE8dGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKXt2YXIgbmV4dE1hcHBpbmc9dGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXgrMV07aWYobWFwcGluZy5nZW5lcmF0ZWRMaW5lPT09bmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSl7bWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uPW5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbi0xO2NvbnRpbnVlO319Ly8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbm1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbj1JbmZpbml0eTt9fTsvKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3Mpe3ZhciBuZWVkbGU9e2dlbmVyYXRlZExpbmU6dXRpbC5nZXRBcmcoYUFyZ3MsJ2xpbmUnKSxnZW5lcmF0ZWRDb2x1bW46dXRpbC5nZXRBcmcoYUFyZ3MsJ2NvbHVtbicpfTt2YXIgaW5kZXg9dGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFwiZ2VuZXJhdGVkTGluZVwiLFwiZ2VuZXJhdGVkQ29sdW1uXCIsdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCx1dGlsLmdldEFyZyhhQXJncywnYmlhcycsU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpKTtpZihpbmRleD49MCl7dmFyIG1hcHBpbmc9dGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO2lmKG1hcHBpbmcuZ2VuZXJhdGVkTGluZT09PW5lZWRsZS5nZW5lcmF0ZWRMaW5lKXt2YXIgc291cmNlPXV0aWwuZ2V0QXJnKG1hcHBpbmcsJ3NvdXJjZScsbnVsbCk7aWYoc291cmNlIT09bnVsbCl7c291cmNlPXRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtzb3VyY2U9dXRpbC5jb21wdXRlU291cmNlVVJMKHRoaXMuc291cmNlUm9vdCxzb3VyY2UsdGhpcy5fc291cmNlTWFwVVJMKTt9dmFyIG5hbWU9dXRpbC5nZXRBcmcobWFwcGluZywnbmFtZScsbnVsbCk7aWYobmFtZSE9PW51bGwpe25hbWU9dGhpcy5fbmFtZXMuYXQobmFtZSk7fXJldHVybntzb3VyY2U6c291cmNlLGxpbmU6dXRpbC5nZXRBcmcobWFwcGluZywnb3JpZ2luYWxMaW5lJyxudWxsKSxjb2x1bW46dXRpbC5nZXRBcmcobWFwcGluZywnb3JpZ2luYWxDb2x1bW4nLG51bGwpLG5hbWU6bmFtZX07fX1yZXR1cm57c291cmNlOm51bGwsbGluZTpudWxsLGNvbHVtbjpudWxsLG5hbWU6bnVsbH07fTsvKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcz1mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCl7aWYoIXRoaXMuc291cmNlc0NvbnRlbnQpe3JldHVybiBmYWxzZTt9cmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoPj10aGlzLl9zb3VyY2VzLnNpemUoKSYmIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbihzYyl7cmV0dXJuIHNjPT1udWxsO30pO307LyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3I9ZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLG51bGxPbk1pc3Npbmcpe2lmKCF0aGlzLnNvdXJjZXNDb250ZW50KXtyZXR1cm4gbnVsbDt9dmFyIGluZGV4PXRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtpZihpbmRleD49MCl7cmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO312YXIgcmVsYXRpdmVTb3VyY2U9YVNvdXJjZTtpZih0aGlzLnNvdXJjZVJvb3QhPW51bGwpe3JlbGF0aXZlU291cmNlPXV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LHJlbGF0aXZlU291cmNlKTt9dmFyIHVybDtpZih0aGlzLnNvdXJjZVJvb3QhPW51bGwmJih1cmw9dXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSl7Ly8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3Jcbi8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4vLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbi8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbnZhciBmaWxlVXJpQWJzUGF0aD1yZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLFwiXCIpO2lmKHVybC5zY2hlbWU9PVwiZmlsZVwiJiZ0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpe3JldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldO31pZigoIXVybC5wYXRofHx1cmwucGF0aD09XCIvXCIpJiZ0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIityZWxhdGl2ZVNvdXJjZSkpe3JldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIityZWxhdGl2ZVNvdXJjZSldO319Ly8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbi8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbi8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG5pZihudWxsT25NaXNzaW5nKXtyZXR1cm4gbnVsbDt9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoJ1wiJytyZWxhdGl2ZVNvdXJjZSsnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7fX07LyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL0Jhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yPWZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKXt2YXIgc291cmNlPXV0aWwuZ2V0QXJnKGFBcmdzLCdzb3VyY2UnKTtzb3VyY2U9dGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7aWYoc291cmNlPDApe3JldHVybntsaW5lOm51bGwsY29sdW1uOm51bGwsbGFzdENvbHVtbjpudWxsfTt9dmFyIG5lZWRsZT17c291cmNlOnNvdXJjZSxvcmlnaW5hbExpbmU6dXRpbC5nZXRBcmcoYUFyZ3MsJ2xpbmUnKSxvcmlnaW5hbENvbHVtbjp1dGlsLmdldEFyZyhhQXJncywnY29sdW1uJyl9O3ZhciBpbmRleD10aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcIm9yaWdpbmFsTGluZVwiLFwib3JpZ2luYWxDb2x1bW5cIix1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLHV0aWwuZ2V0QXJnKGFBcmdzLCdiaWFzJyxTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCkpO2lmKGluZGV4Pj0wKXt2YXIgbWFwcGluZz10aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtpZihtYXBwaW5nLnNvdXJjZT09PW5lZWRsZS5zb3VyY2Upe3JldHVybntsaW5lOnV0aWwuZ2V0QXJnKG1hcHBpbmcsJ2dlbmVyYXRlZExpbmUnLG51bGwpLGNvbHVtbjp1dGlsLmdldEFyZyhtYXBwaW5nLCdnZW5lcmF0ZWRDb2x1bW4nLG51bGwpLGxhc3RDb2x1bW46dXRpbC5nZXRBcmcobWFwcGluZywnbGFzdEdlbmVyYXRlZENvbHVtbicsbnVsbCl9O319cmV0dXJue2xpbmU6bnVsbCxjb2x1bW46bnVsbCxsYXN0Q29sdW1uOm51bGx9O307ZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyPUJhc2ljU291cmNlTWFwQ29uc3VtZXI7LyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsYVNvdXJjZU1hcFVSTCl7dmFyIHNvdXJjZU1hcD1hU291cmNlTWFwO2lmKHR5cGVvZiBhU291cmNlTWFwPT09J3N0cmluZycpe3NvdXJjZU1hcD11dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7fXZhciB2ZXJzaW9uPXV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwndmVyc2lvbicpO3ZhciBzZWN0aW9ucz11dGlsLmdldEFyZyhzb3VyY2VNYXAsJ3NlY3Rpb25zJyk7aWYodmVyc2lvbiE9dGhpcy5fdmVyc2lvbil7dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnK3ZlcnNpb24pO310aGlzLl9zb3VyY2VzPW5ldyBBcnJheVNldCgpO3RoaXMuX25hbWVzPW5ldyBBcnJheVNldCgpO3ZhciBsYXN0T2Zmc2V0PXtsaW5lOi0xLGNvbHVtbjowfTt0aGlzLl9zZWN0aW9ucz1zZWN0aW9ucy5tYXAoZnVuY3Rpb24ocyl7aWYocy51cmwpey8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG50aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7fXZhciBvZmZzZXQ9dXRpbC5nZXRBcmcocywnb2Zmc2V0Jyk7dmFyIG9mZnNldExpbmU9dXRpbC5nZXRBcmcob2Zmc2V0LCdsaW5lJyk7dmFyIG9mZnNldENvbHVtbj11dGlsLmdldEFyZyhvZmZzZXQsJ2NvbHVtbicpO2lmKG9mZnNldExpbmU8bGFzdE9mZnNldC5saW5lfHxvZmZzZXRMaW5lPT09bGFzdE9mZnNldC5saW5lJiZvZmZzZXRDb2x1bW48bGFzdE9mZnNldC5jb2x1bW4pe3Rocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO31sYXN0T2Zmc2V0PW9mZnNldDtyZXR1cm57Z2VuZXJhdGVkT2Zmc2V0OnsvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG5nZW5lcmF0ZWRMaW5lOm9mZnNldExpbmUrMSxnZW5lcmF0ZWRDb2x1bW46b2Zmc2V0Q29sdW1uKzF9LGNvbnN1bWVyOm5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCdtYXAnKSxhU291cmNlTWFwVVJMKX07fSk7fUluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO0luZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3I9U291cmNlTWFwQ29uc3VtZXI7LyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uPTM7LyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsJ3NvdXJjZXMnLHtnZXQ6ZnVuY3Rpb24gZ2V0KCl7dmFyIHNvdXJjZXM9W107Zm9yKHZhciBpPTA7aTx0aGlzLl9zZWN0aW9ucy5sZW5ndGg7aSsrKXtmb3IodmFyIGo9MDtqPHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoO2orKyl7c291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO319cmV0dXJuIHNvdXJjZXM7fX0pOy8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL0luZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvcj1mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncyl7dmFyIG5lZWRsZT17Z2VuZXJhdGVkTGluZTp1dGlsLmdldEFyZyhhQXJncywnbGluZScpLGdlbmVyYXRlZENvbHVtbjp1dGlsLmdldEFyZyhhQXJncywnY29sdW1uJyl9Oy8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbi8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxudmFyIHNlY3Rpb25JbmRleD1iaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSx0aGlzLl9zZWN0aW9ucyxmdW5jdGlvbihuZWVkbGUsc2VjdGlvbil7dmFyIGNtcD1uZWVkbGUuZ2VuZXJhdGVkTGluZS1zZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO2lmKGNtcCl7cmV0dXJuIGNtcDt9cmV0dXJuIG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4tc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uO30pO3ZhciBzZWN0aW9uPXRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07aWYoIXNlY3Rpb24pe3JldHVybntzb3VyY2U6bnVsbCxsaW5lOm51bGwsY29sdW1uOm51bGwsbmFtZTpudWxsfTt9cmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7bGluZTpuZWVkbGUuZ2VuZXJhdGVkTGluZS0oc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZS0xKSxjb2x1bW46bmVlZGxlLmdlbmVyYXRlZENvbHVtbi0oc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZT09PW5lZWRsZS5nZW5lcmF0ZWRMaW5lP3NlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbi0xOjApLGJpYXM6YUFyZ3MuYmlhc30pO307LyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcz1mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKXtyZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24ocyl7cmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTt9KTt9Oy8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3I9ZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSxudWxsT25NaXNzaW5nKXtmb3IodmFyIGk9MDtpPHRoaXMuX3NlY3Rpb25zLmxlbmd0aDtpKyspe3ZhciBzZWN0aW9uPXRoaXMuX3NlY3Rpb25zW2ldO3ZhciBjb250ZW50PXNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLHRydWUpO2lmKGNvbnRlbnQpe3JldHVybiBjb250ZW50O319aWYobnVsbE9uTWlzc2luZyl7cmV0dXJuIG51bGw7fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdcIicrYVNvdXJjZSsnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7fX07LyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLiBcbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yPWZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyl7Zm9yKHZhciBpPTA7aTx0aGlzLl9zZWN0aW9ucy5sZW5ndGg7aSsrKXt2YXIgc2VjdGlvbj10aGlzLl9zZWN0aW9uc1tpXTsvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG5pZihzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsJ3NvdXJjZScpKT09PS0xKXtjb250aW51ZTt9dmFyIGdlbmVyYXRlZFBvc2l0aW9uPXNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO2lmKGdlbmVyYXRlZFBvc2l0aW9uKXt2YXIgcmV0PXtsaW5lOmdlbmVyYXRlZFBvc2l0aW9uLmxpbmUrKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUtMSksY29sdW1uOmdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbisoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZT09PWdlbmVyYXRlZFBvc2l0aW9uLmxpbmU/c2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uLTE6MCl9O3JldHVybiByZXQ7fX1yZXR1cm57bGluZTpudWxsLGNvbHVtbjpudWxsfTt9Oy8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncz1mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLGFTb3VyY2VSb290KXt0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M9W107dGhpcy5fX29yaWdpbmFsTWFwcGluZ3M9W107Zm9yKHZhciBpPTA7aTx0aGlzLl9zZWN0aW9ucy5sZW5ndGg7aSsrKXt2YXIgc2VjdGlvbj10aGlzLl9zZWN0aW9uc1tpXTt2YXIgc2VjdGlvbk1hcHBpbmdzPXNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO2Zvcih2YXIgaj0wO2o8c2VjdGlvbk1hcHBpbmdzLmxlbmd0aDtqKyspe3ZhciBtYXBwaW5nPXNlY3Rpb25NYXBwaW5nc1tqXTt2YXIgc291cmNlPXNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO3NvdXJjZT11dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LHNvdXJjZSx0aGlzLl9zb3VyY2VNYXBVUkwpO3RoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7c291cmNlPXRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO3ZhciBuYW1lPW51bGw7aWYobWFwcGluZy5uYW1lKXtuYW1lPXNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7dGhpcy5fbmFtZXMuYWRkKG5hbWUpO25hbWU9dGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTt9Ly8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4vLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4vLyBnZW5lcmF0ZWQgZmlsZS5cbnZhciBhZGp1c3RlZE1hcHBpbmc9e3NvdXJjZTpzb3VyY2UsZ2VuZXJhdGVkTGluZTptYXBwaW5nLmdlbmVyYXRlZExpbmUrKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUtMSksZ2VuZXJhdGVkQ29sdW1uOm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKyhzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lPT09bWFwcGluZy5nZW5lcmF0ZWRMaW5lP3NlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbi0xOjApLG9yaWdpbmFsTGluZTptYXBwaW5nLm9yaWdpbmFsTGluZSxvcmlnaW5hbENvbHVtbjptYXBwaW5nLm9yaWdpbmFsQ29sdW1uLG5hbWU6bmFtZX07dGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtpZih0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZT09PSdudW1iZXInKXt0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7fX19cXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyx1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7fTtleHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcj1JbmRleGVkU291cmNlTWFwQ29uc3VtZXI7fSx7XCIuL2FycmF5LXNldFwiOjY4LFwiLi9iYXNlNjQtdmxxXCI6NjksXCIuL2JpbmFyeS1zZWFyY2hcIjo3MSxcIi4vcXVpY2stc29ydFwiOjczLFwiLi91dGlsXCI6Nzd9XSw3NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovdmFyIGJhc2U2NFZMUT1yZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTt2YXIgdXRpbD1yZXF1aXJlKCcuL3V0aWwnKTt2YXIgQXJyYXlTZXQ9cmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDt2YXIgTWFwcGluZ0xpc3Q9cmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDsvKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3Mpe2lmKCFhQXJncyl7YUFyZ3M9e307fXRoaXMuX2ZpbGU9dXRpbC5nZXRBcmcoYUFyZ3MsJ2ZpbGUnLG51bGwpO3RoaXMuX3NvdXJjZVJvb3Q9dXRpbC5nZXRBcmcoYUFyZ3MsJ3NvdXJjZVJvb3QnLG51bGwpO3RoaXMuX3NraXBWYWxpZGF0aW9uPXV0aWwuZ2V0QXJnKGFBcmdzLCdza2lwVmFsaWRhdGlvbicsZmFsc2UpO3RoaXMuX3NvdXJjZXM9bmV3IEFycmF5U2V0KCk7dGhpcy5fbmFtZXM9bmV3IEFycmF5U2V0KCk7dGhpcy5fbWFwcGluZ3M9bmV3IE1hcHBpbmdMaXN0KCk7dGhpcy5fc291cmNlc0NvbnRlbnRzPW51bGw7fVNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb249MzsvKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcD1mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpe3ZhciBzb3VyY2VSb290PWFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O3ZhciBnZW5lcmF0b3I9bmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7ZmlsZTphU291cmNlTWFwQ29uc3VtZXIuZmlsZSxzb3VyY2VSb290OnNvdXJjZVJvb3R9KTthU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24obWFwcGluZyl7dmFyIG5ld01hcHBpbmc9e2dlbmVyYXRlZDp7bGluZTptYXBwaW5nLmdlbmVyYXRlZExpbmUsY29sdW1uOm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1ufX07aWYobWFwcGluZy5zb3VyY2UhPW51bGwpe25ld01hcHBpbmcuc291cmNlPW1hcHBpbmcuc291cmNlO2lmKHNvdXJjZVJvb3QhPW51bGwpe25ld01hcHBpbmcuc291cmNlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxuZXdNYXBwaW5nLnNvdXJjZSk7fW5ld01hcHBpbmcub3JpZ2luYWw9e2xpbmU6bWFwcGluZy5vcmlnaW5hbExpbmUsY29sdW1uOm1hcHBpbmcub3JpZ2luYWxDb2x1bW59O2lmKG1hcHBpbmcubmFtZSE9bnVsbCl7bmV3TWFwcGluZy5uYW1lPW1hcHBpbmcubmFtZTt9fWdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO30pO2FTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlRmlsZSl7dmFyIHNvdXJjZVJlbGF0aXZlPXNvdXJjZUZpbGU7aWYoc291cmNlUm9vdCE9PW51bGwpe3NvdXJjZVJlbGF0aXZlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxzb3VyY2VGaWxlKTt9aWYoIWdlbmVyYXRvci5fc291cmNlcy5oYXMoc291cmNlUmVsYXRpdmUpKXtnZW5lcmF0b3IuX3NvdXJjZXMuYWRkKHNvdXJjZVJlbGF0aXZlKTt9dmFyIGNvbnRlbnQ9YVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7aWYoY29udGVudCE9bnVsbCl7Z2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSxjb250ZW50KTt9fSk7cmV0dXJuIGdlbmVyYXRvcjt9Oy8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmc9ZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3Mpe3ZhciBnZW5lcmF0ZWQ9dXRpbC5nZXRBcmcoYUFyZ3MsJ2dlbmVyYXRlZCcpO3ZhciBvcmlnaW5hbD11dGlsLmdldEFyZyhhQXJncywnb3JpZ2luYWwnLG51bGwpO3ZhciBzb3VyY2U9dXRpbC5nZXRBcmcoYUFyZ3MsJ3NvdXJjZScsbnVsbCk7dmFyIG5hbWU9dXRpbC5nZXRBcmcoYUFyZ3MsJ25hbWUnLG51bGwpO2lmKCF0aGlzLl9za2lwVmFsaWRhdGlvbil7dGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCxvcmlnaW5hbCxzb3VyY2UsbmFtZSk7fWlmKHNvdXJjZSE9bnVsbCl7c291cmNlPVN0cmluZyhzb3VyY2UpO2lmKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKXt0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO319aWYobmFtZSE9bnVsbCl7bmFtZT1TdHJpbmcobmFtZSk7aWYoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSl7dGhpcy5fbmFtZXMuYWRkKG5hbWUpO319dGhpcy5fbWFwcGluZ3MuYWRkKHtnZW5lcmF0ZWRMaW5lOmdlbmVyYXRlZC5saW5lLGdlbmVyYXRlZENvbHVtbjpnZW5lcmF0ZWQuY29sdW1uLG9yaWdpbmFsTGluZTpvcmlnaW5hbCE9bnVsbCYmb3JpZ2luYWwubGluZSxvcmlnaW5hbENvbHVtbjpvcmlnaW5hbCE9bnVsbCYmb3JpZ2luYWwuY29sdW1uLHNvdXJjZTpzb3VyY2UsbmFtZTpuYW1lfSk7fTsvKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQ9ZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsYVNvdXJjZUNvbnRlbnQpe3ZhciBzb3VyY2U9YVNvdXJjZUZpbGU7aWYodGhpcy5fc291cmNlUm9vdCE9bnVsbCl7c291cmNlPXV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCxzb3VyY2UpO31pZihhU291cmNlQ29udGVudCE9bnVsbCl7Ly8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4vLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG5pZighdGhpcy5fc291cmNlc0NvbnRlbnRzKXt0aGlzLl9zb3VyY2VzQ29udGVudHM9T2JqZWN0LmNyZWF0ZShudWxsKTt9dGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV09YVNvdXJjZUNvbnRlbnQ7fWVsc2UgaWYodGhpcy5fc291cmNlc0NvbnRlbnRzKXsvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG5kZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07aWYoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGg9PT0wKXt0aGlzLl9zb3VyY2VzQ29udGVudHM9bnVsbDt9fX07LyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsYVNvdXJjZUZpbGUsYVNvdXJjZU1hcFBhdGgpe3ZhciBzb3VyY2VGaWxlPWFTb3VyY2VGaWxlOy8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbmlmKGFTb3VyY2VGaWxlPT1udWxsKXtpZihhU291cmNlTWFwQ29uc3VtZXIuZmlsZT09bnVsbCl7dGhyb3cgbmV3IEVycm9yKCdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJysnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nKTt9c291cmNlRmlsZT1hU291cmNlTWFwQ29uc3VtZXIuZmlsZTt9dmFyIHNvdXJjZVJvb3Q9dGhpcy5fc291cmNlUm9vdDsvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG5pZihzb3VyY2VSb290IT1udWxsKXtzb3VyY2VGaWxlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxzb3VyY2VGaWxlKTt9Ly8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbi8vIHRoZSBuYW1lcyBhcnJheS5cbnZhciBuZXdTb3VyY2VzPW5ldyBBcnJheVNldCgpO3ZhciBuZXdOYW1lcz1uZXcgQXJyYXlTZXQoKTsvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbnRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbihtYXBwaW5nKXtpZihtYXBwaW5nLnNvdXJjZT09PXNvdXJjZUZpbGUmJm1hcHBpbmcub3JpZ2luYWxMaW5lIT1udWxsKXsvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbnZhciBvcmlnaW5hbD1hU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7bGluZTptYXBwaW5nLm9yaWdpbmFsTGluZSxjb2x1bW46bWFwcGluZy5vcmlnaW5hbENvbHVtbn0pO2lmKG9yaWdpbmFsLnNvdXJjZSE9bnVsbCl7Ly8gQ29weSBtYXBwaW5nXG5tYXBwaW5nLnNvdXJjZT1vcmlnaW5hbC5zb3VyY2U7aWYoYVNvdXJjZU1hcFBhdGghPW51bGwpe21hcHBpbmcuc291cmNlPXV0aWwuam9pbihhU291cmNlTWFwUGF0aCxtYXBwaW5nLnNvdXJjZSk7fWlmKHNvdXJjZVJvb3QhPW51bGwpe21hcHBpbmcuc291cmNlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxtYXBwaW5nLnNvdXJjZSk7fW1hcHBpbmcub3JpZ2luYWxMaW5lPW9yaWdpbmFsLmxpbmU7bWFwcGluZy5vcmlnaW5hbENvbHVtbj1vcmlnaW5hbC5jb2x1bW47aWYob3JpZ2luYWwubmFtZSE9bnVsbCl7bWFwcGluZy5uYW1lPW9yaWdpbmFsLm5hbWU7fX19dmFyIHNvdXJjZT1tYXBwaW5nLnNvdXJjZTtpZihzb3VyY2UhPW51bGwmJiFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKXtuZXdTb3VyY2VzLmFkZChzb3VyY2UpO312YXIgbmFtZT1tYXBwaW5nLm5hbWU7aWYobmFtZSE9bnVsbCYmIW5ld05hbWVzLmhhcyhuYW1lKSl7bmV3TmFtZXMuYWRkKG5hbWUpO319LHRoaXMpO3RoaXMuX3NvdXJjZXM9bmV3U291cmNlczt0aGlzLl9uYW1lcz1uZXdOYW1lczsvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbmFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlRmlsZSl7dmFyIGNvbnRlbnQ9YVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7aWYoY29udGVudCE9bnVsbCl7aWYoYVNvdXJjZU1hcFBhdGghPW51bGwpe3NvdXJjZUZpbGU9dXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLHNvdXJjZUZpbGUpO31pZihzb3VyY2VSb290IT1udWxsKXtzb3VyY2VGaWxlPXV0aWwucmVsYXRpdmUoc291cmNlUm9vdCxzb3VyY2VGaWxlKTt9dGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsY29udGVudCk7fX0sdGhpcyk7fTsvKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCxhT3JpZ2luYWwsYVNvdXJjZSxhTmFtZSl7Ly8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbi8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuLy8gc3BlY2lmaWMgZXJyb3IgbWVzc2FnZSB0byB0cnkgdG8gZ3VpZGUgdGhlbSB0aGUgcmlnaHQgd2F5LlxuLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuaWYoYU9yaWdpbmFsJiZ0eXBlb2YgYU9yaWdpbmFsLmxpbmUhPT0nbnVtYmVyJyYmdHlwZW9mIGFPcmlnaW5hbC5jb2x1bW4hPT0nbnVtYmVyJyl7dGhyb3cgbmV3IEVycm9yKCdvcmlnaW5hbC5saW5lIGFuZCBvcmlnaW5hbC5jb2x1bW4gYXJlIG5vdCBudW1iZXJzIC0tIHlvdSBwcm9iYWJseSBtZWFudCB0byBvbWl0ICcrJ3RoZSBvcmlnaW5hbCBtYXBwaW5nIGVudGlyZWx5IGFuZCBvbmx5IG1hcCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLiBJZiBzbywgcGFzcyAnKydudWxsIGZvciB0aGUgb3JpZ2luYWwgbWFwcGluZyBpbnN0ZWFkIG9mIGFuIG9iamVjdCB3aXRoIGVtcHR5IG9yIG51bGwgdmFsdWVzLicpO31pZihhR2VuZXJhdGVkJiYnbGluZSdpbiBhR2VuZXJhdGVkJiYnY29sdW1uJ2luIGFHZW5lcmF0ZWQmJmFHZW5lcmF0ZWQubGluZT4wJiZhR2VuZXJhdGVkLmNvbHVtbj49MCYmIWFPcmlnaW5hbCYmIWFTb3VyY2UmJiFhTmFtZSl7Ly8gQ2FzZSAxLlxucmV0dXJuO31lbHNlIGlmKGFHZW5lcmF0ZWQmJidsaW5lJ2luIGFHZW5lcmF0ZWQmJidjb2x1bW4naW4gYUdlbmVyYXRlZCYmYU9yaWdpbmFsJiYnbGluZSdpbiBhT3JpZ2luYWwmJidjb2x1bW4naW4gYU9yaWdpbmFsJiZhR2VuZXJhdGVkLmxpbmU+MCYmYUdlbmVyYXRlZC5jb2x1bW4+PTAmJmFPcmlnaW5hbC5saW5lPjAmJmFPcmlnaW5hbC5jb2x1bW4+PTAmJmFTb3VyY2Upey8vIENhc2VzIDIgYW5kIDMuXG5yZXR1cm47fWVsc2V7dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcrSlNPTi5zdHJpbmdpZnkoe2dlbmVyYXRlZDphR2VuZXJhdGVkLHNvdXJjZTphU291cmNlLG9yaWdpbmFsOmFPcmlnaW5hbCxuYW1lOmFOYW1lfSkpO319Oy8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpe3ZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbj0wO3ZhciBwcmV2aW91c0dlbmVyYXRlZExpbmU9MTt2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbj0wO3ZhciBwcmV2aW91c09yaWdpbmFsTGluZT0wO3ZhciBwcmV2aW91c05hbWU9MDt2YXIgcHJldmlvdXNTb3VyY2U9MDt2YXIgcmVzdWx0PScnO3ZhciBuZXh0O3ZhciBtYXBwaW5nO3ZhciBuYW1lSWR4O3ZhciBzb3VyY2VJZHg7dmFyIG1hcHBpbmdzPXRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtmb3IodmFyIGk9MCxsZW49bWFwcGluZ3MubGVuZ3RoO2k8bGVuO2krKyl7bWFwcGluZz1tYXBwaW5nc1tpXTtuZXh0PScnO2lmKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSE9PXByZXZpb3VzR2VuZXJhdGVkTGluZSl7cHJldmlvdXNHZW5lcmF0ZWRDb2x1bW49MDt3aGlsZShtYXBwaW5nLmdlbmVyYXRlZExpbmUhPT1wcmV2aW91c0dlbmVyYXRlZExpbmUpe25leHQrPSc7JztwcmV2aW91c0dlbmVyYXRlZExpbmUrKzt9fWVsc2V7aWYoaT4wKXtpZighdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLG1hcHBpbmdzW2ktMV0pKXtjb250aW51ZTt9bmV4dCs9JywnO319bmV4dCs9YmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtbi1wcmV2aW91c0dlbmVyYXRlZENvbHVtbik7cHJldmlvdXNHZW5lcmF0ZWRDb2x1bW49bWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47aWYobWFwcGluZy5zb3VyY2UhPW51bGwpe3NvdXJjZUlkeD10aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO25leHQrPWJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4LXByZXZpb3VzU291cmNlKTtwcmV2aW91c1NvdXJjZT1zb3VyY2VJZHg7Ly8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xubmV4dCs9YmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZS0xLXByZXZpb3VzT3JpZ2luYWxMaW5lKTtwcmV2aW91c09yaWdpbmFsTGluZT1tYXBwaW5nLm9yaWdpbmFsTGluZS0xO25leHQrPWJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtbi1wcmV2aW91c09yaWdpbmFsQ29sdW1uKTtwcmV2aW91c09yaWdpbmFsQ29sdW1uPW1hcHBpbmcub3JpZ2luYWxDb2x1bW47aWYobWFwcGluZy5uYW1lIT1udWxsKXtuYW1lSWR4PXRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtuZXh0Kz1iYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHgtcHJldmlvdXNOYW1lKTtwcmV2aW91c05hbWU9bmFtZUlkeDt9fXJlc3VsdCs9bmV4dDt9cmV0dXJuIHJlc3VsdDt9O1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQ9ZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsYVNvdXJjZVJvb3Qpe3JldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24oc291cmNlKXtpZighdGhpcy5fc291cmNlc0NvbnRlbnRzKXtyZXR1cm4gbnVsbDt9aWYoYVNvdXJjZVJvb3QhPW51bGwpe3NvdXJjZT11dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LHNvdXJjZSk7fXZhciBrZXk9dXRpbC50b1NldFN0cmluZyhzb3VyY2UpO3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLGtleSk/dGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV06bnVsbDt9LHRoaXMpO307LyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKXt2YXIgbWFwPXt2ZXJzaW9uOnRoaXMuX3ZlcnNpb24sc291cmNlczp0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxuYW1lczp0aGlzLl9uYW1lcy50b0FycmF5KCksbWFwcGluZ3M6dGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKX07aWYodGhpcy5fZmlsZSE9bnVsbCl7bWFwLmZpbGU9dGhpcy5fZmlsZTt9aWYodGhpcy5fc291cmNlUm9vdCE9bnVsbCl7bWFwLnNvdXJjZVJvb3Q9dGhpcy5fc291cmNlUm9vdDt9aWYodGhpcy5fc291cmNlc0NvbnRlbnRzKXttYXAuc291cmNlc0NvbnRlbnQ9dGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcyxtYXAuc291cmNlUm9vdCk7fXJldHVybiBtYXA7fTsvKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpe3JldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTt9O2V4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yPVNvdXJjZU1hcEdlbmVyYXRvcjt9LHtcIi4vYXJyYXktc2V0XCI6NjgsXCIuL2Jhc2U2NC12bHFcIjo2OSxcIi4vbWFwcGluZy1saXN0XCI6NzIsXCIuL3V0aWxcIjo3N31dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovIC8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi92YXIgU291cmNlTWFwR2VuZXJhdG9yPXJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7dmFyIHV0aWw9cmVxdWlyZSgnLi91dGlsJyk7Ly8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FPS8oXFxyP1xcbikvOy8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERT0xMDsvLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlPVwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7LyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLGFDb2x1bW4sYVNvdXJjZSxhQ2h1bmtzLGFOYW1lKXt0aGlzLmNoaWxkcmVuPVtdO3RoaXMuc291cmNlQ29udGVudHM9e307dGhpcy5saW5lPWFMaW5lPT1udWxsP251bGw6YUxpbmU7dGhpcy5jb2x1bW49YUNvbHVtbj09bnVsbD9udWxsOmFDb2x1bW47dGhpcy5zb3VyY2U9YVNvdXJjZT09bnVsbD9udWxsOmFTb3VyY2U7dGhpcy5uYW1lPWFOYW1lPT1udWxsP251bGw6YU5hbWU7dGhpc1tpc1NvdXJjZU5vZGVdPXRydWU7aWYoYUNodW5rcyE9bnVsbCl0aGlzLmFkZChhQ2h1bmtzKTt9LyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1NvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXA9ZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSxhU291cmNlTWFwQ29uc3VtZXIsYVJlbGF0aXZlUGF0aCl7Ly8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4vLyBhbmQgdGhlIFNvdXJjZU1hcFxudmFyIG5vZGU9bmV3IFNvdXJjZU5vZGUoKTsvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4vLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4vLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSBhY2Nlc3NlZCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbnZhciByZW1haW5pbmdMaW5lcz1hR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTt2YXIgcmVtYWluaW5nTGluZXNJbmRleD0wO3ZhciBzaGlmdE5leHRMaW5lPWZ1bmN0aW9uIHNoaWZ0TmV4dExpbmUoKXt2YXIgbGluZUNvbnRlbnRzPWdldE5leHRMaW5lKCk7Ly8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxudmFyIG5ld0xpbmU9Z2V0TmV4dExpbmUoKXx8XCJcIjtyZXR1cm4gbGluZUNvbnRlbnRzK25ld0xpbmU7ZnVuY3Rpb24gZ2V0TmV4dExpbmUoKXtyZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleDxyZW1haW5pbmdMaW5lcy5sZW5ndGg/cmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleCsrXTp1bmRlZmluZWQ7fX07Ly8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG52YXIgbGFzdEdlbmVyYXRlZExpbmU9MSxsYXN0R2VuZXJhdGVkQ29sdW1uPTA7Ly8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbi8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbnZhciBsYXN0TWFwcGluZz1udWxsO2FTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbihtYXBwaW5nKXtpZihsYXN0TWFwcGluZyE9PW51bGwpey8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbi8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbmlmKGxhc3RHZW5lcmF0ZWRMaW5lPG1hcHBpbmcuZ2VuZXJhdGVkTGluZSl7Ly8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbmFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZyxzaGlmdE5leHRMaW5lKCkpO2xhc3RHZW5lcmF0ZWRMaW5lKys7bGFzdEdlbmVyYXRlZENvbHVtbj0wOy8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbn1lbHNley8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4vLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbi8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxudmFyIG5leHRMaW5lPXJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdfHwnJzt2YXIgY29kZT1uZXh0TGluZS5zdWJzdHIoMCxtYXBwaW5nLmdlbmVyYXRlZENvbHVtbi1sYXN0R2VuZXJhdGVkQ29sdW1uKTtyZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XT1uZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4tbGFzdEdlbmVyYXRlZENvbHVtbik7bGFzdEdlbmVyYXRlZENvbHVtbj1tYXBwaW5nLmdlbmVyYXRlZENvbHVtbjthZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsY29kZSk7Ly8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbmxhc3RNYXBwaW5nPW1hcHBpbmc7cmV0dXJuO319Ly8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbi8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG53aGlsZShsYXN0R2VuZXJhdGVkTGluZTxtYXBwaW5nLmdlbmVyYXRlZExpbmUpe25vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7bGFzdEdlbmVyYXRlZExpbmUrKzt9aWYobGFzdEdlbmVyYXRlZENvbHVtbjxtYXBwaW5nLmdlbmVyYXRlZENvbHVtbil7dmFyIG5leHRMaW5lPXJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdfHwnJztub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCxtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO3JlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdPW5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7bGFzdEdlbmVyYXRlZENvbHVtbj1tYXBwaW5nLmdlbmVyYXRlZENvbHVtbjt9bGFzdE1hcHBpbmc9bWFwcGluZzt9LHRoaXMpOy8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbmlmKHJlbWFpbmluZ0xpbmVzSW5kZXg8cmVtYWluaW5nTGluZXMubGVuZ3RoKXtpZihsYXN0TWFwcGluZyl7Ly8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG5hZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsc2hpZnROZXh0TGluZSgpKTt9Ly8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbm5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNwbGljZShyZW1haW5pbmdMaW5lc0luZGV4KS5qb2luKFwiXCIpKTt9Ly8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbmFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlRmlsZSl7dmFyIGNvbnRlbnQ9YVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7aWYoY29udGVudCE9bnVsbCl7aWYoYVJlbGF0aXZlUGF0aCE9bnVsbCl7c291cmNlRmlsZT11dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCxzb3VyY2VGaWxlKTt9bm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsY29udGVudCk7fX0pO3JldHVybiBub2RlO2Z1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLGNvZGUpe2lmKG1hcHBpbmc9PT1udWxsfHxtYXBwaW5nLnNvdXJjZT09PXVuZGVmaW5lZCl7bm9kZS5hZGQoY29kZSk7fWVsc2V7dmFyIHNvdXJjZT1hUmVsYXRpdmVQYXRoP3V0aWwuam9pbihhUmVsYXRpdmVQYXRoLG1hcHBpbmcuc291cmNlKTptYXBwaW5nLnNvdXJjZTtub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLHNvdXJjZSxjb2RlLG1hcHBpbmcubmFtZSkpO319fTsvKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9Tb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKXtpZihBcnJheS5pc0FycmF5KGFDaHVuaykpe2FDaHVuay5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKXt0aGlzLmFkZChjaHVuayk7fSx0aGlzKTt9ZWxzZSBpZihhQ2h1bmtbaXNTb3VyY2VOb2RlXXx8dHlwZW9mIGFDaHVuaz09PVwic3RyaW5nXCIpe2lmKGFDaHVuayl7dGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7fX1lbHNle3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIithQ2h1bmspO31yZXR1cm4gdGhpczt9Oy8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZD1mdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKXtpZihBcnJheS5pc0FycmF5KGFDaHVuaykpe2Zvcih2YXIgaT1hQ2h1bmsubGVuZ3RoLTE7aT49MDtpLS0pe3RoaXMucHJlcGVuZChhQ2h1bmtbaV0pO319ZWxzZSBpZihhQ2h1bmtbaXNTb3VyY2VOb2RlXXx8dHlwZW9mIGFDaHVuaz09PVwic3RyaW5nXCIpe3RoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO31lbHNle3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIithQ2h1bmspO31yZXR1cm4gdGhpczt9Oy8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrPWZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pe3ZhciBjaHVuaztmb3IodmFyIGk9MCxsZW49dGhpcy5jaGlsZHJlbi5sZW5ndGg7aTxsZW47aSsrKXtjaHVuaz10aGlzLmNoaWxkcmVuW2ldO2lmKGNodW5rW2lzU291cmNlTm9kZV0pe2NodW5rLndhbGsoYUZuKTt9ZWxzZXtpZihjaHVuayE9PScnKXthRm4oY2h1bmsse3NvdXJjZTp0aGlzLnNvdXJjZSxsaW5lOnRoaXMubGluZSxjb2x1bW46dGhpcy5jb2x1bW4sbmFtZTp0aGlzLm5hbWV9KTt9fX19Oy8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovU291cmNlTm9kZS5wcm90b3R5cGUuam9pbj1mdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCl7dmFyIG5ld0NoaWxkcmVuO3ZhciBpO3ZhciBsZW49dGhpcy5jaGlsZHJlbi5sZW5ndGg7aWYobGVuPjApe25ld0NoaWxkcmVuPVtdO2ZvcihpPTA7aTxsZW4tMTtpKyspe25ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7bmV3Q2hpbGRyZW4ucHVzaChhU2VwKTt9bmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTt0aGlzLmNoaWxkcmVuPW5ld0NoaWxkcmVuO31yZXR1cm4gdGhpczt9Oy8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0PWZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLGFSZXBsYWNlbWVudCl7dmFyIGxhc3RDaGlsZD10aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoLTFdO2lmKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKXtsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLGFSZXBsYWNlbWVudCk7fWVsc2UgaWYodHlwZW9mIGxhc3RDaGlsZD09PSdzdHJpbmcnKXt0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoLTFdPWxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLGFSZXBsYWNlbWVudCk7fWVsc2V7dGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sYVJlcGxhY2VtZW50KSk7fXJldHVybiB0aGlzO307LyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICpcbiAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKi9Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50PWZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSxhU291cmNlQ29udGVudCl7dGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV09YVNvdXJjZUNvbnRlbnQ7fTsvKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHM9ZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKXtmb3IodmFyIGk9MCxsZW49dGhpcy5jaGlsZHJlbi5sZW5ndGg7aTxsZW47aSsrKXtpZih0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pe3RoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7fX12YXIgc291cmNlcz1PYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtmb3IodmFyIGk9MCxsZW49c291cmNlcy5sZW5ndGg7aTxsZW47aSsrKXthRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO319Oy8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1NvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKXt2YXIgc3RyPVwiXCI7dGhpcy53YWxrKGZ1bmN0aW9uKGNodW5rKXtzdHIrPWNodW5rO30pO3JldHVybiBzdHI7fTsvKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1NvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcD1mdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncyl7dmFyIGdlbmVyYXRlZD17Y29kZTpcIlwiLGxpbmU6MSxjb2x1bW46MH07dmFyIG1hcD1uZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTt2YXIgc291cmNlTWFwcGluZ0FjdGl2ZT1mYWxzZTt2YXIgbGFzdE9yaWdpbmFsU291cmNlPW51bGw7dmFyIGxhc3RPcmlnaW5hbExpbmU9bnVsbDt2YXIgbGFzdE9yaWdpbmFsQ29sdW1uPW51bGw7dmFyIGxhc3RPcmlnaW5hbE5hbWU9bnVsbDt0aGlzLndhbGsoZnVuY3Rpb24oY2h1bmssb3JpZ2luYWwpe2dlbmVyYXRlZC5jb2RlKz1jaHVuaztpZihvcmlnaW5hbC5zb3VyY2UhPT1udWxsJiZvcmlnaW5hbC5saW5lIT09bnVsbCYmb3JpZ2luYWwuY29sdW1uIT09bnVsbCl7aWYobGFzdE9yaWdpbmFsU291cmNlIT09b3JpZ2luYWwuc291cmNlfHxsYXN0T3JpZ2luYWxMaW5lIT09b3JpZ2luYWwubGluZXx8bGFzdE9yaWdpbmFsQ29sdW1uIT09b3JpZ2luYWwuY29sdW1ufHxsYXN0T3JpZ2luYWxOYW1lIT09b3JpZ2luYWwubmFtZSl7bWFwLmFkZE1hcHBpbmcoe3NvdXJjZTpvcmlnaW5hbC5zb3VyY2Usb3JpZ2luYWw6e2xpbmU6b3JpZ2luYWwubGluZSxjb2x1bW46b3JpZ2luYWwuY29sdW1ufSxnZW5lcmF0ZWQ6e2xpbmU6Z2VuZXJhdGVkLmxpbmUsY29sdW1uOmdlbmVyYXRlZC5jb2x1bW59LG5hbWU6b3JpZ2luYWwubmFtZX0pO31sYXN0T3JpZ2luYWxTb3VyY2U9b3JpZ2luYWwuc291cmNlO2xhc3RPcmlnaW5hbExpbmU9b3JpZ2luYWwubGluZTtsYXN0T3JpZ2luYWxDb2x1bW49b3JpZ2luYWwuY29sdW1uO2xhc3RPcmlnaW5hbE5hbWU9b3JpZ2luYWwubmFtZTtzb3VyY2VNYXBwaW5nQWN0aXZlPXRydWU7fWVsc2UgaWYoc291cmNlTWFwcGluZ0FjdGl2ZSl7bWFwLmFkZE1hcHBpbmcoe2dlbmVyYXRlZDp7bGluZTpnZW5lcmF0ZWQubGluZSxjb2x1bW46Z2VuZXJhdGVkLmNvbHVtbn19KTtsYXN0T3JpZ2luYWxTb3VyY2U9bnVsbDtzb3VyY2VNYXBwaW5nQWN0aXZlPWZhbHNlO31mb3IodmFyIGlkeD0wLGxlbmd0aD1jaHVuay5sZW5ndGg7aWR4PGxlbmd0aDtpZHgrKyl7aWYoY2h1bmsuY2hhckNvZGVBdChpZHgpPT09TkVXTElORV9DT0RFKXtnZW5lcmF0ZWQubGluZSsrO2dlbmVyYXRlZC5jb2x1bW49MDsvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG5pZihpZHgrMT09PWxlbmd0aCl7bGFzdE9yaWdpbmFsU291cmNlPW51bGw7c291cmNlTWFwcGluZ0FjdGl2ZT1mYWxzZTt9ZWxzZSBpZihzb3VyY2VNYXBwaW5nQWN0aXZlKXttYXAuYWRkTWFwcGluZyh7c291cmNlOm9yaWdpbmFsLnNvdXJjZSxvcmlnaW5hbDp7bGluZTpvcmlnaW5hbC5saW5lLGNvbHVtbjpvcmlnaW5hbC5jb2x1bW59LGdlbmVyYXRlZDp7bGluZTpnZW5lcmF0ZWQubGluZSxjb2x1bW46Z2VuZXJhdGVkLmNvbHVtbn0sbmFtZTpvcmlnaW5hbC5uYW1lfSk7fX1lbHNle2dlbmVyYXRlZC5jb2x1bW4rKzt9fX0pO3RoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uKHNvdXJjZUZpbGUsc291cmNlQ29udGVudCl7bWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSxzb3VyY2VDb250ZW50KTt9KTtyZXR1cm57Y29kZTpnZW5lcmF0ZWQuY29kZSxtYXA6bWFwfTt9O2V4cG9ydHMuU291cmNlTm9kZT1Tb3VyY2VOb2RlO30se1wiLi9zb3VyY2UtbWFwLWdlbmVyYXRvclwiOjc1LFwiLi91dGlsXCI6Nzd9XSw3NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7LyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqLyAvKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovIC8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsYU5hbWUsYURlZmF1bHRWYWx1ZSl7aWYoYU5hbWUgaW4gYUFyZ3Mpe3JldHVybiBhQXJnc1thTmFtZV07fWVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aD09PTMpe3JldHVybiBhRGVmYXVsdFZhbHVlO31lbHNle3Rocm93IG5ldyBFcnJvcignXCInK2FOYW1lKydcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO319ZXhwb3J0cy5nZXRBcmc9Z2V0QXJnO3ZhciB1cmxSZWdleHA9L14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy4tXSopKD86OihcXGQrKSk/KC4qKSQvO3ZhciBkYXRhVXJsUmVnZXhwPS9eZGF0YTouK1xcLC4rJC87ZnVuY3Rpb24gdXJsUGFyc2UoYVVybCl7dmFyIG1hdGNoPWFVcmwubWF0Y2godXJsUmVnZXhwKTtpZighbWF0Y2gpe3JldHVybiBudWxsO31yZXR1cm57c2NoZW1lOm1hdGNoWzFdLGF1dGg6bWF0Y2hbMl0saG9zdDptYXRjaFszXSxwb3J0Om1hdGNoWzRdLHBhdGg6bWF0Y2hbNV19O31leHBvcnRzLnVybFBhcnNlPXVybFBhcnNlO2Z1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpe3ZhciB1cmw9Jyc7aWYoYVBhcnNlZFVybC5zY2hlbWUpe3VybCs9YVBhcnNlZFVybC5zY2hlbWUrJzonO311cmwrPScvLyc7aWYoYVBhcnNlZFVybC5hdXRoKXt1cmwrPWFQYXJzZWRVcmwuYXV0aCsnQCc7fWlmKGFQYXJzZWRVcmwuaG9zdCl7dXJsKz1hUGFyc2VkVXJsLmhvc3Q7fWlmKGFQYXJzZWRVcmwucG9ydCl7dXJsKz1cIjpcIithUGFyc2VkVXJsLnBvcnQ7fWlmKGFQYXJzZWRVcmwucGF0aCl7dXJsKz1hUGFyc2VkVXJsLnBhdGg7fXJldHVybiB1cmw7fWV4cG9ydHMudXJsR2VuZXJhdGU9dXJsR2VuZXJhdGU7LyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpe3ZhciBwYXRoPWFQYXRoO3ZhciB1cmw9dXJsUGFyc2UoYVBhdGgpO2lmKHVybCl7aWYoIXVybC5wYXRoKXtyZXR1cm4gYVBhdGg7fXBhdGg9dXJsLnBhdGg7fXZhciBpc0Fic29sdXRlPWV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTt2YXIgcGFydHM9cGF0aC5zcGxpdCgvXFwvKy8pO2Zvcih2YXIgcGFydCx1cD0wLGk9cGFydHMubGVuZ3RoLTE7aT49MDtpLS0pe3BhcnQ9cGFydHNbaV07aWYocGFydD09PScuJyl7cGFydHMuc3BsaWNlKGksMSk7fWVsc2UgaWYocGFydD09PScuLicpe3VwKys7fWVsc2UgaWYodXA+MCl7aWYocGFydD09PScnKXsvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4vLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG5wYXJ0cy5zcGxpY2UoaSsxLHVwKTt1cD0wO31lbHNle3BhcnRzLnNwbGljZShpLDIpO3VwLS07fX19cGF0aD1wYXJ0cy5qb2luKCcvJyk7aWYocGF0aD09PScnKXtwYXRoPWlzQWJzb2x1dGU/Jy8nOicuJzt9aWYodXJsKXt1cmwucGF0aD1wYXRoO3JldHVybiB1cmxHZW5lcmF0ZSh1cmwpO31yZXR1cm4gcGF0aDt9ZXhwb3J0cy5ub3JtYWxpemU9bm9ybWFsaXplOy8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL2Z1bmN0aW9uIGpvaW4oYVJvb3QsYVBhdGgpe2lmKGFSb290PT09XCJcIil7YVJvb3Q9XCIuXCI7fWlmKGFQYXRoPT09XCJcIil7YVBhdGg9XCIuXCI7fXZhciBhUGF0aFVybD11cmxQYXJzZShhUGF0aCk7dmFyIGFSb290VXJsPXVybFBhcnNlKGFSb290KTtpZihhUm9vdFVybCl7YVJvb3Q9YVJvb3RVcmwucGF0aHx8Jy8nO30vLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuaWYoYVBhdGhVcmwmJiFhUGF0aFVybC5zY2hlbWUpe2lmKGFSb290VXJsKXthUGF0aFVybC5zY2hlbWU9YVJvb3RVcmwuc2NoZW1lO31yZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO31pZihhUGF0aFVybHx8YVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpe3JldHVybiBhUGF0aDt9Ly8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG5pZihhUm9vdFVybCYmIWFSb290VXJsLmhvc3QmJiFhUm9vdFVybC5wYXRoKXthUm9vdFVybC5ob3N0PWFQYXRoO3JldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7fXZhciBqb2luZWQ9YVBhdGguY2hhckF0KDApPT09Jy8nP2FQYXRoOm5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sJycpKycvJythUGF0aCk7aWYoYVJvb3RVcmwpe2FSb290VXJsLnBhdGg9am9pbmVkO3JldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7fXJldHVybiBqb2luZWQ7fWV4cG9ydHMuam9pbj1qb2luO2V4cG9ydHMuaXNBYnNvbHV0ZT1mdW5jdGlvbihhUGF0aCl7cmV0dXJuIGFQYXRoLmNoYXJBdCgwKT09PScvJ3x8dXJsUmVnZXhwLnRlc3QoYVBhdGgpO307LyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsYVBhdGgpe2lmKGFSb290PT09XCJcIil7YVJvb3Q9XCIuXCI7fWFSb290PWFSb290LnJlcGxhY2UoL1xcLyQvLCcnKTsvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4vLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4vLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbi8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbnZhciBsZXZlbD0wO3doaWxlKGFQYXRoLmluZGV4T2YoYVJvb3QrJy8nKSE9PTApe3ZhciBpbmRleD1hUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7aWYoaW5kZXg8MCl7cmV0dXJuIGFQYXRoO30vLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4vLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4vLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuYVJvb3Q9YVJvb3Quc2xpY2UoMCxpbmRleCk7aWYoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpe3JldHVybiBhUGF0aDt9KytsZXZlbDt9Ly8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbnJldHVybiBBcnJheShsZXZlbCsxKS5qb2luKFwiLi4vXCIpK2FQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGgrMSk7fWV4cG9ydHMucmVsYXRpdmU9cmVsYXRpdmU7dmFyIHN1cHBvcnRzTnVsbFByb3RvPWZ1bmN0aW9uKCl7dmFyIG9iaj1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiEoJ19fcHJvdG9fXydpbiBvYmopO30oKTtmdW5jdGlvbiBpZGVudGl0eShzKXtyZXR1cm4gczt9LyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKXtpZihpc1Byb3RvU3RyaW5nKGFTdHIpKXtyZXR1cm4nJCcrYVN0cjt9cmV0dXJuIGFTdHI7fWV4cG9ydHMudG9TZXRTdHJpbmc9c3VwcG9ydHNOdWxsUHJvdG8/aWRlbnRpdHk6dG9TZXRTdHJpbmc7ZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKXtpZihpc1Byb3RvU3RyaW5nKGFTdHIpKXtyZXR1cm4gYVN0ci5zbGljZSgxKTt9cmV0dXJuIGFTdHI7fWV4cG9ydHMuZnJvbVNldFN0cmluZz1zdXBwb3J0c051bGxQcm90bz9pZGVudGl0eTpmcm9tU2V0U3RyaW5nO2Z1bmN0aW9uIGlzUHJvdG9TdHJpbmcocyl7aWYoIXMpe3JldHVybiBmYWxzZTt9dmFyIGxlbmd0aD1zLmxlbmd0aDtpZihsZW5ndGg8OS8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKXtyZXR1cm4gZmFsc2U7fWlmKHMuY2hhckNvZGVBdChsZW5ndGgtMSkhPT05NS8qICdfJyAqL3x8cy5jaGFyQ29kZUF0KGxlbmd0aC0yKSE9PTk1LyogJ18nICovfHxzLmNoYXJDb2RlQXQobGVuZ3RoLTMpIT09MTExLyogJ28nICovfHxzLmNoYXJDb2RlQXQobGVuZ3RoLTQpIT09MTE2LyogJ3QnICovfHxzLmNoYXJDb2RlQXQobGVuZ3RoLTUpIT09MTExLyogJ28nICovfHxzLmNoYXJDb2RlQXQobGVuZ3RoLTYpIT09MTE0LyogJ3InICovfHxzLmNoYXJDb2RlQXQobGVuZ3RoLTcpIT09MTEyLyogJ3AnICovfHxzLmNoYXJDb2RlQXQobGVuZ3RoLTgpIT09OTUvKiAnXycgKi98fHMuY2hhckNvZGVBdChsZW5ndGgtOSkhPT05NS8qICdfJyAqLyl7cmV0dXJuIGZhbHNlO31mb3IodmFyIGk9bGVuZ3RoLTEwO2k+PTA7aS0tKXtpZihzLmNoYXJDb2RlQXQoaSkhPT0zNi8qICckJyAqLyl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fS8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsbWFwcGluZ0Isb25seUNvbXBhcmVPcmlnaW5hbCl7dmFyIGNtcD1zdHJjbXAobWFwcGluZ0Euc291cmNlLG1hcHBpbmdCLnNvdXJjZSk7aWYoY21wIT09MCl7cmV0dXJuIGNtcDt9Y21wPW1hcHBpbmdBLm9yaWdpbmFsTGluZS1tYXBwaW5nQi5vcmlnaW5hbExpbmU7aWYoY21wIT09MCl7cmV0dXJuIGNtcDt9Y21wPW1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uLW1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO2lmKGNtcCE9PTB8fG9ubHlDb21wYXJlT3JpZ2luYWwpe3JldHVybiBjbXA7fWNtcD1tYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4tbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fWNtcD1tYXBwaW5nQS5nZW5lcmF0ZWRMaW5lLW1hcHBpbmdCLmdlbmVyYXRlZExpbmU7aWYoY21wIT09MCl7cmV0dXJuIGNtcDt9cmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLG1hcHBpbmdCLm5hbWUpO31leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zPWNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zOy8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL2Z1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLG1hcHBpbmdCLG9ubHlDb21wYXJlR2VuZXJhdGVkKXt2YXIgY21wPW1hcHBpbmdBLmdlbmVyYXRlZExpbmUtbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31jbXA9bWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uLW1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtpZihjbXAhPT0wfHxvbmx5Q29tcGFyZUdlbmVyYXRlZCl7cmV0dXJuIGNtcDt9Y21wPXN0cmNtcChtYXBwaW5nQS5zb3VyY2UsbWFwcGluZ0Iuc291cmNlKTtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31jbXA9bWFwcGluZ0Eub3JpZ2luYWxMaW5lLW1hcHBpbmdCLm9yaWdpbmFsTGluZTtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31jbXA9bWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4tbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47aWYoY21wIT09MCl7cmV0dXJuIGNtcDt9cmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLG1hcHBpbmdCLm5hbWUpO31leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkPWNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO2Z1bmN0aW9uIHN0cmNtcChhU3RyMSxhU3RyMil7aWYoYVN0cjE9PT1hU3RyMil7cmV0dXJuIDA7fWlmKGFTdHIxPT09bnVsbCl7cmV0dXJuIDE7Ly8gYVN0cjIgIT09IG51bGxcbn1pZihhU3RyMj09PW51bGwpe3JldHVybi0xOy8vIGFTdHIxICE9PSBudWxsXG59aWYoYVN0cjE+YVN0cjIpe3JldHVybiAxO31yZXR1cm4tMTt9LyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL2Z1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLG1hcHBpbmdCKXt2YXIgY21wPW1hcHBpbmdBLmdlbmVyYXRlZExpbmUtbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31jbXA9bWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uLW1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31jbXA9c3RyY21wKG1hcHBpbmdBLnNvdXJjZSxtYXBwaW5nQi5zb3VyY2UpO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fWNtcD1tYXBwaW5nQS5vcmlnaW5hbExpbmUtbWFwcGluZ0Iub3JpZ2luYWxMaW5lO2lmKGNtcCE9PTApe3JldHVybiBjbXA7fWNtcD1tYXBwaW5nQS5vcmlnaW5hbENvbHVtbi1tYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtpZihjbXAhPT0wKXtyZXR1cm4gY21wO31yZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsbWFwcGluZ0IubmFtZSk7fWV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ9Y29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7LyoqXG4gKiBTdHJpcCBhbnkgSlNPTiBYU1NJIGF2b2lkYW5jZSBwcmVmaXggZnJvbSB0aGUgc3RyaW5nIChhcyBkb2N1bWVudGVkXG4gKiBpbiB0aGUgc291cmNlIG1hcHMgc3BlY2lmaWNhdGlvbiksIGFuZCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcgYXNcbiAqIEpTT04uXG4gKi9mdW5jdGlvbiBwYXJzZVNvdXJjZU1hcElucHV0KHN0cil7cmV0dXJuIEpTT04ucGFyc2Uoc3RyLnJlcGxhY2UoL15cXCldfSdbXlxcbl0qXFxuLywnJykpO31leHBvcnRzLnBhcnNlU291cmNlTWFwSW5wdXQ9cGFyc2VTb3VyY2VNYXBJbnB1dDsvKipcbiAqIENvbXB1dGUgdGhlIFVSTCBvZiBhIHNvdXJjZSBnaXZlbiB0aGUgdGhlIHNvdXJjZSByb290LCB0aGUgc291cmNlJ3NcbiAqIFVSTCwgYW5kIHRoZSBzb3VyY2UgbWFwJ3MgVVJMLlxuICovZnVuY3Rpb24gY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LHNvdXJjZVVSTCxzb3VyY2VNYXBVUkwpe3NvdXJjZVVSTD1zb3VyY2VVUkx8fCcnO2lmKHNvdXJjZVJvb3Qpey8vIFRoaXMgZm9sbG93cyB3aGF0IENocm9tZSBkb2VzLlxuaWYoc291cmNlUm9vdFtzb3VyY2VSb290Lmxlbmd0aC0xXSE9PScvJyYmc291cmNlVVJMWzBdIT09Jy8nKXtzb3VyY2VSb290Kz0nLyc7fS8vIFRoZSBzcGVjIHNheXM6XG4vLyAgIExpbmUgNDogQW4gb3B0aW9uYWwgc291cmNlIHJvb3QsIHVzZWZ1bCBmb3IgcmVsb2NhdGluZyBzb3VyY2Vcbi8vICAgZmlsZXMgb24gYSBzZXJ2ZXIgb3IgcmVtb3ZpbmcgcmVwZWF0ZWQgdmFsdWVzIGluIHRoZVxuLy8gICDigJxzb3VyY2Vz4oCdIGVudHJ5LiAgVGhpcyB2YWx1ZSBpcyBwcmVwZW5kZWQgdG8gdGhlIGluZGl2aWR1YWxcbi8vICAgZW50cmllcyBpbiB0aGUg4oCcc291cmNl4oCdIGZpZWxkLlxuc291cmNlVVJMPXNvdXJjZVJvb3Qrc291cmNlVVJMO30vLyBIaXN0b3JpY2FsbHksIFNvdXJjZU1hcENvbnN1bWVyIGRpZCBub3QgdGFrZSB0aGUgc291cmNlTWFwVVJMIGFzXG4vLyBhIHBhcmFtZXRlci4gIFRoaXMgbW9kZSBpcyBzdGlsbCBzb21ld2hhdCBzdXBwb3J0ZWQsIHdoaWNoIGlzIHdoeVxuLy8gdGhpcyBjb2RlIGJsb2NrIGlzIGNvbmRpdGlvbmFsLiAgSG93ZXZlciwgaXQncyBwcmVmZXJhYmxlIHRvIHBhc3Ncbi8vIHRoZSBzb3VyY2UgbWFwIFVSTCB0byBTb3VyY2VNYXBDb25zdW1lciwgc28gdGhhdCB0aGlzIGZ1bmN0aW9uXG4vLyBjYW4gaW1wbGVtZW50IHRoZSBzb3VyY2UgVVJMIHJlc29sdXRpb24gYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluXG4vLyB0aGUgc3BlYy4gIFRoaXMgYmxvY2sgaXMgYmFzaWNhbGx5IHRoZSBlcXVpdmFsZW50IG9mOlxuLy8gICAgbmV3IFVSTChzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkudG9TdHJpbmcoKVxuLy8gLi4uIGV4Y2VwdCBpdCBhdm9pZHMgdXNpbmcgVVJMLCB3aGljaCB3YXNuJ3QgYXZhaWxhYmxlIGluIHRoZVxuLy8gb2xkZXIgcmVsZWFzZXMgb2Ygbm9kZSBzdGlsbCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxuLy9cbi8vIFRoZSBzcGVjIHNheXM6XG4vLyAgIElmIHRoZSBzb3VyY2VzIGFyZSBub3QgYWJzb2x1dGUgVVJMcyBhZnRlciBwcmVwZW5kaW5nIG9mIHRoZVxuLy8gICDigJxzb3VyY2VSb2904oCdLCB0aGUgc291cmNlcyBhcmUgcmVzb2x2ZWQgcmVsYXRpdmUgdG8gdGhlXG4vLyAgIFNvdXJjZU1hcCAobGlrZSByZXNvbHZpbmcgc2NyaXB0IHNyYyBpbiBhIGh0bWwgZG9jdW1lbnQpLlxuaWYoc291cmNlTWFwVVJMKXt2YXIgcGFyc2VkPXVybFBhcnNlKHNvdXJjZU1hcFVSTCk7aWYoIXBhcnNlZCl7dGhyb3cgbmV3IEVycm9yKFwic291cmNlTWFwVVJMIGNvdWxkIG5vdCBiZSBwYXJzZWRcIik7fWlmKHBhcnNlZC5wYXRoKXsvLyBTdHJpcCB0aGUgbGFzdCBwYXRoIGNvbXBvbmVudCwgYnV0IGtlZXAgdGhlIFwiL1wiLlxudmFyIGluZGV4PXBhcnNlZC5wYXRoLmxhc3RJbmRleE9mKCcvJyk7aWYoaW5kZXg+PTApe3BhcnNlZC5wYXRoPXBhcnNlZC5wYXRoLnN1YnN0cmluZygwLGluZGV4KzEpO319c291cmNlVVJMPWpvaW4odXJsR2VuZXJhdGUocGFyc2VkKSxzb3VyY2VVUkwpO31yZXR1cm4gbm9ybWFsaXplKHNvdXJjZVVSTCk7fWV4cG9ydHMuY29tcHV0ZVNvdXJjZVVSTD1jb21wdXRlU291cmNlVVJMO30se31dLDc4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3I9cmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7ZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lcj1yZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7ZXhwb3J0cy5Tb3VyY2VOb2RlPXJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTt9LHtcIi4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXJcIjo3NCxcIi4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yXCI6NzUsXCIuL2xpYi9zb3VyY2Utbm9kZVwiOjc2fV0sNzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyd1c2Ugc3RyaWN0Jzt2YXIgaW50ZWdlclJlZ2V4PS9eXFxkKyQvO2Z1bmN0aW9uIGRlZXBVbmlxdWUoYXJyYXkpe3JldHVybiBhcnJheS5zb3J0KCkuZmlsdGVyKGZ1bmN0aW9uKGVsZW1lbnQsaW5kZXgpe3JldHVybiBKU09OLnN0cmluZ2lmeShlbGVtZW50KSE9PUpTT04uc3RyaW5naWZ5KGFycmF5W2luZGV4LTFdKTt9KTt9ZXhwb3J0cy5wYXJzZT1mdW5jdGlvbihzdHJpbmcpe3JldHVybiBkZWVwVW5pcXVlKHN0cmluZy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbihwYXJ0KXt2YXIgcmVzdWx0PXt9O3BhcnQudHJpbSgpLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LGluZGV4KXtpZihpbmRleD09PTApe3Jlc3VsdC51cmw9ZWxlbWVudDtyZXR1cm47fXZhciB2YWx1ZT1lbGVtZW50LnNsaWNlKDAsZWxlbWVudC5sZW5ndGgtMSk7dmFyIHBvc3RmaXg9ZWxlbWVudFtlbGVtZW50Lmxlbmd0aC0xXTt2YXIgaW50ZWdlclZhbHVlPXBhcnNlSW50KHZhbHVlLDEwKTt2YXIgZmxvYXRWYWx1ZT1wYXJzZUZsb2F0KHZhbHVlKTtpZihwb3N0Zml4PT09J3cnJiZpbnRlZ2VyUmVnZXgudGVzdCh2YWx1ZSkpe3Jlc3VsdC53aWR0aD1pbnRlZ2VyVmFsdWU7fWVsc2UgaWYocG9zdGZpeD09PSdoJyYmaW50ZWdlclJlZ2V4LnRlc3QodmFsdWUpKXtyZXN1bHQuaGVpZ2h0PWludGVnZXJWYWx1ZTt9ZWxzZSBpZihwb3N0Zml4PT09J3gnJiYhTnVtYmVyLmlzTmFOKGZsb2F0VmFsdWUpKXtyZXN1bHQuZGVuc2l0eT1mbG9hdFZhbHVlO31lbHNle3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3Jjc2V0IGRlc2NyaXB0b3I6IFwiLmNvbmNhdChlbGVtZW50KSk7fX0pO3JldHVybiByZXN1bHQ7fSkpO307ZXhwb3J0cy5zdHJpbmdpZnk9ZnVuY3Rpb24oYXJyYXkpe3JldHVybiBfdG9Db25zdW1hYmxlQXJyYXkobmV3IFNldChhcnJheS5tYXAoZnVuY3Rpb24oZWxlbWVudCl7aWYoIWVsZW1lbnQudXJsKXt0aHJvdyBuZXcgRXJyb3IoJ1VSTCBpcyByZXF1aXJlZCcpO312YXIgcmVzdWx0PVtlbGVtZW50LnVybF07aWYoZWxlbWVudC53aWR0aCl7cmVzdWx0LnB1c2goXCJcIi5jb25jYXQoZWxlbWVudC53aWR0aCxcIndcIikpO31pZihlbGVtZW50LmhlaWdodCl7cmVzdWx0LnB1c2goXCJcIi5jb25jYXQoZWxlbWVudC5oZWlnaHQsXCJoXCIpKTt9aWYoZWxlbWVudC5kZW5zaXR5KXtyZXN1bHQucHVzaChcIlwiLmNvbmNhdChlbGVtZW50LmRlbnNpdHksXCJ4XCIpKTt9cmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7fSkpKS5qb2luKCcsICcpO307fSx7fV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO3ZhciBwdW55Y29kZT1yZXF1aXJlKCdwdW55Y29kZScpO3ZhciB1dGlsPXJlcXVpcmUoJy4vdXRpbCcpO2V4cG9ydHMucGFyc2U9dXJsUGFyc2U7ZXhwb3J0cy5yZXNvbHZlPXVybFJlc29sdmU7ZXhwb3J0cy5yZXNvbHZlT2JqZWN0PXVybFJlc29sdmVPYmplY3Q7ZXhwb3J0cy5mb3JtYXQ9dXJsRm9ybWF0O2V4cG9ydHMuVXJsPVVybDtmdW5jdGlvbiBVcmwoKXt0aGlzLnByb3RvY29sPW51bGw7dGhpcy5zbGFzaGVzPW51bGw7dGhpcy5hdXRoPW51bGw7dGhpcy5ob3N0PW51bGw7dGhpcy5wb3J0PW51bGw7dGhpcy5ob3N0bmFtZT1udWxsO3RoaXMuaGFzaD1udWxsO3RoaXMuc2VhcmNoPW51bGw7dGhpcy5xdWVyeT1udWxsO3RoaXMucGF0aG5hbWU9bnVsbDt0aGlzLnBhdGg9bnVsbDt0aGlzLmhyZWY9bnVsbDt9Ly8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuPS9eKFthLXowLTkuKy1dKzopL2kscG9ydFBhdHRlcm49LzpbMC05XSokLywvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG5zaW1wbGVQYXRoUGF0dGVybj0vXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4vLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuZGVsaW1zPVsnPCcsJz4nLCdcIicsJ2AnLCcgJywnXFxyJywnXFxuJywnXFx0J10sLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbnVud2lzZT1bJ3snLCd9JywnfCcsJ1xcXFwnLCdeJywnYCddLmNvbmNhdChkZWxpbXMpLC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbmF1dG9Fc2NhcGU9WydcXCcnXS5jb25jYXQodW53aXNlKSwvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4vLyB0aGVtLlxubm9uSG9zdENoYXJzPVsnJScsJy8nLCc/JywnOycsJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksaG9zdEVuZGluZ0NoYXJzPVsnLycsJz8nLCcjJ10saG9zdG5hbWVNYXhMZW49MjU1LGhvc3RuYW1lUGFydFBhdHRlcm49L15bK2EtejAtOUEtWl8tXXswLDYzfSQvLGhvc3RuYW1lUGFydFN0YXJ0PS9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLywvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbnVuc2FmZVByb3RvY29sPXsnamF2YXNjcmlwdCc6dHJ1ZSwnamF2YXNjcmlwdDonOnRydWV9LC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbmhvc3RsZXNzUHJvdG9jb2w9eydqYXZhc2NyaXB0Jzp0cnVlLCdqYXZhc2NyaXB0Oic6dHJ1ZX0sLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG5zbGFzaGVkUHJvdG9jb2w9eydodHRwJzp0cnVlLCdodHRwcyc6dHJ1ZSwnZnRwJzp0cnVlLCdnb3BoZXInOnRydWUsJ2ZpbGUnOnRydWUsJ2h0dHA6Jzp0cnVlLCdodHRwczonOnRydWUsJ2Z0cDonOnRydWUsJ2dvcGhlcjonOnRydWUsJ2ZpbGU6Jzp0cnVlfSxxdWVyeXN0cmluZz1yZXF1aXJlKCdxdWVyeXN0cmluZycpO2Z1bmN0aW9uIHVybFBhcnNlKHVybCxwYXJzZVF1ZXJ5U3RyaW5nLHNsYXNoZXNEZW5vdGVIb3N0KXtpZih1cmwmJnV0aWwuaXNPYmplY3QodXJsKSYmdXJsIGluc3RhbmNlb2YgVXJsKXJldHVybiB1cmw7dmFyIHU9bmV3IFVybCgpO3UucGFyc2UodXJsLHBhcnNlUXVlcnlTdHJpbmcsc2xhc2hlc0Rlbm90ZUhvc3QpO3JldHVybiB1O31VcmwucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKHVybCxwYXJzZVF1ZXJ5U3RyaW5nLHNsYXNoZXNEZW5vdGVIb3N0KXtpZighdXRpbC5pc1N0cmluZyh1cmwpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIitfdHlwZW9mKHVybCkpO30vLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbi8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbnZhciBxdWVyeUluZGV4PXVybC5pbmRleE9mKCc/Jyksc3BsaXR0ZXI9cXVlcnlJbmRleCE9PS0xJiZxdWVyeUluZGV4PHVybC5pbmRleE9mKCcjJyk/Jz8nOicjJyx1U3BsaXQ9dXJsLnNwbGl0KHNwbGl0dGVyKSxzbGFzaFJlZ2V4PS9cXFxcL2c7dVNwbGl0WzBdPXVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsJy8nKTt1cmw9dVNwbGl0LmpvaW4oc3BsaXR0ZXIpO3ZhciByZXN0PXVybDsvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxucmVzdD1yZXN0LnRyaW0oKTtpZighc2xhc2hlc0Rlbm90ZUhvc3QmJnVybC5zcGxpdCgnIycpLmxlbmd0aD09PTEpey8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG52YXIgc2ltcGxlUGF0aD1zaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO2lmKHNpbXBsZVBhdGgpe3RoaXMucGF0aD1yZXN0O3RoaXMuaHJlZj1yZXN0O3RoaXMucGF0aG5hbWU9c2ltcGxlUGF0aFsxXTtpZihzaW1wbGVQYXRoWzJdKXt0aGlzLnNlYXJjaD1zaW1wbGVQYXRoWzJdO2lmKHBhcnNlUXVlcnlTdHJpbmcpe3RoaXMucXVlcnk9cXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTt9ZWxzZXt0aGlzLnF1ZXJ5PXRoaXMuc2VhcmNoLnN1YnN0cigxKTt9fWVsc2UgaWYocGFyc2VRdWVyeVN0cmluZyl7dGhpcy5zZWFyY2g9Jyc7dGhpcy5xdWVyeT17fTt9cmV0dXJuIHRoaXM7fX12YXIgcHJvdG89cHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7aWYocHJvdG8pe3Byb3RvPXByb3RvWzBdO3ZhciBsb3dlclByb3RvPXByb3RvLnRvTG93ZXJDYXNlKCk7dGhpcy5wcm90b2NvbD1sb3dlclByb3RvO3Jlc3Q9cmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTt9Ly8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3Rcbi8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbi8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3Ncbi8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuaWYoc2xhc2hlc0Rlbm90ZUhvc3R8fHByb3RvfHxyZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSl7dmFyIHNsYXNoZXM9cmVzdC5zdWJzdHIoMCwyKT09PScvLyc7aWYoc2xhc2hlcyYmIShwcm90byYmaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKXtyZXN0PXJlc3Quc3Vic3RyKDIpO3RoaXMuc2xhc2hlcz10cnVlO319aWYoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dJiYoc2xhc2hlc3x8cHJvdG8mJiFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSl7Ly8gdGhlcmUncyBhIGhvc3RuYW1lLlxuLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbi8vXG4vLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4vLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbi8vIFVSTHMgYXJlIG9ibm94aW91cy5cbi8vXG4vLyBleDpcbi8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4vLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG4vLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4vLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xudmFyIGhvc3RFbmQ9LTE7Zm9yKHZhciBpPTA7aTxob3N0RW5kaW5nQ2hhcnMubGVuZ3RoO2krKyl7dmFyIGhlYz1yZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtpZihoZWMhPT0tMSYmKGhvc3RFbmQ9PT0tMXx8aGVjPGhvc3RFbmQpKWhvc3RFbmQ9aGVjO30vLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbi8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxudmFyIGF1dGgsYXRTaWduO2lmKGhvc3RFbmQ9PT0tMSl7Ly8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbmF0U2lnbj1yZXN0Lmxhc3RJbmRleE9mKCdAJyk7fWVsc2V7Ly8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbmF0U2lnbj1yZXN0Lmxhc3RJbmRleE9mKCdAJyxob3N0RW5kKTt9Ly8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4vLyBQdWxsIHRoYXQgb2ZmLlxuaWYoYXRTaWduIT09LTEpe2F1dGg9cmVzdC5zbGljZSgwLGF0U2lnbik7cmVzdD1yZXN0LnNsaWNlKGF0U2lnbisxKTt0aGlzLmF1dGg9ZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO30vLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG5ob3N0RW5kPS0xO2Zvcih2YXIgaT0wO2k8bm9uSG9zdENoYXJzLmxlbmd0aDtpKyspe3ZhciBoZWM9cmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7aWYoaGVjIT09LTEmJihob3N0RW5kPT09LTF8fGhlYzxob3N0RW5kKSlob3N0RW5kPWhlYzt9Ly8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuaWYoaG9zdEVuZD09PS0xKWhvc3RFbmQ9cmVzdC5sZW5ndGg7dGhpcy5ob3N0PXJlc3Quc2xpY2UoMCxob3N0RW5kKTtyZXN0PXJlc3Quc2xpY2UoaG9zdEVuZCk7Ly8gcHVsbCBvdXQgcG9ydC5cbnRoaXMucGFyc2VIb3N0KCk7Ly8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbi8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG50aGlzLmhvc3RuYW1lPXRoaXMuaG9zdG5hbWV8fCcnOy8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4vLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbnZhciBpcHY2SG9zdG5hbWU9dGhpcy5ob3N0bmFtZVswXT09PSdbJyYmdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aC0xXT09PSddJzsvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbmlmKCFpcHY2SG9zdG5hbWUpe3ZhciBob3N0cGFydHM9dGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7Zm9yKHZhciBpPTAsbD1ob3N0cGFydHMubGVuZ3RoO2k8bDtpKyspe3ZhciBwYXJ0PWhvc3RwYXJ0c1tpXTtpZighcGFydCljb250aW51ZTtpZighcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSl7dmFyIG5ld3BhcnQ9Jyc7Zm9yKHZhciBqPTAsaz1wYXJ0Lmxlbmd0aDtqPGs7aisrKXtpZihwYXJ0LmNoYXJDb2RlQXQoaik+MTI3KXsvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbi8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3Rcbi8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbm5ld3BhcnQrPSd4Jzt9ZWxzZXtuZXdwYXJ0Kz1wYXJ0W2pdO319Ly8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuaWYoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpe3ZhciB2YWxpZFBhcnRzPWhvc3RwYXJ0cy5zbGljZSgwLGkpO3ZhciBub3RIb3N0PWhvc3RwYXJ0cy5zbGljZShpKzEpO3ZhciBiaXQ9cGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7aWYoYml0KXt2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtub3RIb3N0LnVuc2hpZnQoYml0WzJdKTt9aWYobm90SG9zdC5sZW5ndGgpe3Jlc3Q9Jy8nK25vdEhvc3Quam9pbignLicpK3Jlc3Q7fXRoaXMuaG9zdG5hbWU9dmFsaWRQYXJ0cy5qb2luKCcuJyk7YnJlYWs7fX19fWlmKHRoaXMuaG9zdG5hbWUubGVuZ3RoPmhvc3RuYW1lTWF4TGVuKXt0aGlzLmhvc3RuYW1lPScnO31lbHNley8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG50aGlzLmhvc3RuYW1lPXRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTt9aWYoIWlwdjZIb3N0bmFtZSl7Ly8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4vLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4vLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4vLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxudGhpcy5ob3N0bmFtZT1wdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO312YXIgcD10aGlzLnBvcnQ/JzonK3RoaXMucG9ydDonJzt2YXIgaD10aGlzLmhvc3RuYW1lfHwnJzt0aGlzLmhvc3Q9aCtwO3RoaXMuaHJlZis9dGhpcy5ob3N0Oy8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbi8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG5pZihpcHY2SG9zdG5hbWUpe3RoaXMuaG9zdG5hbWU9dGhpcy5ob3N0bmFtZS5zdWJzdHIoMSx0aGlzLmhvc3RuYW1lLmxlbmd0aC0yKTtpZihyZXN0WzBdIT09Jy8nKXtyZXN0PScvJytyZXN0O319fS8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuaWYoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKXsvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4vLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbi8vIG5lZWQgdG8gYmUuXG5mb3IodmFyIGk9MCxsPWF1dG9Fc2NhcGUubGVuZ3RoO2k8bDtpKyspe3ZhciBhZT1hdXRvRXNjYXBlW2ldO2lmKHJlc3QuaW5kZXhPZihhZSk9PT0tMSljb250aW51ZTt2YXIgZXNjPWVuY29kZVVSSUNvbXBvbmVudChhZSk7aWYoZXNjPT09YWUpe2VzYz1lc2NhcGUoYWUpO31yZXN0PXJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTt9fS8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG52YXIgaGFzaD1yZXN0LmluZGV4T2YoJyMnKTtpZihoYXNoIT09LTEpey8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbnRoaXMuaGFzaD1yZXN0LnN1YnN0cihoYXNoKTtyZXN0PXJlc3Quc2xpY2UoMCxoYXNoKTt9dmFyIHFtPXJlc3QuaW5kZXhPZignPycpO2lmKHFtIT09LTEpe3RoaXMuc2VhcmNoPXJlc3Quc3Vic3RyKHFtKTt0aGlzLnF1ZXJ5PXJlc3Quc3Vic3RyKHFtKzEpO2lmKHBhcnNlUXVlcnlTdHJpbmcpe3RoaXMucXVlcnk9cXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7fXJlc3Q9cmVzdC5zbGljZSgwLHFtKTt9ZWxzZSBpZihwYXJzZVF1ZXJ5U3RyaW5nKXsvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxudGhpcy5zZWFyY2g9Jyc7dGhpcy5xdWVyeT17fTt9aWYocmVzdCl0aGlzLnBhdGhuYW1lPXJlc3Q7aWYoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dJiZ0aGlzLmhvc3RuYW1lJiYhdGhpcy5wYXRobmFtZSl7dGhpcy5wYXRobmFtZT0nLyc7fS8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbmlmKHRoaXMucGF0aG5hbWV8fHRoaXMuc2VhcmNoKXt2YXIgcD10aGlzLnBhdGhuYW1lfHwnJzt2YXIgcz10aGlzLnNlYXJjaHx8Jyc7dGhpcy5wYXRoPXArczt9Ly8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG50aGlzLmhyZWY9dGhpcy5mb3JtYXQoKTtyZXR1cm4gdGhpczt9Oy8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopey8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4vLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbmlmKHV0aWwuaXNTdHJpbmcob2JqKSlvYmo9dXJsUGFyc2Uob2JqKTtpZighKG9iaiBpbnN0YW5jZW9mIFVybCkpcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtyZXR1cm4gb2JqLmZvcm1hdCgpO31VcmwucHJvdG90eXBlLmZvcm1hdD1mdW5jdGlvbigpe3ZhciBhdXRoPXRoaXMuYXV0aHx8Jyc7aWYoYXV0aCl7YXV0aD1lbmNvZGVVUklDb21wb25lbnQoYXV0aCk7YXV0aD1hdXRoLnJlcGxhY2UoLyUzQS9pLCc6Jyk7YXV0aCs9J0AnO312YXIgcHJvdG9jb2w9dGhpcy5wcm90b2NvbHx8JycscGF0aG5hbWU9dGhpcy5wYXRobmFtZXx8JycsaGFzaD10aGlzLmhhc2h8fCcnLGhvc3Q9ZmFsc2UscXVlcnk9Jyc7aWYodGhpcy5ob3N0KXtob3N0PWF1dGgrdGhpcy5ob3N0O31lbHNlIGlmKHRoaXMuaG9zdG5hbWUpe2hvc3Q9YXV0aCsodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6Jyk9PT0tMT90aGlzLmhvc3RuYW1lOidbJyt0aGlzLmhvc3RuYW1lKyddJyk7aWYodGhpcy5wb3J0KXtob3N0Kz0nOicrdGhpcy5wb3J0O319aWYodGhpcy5xdWVyeSYmdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSYmT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKXtxdWVyeT1xdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7fXZhciBzZWFyY2g9dGhpcy5zZWFyY2h8fHF1ZXJ5JiYnPycrcXVlcnl8fCcnO2lmKHByb3RvY29sJiZwcm90b2NvbC5zdWJzdHIoLTEpIT09JzonKXByb3RvY29sKz0nOic7Ly8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4vLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuaWYodGhpcy5zbGFzaGVzfHwoIXByb3RvY29sfHxzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSYmaG9zdCE9PWZhbHNlKXtob3N0PScvLycrKGhvc3R8fCcnKTtpZihwYXRobmFtZSYmcGF0aG5hbWUuY2hhckF0KDApIT09Jy8nKXBhdGhuYW1lPScvJytwYXRobmFtZTt9ZWxzZSBpZighaG9zdCl7aG9zdD0nJzt9aWYoaGFzaCYmaGFzaC5jaGFyQXQoMCkhPT0nIycpaGFzaD0nIycraGFzaDtpZihzZWFyY2gmJnNlYXJjaC5jaGFyQXQoMCkhPT0nPycpc2VhcmNoPSc/JytzZWFyY2g7cGF0aG5hbWU9cGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLGZ1bmN0aW9uKG1hdGNoKXtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTt9KTtzZWFyY2g9c2VhcmNoLnJlcGxhY2UoJyMnLCclMjMnKTtyZXR1cm4gcHJvdG9jb2wraG9zdCtwYXRobmFtZStzZWFyY2graGFzaDt9O2Z1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLHJlbGF0aXZlKXtyZXR1cm4gdXJsUGFyc2Uoc291cmNlLGZhbHNlLHRydWUpLnJlc29sdmUocmVsYXRpdmUpO31VcmwucHJvdG90eXBlLnJlc29sdmU9ZnVuY3Rpb24ocmVsYXRpdmUpe3JldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsZmFsc2UsdHJ1ZSkpLmZvcm1hdCgpO307ZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UscmVsYXRpdmUpe2lmKCFzb3VyY2UpcmV0dXJuIHJlbGF0aXZlO3JldHVybiB1cmxQYXJzZShzb3VyY2UsZmFsc2UsdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7fVVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdD1mdW5jdGlvbihyZWxhdGl2ZSl7aWYodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpe3ZhciByZWw9bmV3IFVybCgpO3JlbC5wYXJzZShyZWxhdGl2ZSxmYWxzZSx0cnVlKTtyZWxhdGl2ZT1yZWw7fXZhciByZXN1bHQ9bmV3IFVybCgpO3ZhciB0a2V5cz1PYmplY3Qua2V5cyh0aGlzKTtmb3IodmFyIHRrPTA7dGs8dGtleXMubGVuZ3RoO3RrKyspe3ZhciB0a2V5PXRrZXlzW3RrXTtyZXN1bHRbdGtleV09dGhpc1t0a2V5XTt9Ly8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4vLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbnJlc3VsdC5oYXNoPXJlbGF0aXZlLmhhc2g7Ly8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuaWYocmVsYXRpdmUuaHJlZj09PScnKXtyZXN1bHQuaHJlZj1yZXN1bHQuZm9ybWF0KCk7cmV0dXJuIHJlc3VsdDt9Ly8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG5pZihyZWxhdGl2ZS5zbGFzaGVzJiYhcmVsYXRpdmUucHJvdG9jb2wpey8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbnZhciBya2V5cz1PYmplY3Qua2V5cyhyZWxhdGl2ZSk7Zm9yKHZhciByaz0wO3JrPHJrZXlzLmxlbmd0aDtyaysrKXt2YXIgcmtleT1ya2V5c1tya107aWYocmtleSE9PSdwcm90b2NvbCcpcmVzdWx0W3JrZXldPXJlbGF0aXZlW3JrZXldO30vL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuaWYoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0mJnJlc3VsdC5ob3N0bmFtZSYmIXJlc3VsdC5wYXRobmFtZSl7cmVzdWx0LnBhdGg9cmVzdWx0LnBhdGhuYW1lPScvJzt9cmVzdWx0LmhyZWY9cmVzdWx0LmZvcm1hdCgpO3JldHVybiByZXN1bHQ7fWlmKHJlbGF0aXZlLnByb3RvY29sJiZyZWxhdGl2ZS5wcm90b2NvbCE9PXJlc3VsdC5wcm90b2NvbCl7Ly8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4vLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbi8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4vLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4vLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4vLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG5pZighc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSl7dmFyIGtleXM9T2JqZWN0LmtleXMocmVsYXRpdmUpO2Zvcih2YXIgdj0wO3Y8a2V5cy5sZW5ndGg7disrKXt2YXIgaz1rZXlzW3ZdO3Jlc3VsdFtrXT1yZWxhdGl2ZVtrXTt9cmVzdWx0LmhyZWY9cmVzdWx0LmZvcm1hdCgpO3JldHVybiByZXN1bHQ7fXJlc3VsdC5wcm90b2NvbD1yZWxhdGl2ZS5wcm90b2NvbDtpZighcmVsYXRpdmUuaG9zdCYmIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKXt2YXIgcmVsUGF0aD0ocmVsYXRpdmUucGF0aG5hbWV8fCcnKS5zcGxpdCgnLycpO3doaWxlKHJlbFBhdGgubGVuZ3RoJiYhKHJlbGF0aXZlLmhvc3Q9cmVsUGF0aC5zaGlmdCgpKSl7O31pZighcmVsYXRpdmUuaG9zdClyZWxhdGl2ZS5ob3N0PScnO2lmKCFyZWxhdGl2ZS5ob3N0bmFtZSlyZWxhdGl2ZS5ob3N0bmFtZT0nJztpZihyZWxQYXRoWzBdIT09JycpcmVsUGF0aC51bnNoaWZ0KCcnKTtpZihyZWxQYXRoLmxlbmd0aDwyKXJlbFBhdGgudW5zaGlmdCgnJyk7cmVzdWx0LnBhdGhuYW1lPXJlbFBhdGguam9pbignLycpO31lbHNle3Jlc3VsdC5wYXRobmFtZT1yZWxhdGl2ZS5wYXRobmFtZTt9cmVzdWx0LnNlYXJjaD1yZWxhdGl2ZS5zZWFyY2g7cmVzdWx0LnF1ZXJ5PXJlbGF0aXZlLnF1ZXJ5O3Jlc3VsdC5ob3N0PXJlbGF0aXZlLmhvc3R8fCcnO3Jlc3VsdC5hdXRoPXJlbGF0aXZlLmF1dGg7cmVzdWx0Lmhvc3RuYW1lPXJlbGF0aXZlLmhvc3RuYW1lfHxyZWxhdGl2ZS5ob3N0O3Jlc3VsdC5wb3J0PXJlbGF0aXZlLnBvcnQ7Ly8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbmlmKHJlc3VsdC5wYXRobmFtZXx8cmVzdWx0LnNlYXJjaCl7dmFyIHA9cmVzdWx0LnBhdGhuYW1lfHwnJzt2YXIgcz1yZXN1bHQuc2VhcmNofHwnJztyZXN1bHQucGF0aD1wK3M7fXJlc3VsdC5zbGFzaGVzPXJlc3VsdC5zbGFzaGVzfHxyZWxhdGl2ZS5zbGFzaGVzO3Jlc3VsdC5ocmVmPXJlc3VsdC5mb3JtYXQoKTtyZXR1cm4gcmVzdWx0O312YXIgaXNTb3VyY2VBYnM9cmVzdWx0LnBhdGhuYW1lJiZyZXN1bHQucGF0aG5hbWUuY2hhckF0KDApPT09Jy8nLGlzUmVsQWJzPXJlbGF0aXZlLmhvc3R8fHJlbGF0aXZlLnBhdGhuYW1lJiZyZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCk9PT0nLycsbXVzdEVuZEFicz1pc1JlbEFic3x8aXNTb3VyY2VBYnN8fHJlc3VsdC5ob3N0JiZyZWxhdGl2ZS5wYXRobmFtZSxyZW1vdmVBbGxEb3RzPW11c3RFbmRBYnMsc3JjUGF0aD1yZXN1bHQucGF0aG5hbWUmJnJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpfHxbXSxyZWxQYXRoPXJlbGF0aXZlLnBhdGhuYW1lJiZyZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpfHxbXSxwc3ljaG90aWM9cmVzdWx0LnByb3RvY29sJiYhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07Ly8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbi8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuaWYocHN5Y2hvdGljKXtyZXN1bHQuaG9zdG5hbWU9Jyc7cmVzdWx0LnBvcnQ9bnVsbDtpZihyZXN1bHQuaG9zdCl7aWYoc3JjUGF0aFswXT09PScnKXNyY1BhdGhbMF09cmVzdWx0Lmhvc3Q7ZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO31yZXN1bHQuaG9zdD0nJztpZihyZWxhdGl2ZS5wcm90b2NvbCl7cmVsYXRpdmUuaG9zdG5hbWU9bnVsbDtyZWxhdGl2ZS5wb3J0PW51bGw7aWYocmVsYXRpdmUuaG9zdCl7aWYocmVsUGF0aFswXT09PScnKXJlbFBhdGhbMF09cmVsYXRpdmUuaG9zdDtlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTt9cmVsYXRpdmUuaG9zdD1udWxsO31tdXN0RW5kQWJzPW11c3RFbmRBYnMmJihyZWxQYXRoWzBdPT09Jyd8fHNyY1BhdGhbMF09PT0nJyk7fWlmKGlzUmVsQWJzKXsvLyBpdCdzIGFic29sdXRlLlxucmVzdWx0Lmhvc3Q9cmVsYXRpdmUuaG9zdHx8cmVsYXRpdmUuaG9zdD09PScnP3JlbGF0aXZlLmhvc3Q6cmVzdWx0Lmhvc3Q7cmVzdWx0Lmhvc3RuYW1lPXJlbGF0aXZlLmhvc3RuYW1lfHxyZWxhdGl2ZS5ob3N0bmFtZT09PScnP3JlbGF0aXZlLmhvc3RuYW1lOnJlc3VsdC5ob3N0bmFtZTtyZXN1bHQuc2VhcmNoPXJlbGF0aXZlLnNlYXJjaDtyZXN1bHQucXVlcnk9cmVsYXRpdmUucXVlcnk7c3JjUGF0aD1yZWxQYXRoOy8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxufWVsc2UgaWYocmVsUGF0aC5sZW5ndGgpey8vIGl0J3MgcmVsYXRpdmVcbi8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuaWYoIXNyY1BhdGgpc3JjUGF0aD1bXTtzcmNQYXRoLnBvcCgpO3NyY1BhdGg9c3JjUGF0aC5jb25jYXQocmVsUGF0aCk7cmVzdWx0LnNlYXJjaD1yZWxhdGl2ZS5zZWFyY2g7cmVzdWx0LnF1ZXJ5PXJlbGF0aXZlLnF1ZXJ5O31lbHNlIGlmKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpey8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbi8vIGxpa2UgaHJlZj0nP2ZvbycuXG4vLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbmlmKHBzeWNob3RpYyl7cmVzdWx0Lmhvc3RuYW1lPXJlc3VsdC5ob3N0PXNyY1BhdGguc2hpZnQoKTsvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4vL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2Vcbi8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG52YXIgYXV0aEluSG9zdD1yZXN1bHQuaG9zdCYmcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpPjA/cmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKTpmYWxzZTtpZihhdXRoSW5Ib3N0KXtyZXN1bHQuYXV0aD1hdXRoSW5Ib3N0LnNoaWZ0KCk7cmVzdWx0Lmhvc3Q9cmVzdWx0Lmhvc3RuYW1lPWF1dGhJbkhvc3Quc2hpZnQoKTt9fXJlc3VsdC5zZWFyY2g9cmVsYXRpdmUuc2VhcmNoO3Jlc3VsdC5xdWVyeT1yZWxhdGl2ZS5xdWVyeTsvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG5pZighdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKXx8IXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKXtyZXN1bHQucGF0aD0ocmVzdWx0LnBhdGhuYW1lP3Jlc3VsdC5wYXRobmFtZTonJykrKHJlc3VsdC5zZWFyY2g/cmVzdWx0LnNlYXJjaDonJyk7fXJlc3VsdC5ocmVmPXJlc3VsdC5mb3JtYXQoKTtyZXR1cm4gcmVzdWx0O31pZighc3JjUGF0aC5sZW5ndGgpey8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbi8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG5yZXN1bHQucGF0aG5hbWU9bnVsbDsvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG5pZihyZXN1bHQuc2VhcmNoKXtyZXN1bHQucGF0aD0nLycrcmVzdWx0LnNlYXJjaDt9ZWxzZXtyZXN1bHQucGF0aD1udWxsO31yZXN1bHQuaHJlZj1yZXN1bHQuZm9ybWF0KCk7cmV0dXJuIHJlc3VsdDt9Ly8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4vLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbi8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG52YXIgbGFzdD1zcmNQYXRoLnNsaWNlKC0xKVswXTt2YXIgaGFzVHJhaWxpbmdTbGFzaD0ocmVzdWx0Lmhvc3R8fHJlbGF0aXZlLmhvc3R8fHNyY1BhdGgubGVuZ3RoPjEpJiYobGFzdD09PScuJ3x8bGFzdD09PScuLicpfHxsYXN0PT09Jyc7Ly8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbnZhciB1cD0wO2Zvcih2YXIgaT1zcmNQYXRoLmxlbmd0aDtpPj0wO2ktLSl7bGFzdD1zcmNQYXRoW2ldO2lmKGxhc3Q9PT0nLicpe3NyY1BhdGguc3BsaWNlKGksMSk7fWVsc2UgaWYobGFzdD09PScuLicpe3NyY1BhdGguc3BsaWNlKGksMSk7dXArKzt9ZWxzZSBpZih1cCl7c3JjUGF0aC5zcGxpY2UoaSwxKTt1cC0tO319Ly8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuaWYoIW11c3RFbmRBYnMmJiFyZW1vdmVBbGxEb3RzKXtmb3IoO3VwLS07dXApe3NyY1BhdGgudW5zaGlmdCgnLi4nKTt9fWlmKG11c3RFbmRBYnMmJnNyY1BhdGhbMF0hPT0nJyYmKCFzcmNQYXRoWzBdfHxzcmNQYXRoWzBdLmNoYXJBdCgwKSE9PScvJykpe3NyY1BhdGgudW5zaGlmdCgnJyk7fWlmKGhhc1RyYWlsaW5nU2xhc2gmJnNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkhPT0nLycpe3NyY1BhdGgucHVzaCgnJyk7fXZhciBpc0Fic29sdXRlPXNyY1BhdGhbMF09PT0nJ3x8c3JjUGF0aFswXSYmc3JjUGF0aFswXS5jaGFyQXQoMCk9PT0nLyc7Ly8gcHV0IHRoZSBob3N0IGJhY2tcbmlmKHBzeWNob3RpYyl7cmVzdWx0Lmhvc3RuYW1lPXJlc3VsdC5ob3N0PWlzQWJzb2x1dGU/Jyc6c3JjUGF0aC5sZW5ndGg/c3JjUGF0aC5zaGlmdCgpOicnOy8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3Rcbi8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbnZhciBhdXRoSW5Ib3N0PXJlc3VsdC5ob3N0JiZyZXN1bHQuaG9zdC5pbmRleE9mKCdAJyk+MD9yZXN1bHQuaG9zdC5zcGxpdCgnQCcpOmZhbHNlO2lmKGF1dGhJbkhvc3Qpe3Jlc3VsdC5hdXRoPWF1dGhJbkhvc3Quc2hpZnQoKTtyZXN1bHQuaG9zdD1yZXN1bHQuaG9zdG5hbWU9YXV0aEluSG9zdC5zaGlmdCgpO319bXVzdEVuZEFicz1tdXN0RW5kQWJzfHxyZXN1bHQuaG9zdCYmc3JjUGF0aC5sZW5ndGg7aWYobXVzdEVuZEFicyYmIWlzQWJzb2x1dGUpe3NyY1BhdGgudW5zaGlmdCgnJyk7fWlmKCFzcmNQYXRoLmxlbmd0aCl7cmVzdWx0LnBhdGhuYW1lPW51bGw7cmVzdWx0LnBhdGg9bnVsbDt9ZWxzZXtyZXN1bHQucGF0aG5hbWU9c3JjUGF0aC5qb2luKCcvJyk7fS8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbmlmKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpfHwhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpe3Jlc3VsdC5wYXRoPShyZXN1bHQucGF0aG5hbWU/cmVzdWx0LnBhdGhuYW1lOicnKSsocmVzdWx0LnNlYXJjaD9yZXN1bHQuc2VhcmNoOicnKTt9cmVzdWx0LmF1dGg9cmVsYXRpdmUuYXV0aHx8cmVzdWx0LmF1dGg7cmVzdWx0LnNsYXNoZXM9cmVzdWx0LnNsYXNoZXN8fHJlbGF0aXZlLnNsYXNoZXM7cmVzdWx0LmhyZWY9cmVzdWx0LmZvcm1hdCgpO3JldHVybiByZXN1bHQ7fTtVcmwucHJvdG90eXBlLnBhcnNlSG9zdD1mdW5jdGlvbigpe3ZhciBob3N0PXRoaXMuaG9zdDt2YXIgcG9ydD1wb3J0UGF0dGVybi5leGVjKGhvc3QpO2lmKHBvcnQpe3BvcnQ9cG9ydFswXTtpZihwb3J0IT09JzonKXt0aGlzLnBvcnQ9cG9ydC5zdWJzdHIoMSk7fWhvc3Q9aG9zdC5zdWJzdHIoMCxob3N0Lmxlbmd0aC1wb3J0Lmxlbmd0aCk7fWlmKGhvc3QpdGhpcy5ob3N0bmFtZT1ob3N0O307fSx7XCIuL3V0aWxcIjo4MSxcInB1bnljb2RlXCI6NjQsXCJxdWVyeXN0cmluZ1wiOjY3fV0sODE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeyd1c2Ugc3RyaWN0Jzttb2R1bGUuZXhwb3J0cz17aXNTdHJpbmc6ZnVuY3Rpb24gaXNTdHJpbmcoYXJnKXtyZXR1cm4gdHlwZW9mIGFyZz09PSdzdHJpbmcnO30saXNPYmplY3Q6ZnVuY3Rpb24gaXNPYmplY3QoYXJnKXtyZXR1cm4gX3R5cGVvZihhcmcpPT09J29iamVjdCcmJmFyZyE9PW51bGw7fSxpc051bGw6ZnVuY3Rpb24gaXNOdWxsKGFyZyl7cmV0dXJuIGFyZz09PW51bGw7fSxpc051bGxPclVuZGVmaW5lZDpmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpe3JldHVybiBhcmc9PW51bGw7fX07fSx7fV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPWV4dGVuZDt2YXIgaGFzT3duUHJvcGVydHk9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiBleHRlbmQoKXt2YXIgdGFyZ2V0PXt9O2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe3ZhciBzb3VyY2U9YXJndW1lbnRzW2ldO2Zvcih2YXIga2V5IGluIHNvdXJjZSl7aWYoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2Usa2V5KSl7dGFyZ2V0W2tleV09c291cmNlW2tleV07fX19cmV0dXJuIHRhcmdldDt9fSx7fV0sODM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpey8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovdmFyIGh0bWxwYXJzZXI9cmVxdWlyZSgnaHRtbHBhcnNlcjInKTt2YXIgZXh0ZW5kPXJlcXVpcmUoJ3h0ZW5kJyk7dmFyIHF1b3RlUmVnZXhwPXJlcXVpcmUoJ2xvZGFzaC5lc2NhcGVyZWdleHAnKTt2YXIgY2xvbmVEZWVwPXJlcXVpcmUoJ2xvZGFzaC5jbG9uZWRlZXAnKTt2YXIgbWVyZ2VXaXRoPXJlcXVpcmUoJ2xvZGFzaC5tZXJnZXdpdGgnKTt2YXIgaXNTdHJpbmc9cmVxdWlyZSgnbG9kYXNoLmlzc3RyaW5nJyk7dmFyIGlzUGxhaW5PYmplY3Q9cmVxdWlyZSgnbG9kYXNoLmlzcGxhaW5vYmplY3QnKTt2YXIgc3Jjc2V0PXJlcXVpcmUoJ3NyY3NldCcpO3ZhciBwb3N0Y3NzPXJlcXVpcmUoJ3Bvc3Rjc3MnKTt2YXIgdXJsPXJlcXVpcmUoJ3VybCcpO2Z1bmN0aW9uIGVhY2gob2JqLGNiKXtpZihvYmope09iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbihrZXkpe2NiKG9ialtrZXldLGtleSk7fSk7fX0vLyBBdm9pZCBmYWxzZSBwb3NpdGl2ZXMgd2l0aCAuX19wcm90b19fLCAuaGFzT3duUHJvcGVydHksIGV0Yy5cbmZ1bmN0aW9uIGhhcyhvYmosa2V5KXtyZXR1cm57fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixrZXkpO30vLyBSZXR1cm5zIHRob3NlIGVsZW1lbnRzIG9mIGBhYCBmb3Igd2hpY2ggYGNiKGEpYCByZXR1cm5zIHRydXRoeVxuZnVuY3Rpb24gZmlsdGVyKGEsY2Ipe3ZhciBuPVtdO2VhY2goYSxmdW5jdGlvbih2KXtpZihjYih2KSl7bi5wdXNoKHYpO319KTtyZXR1cm4gbjt9ZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmope2Zvcih2YXIga2V5IGluIG9iail7aWYoaGFzKG9iaixrZXkpKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9bW9kdWxlLmV4cG9ydHM9c2FuaXRpemVIdG1sOy8vIEEgdmFsaWQgYXR0cmlidXRlIG5hbWUuXG4vLyBXZSB1c2UgYSB0b2xlcmFudCBkZWZpbml0aW9uIGJhc2VkIG9uIHRoZSBzZXQgb2Ygc3RyaW5ncyBkZWZpbmVkIGJ5XG4vLyBodG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI2JlZm9yZS1hdHRyaWJ1dGUtbmFtZS1zdGF0ZVxuLy8gYW5kIGh0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjYXR0cmlidXRlLW5hbWUtc3RhdGUgLlxuLy8gVGhlIGNoYXJhY3RlcnMgYWNjZXB0ZWQgYXJlIG9uZXMgd2hpY2ggY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSBhdHRyaWJ1dGVcbi8vIG5hbWUgYnVmZmVyIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHBhcnNlIGVycm9yOlxuLy8gICAqIHVuZXhwZWN0ZWQtZXF1YWxzLXNpZ24tYmVmb3JlLWF0dHJpYnV0ZS1uYW1lXG4vLyAgICogdW5leHBlY3RlZC1udWxsLWNoYXJhY3RlclxuLy8gICAqIHVuZXhwZWN0ZWQtY2hhcmFjdGVyLWluLWF0dHJpYnV0ZS1uYW1lXG4vLyBXZSBleGNsdWRlIHRoZSBlbXB0eSBzdHJpbmcgYmVjYXVzZSBpdCdzIGltcG9zc2libGUgdG8gZ2V0IHRvIHRoZSBhZnRlclxuLy8gYXR0cmlidXRlIG5hbWUgc3RhdGUgd2l0aCBhbiBlbXB0eSBhdHRyaWJ1dGUgbmFtZSBidWZmZXIuXG52YXIgVkFMSURfSFRNTF9BVFRSSUJVVEVfTkFNRT0vXlteXFwwXFx0XFxuXFxmXFxyIC88PT5dKyQvOy8vIElnbm9yZSB0aGUgX3JlY3Vyc2luZyBmbGFnOyBpdCdzIHRoZXJlIGZvciByZWN1cnNpdmVcbi8vIGludm9jYXRpb24gYXMgYSBndWFyZCBhZ2FpbnN0IHRoaXMgZXhwbG9pdDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYjU1L2h0bWxwYXJzZXIyL2lzc3Vlcy8xMDVcbmZ1bmN0aW9uIHNhbml0aXplSHRtbChodG1sLG9wdGlvbnMsX3JlY3Vyc2luZyl7dmFyIHJlc3VsdD0nJzsvLyBVc2VkIGZvciBob3Qgc3dhcHBpbmcgdGhlIHJlc3VsdCB2YXJpYWJsZSB3aXRoIGFuIGVtcHR5IHN0cmluZyBpbiBvcmRlciB0byBcImNhcHR1cmVcIiB0aGUgdGV4dCB3cml0dGVuIHRvIGl0LlxudmFyIHRlbXBSZXN1bHQ9Jyc7ZnVuY3Rpb24gRnJhbWUodGFnLGF0dHJpYnMpe3ZhciB0aGF0PXRoaXM7dGhpcy50YWc9dGFnO3RoaXMuYXR0cmlicz1hdHRyaWJzfHx7fTt0aGlzLnRhZ1Bvc2l0aW9uPXJlc3VsdC5sZW5ndGg7dGhpcy50ZXh0PScnOy8vIE5vZGUgaW5uZXIgdGV4dFxudGhpcy51cGRhdGVQYXJlbnROb2RlVGV4dD1mdW5jdGlvbigpe2lmKHN0YWNrLmxlbmd0aCl7dmFyIHBhcmVudEZyYW1lPXN0YWNrW3N0YWNrLmxlbmd0aC0xXTtwYXJlbnRGcmFtZS50ZXh0Kz10aGF0LnRleHQ7fX07fWlmKCFvcHRpb25zKXtvcHRpb25zPXNhbml0aXplSHRtbC5kZWZhdWx0cztvcHRpb25zLnBhcnNlcj1odG1sUGFyc2VyRGVmYXVsdHM7fWVsc2V7b3B0aW9ucz1leHRlbmQoc2FuaXRpemVIdG1sLmRlZmF1bHRzLG9wdGlvbnMpO2lmKG9wdGlvbnMucGFyc2VyKXtvcHRpb25zLnBhcnNlcj1leHRlbmQoaHRtbFBhcnNlckRlZmF1bHRzLG9wdGlvbnMucGFyc2VyKTt9ZWxzZXtvcHRpb25zLnBhcnNlcj1odG1sUGFyc2VyRGVmYXVsdHM7fX0vLyBUYWdzIHRoYXQgY29udGFpbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBIVE1MLCBvciB3aGVyZSBkaXNjYXJkaW5nXG4vLyB0aGUgdGV4dCB3aGVuIHRoZSB0YWcgaXMgZGlzYWxsb3dlZCBtYWtlcyBzZW5zZSBmb3Igb3RoZXIgcmVhc29ucy5cbi8vIElmIHdlIGFyZSBub3QgYWxsb3dpbmcgdGhlc2UgdGFncywgd2Ugc2hvdWxkIGRyb3AgdGhlaXIgY29udGVudCB0b28uXG4vLyBGb3Igb3RoZXIgdGFncyB5b3Ugd291bGQgZHJvcCB0aGUgdGFnIGJ1dCBrZWVwIGl0cyBjb250ZW50LlxudmFyIG5vblRleHRUYWdzQXJyYXk9b3B0aW9ucy5ub25UZXh0VGFnc3x8WydzY3JpcHQnLCdzdHlsZScsJ3RleHRhcmVhJ107dmFyIGFsbG93ZWRBdHRyaWJ1dGVzTWFwO3ZhciBhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXA7aWYob3B0aW9ucy5hbGxvd2VkQXR0cmlidXRlcyl7YWxsb3dlZEF0dHJpYnV0ZXNNYXA9e307YWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwPXt9O2VhY2gob3B0aW9ucy5hbGxvd2VkQXR0cmlidXRlcyxmdW5jdGlvbihhdHRyaWJ1dGVzLHRhZyl7YWxsb3dlZEF0dHJpYnV0ZXNNYXBbdGFnXT1bXTt2YXIgZ2xvYlJlZ2V4PVtdO2F0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihvYmope2lmKGlzU3RyaW5nKG9iaikmJm9iai5pbmRleE9mKCcqJyk+PTApe2dsb2JSZWdleC5wdXNoKHF1b3RlUmVnZXhwKG9iaikucmVwbGFjZSgvXFxcXFxcKi9nLCcuKicpKTt9ZWxzZXthbGxvd2VkQXR0cmlidXRlc01hcFt0YWddLnB1c2gob2JqKTt9fSk7YWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwW3RhZ109bmV3IFJlZ0V4cCgnXignK2dsb2JSZWdleC5qb2luKCd8JykrJykkJyk7fSk7fXZhciBhbGxvd2VkQ2xhc3Nlc01hcD17fTtlYWNoKG9wdGlvbnMuYWxsb3dlZENsYXNzZXMsZnVuY3Rpb24oY2xhc3Nlcyx0YWcpey8vIEltcGxpY2l0bHkgYWxsb3dzIHRoZSBjbGFzcyBhdHRyaWJ1dGVcbmlmKGFsbG93ZWRBdHRyaWJ1dGVzTWFwKXtpZighaGFzKGFsbG93ZWRBdHRyaWJ1dGVzTWFwLHRhZykpe2FsbG93ZWRBdHRyaWJ1dGVzTWFwW3RhZ109W107fWFsbG93ZWRBdHRyaWJ1dGVzTWFwW3RhZ10ucHVzaCgnY2xhc3MnKTt9YWxsb3dlZENsYXNzZXNNYXBbdGFnXT1jbGFzc2VzO30pO3ZhciB0cmFuc2Zvcm1UYWdzTWFwPXt9O3ZhciB0cmFuc2Zvcm1UYWdzQWxsO2VhY2gob3B0aW9ucy50cmFuc2Zvcm1UYWdzLGZ1bmN0aW9uKHRyYW5zZm9ybSx0YWcpe3ZhciB0cmFuc0Z1bjtpZih0eXBlb2YgdHJhbnNmb3JtPT09J2Z1bmN0aW9uJyl7dHJhbnNGdW49dHJhbnNmb3JtO31lbHNlIGlmKHR5cGVvZiB0cmFuc2Zvcm09PT1cInN0cmluZ1wiKXt0cmFuc0Z1bj1zYW5pdGl6ZUh0bWwuc2ltcGxlVHJhbnNmb3JtKHRyYW5zZm9ybSk7fWlmKHRhZz09PScqJyl7dHJhbnNmb3JtVGFnc0FsbD10cmFuc0Z1bjt9ZWxzZXt0cmFuc2Zvcm1UYWdzTWFwW3RhZ109dHJhbnNGdW47fX0pO3ZhciBkZXB0aD0wO3ZhciBzdGFjaz1bXTt2YXIgc2tpcE1hcD17fTt2YXIgdHJhbnNmb3JtTWFwPXt9O3ZhciBza2lwVGV4dD1mYWxzZTt2YXIgc2tpcFRleHREZXB0aD0wO3ZhciBwYXJzZXI9bmV3IGh0bWxwYXJzZXIuUGFyc2VyKHtvbm9wZW50YWc6ZnVuY3Rpb24gb25vcGVudGFnKG5hbWUsYXR0cmlicyl7aWYoc2tpcFRleHQpe3NraXBUZXh0RGVwdGgrKztyZXR1cm47fXZhciBmcmFtZT1uZXcgRnJhbWUobmFtZSxhdHRyaWJzKTtzdGFjay5wdXNoKGZyYW1lKTt2YXIgc2tpcD1mYWxzZTt2YXIgaGFzVGV4dD0hIWZyYW1lLnRleHQ7dmFyIHRyYW5zZm9ybWVkVGFnO2lmKGhhcyh0cmFuc2Zvcm1UYWdzTWFwLG5hbWUpKXt0cmFuc2Zvcm1lZFRhZz10cmFuc2Zvcm1UYWdzTWFwW25hbWVdKG5hbWUsYXR0cmlicyk7ZnJhbWUuYXR0cmlicz1hdHRyaWJzPXRyYW5zZm9ybWVkVGFnLmF0dHJpYnM7aWYodHJhbnNmb3JtZWRUYWcudGV4dCE9PXVuZGVmaW5lZCl7ZnJhbWUuaW5uZXJUZXh0PXRyYW5zZm9ybWVkVGFnLnRleHQ7fWlmKG5hbWUhPT10cmFuc2Zvcm1lZFRhZy50YWdOYW1lKXtmcmFtZS5uYW1lPW5hbWU9dHJhbnNmb3JtZWRUYWcudGFnTmFtZTt0cmFuc2Zvcm1NYXBbZGVwdGhdPXRyYW5zZm9ybWVkVGFnLnRhZ05hbWU7fX1pZih0cmFuc2Zvcm1UYWdzQWxsKXt0cmFuc2Zvcm1lZFRhZz10cmFuc2Zvcm1UYWdzQWxsKG5hbWUsYXR0cmlicyk7ZnJhbWUuYXR0cmlicz1hdHRyaWJzPXRyYW5zZm9ybWVkVGFnLmF0dHJpYnM7aWYobmFtZSE9PXRyYW5zZm9ybWVkVGFnLnRhZ05hbWUpe2ZyYW1lLm5hbWU9bmFtZT10cmFuc2Zvcm1lZFRhZy50YWdOYW1lO3RyYW5zZm9ybU1hcFtkZXB0aF09dHJhbnNmb3JtZWRUYWcudGFnTmFtZTt9fWlmKG9wdGlvbnMuYWxsb3dlZFRhZ3MmJm9wdGlvbnMuYWxsb3dlZFRhZ3MuaW5kZXhPZihuYW1lKT09PS0xfHxvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZT09PSdyZWN1cnNpdmVFc2NhcGUnJiYhaXNFbXB0eU9iamVjdChza2lwTWFwKSl7c2tpcD10cnVlO3NraXBNYXBbZGVwdGhdPXRydWU7aWYob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGU9PT0nZGlzY2FyZCcpe2lmKG5vblRleHRUYWdzQXJyYXkuaW5kZXhPZihuYW1lKSE9PS0xKXtza2lwVGV4dD10cnVlO3NraXBUZXh0RGVwdGg9MTt9fXNraXBNYXBbZGVwdGhdPXRydWU7fWRlcHRoKys7aWYoc2tpcCl7aWYob3B0aW9ucy5kaXNhbGxvd2VkVGFnc01vZGU9PT0nZGlzY2FyZCcpey8vIFdlIHdhbnQgdGhlIGNvbnRlbnRzIGJ1dCBub3QgdGhpcyB0YWdcbnJldHVybjt9dGVtcFJlc3VsdD1yZXN1bHQ7cmVzdWx0PScnO31yZXN1bHQrPSc8JytuYW1lO2lmKCFhbGxvd2VkQXR0cmlidXRlc01hcHx8aGFzKGFsbG93ZWRBdHRyaWJ1dGVzTWFwLG5hbWUpfHxhbGxvd2VkQXR0cmlidXRlc01hcFsnKiddKXtlYWNoKGF0dHJpYnMsZnVuY3Rpb24odmFsdWUsYSl7aWYoIVZBTElEX0hUTUxfQVRUUklCVVRFX05BTUUudGVzdChhKSl7Ly8gVGhpcyBwcmV2ZW50cyBwYXJ0IG9mIGFuIGF0dHJpYnV0ZSBuYW1lIGluIHRoZSBvdXRwdXQgZnJvbSBiZWluZ1xuLy8gaW50ZXJwcmV0ZWQgYXMgdGhlIGVuZCBvZiBhbiBhdHRyaWJ1dGUsIG9yIGVuZCBvZiBhIHRhZy5cbmRlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO3JldHVybjt9dmFyIHBhcnNlZDsvLyBjaGVjayBhbGxvd2VkQXR0cmlidXRlc01hcCBmb3IgdGhlIGVsZW1lbnQgYW5kIGF0dHJpYnV0ZSBhbmQgbW9kaWZ5IHRoZSB2YWx1ZVxuLy8gYXMgbmVjZXNzYXJ5IGlmIHRoZXJlIGFyZSBzcGVjaWZpYyB2YWx1ZXMgZGVmaW5lZC5cbnZhciBwYXNzZWRBbGxvd2VkQXR0cmlidXRlc01hcENoZWNrPWZhbHNlO2lmKCFhbGxvd2VkQXR0cmlidXRlc01hcHx8aGFzKGFsbG93ZWRBdHRyaWJ1dGVzTWFwLG5hbWUpJiZhbGxvd2VkQXR0cmlidXRlc01hcFtuYW1lXS5pbmRleE9mKGEpIT09LTF8fGFsbG93ZWRBdHRyaWJ1dGVzTWFwWycqJ10mJmFsbG93ZWRBdHRyaWJ1dGVzTWFwWycqJ10uaW5kZXhPZihhKSE9PS0xfHxoYXMoYWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwLG5hbWUpJiZhbGxvd2VkQXR0cmlidXRlc0dsb2JNYXBbbmFtZV0udGVzdChhKXx8YWxsb3dlZEF0dHJpYnV0ZXNHbG9iTWFwWycqJ10mJmFsbG93ZWRBdHRyaWJ1dGVzR2xvYk1hcFsnKiddLnRlc3QoYSkpe3Bhc3NlZEFsbG93ZWRBdHRyaWJ1dGVzTWFwQ2hlY2s9dHJ1ZTt9ZWxzZSBpZihhbGxvd2VkQXR0cmlidXRlc01hcCYmYWxsb3dlZEF0dHJpYnV0ZXNNYXBbbmFtZV0pe3ZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uPXRydWU7dmFyIF9kaWRJdGVyYXRvckVycm9yPWZhbHNlO3ZhciBfaXRlcmF0b3JFcnJvcj11bmRlZmluZWQ7dHJ5e2Zvcih2YXIgX2l0ZXJhdG9yMTA9YWxsb3dlZEF0dHJpYnV0ZXNNYXBbbmFtZV1bU3ltYm9sLml0ZXJhdG9yXSgpLF9zdGVwOyEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbj0oX3N0ZXA9X2l0ZXJhdG9yMTAubmV4dCgpKS5kb25lKTtfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uPXRydWUpe3ZhciBvPV9zdGVwLnZhbHVlO2lmKGlzUGxhaW5PYmplY3QobykmJm8ubmFtZSYmby5uYW1lPT09YSl7cGFzc2VkQWxsb3dlZEF0dHJpYnV0ZXNNYXBDaGVjaz10cnVlO3ZhciBuZXdWYWx1ZT0nJztpZihvLm11bHRpcGxlPT09dHJ1ZSl7Ly8gdmVyaWZ5IHRoZSB2YWx1ZXMgdGhhdCBhcmUgYWxsb3dlZFxudmFyIHNwbGl0U3RyQXJyYXk9dmFsdWUuc3BsaXQoJyAnKTt2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjI9dHJ1ZTt2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyPWZhbHNlO3ZhciBfaXRlcmF0b3JFcnJvcjI9dW5kZWZpbmVkO3RyeXtmb3IodmFyIF9pdGVyYXRvcjExPXNwbGl0U3RyQXJyYXlbU3ltYm9sLml0ZXJhdG9yXSgpLF9zdGVwMjshKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yPShfc3RlcDI9X2l0ZXJhdG9yMTEubmV4dCgpKS5kb25lKTtfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMj10cnVlKXt2YXIgcz1fc3RlcDIudmFsdWU7aWYoby52YWx1ZXMuaW5kZXhPZihzKSE9PS0xKXtpZihuZXdWYWx1ZT09PScnKXtuZXdWYWx1ZT1zO31lbHNle25ld1ZhbHVlKz0nICcrczt9fX19Y2F0Y2goZXJyKXtfZGlkSXRlcmF0b3JFcnJvcjI9dHJ1ZTtfaXRlcmF0b3JFcnJvcjI9ZXJyO31maW5hbGx5e3RyeXtpZighX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjImJl9pdGVyYXRvcjExW1wicmV0dXJuXCJdIT1udWxsKXtfaXRlcmF0b3IxMVtcInJldHVyblwiXSgpO319ZmluYWxseXtpZihfZGlkSXRlcmF0b3JFcnJvcjIpe3Rocm93IF9pdGVyYXRvckVycm9yMjt9fX19ZWxzZSBpZihvLnZhbHVlcy5pbmRleE9mKHZhbHVlKT49MCl7Ly8gdmVyaWZpZWQgYW4gYWxsb3dlZCB2YWx1ZSBtYXRjaGVzIHRoZSBlbnRpcmUgYXR0cmlidXRlIHZhbHVlXG5uZXdWYWx1ZT12YWx1ZTt9dmFsdWU9bmV3VmFsdWU7fX19Y2F0Y2goZXJyKXtfZGlkSXRlcmF0b3JFcnJvcj10cnVlO19pdGVyYXRvckVycm9yPWVycjt9ZmluYWxseXt0cnl7aWYoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24mJl9pdGVyYXRvcjEwW1wicmV0dXJuXCJdIT1udWxsKXtfaXRlcmF0b3IxMFtcInJldHVyblwiXSgpO319ZmluYWxseXtpZihfZGlkSXRlcmF0b3JFcnJvcil7dGhyb3cgX2l0ZXJhdG9yRXJyb3I7fX19fWlmKHBhc3NlZEFsbG93ZWRBdHRyaWJ1dGVzTWFwQ2hlY2spe2lmKG9wdGlvbnMuYWxsb3dlZFNjaGVtZXNBcHBsaWVkVG9BdHRyaWJ1dGVzLmluZGV4T2YoYSkhPT0tMSl7aWYobmF1Z2h0eUhyZWYobmFtZSx2YWx1ZSkpe2RlbGV0ZSBmcmFtZS5hdHRyaWJzW2FdO3JldHVybjt9fWlmKG5hbWU9PT0naWZyYW1lJyYmYT09PSdzcmMnKXt2YXIgYWxsb3dlZD10cnVlO3RyeXsvLyBuYXVnaHR5SHJlZiBpcyBpbiBjaGFyZ2Ugb2Ygd2hldGhlciBwcm90b2NvbCByZWxhdGl2ZSBVUkxzXG4vLyBhcmUgY29vbC4gV2Ugc2hvdWxkIGp1c3QgYWNjZXB0IHRoZW1cbnBhcnNlZD11cmwucGFyc2UodmFsdWUsZmFsc2UsdHJ1ZSk7dmFyIGlzUmVsYXRpdmVVcmw9cGFyc2VkJiZwYXJzZWQuaG9zdD09PW51bGwmJnBhcnNlZC5wcm90b2NvbD09PW51bGw7aWYoaXNSZWxhdGl2ZVVybCl7Ly8gZGVmYXVsdCB2YWx1ZSBvZiBhbGxvd0lmcmFtZVJlbGF0aXZlVXJscyBpcyB0cnVlIHVubGVzcyBhbGxvd0lmcmFtZUhvc3RuYW1lcyBzcGVjaWZpZWRcbmFsbG93ZWQ9aGFzKG9wdGlvbnMsXCJhbGxvd0lmcmFtZVJlbGF0aXZlVXJsc1wiKT9vcHRpb25zLmFsbG93SWZyYW1lUmVsYXRpdmVVcmxzOiFvcHRpb25zLmFsbG93ZWRJZnJhbWVIb3N0bmFtZXM7fWVsc2UgaWYob3B0aW9ucy5hbGxvd2VkSWZyYW1lSG9zdG5hbWVzKXthbGxvd2VkPW9wdGlvbnMuYWxsb3dlZElmcmFtZUhvc3RuYW1lcy5maW5kKGZ1bmN0aW9uKGhvc3RuYW1lKXtyZXR1cm4gaG9zdG5hbWU9PT1wYXJzZWQuaG9zdG5hbWU7fSk7fX1jYXRjaChlKXsvLyBVbnBhcnNlYWJsZSBpZnJhbWUgc3JjXG5hbGxvd2VkPWZhbHNlO31pZighYWxsb3dlZCl7ZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07cmV0dXJuO319aWYoYT09PSdzcmNzZXQnKXt0cnl7cGFyc2VkPXNyY3NldC5wYXJzZSh2YWx1ZSk7ZWFjaChwYXJzZWQsZnVuY3Rpb24odmFsdWUpe2lmKG5hdWdodHlIcmVmKCdzcmNzZXQnLHZhbHVlLnVybCkpe3ZhbHVlLmV2aWw9dHJ1ZTt9fSk7cGFyc2VkPWZpbHRlcihwYXJzZWQsZnVuY3Rpb24odil7cmV0dXJuIXYuZXZpbDt9KTtpZighcGFyc2VkLmxlbmd0aCl7ZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07cmV0dXJuO31lbHNle3ZhbHVlPXNyY3NldC5zdHJpbmdpZnkoZmlsdGVyKHBhcnNlZCxmdW5jdGlvbih2KXtyZXR1cm4hdi5ldmlsO30pKTtmcmFtZS5hdHRyaWJzW2FdPXZhbHVlO319Y2F0Y2goZSl7Ly8gVW5wYXJzZWFibGUgc3Jjc2V0XG5kZWxldGUgZnJhbWUuYXR0cmlic1thXTtyZXR1cm47fX1pZihhPT09J2NsYXNzJyl7dmFsdWU9ZmlsdGVyQ2xhc3Nlcyh2YWx1ZSxhbGxvd2VkQ2xhc3Nlc01hcFtuYW1lXSk7aWYoIXZhbHVlLmxlbmd0aCl7ZGVsZXRlIGZyYW1lLmF0dHJpYnNbYV07cmV0dXJuO319aWYoYT09PSdzdHlsZScpe3RyeXt2YXIgYWJzdHJhY3RTeW50YXhUcmVlPXBvc3Rjc3MucGFyc2UobmFtZStcIiB7XCIrdmFsdWUrXCJ9XCIpO3ZhciBmaWx0ZXJlZEFTVD1maWx0ZXJDc3MoYWJzdHJhY3RTeW50YXhUcmVlLG9wdGlvbnMuYWxsb3dlZFN0eWxlcyk7dmFsdWU9c3RyaW5naWZ5U3R5bGVBdHRyaWJ1dGVzKGZpbHRlcmVkQVNUKTtpZih2YWx1ZS5sZW5ndGg9PT0wKXtkZWxldGUgZnJhbWUuYXR0cmlic1thXTtyZXR1cm47fX1jYXRjaChlKXtkZWxldGUgZnJhbWUuYXR0cmlic1thXTtyZXR1cm47fX1yZXN1bHQrPScgJythO2lmKHZhbHVlJiZ2YWx1ZS5sZW5ndGgpe3Jlc3VsdCs9Jz1cIicrZXNjYXBlSHRtbCh2YWx1ZSx0cnVlKSsnXCInO319ZWxzZXtkZWxldGUgZnJhbWUuYXR0cmlic1thXTt9fSk7fWlmKG9wdGlvbnMuc2VsZkNsb3NpbmcuaW5kZXhPZihuYW1lKSE9PS0xKXtyZXN1bHQrPVwiIC8+XCI7fWVsc2V7cmVzdWx0Kz1cIj5cIjtpZihmcmFtZS5pbm5lclRleHQmJiFoYXNUZXh0JiYhb3B0aW9ucy50ZXh0RmlsdGVyKXtyZXN1bHQrPWZyYW1lLmlubmVyVGV4dDt9fWlmKHNraXApe3Jlc3VsdD10ZW1wUmVzdWx0K2VzY2FwZUh0bWwocmVzdWx0KTt0ZW1wUmVzdWx0PScnO319LG9udGV4dDpmdW5jdGlvbiBvbnRleHQodGV4dCl7aWYoc2tpcFRleHQpe3JldHVybjt9dmFyIGxhc3RGcmFtZT1zdGFja1tzdGFjay5sZW5ndGgtMV07dmFyIHRhZztpZihsYXN0RnJhbWUpe3RhZz1sYXN0RnJhbWUudGFnOy8vIElmIGlubmVyIHRleHQgd2FzIHNldCBieSB0cmFuc2Zvcm0gZnVuY3Rpb24gdGhlbiBsZXQncyB1c2UgaXRcbnRleHQ9bGFzdEZyYW1lLmlubmVyVGV4dCE9PXVuZGVmaW5lZD9sYXN0RnJhbWUuaW5uZXJUZXh0OnRleHQ7fWlmKG9wdGlvbnMuZGlzYWxsb3dlZFRhZ3NNb2RlPT09J2Rpc2NhcmQnJiYodGFnPT09J3NjcmlwdCd8fHRhZz09PSdzdHlsZScpKXsvLyBodG1scGFyc2VyMiBnaXZlcyB1cyB0aGVzZSBhcy1pcy4gRXNjYXBpbmcgdGhlbSBydWlucyB0aGUgY29udGVudC4gQWxsb3dpbmdcbi8vIHNjcmlwdCB0YWdzIGlzLCBieSBkZWZpbml0aW9uLCBnYW1lIG92ZXIgZm9yIFhTUyBwcm90ZWN0aW9uLCBzbyBpZiB0aGF0J3Ncbi8vIHlvdXIgY29uY2VybiwgZG9uJ3QgYWxsb3cgdGhlbS4gVGhlIHNhbWUgaXMgZXNzZW50aWFsbHkgdHJ1ZSBmb3Igc3R5bGUgdGFnc1xuLy8gd2hpY2ggaGF2ZSB0aGVpciBvd24gY29sbGVjdGlvbiBvZiBYU1MgdmVjdG9ycy5cbnJlc3VsdCs9dGV4dDt9ZWxzZXt2YXIgZXNjYXBlZD1lc2NhcGVIdG1sKHRleHQsZmFsc2UpO2lmKG9wdGlvbnMudGV4dEZpbHRlcil7cmVzdWx0Kz1vcHRpb25zLnRleHRGaWx0ZXIoZXNjYXBlZCx0YWcpO31lbHNle3Jlc3VsdCs9ZXNjYXBlZDt9fWlmKHN0YWNrLmxlbmd0aCl7dmFyIGZyYW1lPXN0YWNrW3N0YWNrLmxlbmd0aC0xXTtmcmFtZS50ZXh0Kz10ZXh0O319LG9uY2xvc2V0YWc6ZnVuY3Rpb24gb25jbG9zZXRhZyhuYW1lKXtpZihza2lwVGV4dCl7c2tpcFRleHREZXB0aC0tO2lmKCFza2lwVGV4dERlcHRoKXtza2lwVGV4dD1mYWxzZTt9ZWxzZXtyZXR1cm47fX12YXIgZnJhbWU9c3RhY2sucG9wKCk7aWYoIWZyYW1lKXsvLyBEbyBub3QgY3Jhc2ggb24gYmFkIG1hcmt1cFxucmV0dXJuO31za2lwVGV4dD1mYWxzZTtkZXB0aC0tO3ZhciBza2lwPXNraXBNYXBbZGVwdGhdO2lmKHNraXApe2RlbGV0ZSBza2lwTWFwW2RlcHRoXTtpZihvcHRpb25zLmRpc2FsbG93ZWRUYWdzTW9kZT09PSdkaXNjYXJkJyl7ZnJhbWUudXBkYXRlUGFyZW50Tm9kZVRleHQoKTtyZXR1cm47fXRlbXBSZXN1bHQ9cmVzdWx0O3Jlc3VsdD0nJzt9aWYodHJhbnNmb3JtTWFwW2RlcHRoXSl7bmFtZT10cmFuc2Zvcm1NYXBbZGVwdGhdO2RlbGV0ZSB0cmFuc2Zvcm1NYXBbZGVwdGhdO31pZihvcHRpb25zLmV4Y2x1c2l2ZUZpbHRlciYmb3B0aW9ucy5leGNsdXNpdmVGaWx0ZXIoZnJhbWUpKXtyZXN1bHQ9cmVzdWx0LnN1YnN0cigwLGZyYW1lLnRhZ1Bvc2l0aW9uKTtyZXR1cm47fWZyYW1lLnVwZGF0ZVBhcmVudE5vZGVUZXh0KCk7aWYob3B0aW9ucy5zZWxmQ2xvc2luZy5pbmRleE9mKG5hbWUpIT09LTEpey8vIEFscmVhZHkgb3V0cHV0IC8+XG5yZXR1cm47fXJlc3VsdCs9XCI8L1wiK25hbWUrXCI+XCI7aWYoc2tpcCl7cmVzdWx0PXRlbXBSZXN1bHQrZXNjYXBlSHRtbChyZXN1bHQpO3RlbXBSZXN1bHQ9Jyc7fX19LG9wdGlvbnMucGFyc2VyKTtwYXJzZXIud3JpdGUoaHRtbCk7cGFyc2VyLmVuZCgpO3JldHVybiByZXN1bHQ7ZnVuY3Rpb24gZXNjYXBlSHRtbChzLHF1b3RlKXtpZih0eXBlb2YgcyE9PSdzdHJpbmcnKXtzPXMrJyc7fWlmKG9wdGlvbnMucGFyc2VyLmRlY29kZUVudGl0aWVzKXtzPXMucmVwbGFjZSgvJi9nLCcmYW1wOycpLnJlcGxhY2UoLzwvZywnJmx0OycpLnJlcGxhY2UoL1xcPi9nLCcmZ3Q7Jyk7aWYocXVvdGUpe3M9cy5yZXBsYWNlKC9cXFwiL2csJyZxdW90OycpO319Ly8gVE9ETzogdGhpcyBpcyBpbmFkZXF1YXRlIGJlY2F1c2UgaXQgd2lsbCBwYXNzIGAmMDtgLiBUaGlzIGFwcHJvYWNoXG4vLyB3aWxsIG5vdCB3b3JrLCBlYWNoICYgbXVzdCBiZSBjb25zaWRlcmVkIHdpdGggcmVnYXJkIHRvIHdoZXRoZXIgaXRcbi8vIGlzIGZvbGxvd2VkIGJ5IGEgMTAwJSBzeW50YWN0aWNhbGx5IHZhbGlkIGVudGl0eSBvciBub3QsIGFuZCBlc2NhcGVkXG4vLyBpZiBpdCBpcyBub3QuIElmIHRoaXMgYm90aGVycyB5b3UsIGRvbid0IHNldCBwYXJzZXIuZGVjb2RlRW50aXRpZXNcbi8vIHRvIGZhbHNlLiAoVGhlIGRlZmF1bHQgaXMgdHJ1ZS4pXG5zPXMucmVwbGFjZSgvJig/IVthLXpBLVowLTkjXXsxLDIwfTspL2csJyZhbXA7JykvLyBNYXRjaCBhbXBlcnNhbmRzIG5vdCBwYXJ0IG9mIGV4aXN0aW5nIEhUTUwgZW50aXR5XG4ucmVwbGFjZSgvPC9nLCcmbHQ7JykucmVwbGFjZSgvXFw+L2csJyZndDsnKTtpZihxdW90ZSl7cz1zLnJlcGxhY2UoL1xcXCIvZywnJnF1b3Q7Jyk7fXJldHVybiBzO31mdW5jdGlvbiBuYXVnaHR5SHJlZihuYW1lLGhyZWYpey8vIEJyb3dzZXJzIGlnbm9yZSBjaGFyYWN0ZXIgY29kZXMgb2YgMzIgKHNwYWNlKSBhbmQgYmVsb3cgaW4gYSBzdXJwcmlzaW5nXG4vLyBudW1iZXIgb2Ygc2l0dWF0aW9ucy4gU3RhcnQgcmVhZGluZyBoZXJlOlxuLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXQjRW1iZWRkZWRfdGFiXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuaHJlZj1ocmVmLnJlcGxhY2UoL1tcXHgwMC1cXHgyMF0rL2csJycpOy8vIENsb2JiZXIgYW55IGNvbW1lbnRzIGluIFVSTHMsIHdoaWNoIHRoZSBicm93c2VyIG1pZ2h0XG4vLyBpbnRlcnByZXQgaW5zaWRlIGFuIFhNTCBkYXRhIGlzbGFuZCwgYWxsb3dpbmdcbi8vIGEgamF2YXNjcmlwdDogVVJMIHRvIGJlIHNudWNrIHRocm91Z2hcbmhyZWY9aHJlZi5yZXBsYWNlKC88XFwhXFwtXFwtLio/XFwtXFwtXFw+L2csJycpOy8vIENhc2UgaW5zZW5zaXRpdmUgc28gd2UgZG9uJ3QgZ2V0IGZha2VkIG91dCBieSBKQVZBU0NSSVBUICMxXG52YXIgbWF0Y2hlcz1ocmVmLm1hdGNoKC9eKFthLXpBLVpdKylcXDovKTtpZighbWF0Y2hlcyl7Ly8gUHJvdG9jb2wtcmVsYXRpdmUgVVJMIHN0YXJ0aW5nIHdpdGggYW55IGNvbWJpbmF0aW9uIG9mICcvJyBhbmQgJ1xcJ1xuaWYoaHJlZi5tYXRjaCgvXltcXC9cXFxcXXsyfS8pKXtyZXR1cm4hb3B0aW9ucy5hbGxvd1Byb3RvY29sUmVsYXRpdmU7fS8vIE5vIHNjaGVtZVxucmV0dXJuIGZhbHNlO312YXIgc2NoZW1lPW1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtpZihoYXMob3B0aW9ucy5hbGxvd2VkU2NoZW1lc0J5VGFnLG5hbWUpKXtyZXR1cm4gb3B0aW9ucy5hbGxvd2VkU2NoZW1lc0J5VGFnW25hbWVdLmluZGV4T2Yoc2NoZW1lKT09PS0xO31yZXR1cm4hb3B0aW9ucy5hbGxvd2VkU2NoZW1lc3x8b3B0aW9ucy5hbGxvd2VkU2NoZW1lcy5pbmRleE9mKHNjaGVtZSk9PT0tMTt9LyoqXG4gICAqIEZpbHRlcnMgdXNlciBpbnB1dCBjc3MgcHJvcGVydGllcyBieSB3aGl0ZWxpc3RlZCByZWdleCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYWJzdHJhY3RTeW50YXhUcmVlICAtIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBDU1MgYXR0cmlidXRlcy5cbiAgICogQHByb3BlcnR5IHthcnJheVtEZWNsYXJhdGlvbl19IGFic3RyYWN0U3ludGF4VHJlZS5ub2Rlc1swXSAtIEVhY2ggb2JqZWN0IGNvaW50YWlucyBwcm9wIGFuZCB2YWx1ZSBrZXksIGkuZSB7IHByb3A6ICdjb2xvcicsIHZhbHVlOiAncmVkJyB9LlxuICAgKiBAcGFyYW0ge29iamVjdH0gYWxsb3dlZFN0eWxlcyAgICAgICAtIEtleXMgYXJlIHByb3BlcnRpZXMgKGkuZSBjb2xvciksIHZhbHVlIGlzIGxpc3Qgb2YgcGVybWl0dGVkIHJlZ2V4IHJ1bGVzIChpLmUgL2dyZWVuL2kpLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAtIEFic3RyYWN0IFN5bnRheCBUcmVlIHdpdGggZmlsdGVyZWQgc3R5bGUgYXR0cmlidXRlcy5cbiAgICovZnVuY3Rpb24gZmlsdGVyQ3NzKGFic3RyYWN0U3ludGF4VHJlZSxhbGxvd2VkU3R5bGVzKXtpZighYWxsb3dlZFN0eWxlcyl7cmV0dXJuIGFic3RyYWN0U3ludGF4VHJlZTt9dmFyIGZpbHRlcmVkQVNUPWNsb25lRGVlcChhYnN0cmFjdFN5bnRheFRyZWUpO3ZhciBhc3RSdWxlcz1hYnN0cmFjdFN5bnRheFRyZWUubm9kZXNbMF07dmFyIHNlbGVjdGVkUnVsZTsvLyBNZXJnZSBnbG9iYWwgYW5kIHRhZy1zcGVjaWZpYyBzdHlsZXMgaW50byBuZXcgQVNULlxuaWYoYWxsb3dlZFN0eWxlc1thc3RSdWxlcy5zZWxlY3Rvcl0mJmFsbG93ZWRTdHlsZXNbJyonXSl7c2VsZWN0ZWRSdWxlPW1lcmdlV2l0aChjbG9uZURlZXAoYWxsb3dlZFN0eWxlc1thc3RSdWxlcy5zZWxlY3Rvcl0pLGFsbG93ZWRTdHlsZXNbJyonXSxmdW5jdGlvbihvYmpWYWx1ZSxzcmNWYWx1ZSl7aWYoQXJyYXkuaXNBcnJheShvYmpWYWx1ZSkpe3JldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO319KTt9ZWxzZXtzZWxlY3RlZFJ1bGU9YWxsb3dlZFN0eWxlc1thc3RSdWxlcy5zZWxlY3Rvcl18fGFsbG93ZWRTdHlsZXNbJyonXTt9aWYoc2VsZWN0ZWRSdWxlKXtmaWx0ZXJlZEFTVC5ub2Rlc1swXS5ub2Rlcz1hc3RSdWxlcy5ub2Rlcy5yZWR1Y2UoZmlsdGVyRGVjbGFyYXRpb25zKHNlbGVjdGVkUnVsZSksW10pO31yZXR1cm4gZmlsdGVyZWRBU1Q7fS8qKlxuICAgKiBFeHRyYWN0cyB0aGUgc3R5bGUgYXR0cmlidWVzIGZyb20gYW4gQWJzdHJhY3RTeW50YXhUcmVlIGFuZCBmb3JtYXRzIHRob3NlXG4gICAqIHZhbHVlcyBpbiB0aGUgaW5saW5lIHN0eWxlIGF0dHJpYnV0ZSBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSAge0Fic3RyYWN0U3ludGF4VHJlZX0gZmlsdGVyZWRBU1RcbiAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAtIEV4YW1wbGU6IFwiY29sb3I6eWVsbG93O3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtZmFtaWx5OmhlbHZldGljYTtcIlxuICAgKi9mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZUF0dHJpYnV0ZXMoZmlsdGVyZWRBU1Qpe3JldHVybiBmaWx0ZXJlZEFTVC5ub2Rlc1swXS5ub2Rlcy5yZWR1Y2UoZnVuY3Rpb24oZXh0cmFjdGVkQXR0cmlidXRlcyxhdHRyaWJ1dGVPYmplY3Qpe2V4dHJhY3RlZEF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGVPYmplY3QucHJvcCsnOicrYXR0cmlidXRlT2JqZWN0LnZhbHVlKTtyZXR1cm4gZXh0cmFjdGVkQXR0cmlidXRlczt9LFtdKS5qb2luKCc7Jyk7fS8qKlxuICAgICogRmlsdGVycyB0aGUgZXhpc3RpbmcgYXR0cmlidXRlcyBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LiBEaXNjYXJkcyBhbnkgYXR0cmlidXRlc1xuICAgICogd2hpY2ggZG9uJ3QgbWF0Y2ggdGhlIHdoaXRlbGlzdC5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtvYmplY3R9IHNlbGVjdGVkUnVsZSAgICAgICAgICAgICAtIEV4YW1wbGU6IHsgY29sb3I6IHJlZCwgZm9udC1mYW1pbHk6IGhlbHZldGljYSB9XG4gICAgKiBAcGFyYW0gIHthcnJheX0gYWxsb3dlZERlY2xhcmF0aW9uc0xpc3QgICAtIExpc3Qgb2YgZGVjbGFyYXRpb25zIHdoaWNoIHBhc3Mgd2hpdGVsaXN0aW5nLlxuICAgICogQHBhcmFtICB7b2JqZWN0fSBhdHRyaWJ1dGVPYmplY3QgICAgICAgICAgLSBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGNzcyBwcm9wZXJ0eS5cbiAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyaWJ1dGVPYmplY3QudHlwZSAgIC0gVHlwaWNhbGx5ICdkZWNsYXJhdGlvbicuXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gYXR0cmlidXRlT2JqZWN0LnByb3AgICAtIFRoZSBDU1MgcHJvcGVydHksIGkuZSAnY29sb3InLlxuICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHJpYnV0ZU9iamVjdC52YWx1ZSAgLSBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSB0byB0aGUgY3NzIHByb3BlcnR5LCBpLmUgJ3JlZCcuXG4gICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgICAgICAtIFdoZW4gdXNlZCBpbiBBcnJheS5yZWR1Y2UsIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIERlY2xhcmF0aW9uIG9iamVjdHNcbiAgICAqL2Z1bmN0aW9uIGZpbHRlckRlY2xhcmF0aW9ucyhzZWxlY3RlZFJ1bGUpe3JldHVybiBmdW5jdGlvbihhbGxvd2VkRGVjbGFyYXRpb25zTGlzdCxhdHRyaWJ1dGVPYmplY3Qpey8vIElmIHRoaXMgcHJvcGVydHkgaXMgd2hpdGVsaXN0ZWQuLi5cbmlmKHNlbGVjdGVkUnVsZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVPYmplY3QucHJvcCkpe3ZhciBtYXRjaGVzUmVnZXg9c2VsZWN0ZWRSdWxlW2F0dHJpYnV0ZU9iamVjdC5wcm9wXS5zb21lKGZ1bmN0aW9uKHJlZ3VsYXJFeHByZXNzaW9uKXtyZXR1cm4gcmVndWxhckV4cHJlc3Npb24udGVzdChhdHRyaWJ1dGVPYmplY3QudmFsdWUpO30pO2lmKG1hdGNoZXNSZWdleCl7YWxsb3dlZERlY2xhcmF0aW9uc0xpc3QucHVzaChhdHRyaWJ1dGVPYmplY3QpO319cmV0dXJuIGFsbG93ZWREZWNsYXJhdGlvbnNMaXN0O307fWZ1bmN0aW9uIGZpbHRlckNsYXNzZXMoY2xhc3NlcyxhbGxvd2VkKXtpZighYWxsb3dlZCl7Ly8gVGhlIGNsYXNzIGF0dHJpYnV0ZSBpcyBhbGxvd2VkIHdpdGhvdXQgZmlsdGVyaW5nIG9uIHRoaXMgdGFnXG5yZXR1cm4gY2xhc3Nlczt9Y2xhc3Nlcz1jbGFzc2VzLnNwbGl0KC9cXHMrLyk7cmV0dXJuIGNsYXNzZXMuZmlsdGVyKGZ1bmN0aW9uKGNsc3Mpe3JldHVybiBhbGxvd2VkLmluZGV4T2YoY2xzcykhPT0tMTt9KS5qb2luKCcgJyk7fX0vLyBEZWZhdWx0cyBhcmUgYWNjZXNzaWJsZSB0byB5b3Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGVtIGFzIGEgc3RhcnRpbmcgcG9pbnRcbi8vIHByb2dyYW1tYXRpY2FsbHkgaWYgeW91IHdpc2hcbnZhciBodG1sUGFyc2VyRGVmYXVsdHM9e2RlY29kZUVudGl0aWVzOnRydWV9O3Nhbml0aXplSHRtbC5kZWZhdWx0cz17YWxsb3dlZFRhZ3M6WydoMycsJ2g0JywnaDUnLCdoNicsJ2Jsb2NrcXVvdGUnLCdwJywnYScsJ3VsJywnb2wnLCdubCcsJ2xpJywnYicsJ2knLCdzdHJvbmcnLCdlbScsJ3N0cmlrZScsJ2NvZGUnLCdocicsJ2JyJywnZGl2JywndGFibGUnLCd0aGVhZCcsJ2NhcHRpb24nLCd0Ym9keScsJ3RyJywndGgnLCd0ZCcsJ3ByZScsJ2lmcmFtZSddLGRpc2FsbG93ZWRUYWdzTW9kZTonZGlzY2FyZCcsYWxsb3dlZEF0dHJpYnV0ZXM6e2E6WydocmVmJywnbmFtZScsJ3RhcmdldCddLC8vIFdlIGRvbid0IGN1cnJlbnRseSBhbGxvdyBpbWcgaXRzZWxmIGJ5IGRlZmF1bHQsIGJ1dCB0aGlzXG4vLyB3b3VsZCBtYWtlIHNlbnNlIGlmIHdlIGRpZC4gWW91IGNvdWxkIGFkZCBzcmNzZXQgaGVyZSxcbi8vIGFuZCBpZiB5b3UgZG8gdGhlIFVSTCBpcyBjaGVja2VkIGZvciBzYWZldHlcbmltZzpbJ3NyYyddfSwvLyBMb3RzIG9mIHRoZXNlIHdvbid0IGNvbWUgdXAgYnkgZGVmYXVsdCBiZWNhdXNlIHdlIGRvbid0IGFsbG93IHRoZW1cbnNlbGZDbG9zaW5nOlsnaW1nJywnYnInLCdocicsJ2FyZWEnLCdiYXNlJywnYmFzZWZvbnQnLCdpbnB1dCcsJ2xpbmsnLCdtZXRhJ10sLy8gVVJMIHNjaGVtZXMgd2UgcGVybWl0XG5hbGxvd2VkU2NoZW1lczpbJ2h0dHAnLCdodHRwcycsJ2Z0cCcsJ21haWx0byddLGFsbG93ZWRTY2hlbWVzQnlUYWc6e30sYWxsb3dlZFNjaGVtZXNBcHBsaWVkVG9BdHRyaWJ1dGVzOlsnaHJlZicsJ3NyYycsJ2NpdGUnXSxhbGxvd1Byb3RvY29sUmVsYXRpdmU6dHJ1ZX07c2FuaXRpemVIdG1sLnNpbXBsZVRyYW5zZm9ybT1mdW5jdGlvbihuZXdUYWdOYW1lLG5ld0F0dHJpYnMsbWVyZ2Upe21lcmdlPW1lcmdlPT09dW5kZWZpbmVkP3RydWU6bWVyZ2U7bmV3QXR0cmlicz1uZXdBdHRyaWJzfHx7fTtyZXR1cm4gZnVuY3Rpb24odGFnTmFtZSxhdHRyaWJzKXt2YXIgYXR0cmliO2lmKG1lcmdlKXtmb3IoYXR0cmliIGluIG5ld0F0dHJpYnMpe2F0dHJpYnNbYXR0cmliXT1uZXdBdHRyaWJzW2F0dHJpYl07fX1lbHNle2F0dHJpYnM9bmV3QXR0cmliczt9cmV0dXJue3RhZ05hbWU6bmV3VGFnTmFtZSxhdHRyaWJzOmF0dHJpYnN9O307fTt9LHtcImh0bWxwYXJzZXIyXCI6MzEsXCJsb2Rhc2guY2xvbmVkZWVwXCI6MzMsXCJsb2Rhc2guZXNjYXBlcmVnZXhwXCI6MzQsXCJsb2Rhc2guaXNwbGFpbm9iamVjdFwiOjM1LFwibG9kYXNoLmlzc3RyaW5nXCI6MzYsXCJsb2Rhc2gubWVyZ2V3aXRoXCI6MzcsXCJwb3N0Y3NzXCI6NTEsXCJzcmNzZXRcIjo3OSxcInVybFwiOjgwLFwieHRlbmRcIjo4Mn1dfSx7fSxbODNdKSg4Myk7fSk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgc2FuaXRpemVIdG1sIGZyb20gJ3Nhbml0aXplLWh0bWwnO1xuXG4vKipcbiAqIFdvcmRQcmVzcyBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgX18gfSBmcm9tICdAd29yZHByZXNzL2kxOG4nO1xuXG5pbXBvcnQgeyBhdXRvcCB9IGZyb20gJ0B3b3JkcHJlc3MvYXV0b3AnO1xuXG5pbXBvcnQgeyBSaWNoVGV4dCB9IGZyb20gJ0B3b3JkcHJlc3MvYmxvY2stZWRpdG9yJztcblxuaW1wb3J0IHtcblx0X19leHBlcmltZW50YWxHZXRTZXR0aW5ncyxcblx0ZGF0ZUkxOG4sXG5cdGZvcm1hdCBhcyBmb3JtYXREYXRlLFxufSBmcm9tICdAd29yZHByZXNzL2RhdGUnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgcmVuZGVyVGVtcGxhdGUgZnJvbSAnLi4vLi4vdXRpbHMvcmVuZGVyVGVtcGxhdGUnO1xuaW1wb3J0IHsgcGxhaW5UZXh0IH0gZnJvbSAnLi4vLi4vY29uZmlnL2h0bWwnO1xuXG4vKipcbiAqIFJlbmRlcnMgYW4gaW5kaXZpZHVhbCBmaWVsZCB0byBiZSB1c2VkIGluIGEgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkIEZpZWxkIGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyBBbGwgYmxvY2sgYXR0cmlidXRlcy5cbiAqL1xuY29uc3QgcmVuZGVyRmllbGQgPSAoIGZpZWxkLCBhdHRyaWJ1dGVzICkgPT4ge1xuXHRjb25zdCB7XG5cdFx0bmFtZSxcblx0XHRmaWVsZE9wdGlvbnMsXG5cdFx0dHlwZSxcblx0fSA9IGZpZWxkO1xuXHRjb25zdCBmaWVsZFZhbHVlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdGlmICggJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiBmaWVsZFZhbHVlICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0c3dpdGNoICggdHlwZSApIHtcblx0XHRjYXNlICdUZXh0Q29udHJvbCc6IHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxkaXYga2V5PXsgbmFtZSB9IGNsYXNzTmFtZT1cImZpZWxkLS10ZXh0Y29udHJvbFwiPlxuXHRcdFx0XHRcdHsgc2FuaXRpemVIdG1sKCBmaWVsZFZhbHVlLCBwbGFpblRleHQgKSB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSAnVGV4dGFyZWFDb250cm9sJzoge1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRhdXRvX3A6IHNob3VsZEF1dG9QLFxuXHRcdFx0fSA9IGZpZWxkT3B0aW9ucztcblxuXHRcdFx0Y29uc3Qgc2FuaXRpemVkVGV4dCA9IHNhbml0aXplSHRtbCggZmllbGRWYWx1ZSwgcGxhaW5UZXh0ICk7XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRrZXk9eyBuYW1lIH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJmaWVsZC0tdGV4dGFyZWFjb250cm9sXCJcblx0XHRcdFx0XHRkYW5nZXJvdXNseVNldElubmVySFRNTD17IHtcblx0XHRcdFx0XHRcdF9faHRtbDogc2hvdWxkQXV0b1AgPyBhdXRvcCggc2FuaXRpemVkVGV4dCApIDogc2FuaXRpemVkVGV4dCxcblx0XHRcdFx0XHR9IH1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhc2UgJ1JpY2hUZXh0Jzoge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PFJpY2hUZXh0LkNvbnRlbnRcblx0XHRcdFx0XHRrZXk9eyBuYW1lIH1cblx0XHRcdFx0XHR0YWdOYW1lPSdwJ1xuXHRcdFx0XHRcdHZhbHVlPXsgZmllbGRWYWx1ZSB9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiZmllbGQtLXJpY2h0ZXh0XCJcblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhc2UgJ0NoZWNrYm94Q29udHJvbCc6IHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxkaXYga2V5PXsgbmFtZSB9IGNsYXNzTmFtZT1cImZpZWxkLS1jaGVja2JveFwiPlxuXHRcdFx0XHRcdHsgZmllbGRWYWx1ZSA/IF9fKCAnWWVzJyApIDogX18oICdObycgKSB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSAnQ2hlY2tib3hHcm91cCc6IHtcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdH0gPSBmaWVsZE9wdGlvbnM7XG5cblx0XHRcdGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoIGZpZWxkVmFsdWUgKVxuXHRcdFx0XHQ/IGZpZWxkVmFsdWUuZmlsdGVyKCB2YWx1ZSA9PiAhISB2YWx1ZS5jaGVja2VkIClcblx0XHRcdFx0OiBbXTtcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdiBrZXk9eyBuYW1lIH0gY2xhc3NOYW1lPVwiZmllbGQtLWNoZWNrYm94LWdyb3VwXCI+XG5cdFx0XHRcdFx0eyB2YWx1ZXMubGVuZ3RoXG5cdFx0XHRcdFx0XHQ/IHZhbHVlcy5tYXAoICggdmFsdWUsIGluZGV4ICkgPT4ge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBtYXRjaGluZ09wdGlvbiA9IG9wdGlvbnMuZmluZCggb3B0aW9uID0+IHZhbHVlLnZhbHVlID09PSBvcHRpb24udmFsdWUgKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJmaWVsZC0tY2hlY2tib3gtZ3JvdXBfX2l0ZW1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgdmFsdWUudmFsdWUgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdHsgbWF0Y2hpbmdPcHRpb24ubGFiZWwgfVxuXHRcdFx0XHRcdFx0XHRcdFx0eyAoIGluZGV4IDwgdmFsdWVzLmxlbmd0aCAtIDEgKSA/ICcsICcgOiAnJyB9XG5cdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdDogJ04vQScgfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhc2UgJ1JhZGlvQ29udHJvbCc6IHtcblx0XHRcdGNvbnN0IHsgb3B0aW9ucyB9ID0gZmllbGRPcHRpb25zO1xuXG5cdFx0XHRjb25zdCBtYXRjaGluZ09wdGlvbiA9IG9wdGlvbnMuZmluZCggb3B0aW9uID0+IGZpZWxkVmFsdWUgPT09IG9wdGlvbi52YWx1ZSApO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8ZGl2IGtleT17IG5hbWUgfSBjbGFzc05hbWU9XCJmaWVsZC0tcmFkaW8tY29udHJvbFwiPlxuXHRcdFx0XHRcdHsgISEgbWF0Y2hpbmdPcHRpb24gPyBtYXRjaGluZ09wdGlvbi5sYWJlbCA6ICdOL0EnIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRjYXNlICdTZWxlY3RDb250cm9sJzoge1xuXHRcdFx0Ly8gQ291bGQgYmUgZWl0aGVyIGEgU2VsZWN0IHdpdGggXCJtdWx0aXBsZVwiIHZhbHVlcyBvciBub3QuXG5cdFx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggZmllbGRWYWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxkaXYga2V5PXsgbmFtZSB9IGNsYXNzTmFtZT1cImZpZWxkLS1zZWxlY3QtY29udHJvbFwiPlxuXHRcdFx0XHRcdFx0eyBmaWVsZFZhbHVlLmxhYmVsIHx8ICdOL0EnIH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlcyA9IGZpZWxkVmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8ZGl2IGtleT17IG5hbWUgfSBjbGFzc05hbWU9XCJmaWVsZC0tc2VsZWN0LWNvbnRyb2wgZmllbGQtLW11bHRpcGxlLXNlbGVjdC1jb250cm9sXCI+XG5cdFx0XHRcdFx0XHR7IHZhbHVlcy5sZW5ndGhcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZXMubWFwKCAoIHZhbHVlLCBpbmRleCApID0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwiZmllbGQtLXNlbGVjdC1ncm91cF9faXRlbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleT17IHZhbHVlIH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB2YWx1ZS5sYWJlbCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgKCBpbmRleCA8IHZhbHVlcy5sZW5ndGggLSAxICkgPyAnLCAnIDogJycgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHRcdDogJ04vQScgfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjYXNlICdEYXRlVGltZVBpY2tlcic6IHtcblx0XHRcdGNvbnN0IGRhdGVGb3JtYXQgPSBfX2V4cGVyaW1lbnRhbEdldFNldHRpbmdzKCkuZm9ybWF0cy5kYXRldGltZTtcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdiBrZXk9eyBuYW1lIH0gY2xhc3NOYW1lPVwiZmllbGQtLWRhdGUtdGltZVwiPlxuXHRcdFx0XHRcdDx0aW1lXG5cdFx0XHRcdFx0XHRkYXRlVGltZT17IGZvcm1hdERhdGUoICdjJywgZmllbGRWYWx1ZSApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IGRhdGVJMThuKCBkYXRlRm9ybWF0LCBmaWVsZFZhbHVlICkgfVxuXHRcdFx0XHRcdDwvdGltZT5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRjYXNlICdOdW1iZXJDb250cm9sJzoge1xuXHRcdFx0bGV0IHsgbG9jYWxlIH0gPSBfX2V4cGVyaW1lbnRhbEdldFNldHRpbmdzKCkubDEwbjtcblxuXHRcdFx0bG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoICdfJywgJy0nICk7XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxkaXYga2V5PXsgbmFtZSB9IGNsYXNzTmFtZT1cImZpZWxkLS1udW1iZXJcIj5cblx0XHRcdFx0XHR7ICEhIGZpZWxkVmFsdWUgJiYgZmllbGRWYWx1ZS50b0xvY2FsZVN0cmluZyggbG9jYWxlICkgfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhc2UgJ01lZGlhVXBsb2FkJzoge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdiBrZXk9eyBuYW1lIH0gY2xhc3NOYW1lPVwiZmllbGQtLW1lZGlhLXVwbG9hZFwiPlxuXHRcdFx0XHRcdHsgZmllbGRWYWx1ZSAmJiBmaWVsZFZhbHVlLnVybCB8fCAnTi9BJyB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSAnQ29sb3JQaWNrZXInOiB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0a2V5PXsgbmFtZSB9IGNsYXNzTmFtZT1cImZpZWxkLS1jb2xvclwiXG5cdFx0XHRcdFx0c3R5bGU9eyB7XG5cdFx0XHRcdFx0XHRjb2xvcjogZmllbGRWYWx1ZSxcblx0XHRcdFx0XHR9IH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgZmllbGRWYWx1ZSB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBudWxsO1xuXHR9XG59O1xuXG5jb25zdCBCbG9ja1ByZXZpZXcgPSAoIHtcblx0dGVtcGxhdGUsXG5cdGZpZWxkcyA9IFtdLFxuXHRhdHRyaWJ1dGVzID0ge31cbn0gKSA9PiB7XG5cdHJldHVybiAoXG5cdFx0PD5cblx0XHRcdHsgcmVuZGVyVGVtcGxhdGUoIHRlbXBsYXRlLCBmaWVsZHMsIGF0dHJpYnV0ZXMsIHJlbmRlckZpZWxkICkgfVxuXHRcdDwvPlxuXHQpXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCbG9ja1ByZXZpZXc7XG5cbiIsIi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQge1xuXHRQYW5lbEJvZHksXG5cdFBhbmVsUm93LFxufSBmcm9tICdAd29yZHByZXNzL2NvbXBvbmVudHMnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgUmVuZGVyZWRGaWVsZCBmcm9tICcuL1JlbmRlcmVkRmllbGQnO1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGZpZWxkcyB0aGF0IGxpdmUgaW4gdGhlIEluc3BlY3RvciBvbiB0aGUgc2lkZWJhci5cbiAqL1xuY29uc3QgRmllbGRJbnNwZWN0b3JDb250cm9scyA9ICgge1xuXHRmaWVsZHMgPSBbXSxcblx0YXR0cmlidXRlcyxcblx0c2V0QXR0cmlidXRlc1xufSApID0+IHtcblx0aWYgKCAhIGZpZWxkcy5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gKFxuXHRcdDw+XG5cdFx0XHR7IGZpZWxkcy5tYXAoICggZmllbGQgKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGZpZWxkT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0bGFiZWwsXG5cdFx0XHRcdFx0XHRoZWFkaW5nLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0gPSBmaWVsZDtcblxuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxQYW5lbEJvZHlcblx0XHRcdFx0XHRcdHRpdGxlPXsgaGVhZGluZyB8fCBsYWJlbCB9XG5cdFx0XHRcdFx0XHRrZXk9eyBuYW1lIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8UGFuZWxSb3cgY2xhc3NOYW1lPVwicG9kcy1pbnNwZWN0b3Itcm93XCI+XG5cdFx0XHRcdFx0XHRcdDxSZW5kZXJlZEZpZWxkXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGQ9eyBmaWVsZH1cblx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGVzPXsgYXR0cmlidXRlcyB9XG5cdFx0XHRcdFx0XHRcdFx0c2V0QXR0cmlidXRlcz17c2V0QXR0cmlidXRlc31cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvUGFuZWxSb3c+XG5cdFx0XHRcdFx0PC9QYW5lbEJvZHk+XG5cdFx0XHRcdClcblx0XHRcdH0gKSB9XG5cdFx0PC8+XG5cdClcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZpZWxkSW5zcGVjdG9yQ29udHJvbHM7XG4iLCIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgU2VsZWN0IGZyb20gJ3JlYWN0LXNlbGVjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBfXyB9IGZyb20gJ0B3b3JkcHJlc3MvaTE4bic7XG5cbmltcG9ydCB7XG5cdFJpY2hUZXh0LFxuXHRNZWRpYVVwbG9hZENoZWNrLFxuXHRNZWRpYVVwbG9hZCxcbn0gZnJvbSAnQHdvcmRwcmVzcy9ibG9jay1lZGl0b3InO1xuXG5pbXBvcnQge1xuXHRDaGVja2JveENvbnRyb2wsXG5cdFRleHRDb250cm9sLFxuXHRUZXh0YXJlYUNvbnRyb2wsXG5cdEJhc2VDb250cm9sLFxuXHREYXRlVGltZVBpY2tlcixcblx0UmFkaW9Db250cm9sLFxuXHRDb2xvclBpY2tlcixcblx0QnV0dG9uLFxufSBmcm9tICdAd29yZHByZXNzL2NvbXBvbmVudHMnO1xuXG5pbXBvcnQgeyB1c2VJbnN0YW5jZUlkIH0gZnJvbSAnQHdvcmRwcmVzcy9jb21wb3NlJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IENoZWNrYm94R3JvdXAgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9DaGVja2JveEdyb3VwJztcbmltcG9ydCBOdW1iZXJDb250cm9sIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvTnVtYmVyQ29udHJvbCc7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgaGFuZGxlciBmb3IgdGhlICdvbkNoYW5nZScgcHJvcCBmb3IgYSBmaWVsZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBmaWVsZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldEF0dHJpYnV0ZXMgVGhlIHNldEF0dHJpYnV0ZXMgZnVuY3Rpb24gZm9yIGEgYmxvY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBhdHRyaWJ1dGUgKCdzdHJpbmcnLCAnYXJyYXknLCAnbnVtYmVyJykuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IEZ1bmN0aW9uIHVwZGF0ZSBhdHRyaWJ1dGVzIHRvIGF0dGFjaCB0byBhbiBgb25DaGFuZ2VgIHByb3AuXG4gKi9cbmNvbnN0IGNyZWF0ZUNoYW5nZUhhbmRsZXIgPSAoIG5hbWUsIHNldEF0dHJpYnV0ZXMsIHR5cGUgKSA9PiAoIG5ld1ZhbHVlICkgPT4ge1xuXHRzZXRBdHRyaWJ1dGVzKCB7XG5cdFx0XHRbIG5hbWUgXTogJ051bWJlckNvbnRyb2wnID09PSB0eXBlID8gcGFyc2VJbnQoIG5ld1ZhbHVlLCAxMCApIDogbmV3VmFsdWUsXG5cdH0gKTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIGFuIGluZGl2aWR1YWwgZmllbGQgdG8gYmUgdXNlZCBpbiBhIHRlbXBsYXRlLlxuICovXG5jb25zdCBSZW5kZXJlZEZpZWxkID0gKCB7XG5cdGZpZWxkLFxuXHRhdHRyaWJ1dGVzLFxuXHRzZXRBdHRyaWJ1dGVzXG59ICkgPT4ge1xuXHRjb25zdCB7XG5cdFx0bmFtZSxcblx0XHR0eXBlLFxuXHRcdGZpZWxkT3B0aW9ucyA9IHt9LFxuXHR9ID0gZmllbGQ7XG5cblx0Y29uc3QgZmllbGRWYWx1ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRjb25zdCBjaGFuZ2VIYW5kbGVyID0gY3JlYXRlQ2hhbmdlSGFuZGxlciggbmFtZSwgc2V0QXR0cmlidXRlcywgdHlwZSApO1xuXG5cdHN3aXRjaCAoIHR5cGUgKSB7XG5cdFx0Y2FzZSAnVGV4dENvbnRyb2wnOiB7XG5cdFx0XHRjb25zdCB7XG5cdFx0XHRcdHR5cGUgPSAndGV4dCcsXG5cdFx0XHRcdGhlbHAsXG5cdFx0XHRcdGxhYmVsLFxuXHRcdFx0fSA9IGZpZWxkT3B0aW9ucztcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PFRleHRDb250cm9sXG5cdFx0XHRcdFx0a2V5PXsgbmFtZSB9XG5cdFx0XHRcdFx0bGFiZWw9eyBsYWJlbCB9XG5cdFx0XHRcdFx0dmFsdWU9eyBmaWVsZFZhbHVlIH1cblx0XHRcdFx0XHR0eXBlPXsgdHlwZSB9XG5cdFx0XHRcdFx0aGVscD17IGhlbHAgfVxuXHRcdFx0XHRcdG9uQ2hhbmdlPXsgY2hhbmdlSGFuZGxlciB9XG5cdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRjYXNlICdUZXh0YXJlYUNvbnRyb2wnOiB7XG5cdFx0XHRjb25zdCB7XG5cdFx0XHRcdGhlbHAsXG5cdFx0XHRcdGxhYmVsLFxuXHRcdFx0fSA9IGZpZWxkT3B0aW9ucztcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PFRleHRhcmVhQ29udHJvbFxuXHRcdFx0XHRcdGtleT17IG5hbWUgfVxuXHRcdFx0XHRcdGxhYmVsPXsgbGFiZWwgfVxuXHRcdFx0XHRcdHZhbHVlPXsgZmllbGRWYWx1ZSB9XG5cdFx0XHRcdFx0aGVscD17IGhlbHAgfVxuXHRcdFx0XHRcdHJvd3M9XCI0XCJcblx0XHRcdFx0XHRvbkNoYW5nZT17IGNoYW5nZUhhbmRsZXIgfVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSAnUmljaFRleHQnOiB7XG5cdFx0XHRjb25zdCB7IHRhZ05hbWUgPSAncCcgfSA9IGZpZWxkT3B0aW9ucztcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PFJpY2hUZXh0XG5cdFx0XHRcdFx0a2V5PXsgbmFtZSB9XG5cdFx0XHRcdFx0dGFnTmFtZT17IHRhZ05hbWUgfVxuXHRcdFx0XHRcdHZhbHVlPXsgZmllbGRWYWx1ZSB9XG5cdFx0XHRcdFx0b25DaGFuZ2U9eyBjaGFuZ2VIYW5kbGVyIH1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhc2UgJ0NoZWNrYm94Q29udHJvbCc6IHtcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0bGFiZWwsXG5cdFx0XHRcdGhlbHAsXG5cdFx0XHR9ID0gZmllbGRPcHRpb25zO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8Q2hlY2tib3hDb250cm9sXG5cdFx0XHRcdFx0a2V5PXsgbmFtZSB9XG5cdFx0XHRcdFx0bGFiZWw9eyBsYWJlbCB9XG5cdFx0XHRcdFx0aGVscD17IGhlbHAgfVxuXHRcdFx0XHRcdGNoZWNrZWQ9eyBmaWVsZFZhbHVlIH1cblx0XHRcdFx0XHRvbkNoYW5nZT17IGNoYW5nZUhhbmRsZXIgfVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSAnQ2hlY2tib3hHcm91cCc6IHtcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0aGVscCxcblx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdH0gPSBmaWVsZE9wdGlvbnM7XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxDaGVja2JveEdyb3VwXG5cdFx0XHRcdFx0a2V5PXsgbmFtZSB9XG5cdFx0XHRcdFx0aGVscD17IGhlbHAgfVxuXHRcdFx0XHRcdG9wdGlvbnM9eyBvcHRpb25zIH1cblx0XHRcdFx0XHR2YWx1ZXM9eyBmaWVsZFZhbHVlIH1cblx0XHRcdFx0XHRvbkNoYW5nZT17IGNoYW5nZUhhbmRsZXIgfVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSAnUmFkaW9Db250cm9sJzoge1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRoZWxwLFxuXHRcdFx0XHRvcHRpb25zLFxuXHRcdFx0fSA9IGZpZWxkT3B0aW9ucztcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PFJhZGlvQ29udHJvbFxuXHRcdFx0XHRcdGtleT17IG5hbWUgfVxuXHRcdFx0XHRcdGhlbHA9eyBoZWxwIH1cblx0XHRcdFx0XHRvcHRpb25zPXsgb3B0aW9ucyB9XG5cdFx0XHRcdFx0c2VsZWN0ZWQ9eyBmaWVsZFZhbHVlIH1cblx0XHRcdFx0XHRvbkNoYW5nZT17IGNoYW5nZUhhbmRsZXIgfVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSAnU2VsZWN0Q29udHJvbCc6IHtcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0bXVsdGlwbGUsXG5cdFx0XHRcdGxhYmVsLFxuXHRcdFx0fSA9IGZpZWxkT3B0aW9ucztcblxuXHRcdFx0Y29uc3QgaW5zdGFuY2VJZCA9IHVzZUluc3RhbmNlSWQoIFNlbGVjdCApO1xuXHRcdFx0Y29uc3QgaWQgPSBgaW5zcGVjdG9yLXNlbGVjdC1jb250cm9sLSR7IGluc3RhbmNlSWQgfWA7XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxCYXNlQ29udHJvbFxuXHRcdFx0XHRcdGxhYmVsPXsgbGFiZWwgfVxuXHRcdFx0XHRcdGlkPXsgaWQgfVxuXHRcdFx0XHRcdGtleT17IG5hbWUgfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImZ1bGwtd2lkdGgtYmFzZS1jb250cm9sXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxTZWxlY3Rcblx0XHRcdFx0XHRcdGlkPXsgaWQgfVxuXHRcdFx0XHRcdFx0bmFtZT17IG5hbWUgfVxuXHRcdFx0XHRcdFx0b3B0aW9ucz17IG9wdGlvbnMgfVxuXHRcdFx0XHRcdFx0dmFsdWU9eyBmaWVsZFZhbHVlIH1cblx0XHRcdFx0XHRcdGlzTXVsdGk9eyBtdWx0aXBsZSB9XG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17IGNoYW5nZUhhbmRsZXIgfVxuXHRcdFx0XHRcdFx0c3R5bGVzPXsge1xuXHRcdFx0XHRcdFx0XHRjb250YWluZXI6ICggcHJvdmlkZWQgKSA9PiAoIHtcblx0XHRcdFx0XHRcdFx0Li4ucHJvdmlkZWQsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0fSB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9CYXNlQ29udHJvbD5cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhc2UgJ0RhdGVUaW1lUGlja2VyJzoge1xuXHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRpczEySG91cixcblx0XHRcdFx0bGFiZWwsXG5cdFx0XHR9ID0gZmllbGRPcHRpb25zO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8QmFzZUNvbnRyb2xcblx0XHRcdFx0XHRsYWJlbD17IGxhYmVsIH1cblx0XHRcdFx0XHRrZXk9eyBuYW1lIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxEYXRlVGltZVBpY2tlclxuXHRcdFx0XHRcdFx0Y3VycmVudERhdGU9eyBmaWVsZFZhbHVlIH1cblx0XHRcdFx0XHRcdG9uQ2hhbmdlPXsgY2hhbmdlSGFuZGxlciB9XG5cdFx0XHRcdFx0XHRpczEySG91cj17IGlzMTJIb3VyIH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0Jhc2VDb250cm9sPlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSAnTnVtYmVyQ29udHJvbCc6IHtcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0aXNTaGlmdFN0ZXBFbmFibGVkLFxuXHRcdFx0XHRzaGlmdFN0ZXAsXG5cdFx0XHRcdGxhYmVsLFxuXHRcdFx0XHRtYXggPSBJbmZpbml0eSxcblx0XHRcdFx0bWluID0gLUluZmluaXR5LFxuXHRcdFx0XHRzdGVwID0gMSxcblx0XHRcdH0gPSBmaWVsZE9wdGlvbnM7XG5cblx0XHRcdGNvbnN0IGluc3RhbmNlSWQgPSB1c2VJbnN0YW5jZUlkKCBOdW1iZXJDb250cm9sICk7XG5cdFx0XHRjb25zdCBpZCA9IGBpbnNwZWN0b3ItbnVtYmVyLWNvbnRyb2wtJHsgaW5zdGFuY2VJZCB9YDtcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PEJhc2VDb250cm9sXG5cdFx0XHRcdFx0bGFiZWw9eyBsYWJlbCB9XG5cdFx0XHRcdFx0aWQ9eyBpZCB9XG5cdFx0XHRcdFx0a2V5PXsgbmFtZSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8TnVtYmVyQ29udHJvbFxuXHRcdFx0XHRcdFx0aWQ9eyBpZCB9XG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17IGNoYW5nZUhhbmRsZXIgfVxuXHRcdFx0XHRcdFx0aXNTaGlmdFN0ZXBFbmFibGVkPXsgaXNTaGlmdFN0ZXBFbmFibGVkIH1cblx0XHRcdFx0XHRcdHNoaWZ0U3RlcD17IHNoaWZ0U3RlcCB9XG5cdFx0XHRcdFx0XHRtYXg9eyBtYXggfVxuXHRcdFx0XHRcdFx0bWluPXsgbWluIH1cblx0XHRcdFx0XHRcdHN0ZXA9eyBzdGVwIH1cblx0XHRcdFx0XHRcdHZhbHVlPXsgZmllbGRWYWx1ZSB8fCAnJyB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9CYXNlQ29udHJvbD5cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhc2UgJ01lZGlhVXBsb2FkJzoge1xuXHRcdFx0Y29uc3QgQUxMT1dFRF9NRURJQV9UWVBFUyA9IFsgJ2ltYWdlJyBdO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdDxNZWRpYVVwbG9hZENoZWNrPlxuXHRcdFx0XHRcdFx0PE1lZGlhVXBsb2FkXG5cdFx0XHRcdFx0XHRcdG9uU2VsZWN0PXsgKCBtZWRpYSApID0+IHsgY2hhbmdlSGFuZGxlciggeyBpZDogbWVkaWEuaWQsIHVybDogbWVkaWEudXJsLCB0aXRsZTogbWVkaWEudGl0bGUgfSApOyB9IH1cblx0XHRcdFx0XHRcdFx0YWxsb3dlZFR5cGVzPXsgQUxMT1dFRF9NRURJQV9UWVBFUyB9XG5cdFx0XHRcdFx0XHRcdHZhbHVlPXsgZmllbGRWYWx1ZSB9XG5cdFx0XHRcdFx0XHRcdHJlbmRlcj17ICggeyBvcGVuIH0gKSA9PiAoXG5cdFx0XHRcdFx0XHRcdFx0PEJ1dHRvbiBvbkNsaWNrPXsgb3BlbiB9IGlzUHJpbWFyeT5cblx0XHRcdFx0XHRcdFx0XHRcdHsgX18oICdVcGxvYWQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdDwvQnV0dG9uPlxuXHRcdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9NZWRpYVVwbG9hZENoZWNrPlxuXHRcdFx0XHRcdHsgISEgZmllbGRWYWx1ZSAmJlxuXHRcdFx0XHRcdFx0PEJ1dHRvblxuXHRcdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gY2hhbmdlSGFuZGxlciggbnVsbCApIH1cblx0XHRcdFx0XHRcdFx0aXNTZWNvbmRhcnlcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0eyBfXyggJ1JlbW92ZSBVcGxvYWQnICkgfVxuXHRcdFx0XHRcdFx0PC9CdXR0b24+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHsgZmllbGRWYWx1ZSAmJiAhISBmaWVsZFZhbHVlLnRpdGxlICYmIChcblx0XHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHRcdHsgZmllbGRWYWx1ZS50aXRsZSB9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQpIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRjYXNlICdDb2xvclBpY2tlcic6IHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdGNvbG9yPXsgZmllbGRWYWx1ZSB9XG5cdFx0XHRcdFx0b25DaGFuZ2VDb21wbGV0ZT17ICggdmFsdWUgKSA9PiBjaGFuZ2VIYW5kbGVyKCB2YWx1ZS5oZXggKSB9XG5cdFx0XHRcdFx0ZGlzYWJsZUFscGhhXG5cdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVkRmllbGQ7XG4iLCIvKipcbiAqIFJldHVybnMgYW4gXCJhdHRyaWJ1dGVzXCIgb2JqZWN0LCBhcyBleHBlY3RlZCBieSByZWdpc3RlckJsb2NrVHlwZSgpLFxuICogYmFzZWQgb24gdGhlIGZpZWxkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZmllbGRzIEFycmF5IG9mIGZpZWxkIGRhdGEsIGVhY2ggY29udGFpbmluZyBhIGBuYW1lYFxuICogICAgICAgICAgICAgICAgICAgICAgIGFuZCBhcnJheSBvZiBgYXR0cmlidXRlT3B0aW9uc2AuXG4gKlxuICogQHJldHVybnMge09iamVjdH0gQXR0cmlidXRlcyBvYmplY3QgdG8gcGFzcyB0byByZWdpc3RlckJsb2NrVHlwZSgpLlxuICovXG5jb25zdCBjcmVhdGVBdHRyaWJ1dGVzRnJvbUZpZWxkcyA9ICggZmllbGRzICkgPT5cblx0ZmllbGRzLnJlZHVjZSggKCBhdHRyaWJ1dGVzLCBjdXJyZW50RmllbGQgKSA9PiB7XG5cdFx0aWYgKCAhIGN1cnJlbnRGaWVsZC5uYW1lICkge1xuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBuYW1lLCBhdHRyaWJ1dGVPcHRpb25zIH0gPSBjdXJyZW50RmllbGQ7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Li4uYXR0cmlidXRlcyxcblx0XHRcdFsgbmFtZSBdOiB7XG5cdFx0XHRcdC4uLmF0dHJpYnV0ZU9wdGlvbnMsXG5cdFx0XHRcdC8vIERlZmF1bHQgdG8gc2V0dGluZyB0aGUgYXR0cmlidXRlIHR5cGUgdG8gXCJzdHJpbmdcIlxuXHRcdFx0XHQvLyBpZiBvbmUgd2Fzbid0IHByb3ZpZGVkLlxuXHRcdFx0XHR0eXBlOiBhdHRyaWJ1dGVPcHRpb25zLnR5cGUgfHwgJ3N0cmluZycsXG5cdFx0XHR9LFxuXHRcdH07XG5cdH0sIHt9ICk7XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUF0dHJpYnV0ZXNGcm9tRmllbGRzO1xuIiwiLyoqXG4gKiBXb3JkUHJlc3MgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IF9fIH0gZnJvbSAnQHdvcmRwcmVzcy9pMThuJztcbmltcG9ydCB7IEluc3BlY3RvckNvbnRyb2xzIH0gZnJvbSAnQHdvcmRwcmVzcy9ibG9jay1lZGl0b3InO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgRmllbGRJbnNwZWN0b3JDb250cm9scyBmcm9tICcuL2NvbXBvbmVudHMvRmllbGRJbnNwZWN0b3JDb250cm9scyc7XG5pbXBvcnQgQmxvY2tQcmV2aWV3IGZyb20gJy4vY29tcG9uZW50cy9CbG9ja1ByZXZpZXcnO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlICdlZGl0JyBjb21wb25lbnQgZm9yIGEgZ2l2ZW4gYmxvY2sgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYmxvY2sgQmxvY2sgc3BlY2lmaWNhdGlvbiAoVEJEKS5cbiAqL1xuY29uc3QgY3JlYXRlQmxvY2tFZGl0Q29tcG9uZW50ID0gKCBibG9jayApID0+ICggcHJvcHMgKSA9PiB7XG5cdGNvbnN0IHtcblx0XHRmaWVsZHMgPSBbXSxcblx0XHR0ZW1wbGF0ZSxcblx0fSA9IGJsb2NrO1xuXG5cdGNvbnN0IHtcblx0XHRjbGFzc05hbWUsXG5cdFx0YXR0cmlidXRlcyA9IHt9LFxuXHRcdHNldEF0dHJpYnV0ZXMsXG5cdH0gPSBwcm9wcztcblxuXHRyZXR1cm4gKFxuXHRcdDxkaXYgY2xhc3NOYW1lPXsgY2xhc3NOYW1lIH0+XG5cdFx0XHQ8SW5zcGVjdG9yQ29udHJvbHM+XG5cdFx0XHRcdDxGaWVsZEluc3BlY3RvckNvbnRyb2xzXG5cdFx0XHRcdFx0ZmllbGRzPXsgZmllbGRzIH1cblx0XHRcdFx0XHRhdHRyaWJ1dGVzPXsgYXR0cmlidXRlcyB9XG5cdFx0XHRcdFx0c2V0QXR0cmlidXRlcz17IHNldEF0dHJpYnV0ZXMgfVxuXHRcdFx0XHQvPlxuXHRcdFx0PC9JbnNwZWN0b3JDb250cm9scz5cblx0XHRcdDxCbG9ja1ByZXZpZXdcblx0XHRcdFx0dGVtcGxhdGU9eyB0ZW1wbGF0ZSB9XG5cdFx0XHRcdGZpZWxkcz17IGZpZWxkcyB9XG5cdFx0XHRcdGF0dHJpYnV0ZXM9eyBhdHRyaWJ1dGVzIH1cblx0XHRcdC8+XG5cdFx0PC9kaXY+XG5cdCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCbG9ja0VkaXRDb21wb25lbnQ7XG4iLCIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyByZWdpc3RlckJsb2NrVHlwZSB9IGZyb20gJ0B3b3JkcHJlc3MvYmxvY2tzJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IGNyZWF0ZUJsb2NrRWRpdENvbXBvbmVudCBmcm9tICcuL2NyZWF0ZUJsb2NrRWRpdENvbXBvbmVudCc7XG5pbXBvcnQgY3JlYXRlQXR0cmlidXRlc0Zyb21GaWVsZHMgZnJvbSAnLi9jcmVhdGVBdHRyaWJ1dGVzRnJvbUZpZWxkcyc7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgYmxvY2sgZnJvbSB0aGUgcHJvdmlkZWQgZGF0YS5cbiAqL1xuY29uc3QgY3JlYXRlQmxvY2sgPSAoIGJsb2NrICkgPT4ge1xuXHRjb25zdCB7XG5cdFx0YmxvY2tOYW1lLFxuXHRcdGZpZWxkcyxcblx0XHRjYXRlZ29yeSxcblx0XHRkZXNjcmlwdGlvbixcblx0XHRpY29uLFxuXHRcdGtleXdvcmRzLFxuXHRcdHN1cHBvcnRzLFxuXHRcdHRpdGxlLFxuXHR9ID0gYmxvY2s7XG5cblx0Y29uc3QgRWRpdENvbXBvbmVudCA9IGNyZWF0ZUJsb2NrRWRpdENvbXBvbmVudCggYmxvY2sgKTtcblxuXHRyZWdpc3RlckJsb2NrVHlwZSggYmxvY2tOYW1lLCB7XG5cdFx0YXR0cmlidXRlczogY3JlYXRlQXR0cmlidXRlc0Zyb21GaWVsZHMoIGZpZWxkcyApLFxuXHRcdGNhdGVnb3J5LFxuXHRcdGRlc2NyaXB0aW9uLFxuXHRcdGVkaXQ6IEVkaXRDb21wb25lbnQsXG5cdFx0aWNvbixcblx0XHRrZXl3b3Jkcyxcblx0XHRzYXZlOiAoKSA9PiBudWxsLFxuXHRcdHN1cHBvcnRzLFxuXHRcdHRpdGxlLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCbG9jaztcbiIsIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuLyoqXG4gKiBXb3JkUHJlc3MgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7XG5cdENoZWNrYm94Q29udHJvbCxcbn0gZnJvbSAnQHdvcmRwcmVzcy9jb21wb25lbnRzJztcblxuY29uc3QgQ2hlY2tib3hHcm91cCA9ICgge1xuXHRpZCxcblx0Y2xhc3NOYW1lLFxuXHRoZWFkaW5nLFxuXHRoZWxwLFxuXHRvcHRpb25zLFxuXHR2YWx1ZXMsXG5cdG9uQ2hhbmdlLFxufSApID0+IHtcblx0Ly8gVXBkYXRlIHRoZSBDaGVja2JveEdyb3VwJ3MgdmFsdWUgd2hlbmV2ZXIgYW4gaW5kaXZpZHVhbCBjaGVja2JveCBoYXNcblx0Ly8gYmVlbiBjaGFuZ2VkLlxuXHRjb25zdCBoYW5kbGVDaGVja2JveENvbnRyb2xDaGFuZ2UgPSAoIHZhbHVlLCBjaGVja2VkICkgPT4ge1xuXHRcdGNvbnN0IHVwZGF0ZWRWYWx1ZXMgPSBbIC4uLnZhbHVlcyBdO1xuXG5cdFx0Y29uc3QgdXBkYXRlZEluZGV4ID0gdXBkYXRlZFZhbHVlcy5maW5kSW5kZXgoIGZpZWxkID0+IGZpZWxkLnZhbHVlID09PSB2YWx1ZSApO1xuXG5cdFx0aWYgKCAtMSAhPT0gdXBkYXRlZEluZGV4ICkge1xuXHRcdFx0dXBkYXRlZFZhbHVlc1sgdXBkYXRlZEluZGV4IF0uY2hlY2tlZCA9IGNoZWNrZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVwZGF0ZWRWYWx1ZXMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0Y2hlY2tlZCxcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRvbkNoYW5nZSggdXBkYXRlZFZhbHVlcyApO1xuXHR9XG5cblx0cmV0dXJuIChcblx0XHQ8ZmllbGRzZXQgY2xhc3NOYW1lPXsgY2xhc3NOYW1lcyggJ2NvbXBvbmVudHMtYmxvY2stZmllbGRzLWNoZWNrYm94LWdyb3VwJywgY2xhc3NOYW1lICkgfT5cblx0XHRcdHsgaGVhZGluZyAmJiA8bGVnZW5kPnsgaGVhZGluZyB9PC9sZWdlbmQ+IH1cblxuXHRcdFx0eyBvcHRpb25zLm1hcCggb3B0aW9uID0+IHtcblx0XHRcdFx0Y29uc3QgbWF0Y2hpbmdWYWx1ZSA9IHZhbHVlcy5maW5kKCB2YWx1ZSA9PiB2YWx1ZS52YWx1ZSA9PT0gb3B0aW9uLnZhbHVlICkgfHwgZmFsc2U7XG5cblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8Q2hlY2tib3hDb250cm9sXG5cdFx0XHRcdFx0XHRrZXk9eyBvcHRpb24udmFsdWUgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyBvcHRpb24ubGFiZWwgfVxuXHRcdFx0XHRcdFx0Y2hlY2tlZD17IG1hdGNoaW5nVmFsdWUuY2hlY2tlZCB8fCBmYWxzZSB9XG5cdFx0XHRcdFx0XHRvbkNoYW5nZT17ICggbmV3Q2hlY2tlZCApID0+IGhhbmRsZUNoZWNrYm94Q29udHJvbENoYW5nZSggb3B0aW9uLnZhbHVlLCBuZXdDaGVja2VkICkgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdCk7XG5cdFx0XHR9ICkgfVxuXG5cdFx0XHR7ICEhIGhlbHAgJiYgKFxuXHRcdFx0XHQ8cFxuXHRcdFx0XHRcdGlkPXsgaWQgKyAnX19oZWxwJyB9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiY29tcG9uZW50cy1ibG9jay1maWVsZHMtY2hlY2tib3gtZ3JvdXBfX2hlbHBcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyBoZWxwIH1cblx0XHRcdFx0PC9wPlxuXHRcdFx0KSB9XG5cdFx0PC9maWVsZHNldD5cblx0KTtcbn07XG5cbkNoZWNrYm94R3JvdXAucHJvcFR5cGVzID0ge1xuXHRpZDogUHJvcFR5cGVzLnN0cmluZyxcblx0Y2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRoZWFkaW5nOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRoZWxwOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRvcHRpb25zOiBQcm9wVHlwZXMuYXJyYXlPZihcblx0XHRQcm9wVHlwZXMuc2hhcGUoIHtcblx0XHRcdGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cdFx0XHR2YWx1ZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXHRcdH0gKVxuXHQpLFxuXHR2YWx1ZXM6IFByb3BUeXBlcy5hcnJheU9mKFxuXHRcdFByb3BUeXBlcy5zaGFwZSgge1xuXHRcdFx0dmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblx0XHRcdGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuXHRcdH0gKVxuXHQpLFxuXHRvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbkNoZWNrYm94R3JvdXAuZGVmYXVsdFByb3BzID0ge1xuXHRpZDogJycsXG5cdGNsYXNzTmFtZTogbnVsbCxcblx0aGVhZGluZzogbnVsbCxcblx0aGVscDogbnVsbCxcblx0b3B0aW9uczogW10sXG5cdHZhbHVlczogW10sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBDaGVja2JveEdyb3VwO1xuIiwiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY2xhbXAsIG5vb3AgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBVUCwgRE9XTiB9IGZyb20gJ0B3b3JkcHJlc3Mva2V5Y29kZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBOdW1iZXJDb250cm9sKCB7XG5cdGNsYXNzTmFtZSxcblx0aXNTaGlmdFN0ZXBFbmFibGVkID0gdHJ1ZSxcblx0bWF4ID0gSW5maW5pdHksXG5cdG1pbiA9IC1JbmZpbml0eSxcblx0b25DaGFuZ2UgPSBub29wLFxuXHRvbktleURvd24gPSBub29wLFxuXHRzaGlmdFN0ZXAgPSAxMCxcblx0c3RlcCA9IDEsXG5cdC4uLnByb3BzXG59ICkge1xuXHRjb25zdCBiYXNlVmFsdWUgPSBjbGFtcCggMCwgbWluLCBtYXggKTtcblxuXHRjb25zdCBoYW5kbGVPbktleURvd24gPSAoIGV2ZW50ICkgPT4ge1xuXHRcdG9uS2V5RG93biggZXZlbnQgKTtcblx0XHRjb25zdCB7IHZhbHVlIH0gPSBldmVudC50YXJnZXQ7XG5cblx0XHRjb25zdCBpc0VtcHR5ID0gdmFsdWUgPT09ICcnO1xuXHRcdGNvbnN0IGVuYWJsZVNoaWZ0ID0gZXZlbnQuc2hpZnRLZXkgJiYgaXNTaGlmdFN0ZXBFbmFibGVkO1xuXG5cdFx0Y29uc3QgaW5jcmVtZW50YWxWYWx1ZSA9IGVuYWJsZVNoaWZ0XG5cdFx0XHQ/IHBhcnNlRmxvYXQoIHNoaWZ0U3RlcCApXG5cdFx0XHQ6IHBhcnNlRmxvYXQoIHN0ZXAgKTtcblx0XHRsZXQgbmV4dFZhbHVlID0gaXNFbXB0eSA/IGJhc2VWYWx1ZSA6IHZhbHVlO1xuXG5cdFx0Ly8gQ29udmVydCB0byBhIG51bWJlciB0byB1c2UgbWF0aFxuXHRcdG5leHRWYWx1ZSA9IHBhcnNlRmxvYXQoIG5leHRWYWx1ZSApO1xuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdGNhc2UgVVA6XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0bmV4dFZhbHVlID0gbmV4dFZhbHVlICsgaW5jcmVtZW50YWxWYWx1ZTtcblx0XHRcdFx0bmV4dFZhbHVlID0gY2xhbXAoIG5leHRWYWx1ZSwgbWluLCBtYXggKTtcblxuXHRcdFx0XHRvbkNoYW5nZSggbmV4dFZhbHVlLnRvU3RyaW5nKCksIHsgZXZlbnQgfSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIERPV046XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0bmV4dFZhbHVlID0gbmV4dFZhbHVlIC0gaW5jcmVtZW50YWxWYWx1ZTtcblx0XHRcdFx0bmV4dFZhbHVlID0gY2xhbXAoIG5leHRWYWx1ZSwgbWluLCBtYXggKTtcblxuXHRcdFx0XHRvbkNoYW5nZSggbmV4dFZhbHVlLnRvU3RyaW5nKCksIHsgZXZlbnQgfSApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBoYW5kbGVPbkNoYW5nZSA9ICggZXZlbnQgKSA9PiB7XG5cdFx0b25DaGFuZ2UoIGV2ZW50LnRhcmdldC52YWx1ZSwgeyBldmVudCB9ICk7XG5cdH07XG5cblx0Y29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoICdjb21wb25lbnQtbnVtYmVyLWNvbnRyb2wnLCBjbGFzc05hbWUgKTtcblxuXHRyZXR1cm4gKFxuXHRcdDxpbnB1dFxuXHRcdFx0aW5wdXRNb2RlPVwibnVtZXJpY1wiXG5cdFx0XHR7IC4uLnByb3BzIH1cblx0XHRcdGNsYXNzTmFtZT17IGNsYXNzZXMgfVxuXHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRvbkNoYW5nZT17IGhhbmRsZU9uQ2hhbmdlIH1cblx0XHRcdG9uS2V5RG93bj17IGhhbmRsZU9uS2V5RG93biB9XG5cdFx0Lz5cblx0KTtcbn1cbiIsImV4cG9ydCBjb25zdCByaWNoVGV4dCA9IHtcblx0YWxsb3dlZFRhZ3M6IFtcblx0XHQnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnYmxvY2txdW90ZScsICdwJywgJ2EnLCAndWwnLCAnb2wnLFxuXHRcdCdubCcsICdsaScsICdiJywgJ2knLCAnc3Ryb25nJywgJ2VtJywgJ3N0cmlrZScsICdjb2RlJywgJ2NpdGUnLCAnaHInLCAnYnInLFxuXHRcdCdkaXYnLCAndGFibGUnLCAndGhlYWQnLCAnY2FwdGlvbicsICd0Ym9keScsICd0cicsICd0aCcsICd0ZCcsICdwcmUnLCAnaW1nJyxcblx0XHQnZmlndXJlJywgJ2ZpZ2NhcHRpb24nLCAnaWZyYW1lJywgJ3NlY3Rpb24nLFxuXHRdLFxuXHRhbGxvd2VkQXR0cmlidXRlczoge1xuXHRcdCcqJzogWyAnY2xhc3MnLCAnaWQnLCAnZGF0YS0qJywgJ3N0eWxlJyBdLFxuXHRcdGlmcmFtZTogWyAnKicgXSxcblx0XHRhOiBbICdocmVmJywgJ25hbWUnLCAndGFyZ2V0JyBdLFxuXHRcdGltZzogWyAnc3JjJywgJ3NyY3NldCcsICdzaXplcycsICdhbHQnLCAnd2lkdGgnLCAnaGVpZ2h0JyBdLFxuXHR9LFxuXHRzZWxmQ2xvc2luZzogW1xuXHRcdCdpbWcnLCAnYnInLCAnaHInLCAnYXJlYScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2lucHV0JywgJ2xpbmsnLCAnbWV0YScsXG5cdF0sXG5cdGFsbG93ZWRTY2hlbWVzOiBbICdodHRwJywgJ2h0dHBzJywgJ2Z0cCcsICdtYWlsdG8nIF0sXG5cdGFsbG93ZWRTY2hlbWVzQnlUYWc6IHt9LFxuXHRhbGxvd1Byb3RvY29sUmVsYXRpdmU6IHRydWUsXG59O1xuXG4gIGV4cG9ydCBjb25zdCBwbGFpblRleHQgPSB7XG5cdGFsbG93ZWRUYWdzOiBbXSxcblx0YWxsb3dlZEF0dHJpYnV0ZXM6IHt9LFxufTtcbiIsIi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBjcmVhdGVCbG9jayBmcm9tICcuL2Jsb2Nrcyc7XG5cbi8vIFJlZ2lzdGVyIGJsb2NrcyBmcm9tIHRoZSBjb25maWcuXG53aW5kb3cucG9kc0Jsb2Nrc0NvbmZpZy5ibG9ja3MuZm9yRWFjaCggY3JlYXRlQmxvY2sgKTtcbiIsIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHJlbmRlclRvU3RyaW5nIH0gZnJvbSAnQHdvcmRwcmVzcy9lbGVtZW50JztcbmltcG9ydCB7IFBhcnNlciwgUHJvY2Vzc05vZGVEZWZpbml0aW9ucyB9IGZyb20gJ2h0bWwtdG8tcmVhY3QnO1xuaW1wb3J0IHNhbml0aXplSHRtbCBmcm9tICdzYW5pdGl6ZS1odG1sJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgcmljaFRleHQgfSBmcm9tICcuLi9jb25maWcvaHRtbCc7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgZWRpdCB0ZW1wbGF0ZSBpbnRvIGFuIGVkaXQgY29tcG9uZW50LlxuICpcbiAqIEB0b2RvIElzIHRoZXJlIGEgbW9yZSBlZmZpY2llbnQgd2F5IHRvIGRvIHRoaXMgd2l0aG91dFxuICogcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgdG8gYSBzdHJpbmcsIHRoZW4gcGFyc2luZyB0aGVcbiAqIGZpbmFsIHN0cmluZyBiYWNrIHRvIGEgUmVhY3QgY29tcG9uZW50PyBUaGUgcGFyc2VyIG1heSBoYXZlXG4gKiBjYWxsYmFja3MgdGhhdCB3ZSBjYW4gdXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUZW1wbGF0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzIEZpZWxkcyB1c2VkIGluIHRoZSBCbG9jay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEJsb2NrIGF0dHJpYnV0ZXMgd2l0aCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW5kZXJGaWVsZCBGdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gYSByZW5kZXJlZCBmaWVsZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldEF0dHJpYnV0ZXMgc2V0QXR0cmlidXRlcyBmdW5jdGlvbiBmb3IgdGhlIGJsb2NrIChPcHRpb25hbCkuXG4gKi9cbmNvbnN0IHJlbmRlclRlbXBsYXRlID0gKFxuXHR0ZW1wbGF0ZSA9ICcnLFxuXHRmaWVsZHMgPSBbXSxcblx0YXR0cmlidXRlcyA9IHt9LFxuXHRyZW5kZXJGaWVsZCxcblx0c2V0QXR0cmlidXRlc1xuKSA9PiB7XG5cdGxldCBodG1sV2l0aFJlbmRlcmVkRmllbGRzID0gc2FuaXRpemVIdG1sKCB0ZW1wbGF0ZSwgcmljaFRleHQgKTtcblxuXHQvLyBSZXBsYWNlIGFsbCBvZiB0aGUgcGxhY2Vob2xkZXJzIGluIHRoZSBmb3JtYXQgb2YgYHtAZmllbGROYW1lfWAgd2l0aCB0aGVcblx0Ly8gcmVuZGVyZWQgZmllbGQuIFRvIGRvIHRoaXMsIHdlIGZpcnN0IG5lZWQgdG8gY3JlYXRlIHRoZSBSZWFjdCBjb21wb25lbnQgZm9yXG5cdC8vIHRoZSBmaWVsZCwgdGhlbiBjb252ZXJ0IGl0IGRvd24gaW50byBhIHN0cmluZy4gVG8gYXZvaWQgbG9zaW5nIGFueSBvZiB0aGUgcHJvcHNcblx0Ly8gZHVyaW5nIHRoaXMgY29udmVyc2lvbiwgd2UncmUgc2F2aW5nIGFueSBwcm9wcyBmcm9tIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIG5hbWUuXG5cdC8vIEF0IHRoZSBlbmQsIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBwYXJzZWQgYmFjayBpbnRvIFJlYWN0IGNvbXBvbmVudHMuXG5cdGNvbnN0IHNhdmVkUHJvcHMgPSBbXTtcblxuXHRmaWVsZHMuZm9yRWFjaCggKCBmaWVsZCApID0+IHtcblx0XHQvLyBPdXIgcmVuZGVyRmllbGQgbWF5IG9yIG1heSBub3QgdGFrZSBhIHNldEF0dHJpYnV0ZXMgZnVuY3Rpb24gYXMgYSBwYXJhbWV0ZXIuXG5cdFx0Y29uc3QgZmllbGRDb21wb25lbnQgPSAoICdmdW5jdGlvbicgPT09IHR5cGVvZiBzZXRBdHRyaWJ1dGVzIClcblx0XHRcdD8gcmVuZGVyRmllbGQoIGZpZWxkLCBhdHRyaWJ1dGVzLCBzZXRBdHRyaWJ1dGVzIClcblx0XHRcdDogcmVuZGVyRmllbGQoIGZpZWxkLCBhdHRyaWJ1dGVzICk7XG5cblx0XHRpZiAoICEhIGZpZWxkQ29tcG9uZW50ICkge1xuXHRcdFx0c2F2ZWRQcm9wc1sgZmllbGQubmFtZSBdID0geyAuLi5maWVsZENvbXBvbmVudC5wcm9wcyB9O1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlbmRlcmVkRmllbGQgPSAhISBmaWVsZENvbXBvbmVudCA/IHJlbmRlclRvU3RyaW5nKCBmaWVsZENvbXBvbmVudCApIDogJyc7XG5cblx0XHRodG1sV2l0aFJlbmRlcmVkRmllbGRzID0gaHRtbFdpdGhSZW5kZXJlZEZpZWxkcy5yZXBsYWNlKFxuXHRcdFx0bmV3IFJlZ0V4cCggYHtAJHsgZmllbGQubmFtZSB9fWAsICdnJyApLFxuXHRcdFx0cmVuZGVyZWRGaWVsZFxuXHRcdCk7XG5cdH0gKTtcblxuXHQvLyBQYXJzZSB0aGUgcmVuZGVyZWQgdGVtcGxhdGUsIHNldHRpbmcgdGhlIHByb3BzIGJhY2sgdG8gdGhlaXIgc2F2ZWQgdmFsdWVzLlxuXHRjb25zdCBwcm9jZXNzTm9kZURlZmluaXRpb25zID0gbmV3IFByb2Nlc3NOb2RlRGVmaW5pdGlvbnMoKTtcblx0Y29uc3QgaHRtbFBhcnNlciA9IG5ldyBQYXJzZXIoKTtcblxuXHRjb25zdCBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zID0gW1xuXHRcdHtcblx0XHRcdHNob3VsZFByb2Nlc3NOb2RlOiAoKSA9PiB0cnVlLFxuXHRcdFx0cHJvY2Vzc05vZGU6IHByb2Nlc3NOb2RlRGVmaW5pdGlvbnMucHJvY2Vzc0RlZmF1bHROb2RlLFxuXHRcdH0sXG5cdF07XG5cblx0Y29uc3QgcGFyc2VkQ29tcG9uZW50cyA9IGh0bWxQYXJzZXIucGFyc2VXaXRoSW5zdHJ1Y3Rpb25zKFxuXHRcdGh0bWxXaXRoUmVuZGVyZWRGaWVsZHMsXG5cdFx0KCkgPT4gdHJ1ZSxcblx0XHRwcm9jZXNzaW5nSW5zdHJ1Y3Rpb25zXG5cdCk7XG5cblx0cmV0dXJuIHBhcnNlZENvbXBvbmVudHM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJUZW1wbGF0ZTtcbiIsIi8qIChpZ25vcmVkKSAqLyIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzW1wid3BcIl1bXCJhdXRvcFwiXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIndwXCJdW1wiYmxvY2tFZGl0b3JcIl07IH0oKSk7IiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHRoaXNbXCJ3cFwiXVtcImJsb2Nrc1wiXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIndwXCJdW1wiY29tcG9uZW50c1wiXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIndwXCJdW1wiY29tcG9zZVwiXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIndwXCJdW1wiZGF0ZVwiXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIndwXCJdW1wiZWxlbWVudFwiXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIndwXCJdW1wiaTE4blwiXTsgfSgpKTsiLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIndwXCJdW1wia2V5Y29kZXNcIl07IH0oKSk7IiwibW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2g7IiwibW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCJtb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NOyJdLCJzb3VyY2VSb290IjoiIn0=